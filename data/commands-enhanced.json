[
  {
    "name": "abs",
    "description": "Returns the absolute value of a number or matrix.",
    "usage": "abs();",
    "category": "general",
    "markdown": "# abs\r\n\r\nReturns the absolute value of a number or matrix.\r\n\r\n| **Syntax**    | **Description**                  |\r\n| ------------- | -------------------------------- |\r\n| out = abs(x); | Returns the absolute value of x. |\r\n\r\n**Example**\r\n\r\nCalculate the absolute value of numbers in an array.\r\n\r\n```\r\n?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?abs(x);\r\nresult: \r\n0 \r\n2.23607  \r\n```",
    "summary": "Returns the absolute value of a number or matrix",
    "syntax": [
      {
        "syntax": "out = abs(x);",
        "description": "Returns the absolute value of x."
      }
    ],
    "example": "?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?abs(x);\r\nresult: \r\n0 \r\n2.23607"
  },
  {
    "name": "acos",
    "description": "Calculates the inverse trigonometric cosine function (arccosine). Angle units are in radians. The function is defined for complex values. Phase of a complex number is evaluated between - π and π . If x is complex, or abs(x) > 1, the following equation is used:",
    "usage": "acos();",
    "category": "general",
    "markdown": "# acos\r\n\r\nCalculates the inverse trigonometric cosine function (arccosine). Angle units are in\r\nradians. The function is defined for complex values. Phase of a complex number is\r\nevaluated between - π and π . If x is complex, or abs(x) > 1, the following equation is\r\nused:\r\n\r\n$$ \\\\text{acos}(x) = -i\\\\ln(x+i\\\\sqrt{1-x^2}) $$\r\n\r\n| **Syntax**     | **Description**                     |\r\n| -------------- | ----------------------------------- |\r\n| out = acos(x); | Returns the complex arccosine of x. |\r\n\r\n**Example**\r\n\r\nCalculate acos( π /4 + i).\r\n\r\n```\r\nx=pi/4+1i;\r\n?acos(x);\r\nresult: \r\n1.03351-0.992724i\r\n```",
    "summary": "Calculates the inverse trigonometric cosine function (arccosine)",
    "syntax": [
      {
        "syntax": "out = acos(x);",
        "description": "Returns the complex arccosine of x."
      }
    ],
    "example": "x=pi/4+1i;\r\n?acos(x);\r\nresult: \r\n1.03351-0.992724i"
  },
  {
    "name": "add2dpoly",
    "description": "Adds a [2D polygon](https://optics.ansys.com/hc/en-us/articles/360034901613) in the simulation space.",
    "usage": "add2dpoly();",
    "category": "general",
    "markdown": "# add2dpoly\r\n\r\nAdds a [2D polygon](https://optics.ansys.com/hc/en-us/articles/360034901613) in the\r\nsimulation space.\r\n\r\n| **Syntax**                   | **Description**                                                                                  |\r\n| ---------------------------- | ------------------------------------------------------------------------------------------------ |\r\n| add2dpoly;                   | Adds a 2D polygon in simulation space. This function does not return any data.                   |\r\n| add2dpoly(\"property\",value); | Adds a 2D polygon and set its the property by specifying the \"property\" and value pair.          |\r\n| add2dpoly(struct_data);      | Adds a 2D polygon and set its the property using a struct containing \"property\" and value pairs. |\r\n\r\n**Example**\r\n\r\nThe following script creates a 2D matrix to store the vertices of a polygon and uses it\r\nto create a 2D polygon primitive on the XY plane.\r\n\r\n```\r\nvtx = [1,0;2,2;4,2;4,1;3,1]*1e-6;  # microns\r\nadd2dpoly;\r\nset(\"name\",\"2D_polygon\");\r\nset(\"surface normal\",3); #  1 = x (normal), 2 = y (normal), 3 = z (normal)\r\nset(\"vertices\",vtx);\r\nset(\"z\",2e-6);\r\n```\r\n\r\nSetting the properties while adding the object:\r\n\r\n```\r\nadd2dpoly(\"name\",\"test_obj\");\r\n\r\n# using struct  \r\nstruct_data = {\"name\": \"test_obj\", \"x\":  1e-6};\r\nadd2dpoly(struct_data);\r\n```",
    "summary": "Adds a [2D polygon](https://optics",
    "syntax": [
      {
        "syntax": "add2dpoly;",
        "description": "Adds a 2D polygon in simulation space. This function does not return any data."
      },
      {
        "syntax": "add2dpoly(\"property\",value);",
        "description": "Adds a 2D polygon and set its the property by specifying the \"property\" and value pair."
      },
      {
        "syntax": "add2dpoly(struct_data);",
        "description": "Adds a 2D polygon and set its the property using a struct containing \"property\" and value pairs."
      }
    ],
    "example": "vtx = [1,0;2,2;4,2;4,1;3,1]*1e-6;  # microns\r\nadd2dpoly;\r\nset(\"name\",\"2D_polygon\");\r\nset(\"surface normal\",3); #  1 = x (normal), 2 = y (normal), 3 = z (normal)\r\nset(\"vertices\",vtx);\r\nset(\"z\",2e-6);"
  },
  {
    "name": "add2drect",
    "description": "Adds a [2D rectangle](https://optics.ansys.com/hc/en-us/articles/360034901593) in the simulation space.",
    "usage": "add2drect();",
    "category": "general",
    "markdown": "# add2drect\r\n\r\nAdds a [2D rectangle](https://optics.ansys.com/hc/en-us/articles/360034901593) in the\r\nsimulation space.\r\n\r\n| **Syntax**                  | **Description**                                                                                    |\r\n| --------------------------- | -------------------------------------------------------------------------------------------------- |\r\n| add2drect;                  | Adds a 2D rectangle in simulation space. This function does not return any data.                   |\r\n| add2rect(\"property\",value); | Adds a 2D rectangle and set its the property by specifying the \"property\" and value pair.          |\r\n| add2drect(struct_data);     | Adds a 2D rectangle and set its the property using a struct containing \"property\" and value pairs. |\r\n\r\n**Example**\r\n\r\nThe following script creates a 2D rectangle on the XY plane, sets its dimension, and\r\nassigns a material to it.\r\n\r\n```\r\nadd2drect;\r\nset(\"name\",\"2D_rectangle\");\r\nset(\"surface normal\",3);  # z (normal)\r\nset(\"x\",1e-6);\r\nset(\"x span\",2e-6);\r\nset(\"y\",1e-6);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"material\",\"Si (Silicon) - Palik\");\r\n```\r\n\r\nSetting the properties while adding the object:\r\n\r\n```\r\nadd2drect(\"name\",\"test_obj\");  \r\n  \r\n# using struct  \r\nstruct_data = {\"name\": \"test_obj\", \"x\": 1e-6};  \r\nadd2drect(struct_data);\r\n```",
    "summary": "Adds a [2D rectangle](https://optics",
    "syntax": [
      {
        "syntax": "add2drect;",
        "description": "Adds a 2D rectangle in simulation space. This function does not return any data."
      },
      {
        "syntax": "add2rect(\"property\",value);",
        "description": "Adds a 2D rectangle and set its the property by specifying the \"property\" and value pair."
      },
      {
        "syntax": "add2drect(struct_data);",
        "description": "Adds a 2D rectangle and set its the property using a struct containing \"property\" and value pairs."
      }
    ],
    "example": "add2drect;\r\nset(\"name\",\"2D_rectangle\");\r\nset(\"surface normal\",3);  # z (normal)\r\nset(\"x\",1e-6);\r\nset(\"x span\",2e-6);\r\nset(\"y\",1e-6);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"material\",\"Si (Silicon) - Palik\");"
  },
  {
    "name": "add2visualizer",
    "description": "Adds data to an existing visualizer.",
    "usage": "add2visualizer();",
    "category": "general",
    "markdown": "# add2visualizer\r\n\r\nAdds data to an existing visualizer.\r\n\r\n| **Syntax**                                   | **Description**                                                                                                                                  |\r\n| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| add2visualizer( dataset, visualizer number ) | This command adds data to an existing visualizer. If there is no visualizer corresponding to the visualizer number, then the command is ignored. |\r\n\r\n**Example**\r\n\r\nSee example for visualize command.",
    "summary": "Adds data to an existing visualizer",
    "syntax": [
      {
        "syntax": "add2visualizer( dataset, visualizer number )",
        "description": "This command adds data to an existing visualizer. If there is no visualizer corresponding to the visualizer number, then the command is ignored."
      }
    ],
    "example": ""
  },
  {
    "name": "addabsorbing",
    "description": "Adds an absorbing boundary condition to the 'DGTD' solver. A DGTD solver region must be present in the objects tree for this command to work.",
    "usage": "addabsorbing();",
    "category": "general",
    "markdown": "# addabsorbing\r\n\r\nAdds an absorbing boundary condition to the 'DGTD' solver. A DGTD solver region must be\r\npresent in the objects tree for this command to work.\r\n\r\n| **Syntax**    | **Description**                                                                             |\r\n| ------------- | ------------------------------------------------------------------------------------------- |\r\n| addabsorbing; | Adds a PML boundary condition to the 'DGTD' solver. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add an absorbing boundary condition to the 'DGTD'\r\nsolver already present in the objects tree and print all available properties of the\r\nboundary condition.\r\n\r\n```\r\naddabsorbing;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add an absorbing boundary condition to the 'DGTD'\r\nsolver, name it, and assign it to the -z and +z boundaries of the simulation region.\r\n\r\n```\r\naddabsorbing; \r\nset(\"name\",\"absorbing_z\");\r\nset(\"surface type\",\"simulation region\");\r\nset(\"z min\",1);\r\nset(\"z max\",1);\r\n```",
    "summary": "Adds an absorbing boundary condition to the 'DGTD' solver",
    "syntax": [
      {
        "syntax": "addabsorbing;",
        "description": "Adds a PML boundary condition to the 'DGTD' solver. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addanalysisgroup",
    "description": "Adds an [analysis group](https://optics.ansys.com/hc/en-us/articles/360034382454) to the simulation environment. Analysis groups are container objects that can contain any simulation object and associated script functions which can be used to create customize data analysis.",
    "usage": "addanalysisgroup();",
    "category": "general",
    "markdown": "# addanalysisgroup\r\n\r\nAdds an [analysis group](https://optics.ansys.com/hc/en-us/articles/360034382454) to the\r\nsimulation environment. Analysis groups are container objects that can contain any\r\nsimulation object and associated script functions which can be used to create customize\r\ndata analysis.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                                                                                                                                               |\r\n| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addanalysisgroup;              | Adds an analysis group to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addanalysisgroup(struct_data); | Adds an analysis group and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nAdd an analysis group and put a time monitor in it.\r\n\r\n```\r\naddanalysisgroup;\r\nset(\"name\",\"group\");\r\naddtime;\r\naddtogroup(\"group\");\r\n```\r\n\r\nTo learn more about how to use analysis groups go to this page:\r\n[ Using Analysis Groups ](https://optics.ansys.com/hc/en-us/articles/360034382454-Analysis-Groups)\r\n.\r\n\r\n## Note: To add a pre-defined analysis group from the object library, use the [ addobject ](./addobject.md) command.",
    "summary": "Adds an [analysis group](https://optics",
    "syntax": [
      {
        "syntax": "addanalysisgroup;",
        "description": "Adds an analysis group to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addanalysisgroup(struct_data);",
        "description": "Adds an analysis group and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addanalysisgroup;\r\nset(\"name\",\"group\");\r\naddtime;\r\naddtogroup(\"group\");"
  },
  {
    "name": "addanalysisprop",
    "description": "Adds a user defined custom analysis property to the setup user defined in structure and analysis groups.",
    "usage": "addanalysisprop();",
    "category": "general",
    "markdown": "# addanalysisprop\r\n\r\nAdds a user defined custom analysis property to the setup user defined in structure and\r\nanalysis groups.\r\n\r\n| **Syntax**                                     | **Description**                                                                                                                                                                                                                                                                                                             |\r\n| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addanalysisprop(\"property name\", type, value); | Adds an analysis property to a selected object group. The name is set to \"property name\". The type is an integer from 0 to 8. The corresponding variable types are: 0 - Number 1 - String 2 - Length 3 - Time 4 - Frequency 5 - Material 6 - Matrix 7 - Cell 8 - Struct The value of the new user property is set to value. |\r\n\r\n**Example**\r\n\r\nAdd a length variable called \"Pname\" as an analysis property for the analysis group\r\n\r\n```\r\naddanalysisgroup;\r\nset(\"name\",\"group\");\r\naddanalysisprop(\"Pname\", 2, 1e-6); # 2 represents Length\r\n```",
    "summary": "Adds a user defined custom analysis property to the setup user defined in structure and analysis gro...",
    "syntax": [
      {
        "syntax": "addanalysisprop(\"property name\", type, value);",
        "description": "Adds an analysis property to a selected object group. The name is set to \"property name\". The type is an integer from 0 to 8. The corresponding variable types are: 0 - Number 1 - String 2 - Length 3 - Time 4 - Frequency 5 - Material 6 - Matrix 7 - Cell 8 - Struct The value of the new user property is set to value."
      }
    ],
    "example": "addanalysisgroup;\r\nset(\"name\",\"group\");\r\naddanalysisprop(\"Pname\", 2, 1e-6); # 2 represents Length"
  },
  {
    "name": "addanalysisresult",
    "description": "Adds a new result to an analysis group object.",
    "usage": "addanalysisresult();",
    "category": "general",
    "markdown": "# addanalysisresult\r\n\r\nAdds a new result to an analysis group object.\r\n\r\n| **Syntax**              | **Description**                                    |\r\n| ----------------------- | -------------------------------------------------- |\r\n| addanalysisresult(\"A\"); | Adds a new result called \"A\" to an analysis group. |\r\n\r\n**Example**\r\n\r\nAdd a result variable \"A\" for output. It must be calculated inside the analysis group.\r\n\r\n```\r\naddanalysisgroup;\r\nset(\"name\",\"group\");\r\naddanalysisresult(\"A\"); # \"A\" is a result variable inside the analysis group. \r\n```",
    "summary": "Adds a new result to an analysis group object",
    "syntax": [
      {
        "syntax": "addanalysisresult(\"A\");",
        "description": "Adds a new result called \"A\" to an analysis group."
      }
    ],
    "example": "addanalysisgroup;\r\nset(\"name\",\"group\");\r\naddanalysisresult(\"A\"); # \"A\" is a result variable inside the analysis group."
  },
  {
    "name": "addattribute",
    "description": "Adds an attribute to an existing dataset.",
    "usage": "addattribute();",
    "category": "general",
    "markdown": "# addattribute\r\n\r\nAdds an attribute to an existing dataset.\r\n\r\n| **Syntax**                                 | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| R.addattribute(\"a_name\", a);               | Adds the scalar attribute a to the dataset R. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about the required dimensions of attribute data.                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| R.addattribute(\"a_vector\", a_1, a_2, a_3); | Adds the vector attribute a_vector to the existing dataset R. The components of the vector are a_1, a_2 and a_3. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about the required dimensions of attribute data.                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| R.addattribute(\"a_name\", [data], \"type\");  | Adds the attribute \"a_name\" to the unstructured dataset R. [data] can be in one of the forms below: vertex_scalar_attribute[npts; npar_1; npar_2; ...1] vertex_vector_attribute[npts; npar_1; npar_2; ...3] cell_scalar_attribute[ncells; 1] cell_vector_attribute[ncells; 3] (npts is the number of vertices, the length of geometric parameters 'x', 'y', 'z' cells is the number of elements, equal to number of rows of geometry parameter 'elements' ) The \"type\" argument is an optional string to specify attribute type and can take values of \"vertex\" or \"cell\". If not provided, the function will guess the attribute type based on the shape of [data] argument. |\r\n\r\n**Examples**\r\n\r\nThis example uses a matrix dataset to store cross section (sigma) data as a function of\r\nfrequency. In this case, the cross section data sigma is the attribute, and frequency is\r\nthe parameter. To allow the user to access the frequency parameter in terms of frequency\r\nor wavelength , both frequency (f) and wavelength (c/f) are added as interdependent\r\nparameters.\r\n\r\n```\r\nsigma = matrixdataset(\"cross_section\");\r\nsigma.addparameter(\"lambda\",c/f,\"f\",f); # add parameter f and lambda\r\nsigma.addattribute(\"sigma\",CS); # add attribute CS\r\nvisualize(sigma); # visualize this dataset in the Visualizer\r\n```\r\n\r\nAlternatively, one can also create a vector rectilinear dataset (with the name E).\r\n\r\n```\r\nE = rectilineardataset(\"E\",x,y,z);\r\nE.addparameter(\"f\",f);\r\nE.addattribute(\"E\",Ex,Ey,Ez); # add a vector E with the components Ex, Ey and Ez\r\nvisualize(E); # visualize this dataset in the Visualizer\r\n```",
    "summary": "Adds an attribute to an existing dataset",
    "syntax": [
      {
        "syntax": "R.addattribute(\"a_name\", a);",
        "description": "Adds the scalar attribute a to the dataset R. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about the required dimensions of attribute data."
      },
      {
        "syntax": "R.addattribute(\"a_vector\", a_1, a_2, a_3);",
        "description": "Adds the vector attribute a_vector to the existing dataset R. The components of the vector are a_1, a_2 and a_3. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about the required dimensions of attribute data."
      },
      {
        "syntax": "R.addattribute(\"a_name\", [data], \"type\");",
        "description": "Adds the attribute \"a_name\" to the unstructured dataset R. [data] can be in one of the forms below: vertex_scalar_attribute[npts; npar_1; npar_2; ...1] vertex_vector_attribute[npts; npar_1; npar_2; ...3] cell_scalar_attribute[ncells; 1] cell_vector_attribute[ncells; 3] (npts is the number of vertices, the length of geometric parameters 'x', 'y', 'z' cells is the number of elements, equal to number of rows of geometry parameter 'elements' ) The \"type\" argument is an optional string to specify attribute type and can take values of \"vertex\" or \"cell\". If not provided, the function will guess the attribute type based on the shape of [data] argument."
      }
    ],
    "example": ""
  },
  {
    "name": "addbandstructuremonitor",
    "description": "Adds a [band structure monitor](https://optics.ansys.com/hc/en-us/articles/360034398174) to the simulation environment. This command requires the presence of a CHARGE solver region in the objects tree.",
    "usage": "addbandstructuremonitor();",
    "category": "general",
    "markdown": "# addbandstructuremonitor\r\n\r\nAdds a [band structure monitor](https://optics.ansys.com/hc/en-us/articles/360034398174)\r\nto the simulation environment. This command requires the presence of a CHARGE solver\r\nregion in the objects tree.\r\n\r\n| **Syntax**                            | **Description**                                                                                                                                                                                                                                                                      |\r\n| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addbandstructuremonitor;              | Adds a band structure monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addbandstructuremonitor(struct_data); | Adds a band structure monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a bandstructure monitor to the simulation\r\nenvironment along the z axis, set its dimension, and enable saving the energy band for\r\nthe vacuum level (Evac).\r\n\r\n```\r\naddbandstructuremonitor;\r\nset(\"name\",\"band\");\r\nset(\"monitor type\",4);  # linear z\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",5e-6);\r\nset(\"record Evac\",1);\r\n```",
    "summary": "Adds a [band structure monitor](https://optics",
    "syntax": [
      {
        "syntax": "addbandstructuremonitor;",
        "description": "Adds a band structure monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addbandstructuremonitor(struct_data);",
        "description": "Adds a band structure monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addbandstructuremonitor;\r\nset(\"name\",\"band\");\r\nset(\"monitor type\",4);  # linear z\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",5e-6);\r\nset(\"record Evac\",1);"
  },
  {
    "name": "addbulkgen",
    "description": "Adds a [bulk (optical) generation region](https://optics.ansys.com/hc/en-us/articles/360034398074) to the simulation environment. The bulk generation (source) object can be used to create an analytic solar generation profile. This command requires a CHARGE solver region to be present in the objects tree.",
    "usage": "addbulkgen();",
    "category": "general",
    "markdown": "# addbulkgen\r\n\r\nAdds a\r\n[bulk (optical) generation region](https://optics.ansys.com/hc/en-us/articles/360034398074)\r\nto the simulation environment. The bulk generation (source) object can be used to create\r\nan analytic solar generation profile. This command requires a CHARGE solver region to be\r\npresent in the objects tree.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                                                                |\r\n| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addbulkgen;              | Add a bulk (optical) generation region. This function does not return any data.                                                                                                                                                                                                                |\r\n| addbulkgen(struct_data); | Adds a bulk (optical) generation region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a bulk generation (source) object to the CHARGE\r\nsolver region. The object is set up to calculate the solar generation rate in silicon\r\nconsidering the AM1.5G solar spectrum.\r\n\r\n```\r\naddbulkgen;\r\nset(\"name\",\"solar\");# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",1e-6);\r\nset(\"z\",5e-6);\r\nset(\"z span\",1e-6);\r\n# set parameters for analytic profile\r\nset(\"illumination face\",6);  #  upper z\r\nset(\"spectrum\",0);  # AM1.5G\r\nset(\"material\",0);  # silicon\r\nset(\"interface reflection\",1);  # air interface\r\n```",
    "summary": "Adds a [bulk (optical) generation region](https://optics",
    "syntax": [
      {
        "syntax": "addbulkgen;",
        "description": "Add a bulk (optical) generation region. This function does not return any data."
      },
      {
        "syntax": "addbulkgen(struct_data);",
        "description": "Adds a bulk (optical) generation region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addbulkgen;\r\nset(\"name\",\"solar\");# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",1e-6);\r\nset(\"z\",5e-6);\r\nset(\"z span\",1e-6);\r\n# set parameters for analytic profile\r\nset(\"illumination face\",6);  #  upper z\r\nset(\"spectrum\",0);  # AM1.5G\r\nset(\"material\",0);  # silicon\r\nset(\"interface reflection\",1);  # air interface"
  },
  {
    "name": "addchargemesh",
    "description": "Adds a [mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994) to the 'CHARGE' simulation. A CHARGE solver region must be present in the objects tree for this command to work.",
    "usage": "addchargemesh();",
    "category": "general",
    "markdown": "# addchargemesh\r\n\r\nAdds a\r\n[mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994)\r\nto the 'CHARGE' simulation. A CHARGE solver region must be present in the objects tree\r\nfor this command to work.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                               |\r\n| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addchargemesh;              | Adds a mesh constraint to the 'CHARGE' simulation environment. This function does not return any data.                                                                                                                                                                        |\r\n| addchargemesh(struct_data); | Adds a mesh constraint and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a mesh constraint to the CHARGE solver region in\r\nFinite Element IDE, name it, set its dimension, and set the maximum edge length for any\r\nelement within the volume.\r\n\r\n```\r\naddchargesolver;\r\naddchargemesh;\r\nset(\"name\",\"mesh_SCR\");\r\n# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n# restrict maximum edge length for elements\r\nset(\"max edge length\",5e-9);\r\n```",
    "summary": "Adds a [mesh constraint (override region)](https://optics",
    "syntax": [
      {
        "syntax": "addchargemesh;",
        "description": "Adds a mesh constraint to the 'CHARGE' simulation environment. This function does not return any data."
      },
      {
        "syntax": "addchargemesh(struct_data);",
        "description": "Adds a mesh constraint and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addchargesolver;\r\naddchargemesh;\r\nset(\"name\",\"mesh_SCR\");\r\n# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n# restrict maximum edge length for elements\r\nset(\"max edge length\",5e-9);"
  },
  {
    "name": "addchargemonitor",
    "description": "Adds a [charge monitor](https://optics.ansys.com/hc/en-us/articles/360034398154) to the simulation environment. This command requires the presence of a CHARGE solver region in the objects tree.",
    "usage": "addchargemonitor();",
    "category": "general",
    "markdown": "# addchargemonitor\r\n\r\nAdds a [charge monitor](https://optics.ansys.com/hc/en-us/articles/360034398154) to the\r\nsimulation environment. This command requires the presence of a CHARGE solver region in\r\nthe objects tree.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                                                                                                                                              |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addchargemonitor;              | Adds a charge monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addchargemonitor(struct_data); | Adds a charge monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a 2D y-normal charge monitor to the simulation\r\nenvironment, set its dimension, and enable saving the charge data in a .mat file.\r\n\r\n```\r\naddchargemonitor;\r\nset(\"name\",\"charge\");\r\nset(\"monitor type\",6);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"save data\",1);\r\nfilename = \"charge_data.mat\";\r\nset(\"filename\",filename);\r\n```",
    "summary": "Adds a [charge monitor](https://optics",
    "syntax": [
      {
        "syntax": "addchargemonitor;",
        "description": "Adds a charge monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addchargemonitor(struct_data);",
        "description": "Adds a charge monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addchargemonitor;\r\nset(\"name\",\"charge\");\r\nset(\"monitor type\",6);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"save data\",1);\r\nfilename = \"charge_data.mat\";\r\nset(\"filename\",filename);"
  },
  {
    "name": "addchargesolver",
    "description": "Adds an [electrical (CHARGE) solver region](https://optics.ansys.com/hc/en-us/articles/360034924473) to the simulation environment.",
    "usage": "addchargesolver();",
    "category": "general",
    "markdown": "# addchargesolver\r\n\r\nAdds an\r\n[electrical (CHARGE) solver region](https://optics.ansys.com/hc/en-us/articles/360034924473)\r\nto the simulation environment.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                                                                                                                                                  |\r\n| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addchargesolver;              | Adds an electrical (CHARGE) solver region to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addchargesolver(struct_data); | Adds an electrical (CHARGE) solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 2D y-normal CHARGE solver region, set its\r\ndimension, and run the simulation. The script assumes that the simulation environment\r\nalready has the geometry and boundary conditions set up.\r\n\r\n```\r\naddchargesolver;\r\nset(\"solver geometry\",1);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;\r\n```",
    "summary": "Adds an [electrical (CHARGE) solver region](https://optics",
    "syntax": [
      {
        "syntax": "addchargesolver;",
        "description": "Adds an electrical (CHARGE) solver region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addchargesolver(struct_data);",
        "description": "Adds an electrical (CHARGE) solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addchargesolver;\r\nset(\"solver geometry\",1);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;"
  },
  {
    "name": "addcircle",
    "description": "Adds a [circle primitive](https://optics.ansys.com/hc/en-us/articles/360034901513) to the simulation environment. Circles denote physical objects which appear circular or ellipsoid from above. These objects are circles or ellipses in 2D, and circular or ellipsoid cylinders in 3D.",
    "usage": "addcircle();",
    "category": "general",
    "markdown": "# addcircle\r\n\r\nAdds a [circle primitive](https://optics.ansys.com/hc/en-us/articles/360034901513) to\r\nthe simulation environment. Circles denote physical objects which appear circular or\r\nellipsoid from above. These objects are circles or ellipses in 2D, and circular or\r\nellipsoid cylinders in 3D.\r\n\r\n| **Syntax**              | **Description**                                                                                                                                                                                                                                                                |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addcircle;              | Adds a circle primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addcircle(struct_data); | Adds a circle primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will create a circle named \"new_circle\" with a radius of 5\r\num centered at (x,y,z) = (1, 2, 0) microns. The circle will have a thickness (z span) of\r\n10 microns.\r\n\r\n```\r\naddcircle;\r\nset(\"name\",\"new_circle\");\r\nset(\"x\",1e-6);\r\nset(\"y\",2e-6);\r\nset(\"radius\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n```",
    "summary": "Adds a [circle primitive](https://optics",
    "syntax": [
      {
        "syntax": "addcircle;",
        "description": "Adds a circle primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addcircle(struct_data);",
        "description": "Adds a circle primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addcircle;\r\nset(\"name\",\"new_circle\");\r\nset(\"x\",1e-6);\r\nset(\"y\",2e-6);\r\nset(\"radius\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);"
  },
  {
    "name": "addconvectionbc",
    "description": "Adds a new convection boundary condition to the HEAT or CHARGE solver \\[ [ Boundary Conditions (Thermal Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-) \\]. A HEAT or CHARGE solver region must be present in the objects tree before this boundary condition can be added. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addconvectionbc();",
    "category": "general",
    "markdown": "# addconvectionbc\r\n\r\nAdds a new convection boundary condition to the HEAT or CHARGE solver \\[\r\n[ Boundary Conditions (Thermal Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\r\n\\]. A HEAT or CHARGE solver region must be present in the objects tree before this\r\nboundary condition can be added. If both solvers are present then the intended solver's\r\nname must be provided as an argument to the script command.\r\n\r\nThe convection boundary condition can only be added to the CHARGE solver when the\r\nsolver's temperature dependency is set to 'coupled'.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                                                |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addconvectionbc;                | Adds a convection boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addconvectionbc(\"solver_name\"); | Adds a convection boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a convection boundary condition to the solver\r\nalready present in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddconvectionbc;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a convection boundary condition to the HEAT\r\nsolver already present in the objects tree. The boundary condition is then assigned to\r\nthe interface (surfaces) between silicon and air. The model is set to a constant h\r\n(convection heat transfer coefficient) and the value of h is set to 10 W/m^2-K. The\r\nambient temperature is set to 300 K.\r\n\r\n```\r\naddconvectionbc(\"HEAT\");\r\nset(\"name\",\"conv_air\");\r\nset(\"convection model\",\"constant\");\r\nset(\"ambient temperature\",300);\r\nset(\"h convection\",10);\r\nset(\"surface type\",\"material:material\");\r\nset(\"material 1\",\"Si (Silicon)\");\r\nset(\"material 2\",\"Air\");\r\n```\r\n\r\n## NOTE: The 'materials' folder in the objects tree must already contain the materials used in the script commands to set up the boundary condition.\r\n\r\n**Example 3**\r\n\r\nThe following script commands will add a convection boundary condition to the HEAT\r\nsolver already present in the objects tree. The boundary condition is assigned to the\r\ninterface (surfaces) between silicon and air. The model is set to forced convection. The\r\nfluid material is automatically selected from the material combination and the length\r\nscale, fluid velocity, and ambient temperature are set from the script.\r\n\r\n```\r\naddconvectionbc(\"HEAT\");\r\nset(\"name\",\"conv_air\");\r\nset(\"convection model\",\"forced\");\r\nset(\"ambient temperature\",300);\r\nset(\"length scale\",1e-3);  # 1 mm\r\nset(\"fluid velocity\",100);  # m/sec\r\nset(\"surface type\",\"material:material\");\r\nset(\"material 1\",\"Si (Silicon)\");\r\nset(\"material 2\",\"Air\");\r\n```\r\n\r\n**Example 4**\r\n\r\nThe following script commands will add a convection boundary condition to the HEAT\r\nsolver already present in the objects tree. The boundary condition is assigned to the\r\ntop (+z) surface of the simulation region. The model is set to a constant h (convection\r\nheat transfer coefficient) and the value of h is set to 100 W/m^2-K. The ambient\r\ntemperature is set to 300 K.\r\n\r\n```\r\naddconvectionbc(\"HEAT\");\r\nset(\"name\",\"conv_top\");\r\nset(\"convection model\",\"constant\");\r\nset(\"ambient temperature\",300);\r\nset(\"h convection\",100);\r\nset(\"surface type\",\"simulation region\");\r\nset(\"z max\",1);\r\n```",
    "summary": "Adds a new convection boundary condition to the HEAT or CHARGE solver \\[ [ Boundary Conditions (Ther...",
    "syntax": [
      {
        "syntax": "addconvectionbc;",
        "description": "Adds a convection boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addconvectionbc(\"solver_name\");",
        "description": "Adds a convection boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addctmaterialproperty",
    "description": "Adds a new electrical material property to the selected material model or the selected ternary alloy. A material model (in the 'materials' folder) or a ternary alloy electrical material property must be selected in the object tree for this script command to work. A ternary alloy may not be created as a component of a ternary alloy. To add an electrical material property from the electrothermal material database, see [ addmaterialproperties ](./addmaterialproperties.md) . For details of electrical material models, see [ Electrical/Thermal Material Models ](https://optics.ansys.com/hc/en-us/articles/360034919093-Electrical-Thermal-Material-Models) or the page specifically about [ Semiconductors](https://optics.ansys.com/hc/en-us/articles/360034919113-Semiconductors).",
    "usage": "addctmaterialproperty();",
    "category": "general",
    "markdown": "# addctmaterialproperty\r\n\r\nAdds a new electrical material property to the selected material model or the selected\r\nternary alloy. A material model (in the 'materials' folder) or a ternary alloy\r\nelectrical material property must be selected in the object tree for this script command\r\nto work. A ternary alloy may not be created as a component of a ternary alloy. To add an\r\nelectrical material property from the electrothermal material database, see\r\n[ addmaterialproperties ](./addmaterialproperties.md) . For details of electrical\r\nmaterial models, see\r\n[ Electrical/Thermal Material Models ](https://optics.ansys.com/hc/en-us/articles/360034919093-Electrical-Thermal-Material-Models)\r\nor the page specifically about\r\n[ Semiconductors](https://optics.ansys.com/hc/en-us/articles/360034919113-Semiconductors).\r\n\r\n| **Syntax**                              | **Description**                                                                                                                                                 |\r\n| --------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addctmaterialproperty(\"property_type\"); | Adds a new electrical material property to the selected material model or the selected ternary alloy. The \"property_type\" argument can be one of the following: |\r\n\r\n- \"Semiconductor\"\r\n- \"Insulator\"\r\n- \"Conductor\"\r\n- \"Ternary Alloy\"\r\n\r\nThis function does not return any data.\r\n\r\n**Example**\r\n\r\nThe following script commands will add a new material to the objects tree in Finite\r\nElement IDE, and assign electrical property of conductor to it.\r\n\r\n```\r\naddmodelmaterial;\r\naddctmaterialproperty(\"Conductor\");\r\n```\r\n\r\n## NOTE: Once a material property is assigned to the material model the selection changes to the corresponding property. Therefore the material model must be re-selected before adding a new property to it.\r\n\r\nNOTE: For a newly created alloy, when the first base material is added to the alloy, the\r\nsecond base material will also be the same material as the first. For example, the\r\nfollowing lines will create a new alloy and assign the solid material \"A\" as both base\r\nmaterial 1 and base material 2 for the alloy:\r\n\r\n```\r\naddmodelmaterial;\r\nset(\"name\",\"test\");\r\naddctmaterialproperty(\"Ternary Alloy\");\r\nset(\"name\",\"alloy\");\r\naddctmaterialproperty(\"Semiconductor\");\r\nset(\"name\",\"A\");  \r\n```\r\n\r\n______________________________________________________________________",
    "summary": "Adds a new electrical material property to the selected material model or the selected ternary alloy",
    "syntax": [
      {
        "syntax": "addctmaterialproperty(\"property_type\");",
        "description": "Adds a new electrical material property to the selected material model or the selected ternary alloy. The \"property_type\" argument can be one of the following:"
      }
    ],
    "example": "addmodelmaterial;\r\naddctmaterialproperty(\"Conductor\");"
  },
  {
    "name": "addcustom",
    "description": "Adds a [custom](https://optics.ansys.com/hc/en-us/articles/360036620233) primitive to the simulation environment. Custom primitives are objects that are defined by equations describing the boundaries of the physical object.",
    "usage": "addcustom();",
    "category": "general",
    "markdown": "# addcustom\r\n\r\nAdds a [custom](https://optics.ansys.com/hc/en-us/articles/360036620233) primitive to\r\nthe simulation environment. Custom primitives are objects that are defined by equations\r\ndescribing the boundaries of the physical object.\r\n\r\n| **Syntax**              | **Description**                                                                                                                                                                                                                                                                |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addcustom;              | Adds a custom primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addcustom(struct_data); | Adds a custom primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will create a half circle with a radius of 0.5 micron in\r\nthe XY plane and extrude it along the Z axis.\r\n\r\n```\r\naddcustom;\r\nset(\"create 3D object by\",\"extrusion\");#  y = sqrt(0.5^2-(x-0.5)^2)\r\nset(\"equation 1\",\"sqrt(\"+num2str(0.5)+\"^2-(x-\"+num2str(0.5)+\")^2)\");   \r\nset(\"x span\",1e-6);\r\nset(\"y span\",1e-6);\r\nset(\"z span\",2e-6);\r\n```\r\n\r\nThe same equation can be used to create half a sphere by rotating the half circle rather\r\nthan extruding it.\r\n\r\n```\r\naddcustom;\r\nset(\"create 3D object by\",\"revolution\");#  y = sqrt(0.5^2-(x-0.5)^2)\r\nset(\"equation 1\",\"sqrt(\"+num2str(0.5)+\"^2-(x-\"+num2str(0.5)+\")^2)\");   \r\nset(\"x span\",1e-6);\r\nset(\"y span\",1e-6);\r\nset(\"z span\",2e-6);\r\n```",
    "summary": "Adds a [custom](https://optics",
    "syntax": [
      {
        "syntax": "addcustom;",
        "description": "Adds a custom primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addcustom(struct_data);",
        "description": "Adds a custom primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addcustom;\r\nset(\"create 3D object by\",\"extrusion\");#  y = sqrt(0.5^2-(x-0.5)^2)\r\nset(\"equation 1\",\"sqrt(\"+num2str(0.5)+\"^2-(x-\"+num2str(0.5)+\")^2)\");   \r\nset(\"x span\",1e-6);\r\nset(\"y span\",1e-6);\r\nset(\"z span\",2e-6);"
  },
  {
    "name": "adddeltachargesource",
    "description": "Adds a [delta optical generation source](https://optics.ansys.com/hc/en-us/articles/360034398094) to the simulation environment. This command requires a CHARGE solver region to be present in the objects tree.",
    "usage": "adddeltachargesource();",
    "category": "general",
    "markdown": "# adddeltachargesource\r\n\r\nAdds a\r\n[delta optical generation source](https://optics.ansys.com/hc/en-us/articles/360034398094)\r\nto the simulation environment. This command requires a CHARGE solver region to be\r\npresent in the objects tree.\r\n\r\n| **Syntax**                         | **Description**                                                                                                                                                                                                                                                                               |\r\n| ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adddeltachargesource;              | Add a delta optical generation source to the simulation environment. This function does not return any data.                                                                                                                                                                                  |\r\n| adddeltachargesource(struct_data); | Adds a delta optical generation source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a delta optical generation source, set its\r\nlocation, and set the generation rate by defining a net electron-hole-pair current\r\n(/sec).\r\n\r\n```\r\nadddeltachargesource;\r\nset(\"name\",\"delta\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",5e-6);\r\nset(\"source type\",2);  #  ehp current\r\nset(\"ehp current\",1e12);  # net ehp current I_ehp = e*1e12 Amp\r\n```",
    "summary": "Adds a [delta optical generation source](https://optics",
    "syntax": [
      {
        "syntax": "adddeltachargesource;",
        "description": "Add a delta optical generation source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "adddeltachargesource(struct_data);",
        "description": "Adds a delta optical generation source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "adddeltachargesource;\r\nset(\"name\",\"delta\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",5e-6);\r\nset(\"source type\",2);  #  ehp current\r\nset(\"ehp current\",1e12);  # net ehp current I_ehp = e*1e12 Amp"
  },
  {
    "name": "adddevice",
    "description": "Adds a CHARGE solver region to the simulation environment.",
    "usage": "adddevice();",
    "category": "general",
    "markdown": "# adddevice\r\n\r\nAdds a CHARGE solver region to the simulation environment.\r\n\r\n## Note: The 'adddevice' command is deprecated and will be removed in future releases. Please refer to [ addchargesolver ](./addchargesolver.md) as a replacement.\r\n\r\n| **Syntax** | **Description**                                                                                   |\r\n| ---------- | ------------------------------------------------------------------------------------------------- |\r\n| adddevice; | Add a CHARGE solver region to the simulation environment. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 2D y-normal CHARGE solver region, set its\r\ndimension, and run the simulation. The script assumes that the simulation environment\r\nalready has the geometry and boundary conditions set up.\r\n\r\n```\r\nadddevice;\r\nset(\"solver geometry\",1);  #  2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;\r\n```",
    "summary": "Adds a CHARGE solver region to the simulation environment",
    "syntax": [
      {
        "syntax": "adddevice;",
        "description": "Add a CHARGE solver region to the simulation environment. This function does not return any data."
      }
    ],
    "example": "adddevice;\r\nset(\"solver geometry\",1);  #  2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;"
  },
  {
    "name": "adddftmonitor",
    "description": "Adds a frequency domain field profile monitor to the simulation environment. This monitor will snap to the nearest mesh cell to record the data by default. To record data exactly where the monitor is placed, change the “spatial interpolation” settings under “Advanced” in the object properties to “specified position”. Specifics regarding each spatial interpolation option can be found in the Knowledge Base article on [Frequeny-domain monitor](https://optics.ansys.com/hc/en-us/articles/360034902393-Frequency-domain-Profile-and-Power-monitor-Simulation-object).",
    "usage": "adddftmonitor();",
    "category": "general",
    "markdown": "# adddftmonitor\r\n\r\nAdds a frequency domain field profile monitor to the simulation environment. This\r\nmonitor will snap to the nearest mesh cell to record the data by default. To record data\r\nexactly where the monitor is placed, change the “spatial interpolation” settings under\r\n“Advanced” in the object properties to “specified position”. Specifics regarding each\r\nspatial interpolation option can be found in the Knowledge Base article on\r\n[Frequeny-domain monitor](https://optics.ansys.com/hc/en-us/articles/360034902393-Frequency-domain-Profile-and-Power-monitor-Simulation-object).\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                     |\r\n| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adddftmonitor;              | Adds a field profile monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| adddftmonitor(struct_data); | Adds a field profile monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\nThe following script commands will add a 2D z-normal frequency domain field profile\r\nmonitor to the simulation region and set its dimension.\r\n\r\n```\r\nadddftmonitor;  \r\nset(\"name\",\"field_profile\");  \r\nset(\"monitor type\",7); # 2D z-normal  \r\nset(\"x\",0);  \r\nset(\"x span\",5e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",5e-6);  \r\nset(\"z\",0);\r\n```",
    "summary": "Adds a frequency domain field profile monitor to the simulation environment",
    "syntax": [
      {
        "syntax": "adddftmonitor;",
        "description": "Adds a field profile monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "adddftmonitor(struct_data);",
        "description": "Adds a field profile monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "adddgtdmesh",
    "description": "Adds a [mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994) to a 'DGTD' simulation. A DGTD solver region must be present in the objects tree for this command to work.",
    "usage": "adddgtdmesh();",
    "category": "general",
    "markdown": "# adddgtdmesh\r\n\r\nAdds a\r\n[mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994)\r\nto a 'DGTD' simulation. A DGTD solver region must be present in the objects tree for\r\nthis command to work.\r\n\r\n| **Syntax**   | **Description**                                                                                      |\r\n| ------------ | ---------------------------------------------------------------------------------------------------- |\r\n| adddgtdmesh; | Adds a mesh constraint to the 'DGTD' simulation environment. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a mesh constraint to the DGTD solver already\r\npresent in the objects tree and print the name of all of its properties.\r\n\r\n```\r\nadddgtdmesh;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a mesh constraint to the DGTD solver region in\r\nFinite Element IDE, name it, assign it to a specific surface between two domains, and\r\nset the maximum edge length for any element on the surface.\r\n\r\n```\r\nadddgtdsolver;\r\nadddgtdmesh;\r\nset(\"name\",\"mesh_surface\");\r\nset(\"geometry type\",\"surface\");\r\nset(\"surface type\",\"domain:domain\");\r\nset(\"domain 1\",2);\r\nset(\"domain 2\",3);\r\nset(\"max edge length\",0.05e-6);\r\n```",
    "summary": "Adds a [mesh constraint (override region)](https://optics",
    "syntax": [
      {
        "syntax": "adddgtdmesh;",
        "description": "Adds a mesh constraint to the 'DGTD' simulation environment. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "adddgtdsolver",
    "description": "Adds a [DGTD solver region](https://optics.ansys.com/hc/en-us/articles/360034397874) to the simulation environment.",
    "usage": "adddgtdsolver();",
    "category": "general",
    "markdown": "# adddgtdsolver\r\n\r\nAdds a [DGTD solver region](https://optics.ansys.com/hc/en-us/articles/360034397874) to\r\nthe simulation environment.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                  |\r\n| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adddgtdsolver;              | Adds a DGTD solver region to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| adddgtdsolver(struct_data); | Adds a DGTD solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a DGTD solver to the objects tree and print the\r\nname of all of its properties.\r\n\r\n```\r\nadddgtdsolver;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script command will add a DGTD solver region, assign it to a simulation\r\nregion, and set the simulation time.\r\n\r\n```\r\nadddgtdsolver;\r\nset(\"solver geometry\",\"simulation region 1\"); \r\nset(\"simulation time\",100e-15);  # 100 fs\r\n```",
    "summary": "Adds a [DGTD solver region](https://optics",
    "syntax": [
      {
        "syntax": "adddgtdsolver;",
        "description": "Adds a DGTD solver region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "adddgtdsolver(struct_data);",
        "description": "Adds a DGTD solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "adddiffusion",
    "description": "Adds a [diffusion doping region](https://optics.ansys.com/hc/en-us/articles/360034918673) to the simulation environment. This command requires a CHARGE solver region to be present in the objects tree.",
    "usage": "adddiffusion();",
    "category": "general",
    "markdown": "# adddiffusion\r\n\r\nAdds a\r\n[diffusion doping region](https://optics.ansys.com/hc/en-us/articles/360034918673) to\r\nthe simulation environment. This command requires a CHARGE solver region to be present\r\nin the objects tree.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                                                                                                                                                                       |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adddiffusion;              | Add a diffusion doping region in the simulation environment. This function does not return any data.                                                                                                                                                                                  |\r\n| adddiffusion(struct_data); | Adds a diffusion doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a n-type diffusion doping object and set its\r\nproperties. The face where the dopants are introduced is defined by the \"source face\"\r\nproperty and the peak doping is defined by the \"concentration\" property. The \"junction\r\nwidth\" property defines the distance over which the doping drops from the (peak)\r\nconcentration to the low \"ref concentration\" at the other faces of the doping object.\r\n\r\n```\r\nadddiffusion;\r\nset(\"name\",\"nwell\");\r\n# set dimensionset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",1e-6);\r\nset(\"z\",5e-6);\r\nset(\"z span\",1e-6);\r\n# set doping profile\r\nset(\"dopant type\",\"n\");\r\nset(\"source face\",6);  # upper z\r\nset(\"junction width\",0.2e-6);\r\nset(\"concentration\",1e25);  # SI unit (/m3)\r\n```\r\n\r\nThe figure below shows the resulting doping profile.\r\n\r\nMore information about the doping object itself, including the diffusion parameters can\r\nbe found in\r\n[this article](https://support.lumerical.com/hc/en-us/articles/360034918673).",
    "summary": "Adds a [diffusion doping region](https://optics",
    "syntax": [
      {
        "syntax": "adddiffusion;",
        "description": "Add a diffusion doping region in the simulation environment. This function does not return any data."
      },
      {
        "syntax": "adddiffusion(struct_data);",
        "description": "Adds a diffusion doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "adddiffusion;\r\nset(\"name\",\"nwell\");\r\n# set dimensionset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",1e-6);\r\nset(\"z\",5e-6);\r\nset(\"z span\",1e-6);\r\n# set doping profile\r\nset(\"dopant type\",\"n\");\r\nset(\"source face\",6);  # upper z\r\nset(\"junction width\",0.2e-6);\r\nset(\"concentration\",1e25);  # SI unit (/m3)"
  },
  {
    "name": "adddipole",
    "description": "Adds a [dipole source](https://optics.ansys.com/hc/en-us/articles/360034382794) to the simulation environment. In MODE the command requires an active varFDTD solver region in the objects tree.",
    "usage": "adddipole();",
    "category": "general",
    "markdown": "# adddipole\r\n\r\nAdds a [dipole source](https://optics.ansys.com/hc/en-us/articles/360034382794) to the\r\nsimulation environment. In MODE the command requires an active varFDTD solver region in\r\nthe objects tree.\r\n\r\n| **Syntax**              | **Description**                                                                                                                                                                                                                                                             |\r\n| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adddipole;              | Adds a dipole source to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| adddipole(struct_data); | Adds a dipole source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a dipole source to the FDTD simulation\r\nenvironment and set its position.\r\n\r\n```\r\nadddipole;\r\nset(\"x\",0);\r\nset(\"y\",-1e-6);\r\nset(\"z\",5e-6);\r\n```",
    "summary": "Adds a [dipole source](https://optics",
    "syntax": [
      {
        "syntax": "adddipole;",
        "description": "Adds a dipole source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "adddipole(struct_data);",
        "description": "Adds a dipole source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "adddipole;\r\nset(\"x\",0);\r\nset(\"y\",-1e-6);\r\nset(\"z\",5e-6);"
  },
  {
    "name": "adddope",
    "description": "Adds a [constant doping object](https://optics.ansys.com/hc/en-us/articles/360034918653) to the simulation environment. This command requires a CHARGE solver region to be present in the objects tree.",
    "usage": "adddope();",
    "category": "general",
    "markdown": "# adddope\r\n\r\nAdds a [constant doping object](https://optics.ansys.com/hc/en-us/articles/360034918653)\r\nto the simulation environment. This command requires a CHARGE solver region to be\r\npresent in the objects tree.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                      |\r\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| adddope;              | Add a constant doping region. This function does not return any data.                                                                                                                                                                                                                |\r\n| adddope(struct_data); | Adds a constant doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a p-type constant doping object and set its\r\ndimension and concentration.\r\n\r\n```\r\nadddope;\r\nset(\"name\",\"pwell\");\r\nset(\"dopant type\",\"p\");\r\nset(\"concentration\",1e25);  # SI unit (/m3)\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",1e-6);\r\nset(\"z\",5e-6);\r\nset(\"z span\",1e-6);\r\n```",
    "summary": "Adds a [constant doping object](https://optics",
    "syntax": [
      {
        "syntax": "adddope;",
        "description": "Add a constant doping region. This function does not return any data."
      },
      {
        "syntax": "adddope(struct_data);",
        "description": "Adds a constant doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "adddope;\r\nset(\"name\",\"pwell\");\r\nset(\"dopant type\",\"p\");\r\nset(\"concentration\",1e25);  # SI unit (/m3)\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",1e-6);\r\nset(\"z\",5e-6);\r\nset(\"z span\",1e-6);"
  },
  {
    "name": "addeffectiveindex",
    "description": "Adds an [effective index monitor](https://optics.ansys.com/hc/en-us/articles/360034396454) to the simulation environment. This command requires the presence of an active varFDTD solver region.",
    "usage": "addeffectiveindex();",
    "category": "general",
    "markdown": "# addeffectiveindex\r\n\r\nAdds an\r\n[effective index monitor](https://optics.ansys.com/hc/en-us/articles/360034396454) to\r\nthe simulation environment. This command requires the presence of an active varFDTD\r\nsolver region.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                                                                                                                                                        |\r\n| ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addeffectiveindex;              | Adds an effective index monitor to the varFDTD solver region. This function does not return any data.                                                                                                                                                                                  |\r\n| addeffectiveindex(struct_data); | Adds an effective index monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add an effective index monitor to the simulation\r\nregion and set its dimension.\r\n\r\n```\r\naddeffectiveindex;\r\nset(\"name\",\"neff\");\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\n```",
    "summary": "Adds an [effective index monitor](https://optics",
    "syntax": [
      {
        "syntax": "addeffectiveindex;",
        "description": "Adds an effective index monitor to the varFDTD solver region. This function does not return any data."
      },
      {
        "syntax": "addeffectiveindex(struct_data);",
        "description": "Adds an effective index monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addeffectiveindex;\r\nset(\"name\",\"neff\");\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);"
  },
  {
    "name": "addefieldmonitor",
    "description": "Adds an [electric field monitor](https://optics.ansys.com/hc/en-us/articles/360034918793) to the simulation environment. This command requires the presence of a CHARGE solver region in the objects tree.",
    "usage": "addefieldmonitor();",
    "category": "general",
    "markdown": "# addefieldmonitor\r\n\r\nAdds an\r\n[electric field monitor](https://optics.ansys.com/hc/en-us/articles/360034918793) to the\r\nsimulation environment. This command requires the presence of a CHARGE solver region in\r\nthe objects tree.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                                                                                                                                                       |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addefieldmonitor;              | Adds an electric field monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addefieldmonitor(struct_data); | Adds an electric field monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a 2D y-normal electric field monitor to the\r\nsimulation environment, set its dimension, enable saving the electrostatic potential,\r\nand save the data in a .mat file.\r\n\r\n```\r\naddefieldmonitor;\r\nset(\"name\",\"E_field\");\r\nset(\"monitor type\",6);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"y span\",5e-6);\r\nset(\"record electrostatic potential\",1);\r\nset(\"save data\",1);\r\nfilename = \"electric_field.mat\";\r\nset(\"filename\",filename);\r\n```",
    "summary": "Adds an [electric field monitor](https://optics",
    "syntax": [
      {
        "syntax": "addefieldmonitor;",
        "description": "Adds an electric field monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addefieldmonitor(struct_data);",
        "description": "Adds an electric field monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addefieldmonitor;\r\nset(\"name\",\"E_field\");\r\nset(\"monitor type\",6);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"y span\",5e-6);\r\nset(\"record electrostatic potential\",1);\r\nset(\"save data\",1);\r\nfilename = \"electric_field.mat\";\r\nset(\"filename\",filename);"
  },
  {
    "name": "addelectricalcontact",
    "description": "Adds a new electrical contact boundary condition to the CHARGE solver \\[ [ Boundary Conditions (Electrical Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034918833-Boundary-Conditions-Electrical-Simulation-) \\]. A CHARGE solver region must be present in the objects tree before an electrical contact boundary condition can be added.",
    "usage": "addelectricalcontact();",
    "category": "general",
    "markdown": "# addelectricalcontact\r\n\r\nAdds a new electrical contact boundary condition to the CHARGE solver \\[\r\n[ Boundary Conditions (Electrical Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034918833-Boundary-Conditions-Electrical-Simulation-)\r\n\\]. A CHARGE solver region must be present in the objects tree before an electrical\r\ncontact boundary condition can be added.\r\n\r\n| **Syntax**            | **Description**                                                                                             |\r\n| --------------------- | ----------------------------------------------------------------------------------------------------------- |\r\n| addelectricalcontact; | Adds an electrical contact boundary condition to the CHARGE solver. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add an electrical contact boundary condition to the\r\nsolver already present in the objects tree and print all available properties of the\r\nboundary condition.\r\n\r\n```\r\naddelectricalcontact;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will create an electrical boundary condition with a fixed\r\nsteady state voltage assigned to a solid named cathode. The objects tree must already\r\nhave a CHARGE solver and a geometry named 'cathode' present.\r\n\r\n```\r\naddelectricalcontact;\r\nset(\"name\",\"cathode\");\r\nset(\"bc mode\",\"steady state\");\r\nset(\"sweep type\",\"single\");\r\nset(\"voltage\",0.2);  # setting the voltage to 0.2 V\r\nset(\"surface type\",\"solid\");\r\nset(\"solid\",\"cathode\");\r\n```\r\n\r\n**Example 3**\r\n\r\nThe following script commands will create a steady state electrical contact boundary\r\ncondition named cathode and apply a voltage sweep over a predefined set of voltages. The\r\nobjects tree must already have a CHARGE solver and a geometry named 'cathode' present.\r\n\r\n```\r\naddelectricalcontact;\r\nset(\"name\",\"cathode\");\r\nset(\"bc mode\",\"steady state\");\r\nset(\"sweep type\",\"value\");\r\nV = [0, 0.1, 0.2, 0.3, 0.4, 0.45, 0.5, 0.55, 0.56, 0.57, 0.58, 0.59, 0.6];\r\nset(\"value table\",V);\r\nset(\"surface type\",\"solid\");\r\nset(\"solid\",\"cathode\");\r\n```\r\n\r\n**Example 4**\r\n\r\nThe following script commands will set up a transient electrical contact boundary\r\ncondition where the voltage is 0 V at t = 0, steps to 1 V between t = 10 ps and 100 ps\r\n(tslew = 90 ps), and remains at 1 V until t = 500 ps. The boundary condition is assigned\r\nto a solid named cathode.\r\n\r\n```\r\naddelectricalcontact;\r\nset(\"name\",\"cathode_trans\");\r\nset(\"bc mode\",\"transient\");\r\ntstep = [0, 10e-12, 100e-12, 500e-12];\r\nV = [0, 0, 1, 1];\r\nset(\"transient voltage time steps\",tstep);\r\nset(\"transient voltage table\",V);\r\nset(\"surface type\",\"solid\");\r\nset(\"solid\",\"cathode\");\r\n```",
    "summary": "Adds a new electrical contact boundary condition to the CHARGE solver \\[ [ Boundary Conditions (Elec...",
    "syntax": [
      {
        "syntax": "addelectricalcontact;",
        "description": "Adds an electrical contact boundary condition to the CHARGE solver. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addelement",
    "description": "Adds an element from the INTERCONNECT element library to the simulation environment.",
    "usage": "addelement();",
    "category": "general",
    "markdown": "# addelement\r\n\r\nAdds an element from the INTERCONNECT element library to the simulation environment.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                     |\r\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addelement(\"element\"); | Adds an element from the element library. If no element name is given, this command will add a compound element by default. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a waveguide coupler to the simulation environment\r\nand edit its properties.\r\n\r\n```\r\naddelement(\"Waveguide Coupler\");\r\neleName = \"coupler_1\";\r\nset(\"name\", eleName);\r\nset(\"x position\", 0); \r\nset(\"y position\", 0);\r\nset(\"coupling coefficient 1\", 0.3);\r\n```",
    "summary": "Adds an element from the INTERCONNECT element library to the simulation environment",
    "syntax": [
      {
        "syntax": "addelement(\"element\");",
        "description": "Adds an element from the element library. If no element name is given, this command will add a compound element by default. This function does not return any data."
      }
    ],
    "example": "addelement(\"Waveguide Coupler\");\r\neleName = \"coupler_1\";\r\nset(\"name\", eleName);\r\nset(\"x position\", 0); \r\nset(\"y position\", 0);\r\nset(\"coupling coefficient 1\", 0.3);"
  },
  {
    "name": "addemabsorptionmonitor",
    "description": "Adds an [absorption monitor](https://optics.ansys.com/hc/en-us/articles/360034918573) to the 'DGTD' solver in Finite Element IDE. The monitor reports the power absorbed within the monitor volume. A DGTD solver region must be present in the objects tree for this command to work.",
    "usage": "addemabsorptionmonitor();",
    "category": "general",
    "markdown": "# addemabsorptionmonitor\r\n\r\nAdds an [absorption monitor](https://optics.ansys.com/hc/en-us/articles/360034918573) to\r\nthe 'DGTD' solver in Finite Element IDE. The monitor reports the power absorbed within\r\nthe monitor volume. A DGTD solver region must be present in the objects tree for this\r\ncommand to work.\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                                                                   |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addemabsorptionmonitor;              | Adds an absorption monitor to the 'DGTD' solver. This function does not return any data.                                                                                                                                                                                          |\r\n| addemabsorptionmonitor(struct_data); | Adds an absorption monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add an absorption monitor to the 'DGTD' solver\r\nalready present in the objects tree and print all available properties of the monitor.\r\n\r\n```\r\naddemabsorptionmonitor;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add an absorption monitor to the 'DGTD' solver,\r\nchange its name, set its frequency span to be the same as the source, and assign it to a\r\nsolid named \"nanoparticle\".\r\n\r\n```\r\naddemabsorptionmonitor; \r\nset(\"name\",\"Pabs\");\r\nset(\"use source limits\",1);\r\nset(\"reference source\",\"plane_wave\");  \r\nset(\"volume type\",\"solid\");\r\nset(\"volume solid\",\"nanoparticle\");\r\n```\r\n\r\n## NOTE: The script above assumes that there is already a solid named \"nanoparticle\" and a source named \"plane_wave\" present in the objects tree.",
    "summary": "Adds an [absorption monitor](https://optics",
    "syntax": [
      {
        "syntax": "addemabsorptionmonitor;",
        "description": "Adds an absorption monitor to the 'DGTD' solver. This function does not return any data."
      },
      {
        "syntax": "addemabsorptionmonitor(struct_data);",
        "description": "Adds an absorption monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addeme",
    "description": "Adds an [Eigenmode Expansion (EME) solver region](https://optics.ansys.com/hc/en-us/articles/360034917013) to the MODE simulation environment.",
    "usage": "addeme();",
    "category": "general",
    "markdown": "# addeme\r\n\r\nAdds an\r\n[Eigenmode Expansion (EME) solver region](https://optics.ansys.com/hc/en-us/articles/360034917013)\r\nto the MODE simulation environment.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                                                                                                                  |\r\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addeme;              | Add an EME solver region to the simulation environment. This function does not return any data.                                                                                                                                                                                  |\r\n| addeme(struct_data); | Adds an EME solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add an EME solver region, set its dimension and other\r\nproperties, and run the simulation. The script assumes that the simulation environment\r\nalready has the geometry set up.\r\n\r\n```\r\naddeme;\r\n# set dimension\r\nset(\"x min\",-8e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5.5e-6);\r\nset(\"z\",0.5e-6);\r\nset(\"z span\",7e-6);\r\n# set cell properties\r\nset(\"number of cell groups\",3);\r\nset(\"group spans\",[3e-6; 10e-6; 3e-6]);\r\nset(\"cells\",[1; 19; 1]);\r\nset(\"subcell method\",[0; 1; 0]);   # 0 = none,  1 = CVCS\r\n# set up ports: port 1\r\nselect(\"EME::Ports::port_1\");\r\nset(\"use full simulation span\",1);\r\nset(\"y\",0);\r\nset(\"y span\",5.5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",7e-6);\r\nset(\"mode selection\",\"fundamental mode\");\r\n# set up ports: port 2\r\nselect(\"EME::Ports::port_2\");\r\nset(\"use full simulation span\",1);\r\nset(\"y\",0);\r\nset(\"y span\",5.5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",7e-6);\r\nset(\"mode selection\",\"fundamental mode\");\r\nrun;\r\n```",
    "summary": "Adds an [Eigenmode Expansion (EME) solver region](https://optics",
    "syntax": [
      {
        "syntax": "addeme;",
        "description": "Add an EME solver region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addeme(struct_data);",
        "description": "Adds an EME solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addeme;\r\n# set dimension\r\nset(\"x min\",-8e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5.5e-6);\r\nset(\"z\",0.5e-6);\r\nset(\"z span\",7e-6);\r\n# set cell properties\r\nset(\"number of cell groups\",3);\r\nset(\"group spans\",[3e-6; 10e-6; 3e-6]);\r\nset(\"cells\",[1; 19; 1]);\r\nset(\"subcell method\",[0; 1; 0]);   # 0 = none,  1 = CVCS\r\n# set up ports: port 1\r\nselect(\"EME::Ports::port_1\");\r\nset(\"use full simulation span\",1);\r\nset(\"y\",0);\r\nset(\"y span\",5.5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",7e-6);\r\nset(\"mode selection\",\"fundamental mode\");\r\n# set up ports: port 2\r\nselect(\"EME::Ports::port_2\");\r\nset(\"use full simulation span\",1);\r\nset(\"y\",0);\r\nset(\"y span\",5.5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",7e-6);\r\nset(\"mode selection\",\"fundamental mode\");\r\nrun;"
  },
  {
    "name": "addemeindex",
    "description": "Adds an [index monitor](https://optics.ansys.com/hc/en-us/articles/360034396434) that can be used to return the spatial refractive index when using an EME solver region. The EME solver object must be set as the active solver for this command to work.",
    "usage": "addemeindex();",
    "category": "general",
    "markdown": "# addemeindex\r\n\r\nAdds an [index monitor](https://optics.ansys.com/hc/en-us/articles/360034396434) that\r\ncan be used to return the spatial refractive index when using an EME solver region. The\r\nEME solver object must be set as the active solver for this command to work.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                  |\r\n| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addemeindex;              | Add an index monitor when using an EME solver region. This function does not return any data.                                                                                                                                                                                    |\r\n| addemeindex(struct_data); | Adds an EME index monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add an index monitor to the EME solver region. The\r\nsetactivesolver command is first used to set the EME solver region as the active solver.\r\n\r\n```\r\nsetactivesolver(\"EME\");\r\naddemeindex;\r\n```",
    "summary": "Adds an [index monitor](https://optics",
    "syntax": [
      {
        "syntax": "addemeindex;",
        "description": "Add an index monitor when using an EME solver region. This function does not return any data."
      },
      {
        "syntax": "addemeindex(struct_data);",
        "description": "Adds an EME index monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "setactivesolver(\"EME\");\r\naddemeindex;"
  },
  {
    "name": "addemeport",
    "description": "Adds a [port](https://optics.ansys.com/hc/en-us/articles/360034396374) to an EME solver region/object. The EME solver object must be set as the active solver for this command to work.",
    "usage": "addemeport();",
    "category": "general",
    "markdown": "# addemeport\r\n\r\nAdds a [port](https://optics.ansys.com/hc/en-us/articles/360034396374) to an EME solver\r\nregion/object. The EME solver object must be set as the active solver for this command\r\nto work.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                                                                    |\r\n| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addemeport;              | Add a port to the active EME solver region. This function does not return any data.                                                                                                                                                                                                                |\r\n| addemeport(struct_data); | Adds a port to the active EME solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a port to the EME solver region. The\r\nsetactivesolver command is first used to set the EME solver region as the active solver.\r\n\r\n```\r\nsetactivesolver(\"EME\");\r\naddemeport;\r\n```",
    "summary": "Adds a [port](https://optics",
    "syntax": [
      {
        "syntax": "addemeport;",
        "description": "Add a port to the active EME solver region. This function does not return any data."
      },
      {
        "syntax": "addemeport(struct_data);",
        "description": "Adds a port to the active EME solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "setactivesolver(\"EME\");\r\naddemeport;"
  },
  {
    "name": "addemeprofile",
    "description": "Adds an [EME profile monitor](https://optics.ansys.com/hc/en-us/articles/360034396474) that can be used to return the spatial electric and magnetic field profiles when using an EME solver region. The EME solver object must be set as the active solver for this command to work.",
    "usage": "addemeprofile();",
    "category": "general",
    "markdown": "# addemeprofile\r\n\r\nAdds an [EME profile monitor](https://optics.ansys.com/hc/en-us/articles/360034396474)\r\nthat can be used to return the spatial electric and magnetic field profiles when using\r\nan EME solver region. The EME solver object must be set as the active solver for this\r\ncommand to work.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                   |\r\n| --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addemeprofile;              | Add a profile monitor when using an EME solver region. This function does not return any data.                                                                                                                                                                                    |\r\n| addemeprofile(struct_data); | Adds a EME profile monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add an index monitor to the EME solver region. The\r\nsetactivesolver command is first used to set the EME solver region as the active solver.\r\n\r\n```\r\nsetactivesolver(\"EME\");\r\naddemeprofile;\r\n```",
    "summary": "Adds an [EME profile monitor](https://optics",
    "syntax": [
      {
        "syntax": "addemeprofile;",
        "description": "Add a profile monitor when using an EME solver region. This function does not return any data."
      },
      {
        "syntax": "addemeprofile(struct_data);",
        "description": "Adds a EME profile monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "setactivesolver(\"EME\");\r\naddemeprofile;"
  },
  {
    "name": "addemfieldmonitor",
    "description": "Adds a frequency domain [EM (electro-magnetic) field monitor](https://optics.ansys.com/hc/en-us/articles/360034918553) to a simulation with 'DGTD' solver . Along with the EM field data the monitor also reports the net flux through the surface of the monitor. A DGTD solver region must be present in the objects tree for this command to work.",
    "usage": "addemfieldmonitor();",
    "category": "general",
    "markdown": "# addemfieldmonitor\r\n\r\nAdds a frequency domain\r\n[EM (electro-magnetic) field monitor](https://optics.ansys.com/hc/en-us/articles/360034918553)\r\nto a simulation with 'DGTD' solver . Along with the EM field data the monitor also\r\nreports the net flux through the surface of the monitor. A DGTD solver region must be\r\npresent in the objects tree for this command to work.\r\n\r\n| **Syntax**         | **Description**                                                                                        |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------ |\r\n| addemfieldmonitor; | Adds a frequency domain EM field monitor to the 'DGTD' solver. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a frequency domain EM field monitor to the 'DGTD'\r\nsolver already present in the objects tree and print all available properties of the\r\nmonitor.\r\n\r\n```\r\naddemfieldmonitor;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a frequency domain EM field monitor to the 'DGTD'\r\nsolver, change its name, set its frequency span to be the same as the source, and assign\r\nit to a solid named \"2D rectangle\".\r\n\r\n```\r\naddemfieldmonitor; \r\nset(\"name\",\"T\");\r\nset(\"use source limits\",1);\r\nset(\"reference source\",\"plane_wave\");  \r\nset(\"surface type\",\"solid\");\r\nset(\"solid\",\"2D rectangle\");\r\n```\r\n\r\n## NOTE: The script above assumes that there is already a solid named \"2D rectangle\" and a source named \"plane_wave\" present in the objects tree.",
    "summary": "Adds a frequency domain [EM (electro-magnetic) field monitor](https://optics",
    "syntax": [
      {
        "syntax": "addemfieldmonitor;",
        "description": "Adds a frequency domain EM field monitor to the 'DGTD' solver. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addemfieldtimemonitor",
    "description": "Adds a time domain [EM (electro-magnetic) field monitor](https://optics.ansys.com/hc/en-us/articles/360034918493) to simulation with 'DGTD' solver. A DGTD solver region must be present in the objects tree for this command to work.",
    "usage": "addemfieldtimemonitor();",
    "category": "general",
    "markdown": "# addemfieldtimemonitor\r\n\r\nAdds a time domain\r\n[EM (electro-magnetic) field monitor](https://optics.ansys.com/hc/en-us/articles/360034918493)\r\nto simulation with 'DGTD' solver. A DGTD solver region must be present in the objects\r\ntree for this command to work.\r\n\r\n| **Syntax**                          | **Description**                                                                                                                                                                                                                                                                            |\r\n| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addemfieldtimemonitor;              | Adds a time domain EM field monitor to the 'DGTD' solver. This function does not return any data.                                                                                                                                                                                          |\r\n| addemfieldtimemonitor(struct_data); | Adds a time domain EM field monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a time domain EM field monitor to the 'DGTD'\r\nsolver already present in the objects tree and print all available properties of the\r\nmonitor.\r\n\r\n```\r\naddemfieldtimemonitor;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a time domain EM field monitor to the 'DGTD'\r\nsolver, change its name, and assign it to a solid named \"2D rectangle\".\r\n\r\n```\r\naddemfieldtimemonitor; \r\nset(\"name\",\"time\");\r\nset(\"geometry type\",\"surface\");\r\nset(\"surface type\",\"solid\");\r\nset(\"solid\",\"2D rectangle\");\r\n```\r\n\r\n## NOTE: The script above assumes that there is already a solid named \"2D rectangle\" present in the objects tree.\r\n\r\n**Example 3**\r\n\r\nThe following script commands will add a 'point' time domain EM field monitor to the\r\n'DGTD' solver and set its location.\r\n\r\n```\r\naddemfieldtimemonitor; \r\nset(\"name\",\"time\");\r\nset(\"geometry type\",\"point\");\r\nset(\"x\",1e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\n```",
    "summary": "Adds a time domain [EM (electro-magnetic) field monitor](https://optics",
    "syntax": [
      {
        "syntax": "addemfieldtimemonitor;",
        "description": "Adds a time domain EM field monitor to the 'DGTD' solver. This function does not return any data."
      },
      {
        "syntax": "addemfieldtimemonitor(struct_data);",
        "description": "Adds a time domain EM field monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addemmaterialproperty",
    "description": "Adds a new optical material property to the selected material model. A material model (in the 'materials' folder) must be selected in the object tree for this script command to work. To add an optical material property from the optical material database, see [ addmaterialproperties ](./addmaterialproperties.md) . For details of optical material models, see [ Optical Material Models ](https://optics.ansys.com/hc/en-us/articles/360034398454-Optical-Material-Models) .",
    "usage": "addemmaterialproperty();",
    "category": "general",
    "markdown": "# addemmaterialproperty\r\n\r\nAdds a new optical material property to the selected material model. A material model\r\n(in the 'materials' folder) must be selected in the object tree for this script command\r\nto work. To add an optical material property from the optical material database, see\r\n[ addmaterialproperties ](./addmaterialproperties.md) . For details of optical material\r\nmodels, see\r\n[ Optical Material Models ](https://optics.ansys.com/hc/en-us/articles/360034398454-Optical-Material-Models)\r\n.\r\n\r\n| **Syntax**                              | **Description**                                                                                                                |\r\n| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| addemmaterialproperty(\"property_type\"); | Adds a new optical material property to the selected material model. The \"property_type\" argument can be one of the following: |\r\n\r\n- \"Conductive\"\r\n- \"Dielectric\"\r\n- \"(n,k) Material\"\r\n- \"Debye\"\r\n- \"Plasma\"\r\n- \"Lorentz\"\r\n- \"Sampled Data 3D\"\r\n\r\nThis function does not return any data.\r\n\r\n**Example**\r\n\r\nThe following script commands will add a new material to the objects tree in Finite\r\nElement IDE, and assign optical property of dielectric to it.\r\n\r\n```\r\naddmodelmaterial;\r\naddemmaterialproperty(\"Dielectric\");\r\n```\r\n\r\n## NOTE: Once a material property is assigned to the material model, the selection changes to the corresponding property. Therefore the material model must be re-selected before adding a new property to it.",
    "summary": "Adds a new optical material property to the selected material model",
    "syntax": [
      {
        "syntax": "addemmaterialproperty(\"property_type\");",
        "description": "Adds a new optical material property to the selected material model. The \"property_type\" argument can be one of the following:"
      }
    ],
    "example": "addmodelmaterial;\r\naddemmaterialproperty(\"Dielectric\");"
  },
  {
    "name": "addfde",
    "description": "Adds a [Finite Difference Eigenmode (FDE) solver region object](https://optics.ansys.com/hc/en-us/articles/360034916973) to the MODE simulation environment.",
    "usage": "addfde();",
    "category": "general",
    "markdown": "# addfde\r\n\r\nAdds a\r\n[Finite Difference Eigenmode (FDE) solver region object](https://optics.ansys.com/hc/en-us/articles/360034916973)\r\nto the MODE simulation environment.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                                                                                                                  |\r\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addfde;              | Adds an FDE solver region to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addfde(struct_data); | Adds an FDE solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add an FDE solver region on the XY plane and\r\ncalculate the eigen modes.\r\n\r\n```\r\naddfde;\r\nset(\"solver type\",3);  \r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",5e-6);  \r\nset(\"z\",0);\r\nfindmodes;\r\n```",
    "summary": "Adds a [Finite Difference Eigenmode (FDE) solver region object](https://optics",
    "syntax": [
      {
        "syntax": "addfde;",
        "description": "Adds an FDE solver region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addfde(struct_data);",
        "description": "Adds an FDE solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addfde;\r\nset(\"solver type\",3);  \r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",5e-6);  \r\nset(\"z\",0);\r\nfindmodes;"
  },
  {
    "name": "addfdtd",
    "description": "Adds an [FDTD solver region](https://optics.ansys.com/hc/en-us/articles/360034382534) to the simulation environment. The extent of the solver region determines the simulated volume/area in FDTD.",
    "usage": "addfdtd();",
    "category": "general",
    "markdown": "# addfdtd\r\n\r\nAdds an [FDTD solver region](https://optics.ansys.com/hc/en-us/articles/360034382534) to\r\nthe simulation environment. The extent of the solver region determines the simulated\r\nvolume/area in FDTD.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                   |\r\n| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addfdtd;              | Adds an FDTD solver region to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addfdtd(struct_data); | Adds an FDTD solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 3D FDTD solver region, set its dimension, and\r\nrun the simulation. The script assumes that the simulation environment already has the\r\ngeometry and sources/monitors set up.\r\n\r\n```\r\naddfdtd;\r\nset(\"dimension\",2);  #  1 = 2D, 2 = 3D\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;\r\n```",
    "summary": "Adds an [FDTD solver region](https://optics",
    "syntax": [
      {
        "syntax": "addfdtd;",
        "description": "Adds an FDTD solver region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addfdtd(struct_data);",
        "description": "Adds an FDTD solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addfdtd;\r\nset(\"dimension\",2);  #  1 = 2D, 2 = 3D\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;"
  },
  {
    "name": "addfeemmesh",
    "description": "Adds a [mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994) to a 'FEEM' simulation.. A FEEM solver region must be present in the objects tree for this command to work.",
    "usage": "addfeemmesh();",
    "category": "general",
    "markdown": "# addfeemmesh\r\n\r\nAdds a\r\n[mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994)\r\nto a 'FEEM' simulation.. A FEEM solver region must be present in the objects tree for\r\nthis command to work.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                    |\r\n| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addfeemmesh;              | Adds a mesh constraint to the 'FEEM' simulation environment. This function does not return any data.                                                                                                                                                                               |\r\n| addfeemmesh(struct_data); | Adds a FEEM mesh constraint and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a mesh constraint to the FEEM solver already\r\npresent in the objects tree and print the name of all of its properties.\r\n\r\n```\r\naddfeemmesh;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a mesh constraint to the FEEM solver region in\r\nFinite Element IDE, name it, assign it to a specific surface between two domains, and\r\nset the maximum edge length for any element on the surface.\r\n\r\n```\r\naddfeemsolver;\r\naddfeemmesh;\r\nset(\"name\",\"mesh_surface\");\r\nset(\"geometry type\",\"surface\");\r\nset(\"surface type\",\"domain:domain\");\r\nset(\"domain 1\",2);\r\nset(\"domain 2\",3);\r\nset(\"max edge length\",0.05e-6);\r\n```",
    "summary": "Adds a [mesh constraint (override region)](https://optics",
    "syntax": [
      {
        "syntax": "addfeemmesh;",
        "description": "Adds a mesh constraint to the 'FEEM' simulation environment. This function does not return any data."
      },
      {
        "syntax": "addfeemmesh(struct_data);",
        "description": "Adds a FEEM mesh constraint and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addfeemsolver",
    "description": "Adds a [FEEM solver region](https://optics.ansys.com/hc/en-us/articles/360034918393) to the simulation environment.",
    "usage": "addfeemsolver();",
    "category": "general",
    "markdown": "# addfeemsolver\r\n\r\nAdds a [FEEM solver region](https://optics.ansys.com/hc/en-us/articles/360034918393) to\r\nthe simulation environment.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                  |\r\n| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addfeemsolver;              | Adds a FEEM solver region to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addfeemsolver(struct_data); | Adds a FEEM solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a FEEM solver to the objects tree and print the\r\nname of all of its properties.\r\n\r\n```\r\naddfeemsolver;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script command will add a FEEM solver region and assign it to a simulation\r\nregion.\r\n\r\n```\r\naddfeemsolver;\r\nset(\"solver geometry\",\"simulation region 1\");\r\n```",
    "summary": "Adds a [FEEM solver region](https://optics",
    "syntax": [
      {
        "syntax": "addfeemsolver;",
        "description": "Adds a FEEM solver region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addfeemsolver(struct_data);",
        "description": "Adds a FEEM solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addfieldregion",
    "description": "Adds a [field region object](https://optics.ansys.com/hc/en-us/articles/36967414684947-Field-Region-Simulation-object) to the simulation environment. The field region object is used with lumopt, see the Knowledge Base article on [Getting started with lumopt](https://optics.ansys.com/hc/en-us/articles/360050995394-Getting-Started-with-lumopt-Python-API) for more information.",
    "usage": "addfieldregion();",
    "category": "general",
    "markdown": "# addfieldregion\r\n\r\nAdds a\r\n[field region object](https://optics.ansys.com/hc/en-us/articles/36967414684947-Field-Region-Simulation-object)\r\nto the simulation environment. The field region object is used with lumopt, see the\r\nKnowledge Base article on\r\n[Getting started with lumopt](https://optics.ansys.com/hc/en-us/articles/360050995394-Getting-Started-with-lumopt-Python-API)\r\nfor more information.\r\n\r\n| **Syntax**                   | **Description**                                                                                                                                                                                                                                                                   |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addfieldregion;              | Adds a field region object to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addfieldregion(struct_data); | Adds a field region object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |",
    "summary": "Adds a [field region object](https://optics",
    "syntax": [
      {
        "syntax": "addfieldregion;",
        "description": "Adds a field region object to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addfieldregion(struct_data);",
        "description": "Adds a field region object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addgaussian",
    "description": "Adds a [Gaussian source](https://optics.ansys.com/hc/en-us/articles/360034382854) to the simulation environment.",
    "usage": "addgaussian();",
    "category": "general",
    "markdown": "# addgaussian\r\n\r\nAdds a [Gaussian source](https://optics.ansys.com/hc/en-us/articles/360034382854) to the\r\nsimulation environment.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                               |\r\n| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addgaussian;              | Adds a Gaussian source to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addgaussian(struct_data); | Adds a Gaussian source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a Gaussian source in the simulation environment\r\nthat will propagate in the negative z direction. The script will set the dimension (and\r\nposition) of the source and will define the beam waist radius using scalar\r\napproximation.\r\n\r\n```\r\naddgaussian;\r\nset(\"injection axis\",\"z\");\r\nset(\"direction\",\"backward\");\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",10e-6);\r\nset(\"use scalar approximation\",1);\r\nset(\"waist radius w0\",0.5e-6);\r\nset(\"distance from waist\",-5e-6);\r\n```",
    "summary": "Adds a [Gaussian source](https://optics",
    "syntax": [
      {
        "syntax": "addgaussian;",
        "description": "Adds a Gaussian source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addgaussian(struct_data);",
        "description": "Adds a Gaussian source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addgaussian;\r\nset(\"injection axis\",\"z\");\r\nset(\"direction\",\"backward\");\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",10e-6);\r\nset(\"use scalar approximation\",1);\r\nset(\"waist radius w0\",0.5e-6);\r\nset(\"distance from waist\",-5e-6);"
  },
  {
    "name": "addgridattribute",
    "description": "Adds a grid attribute object to the simulation environment. Grid attribute objects include:",
    "usage": "addgridattribute();",
    "category": "general",
    "markdown": "# addgridattribute\r\n\r\nAdds a grid attribute object to the simulation environment. Grid attribute objects\r\ninclude:\r\n\r\n- [Liquid Crystal Rotation](https://optics.ansys.com/hc/en-us/articles/360034915153)\r\n- [Permittivity Rotation](https://optics.ansys.com/hc/en-us/articles/360034394714)\r\n- [Matrix Transformation](https://optics.ansys.com/hc/en-us/articles/360034915173)\r\n- [np Density and Temperature Index Perturbation](https://optics.ansys.com/hc/en-us/articles/360034901753)\r\n\r\n| **Syntax**                | **Description**                                 |\r\n| ------------------------- | ----------------------------------------------- |\r\n| addgridattribute(\"type\"); | Adds a grid attribute object to the simulation. |\r\n\r\n- type: Type of attribute to add. Options are \"lc orientation\", \"permittivity rotation\",\r\n  \"matrix transform\", \"np density\", or \"temperature\".\r\n\r\nThis function does not return any data.\\\r\naddgridattribute(\"type\",dataset); | Adds a grid attribute with spatially varying data.\r\n\r\n- type: Type of attribute to add. Options are \"lc orientation\", \"permittivity rotation\",\r\n  \"matrix transform\", \"np density\", or \"temperature\".\r\n- dataset: A dataset containing the grid attribute data - see the below table for\r\n  details.\r\n\r\n| Data                                               | Simulation object                      | Dataset type | Name for variables defining coordinate data                                                                                               | Name for variables defining actual data |\r\n| -------------------------------------------------- | -------------------------------------- | ------------ | ----------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |\r\n| Liquid crystal orientation (3 element unit vector) | 'lc orientation' grid attribute        | Rectilinear  | x, y, z                                                                                                                                   | u                                       |\r\n| Rotation angles in radians                         | 'permittivity rotation' grid attribute | Rectilinear  | x, y, z                                                                                                                                   | theta, phi, psi                         |\r\n| Unitary transform matrix (3x3 tensor)              | 'matrix transform' grid attribute      | Rectilinear  | x, y, z                                                                                                                                   | U                                       |\r\n| Charge density                                     | 'np density' grid attribute            | Unstructured | x, y, z, elements (see [ Dataset builder ](https://optics.ansys.com/hc/en-us/articles/360034901713-Dataset-builder) for more information) | n, p                                    |\r\n| Temperature in Kelvin                              | 'temperature' grid attribute           | Unstructured | x, y, z, elements (see [ Dataset builder ](https://optics.ansys.com/hc/en-us/articles/360034901713-Dataset-builder) for more information) | N                                       |\r\n\r\n### Example\r\n\r\nThe following script is an excerpt from LCD_twist.lsf in the\r\n[ Twisted Nematic LCD](**%20to%20be%20defined%20**) application example which defines a\r\nspatially varying liquid crystal.\r\n\r\n```\r\n# define x/y/z\r\nx = 0;\r\ny = 0;\r\nz = linspace(0e-6,5e-6,100);\r\nX = meshgrid3dx(x,y,z);\r\nY = meshgrid3dy(x,y,z);\r\nZ = meshgrid3dz(x,y,z);\r\nn = matrix(length(x),length(y),length(z),3);\r\n# define the orientation function\r\nn(1:length(x),1:length(y),1:length(z),1) = cos(Z*pi*1e5);\r\nn(1:length(x),1:length(y),1:length(z),2) = sin(Z*pi*1e5);\r\nn(1:length(x),1:length(y),1:length(z),3) = Z;\r\n# create dataset containing orientation vectors and position parameters\r\nLC=rectilineardataset(\"LC\",x,y,z);\r\nLC.addattribute(\"u\",n);\r\n# add LC import grid attribute\r\naddgridattribute(\"lc orientation\",LC);\r\nsetnamed(\"LC attribute\",\"nz\",50); # set resolution\r\n```",
    "summary": "Adds a grid attribute object to the simulation environment",
    "syntax": [
      {
        "syntax": "addgridattribute(\"type\");",
        "description": "Adds a grid attribute object to the simulation."
      }
    ],
    "example": ""
  },
  {
    "name": "addgroup",
    "description": "Adds a container group to the simulation environment. Container groups can be used to put multiple structures, monitors, and/or sources together in a single group in the objects tree. In Ansys Lumerical Multiphysics™, container groups are always children of the solver regions and cannot contain any structure. If multiple solver regions are present in the Ansys Lumerical Multiphysics objects tree, this command will add a container group to the solver region that is currently selected.",
    "usage": "addgroup();",
    "category": "general",
    "markdown": "# addgroup\r\n\r\nAdds a container group to the simulation environment. Container groups can be used to\r\nput multiple structures, monitors, and/or sources together in a single group in the\r\nobjects tree. In Ansys Lumerical Multiphysics™, container groups are always children of\r\nthe solver regions and cannot contain any structure. If multiple solver regions are\r\npresent in the Ansys Lumerical Multiphysics objects tree, this command will add a\r\ncontainer group to the solver region that is currently selected.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                                                                                                                                                                |\r\n| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addgroup;                | Adds a container group to the simulation environment. In Ansys Lumerical Multiphysics, the added container group is placed under the currently selected solver region. This function does not return any data.                                                                                                                                                                                 |\r\n| addgroup(struct_data);   | Adds a container group and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. In Ansys Lumerical Multiphysics, the added container group is placed under the currently selected solver region. This function does not return any data. |\r\n| addgroup(“solver_name”); | Only for Ansys Lumerical Multiphysics. Adds a container group to the solver region specified by solver_name. This function does not return any data.                                                                                                                                                                                                                                           |\r\n\r\n**Example**\r\n\r\nAdd a container group to the HEAT solver region (in Ansys Lumerical Multiphysics) and\r\nput a uniform heat source in it.\r\n\r\n```\r\nselect(\"HEAT\");\r\naddgroup;\r\nset(\"name\",\"test_group\");\r\nadduniformheat;\r\naddtogroup(\"test_group\");\r\n```\r\n\r\nNOTE: In this example script, since the uniform heat source is also a child of the HEAT\r\nsolver, we do not need to specify the full path for the container group name (e.g.\r\nHEAT::test_group).",
    "summary": "Adds a container group to the simulation environment",
    "syntax": [
      {
        "syntax": "addgroup;",
        "description": "Adds a container group to the simulation environment. In Ansys Lumerical Multiphysics, the added container group is placed under the currently selected solver region. This function does not return any data."
      },
      {
        "syntax": "addgroup(struct_data);",
        "description": "Adds a container group and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. In Ansys Lumerical Multiphysics, the added container group is placed under the currently selected solver region. This function does not return any data."
      },
      {
        "syntax": "addgroup(“solver_name”);",
        "description": "Only for Ansys Lumerical Multiphysics. Adds a container group to the solver region specified by solver_name. This function does not return any data."
      }
    ],
    "example": "select(\"HEAT\");\r\naddgroup;\r\nset(\"name\",\"test_group\");\r\nadduniformheat;\r\naddtogroup(\"test_group\");"
  },
  {
    "name": "addheatfluxbc",
    "description": "Adds a new heat flux boundary condition to the HEAT or CHARGE solver \\[ [ Boundary Conditions (Thermal Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-) \\]. A HEAT or CHARGE solver region must be present in the objects tree before this boundary condition can be added. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addheatfluxbc();",
    "category": "general",
    "markdown": "# addheatfluxbc\r\n\r\nAdds a new heat flux boundary condition to the HEAT or CHARGE solver \\[\r\n[ Boundary Conditions (Thermal Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\r\n\\]. A HEAT or CHARGE solver region must be present in the objects tree before this\r\nboundary condition can be added. If both solvers are present then the intended solver's\r\nname must be provided as an argument to the script command.\r\n\r\nThe heat flux boundary condition can only be added to the CHARGE solver when the\r\nsolver's temperature dependency is set to 'coupled'.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                               |\r\n| ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addheatfluxbc;                | Adds a heat flux boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addheatfluxbc(\"solver_name\"); | Adds a heat flux boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a heat flux boundary condition to the solver\r\nalready present in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddheatfluxbc;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a steady state heat flux boundary condition to\r\nthe HEAT solver already present in the objects tree. It will then name the boundary\r\ncondition, assign it to the -x simulation region boundary, and set the heat flux to 1e6\r\nW/m^2.\r\n\r\n```\r\naddheatfluxbc(\"HEAT\");\r\nset(\"name\",\"P_in\");\r\nset(\"heat flux\",1e6);\r\nset(\"surface type\",\"simulation region\");\r\nset(\"x min\",1);\r\n```",
    "summary": "Adds a new heat flux boundary condition to the HEAT or CHARGE solver \\[ [ Boundary Conditions (Therm...",
    "syntax": [
      {
        "syntax": "addheatfluxbc;",
        "description": "Adds a heat flux boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addheatfluxbc(\"solver_name\");",
        "description": "Adds a heat flux boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addheatfluxmonitor",
    "description": "Adds a [heat flux monitor](https://optics.ansys.com/hc/en-us/articles/360034398274) to the HEAT solver region. The monitor can only be added if the simulation environment already has a 'HEAT' solver present.",
    "usage": "addheatfluxmonitor();",
    "category": "general",
    "markdown": "# addheatfluxmonitor\r\n\r\nAdds a [heat flux monitor](https://optics.ansys.com/hc/en-us/articles/360034398274) to\r\nthe HEAT solver region. The monitor can only be added if the simulation environment\r\nalready has a 'HEAT' solver present.\r\n\r\n| **Syntax**                       | **Description**                                                                                                                                                                                                                                                                 |\r\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addheatfluxmonitor;              | Adds a heat flux monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addheatfluxmonitor(struct_data); | Adds a heat flux monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 2D y-normal heat flux monitor to the HEAT solver\r\nregion and set its dimension.\r\n\r\n```\r\naddheatfluxmonitor;\r\nset(\"name\",\"heat\");\r\nset(\"monitor type\",6);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n```",
    "summary": "Adds a [heat flux monitor](https://optics",
    "syntax": [
      {
        "syntax": "addheatfluxmonitor;",
        "description": "Adds a heat flux monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addheatfluxmonitor(struct_data);",
        "description": "Adds a heat flux monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addheatfluxmonitor;\r\nset(\"name\",\"heat\");\r\nset(\"monitor type\",6);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);"
  },
  {
    "name": "addheatmesh",
    "description": "Adds a [mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994) to a 'HEAT' simulation. A HEAT solver region must be present in the objects tree for this command to work.",
    "usage": "addheatmesh();",
    "category": "general",
    "markdown": "# addheatmesh\r\n\r\nAdds a\r\n[mesh constraint (override region)](https://optics.ansys.com/hc/en-us/articles/360034397994)\r\nto a 'HEAT' simulation. A HEAT solver region must be present in the objects tree for\r\nthis command to work.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                                                    |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addheatmesh;              | Adds a mesh constraint to the 'HEAT' simulation environment. This function does not return any data.                                                                                                                                                                                                               |\r\n| addheatmesh(struct_data); | Adds a mesh constraint to the 'HEAT' simulation environment and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a mesh constraint to the HEAT solver region in\r\nFinite Element IDE, name it, set its dimension, and set the maximum edge length for any\r\nelement within the volume.\r\n\r\n```\r\naddheatsolver;\r\naddheatmesh;\r\nset(\"name\",\"mesh_SCR\");\r\n# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n# restrict maximum edge length for elements\r\nset(\"max edge length\",5e-9);\r\n```",
    "summary": "Adds a [mesh constraint (override region)](https://optics",
    "syntax": [
      {
        "syntax": "addheatmesh;",
        "description": "Adds a mesh constraint to the 'HEAT' simulation environment. This function does not return any data."
      },
      {
        "syntax": "addheatmesh(struct_data);",
        "description": "Adds a mesh constraint to the 'HEAT' simulation environment and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addheatsolver;\r\naddheatmesh;\r\nset(\"name\",\"mesh_SCR\");\r\n# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n# restrict maximum edge length for elements\r\nset(\"max edge length\",5e-9);"
  },
  {
    "name": "addheatsolver",
    "description": "Adds a [thermal (HEAT) solver region](https://optics.ansys.com/hc/en-us/articles/360034398234) to the simulation environment.",
    "usage": "addheatsolver();",
    "category": "general",
    "markdown": "# addheatsolver\r\n\r\nAdds a\r\n[thermal (HEAT) solver region](https://optics.ansys.com/hc/en-us/articles/360034398234)\r\nto the simulation environment.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                            |\r\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addheatsolver;              | Adds a thermal (HEAT) solver region to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addheatsolver(struct_data); | Adds a thermal (HEAT) solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 2D y-normal HEAT solver region, set its\r\ndimension, and run the simulation. The script assumes that the simulation environment\r\nalready has the geometry and boundary conditions set up.\r\n\r\n```\r\naddheatsolver;\r\nset(\"solver geometry\",1);  #  2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;\r\n```",
    "summary": "Adds a [thermal (HEAT) solver region](https://optics",
    "syntax": [
      {
        "syntax": "addheatsolver;",
        "description": "Adds a thermal (HEAT) solver region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addheatsolver(struct_data);",
        "description": "Adds a thermal (HEAT) solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addheatsolver;\r\nset(\"solver geometry\",1);  #  2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nrun;"
  },
  {
    "name": "addhtmaterialproperty",
    "description": "Adds a new thermal material property to the selected material model or the selected solid alloy. A material model (in the 'materials' folder) or a solid alloy thermal material property must be selected in the object tree for this script command to work. A solid alloy may not be created as a component of a solid alloy. To add a thermal material property from the electrothermal material database, see [ addmaterialproperties ](./addmaterialproperties.md) . For details of thermal material models, see [ Electrical/Thermal Material Models ](https://optics.ansys.com/hc/en-us/articles/360034919093-Electrical-Thermal-Material-Models) .",
    "usage": "addhtmaterialproperty();",
    "category": "general",
    "markdown": "# addhtmaterialproperty\r\n\r\nAdds a new thermal material property to the selected material model or the selected\r\nsolid alloy. A material model (in the 'materials' folder) or a solid alloy thermal\r\nmaterial property must be selected in the object tree for this script command to work. A\r\nsolid alloy may not be created as a component of a solid alloy. To add a thermal\r\nmaterial property from the electrothermal material database, see\r\n[ addmaterialproperties ](./addmaterialproperties.md) . For details of thermal material\r\nmodels, see\r\n[ Electrical/Thermal Material Models ](https://optics.ansys.com/hc/en-us/articles/360034919093-Electrical-Thermal-Material-Models)\r\n.\r\n\r\n| **Syntax**                              | **Description**                                                                                                                                            |\r\n| --------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addhtmaterialproperty(\"property_type\"); | Adds a new thermal material property to the selected material model or the selected solid alloy. The \"property_type\" argument can be one of the following: |\r\n\r\n- \"Solid\"\r\n- \"Solid Alloy\"\r\n- \"Fluid\"\r\n\r\nThis function does not return any data.\r\n\r\n**Example**\r\n\r\nThe following script commands will add a new material to the objects tree in Finite\r\nElement IDE, and assign thermal property of fluid to it.\r\n\r\n```\r\naddmodelmaterial;\r\naddhtmaterialproperty(\"Fluid\");\r\n```\r\n\r\n## NOTE: Once a material property is assigned to the material model the selection changes to the corresponding property. Therefore the material model must be re-selected before adding a new property to it.\r\n\r\nNOTE: For a newly created alloy, when the first base material is added to the alloy, the\r\nsecond base material will also be the same material as the first. For example, the\r\nfollowing lines will create a new alloy and assign the solid material \"A\" as both base\r\nmaterial 1 and base material 2 for the alloy:\r\n\r\n```\r\naddmodelmaterial;\r\nset(\"name\",\"test\");\r\naddhtmaterialproperty(\"Solid Alloy\");\r\nset(\"name\",\"alloy\");\r\naddhtmaterialproperty(\"Solid\");\r\nset(\"name\",\"A\");  \r\n```\r\n\r\n______________________________________________________________________",
    "summary": "Adds a new thermal material property to the selected material model or the selected solid alloy",
    "syntax": [
      {
        "syntax": "addhtmaterialproperty(\"property_type\");",
        "description": "Adds a new thermal material property to the selected material model or the selected solid alloy. The \"property_type\" argument can be one of the following:"
      }
    ],
    "example": "addmodelmaterial;\r\naddhtmaterialproperty(\"Fluid\");"
  },
  {
    "name": "addimplant",
    "description": "Adds a implant doping region to the simulation environment. This command requires a CHARGE solver region to be present in the objects tree.",
    "usage": "addimplant();",
    "category": "general",
    "markdown": "# addimplant\r\n\r\nAdds a implant doping region to the simulation environment. This command requires a\r\nCHARGE solver region to be present in the objects tree.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                     |\r\n| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adddimplant;              | Add a implant doping region in the simulation environment. This function does not return any data.                                                                                                                                                                                  |\r\n| adddimplant(struct_data); | Adds a implant doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a n-type implant doping object and set its\r\nproperties. The implantation direction is defined by the \"surface normal\" property and\r\nthe peak doping is defined by the \"peak concentration\" property.\r\n\r\n```\r\naddimplant;\r\nset(\"name\",\"nwell\");\r\n# set dimension\r\nV=[-0.5,-0.5;0.5,-0.5;0.5,0.5;-0.5,0.5]*1e-6; # SI unit (m)\r\nset(\"vertices\",V);\r\n# set doping profile\r\nset(\"dopant type\",\"n\");\r\nset(\"surface normal\",\"y\"); \r\nset(\"source theta\",45);\r\nset(\"source phi\",90);\r\nset(\"distribution function\",\"Pearson4\");\r\nset(\"peak concentration\",1e24);  # SI unit (1/m3), equivalent to 1e18 1/cm3\r\n```",
    "summary": "Adds a implant doping region to the simulation environment",
    "syntax": [
      {
        "syntax": "adddimplant;",
        "description": "Add a implant doping region in the simulation environment. This function does not return any data."
      },
      {
        "syntax": "adddimplant(struct_data);",
        "description": "Adds a implant doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addimplant;\r\nset(\"name\",\"nwell\");\r\n# set dimension\r\nV=[-0.5,-0.5;0.5,-0.5;0.5,0.5;-0.5,0.5]*1e-6; # SI unit (m)\r\nset(\"vertices\",V);\r\n# set doping profile\r\nset(\"dopant type\",\"n\");\r\nset(\"surface normal\",\"y\"); \r\nset(\"source theta\",45);\r\nset(\"source phi\",90);\r\nset(\"distribution function\",\"Pearson4\");\r\nset(\"peak concentration\",1e24);  # SI unit (1/m3), equivalent to 1e18 1/cm3"
  },
  {
    "name": "addimport",
    "description": "Adds an import primitive to the simulation environment. The import primitive can be used to create a 3D geometry by importing a surface, an image, or binary data. It can also be used to create an n,k material.",
    "usage": "addimport();",
    "category": "general",
    "markdown": "# addimport\r\n\r\nAdds an import primitive to the simulation environment. The import primitive can be used\r\nto create a 3D geometry by importing a surface, an image, or binary data. It can also be\r\nused to create an n,k material.\r\n\r\n| **Syntax**              | **Description**                                                                                                                                                                                                                                                                 |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addimport;              | Adds an import primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addimport(struct_data); | Adds an import primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will generate a surface data and then use the data to\r\ncreate a layer of glass whose top surface is defined by the generated data.\r\n\r\n```\r\n# generate a surface\r\nnx = 50;\r\nny = 40;\r\nx = linspace(-6,6,nx);\r\ny = linspace(-5,5,ny);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\nZ = exp(-(X^2+Y^2)/4^2) * sin(pi*Y/2);\r\n# Remember that all units are SI. We defined the surface in microns\r\n# so all lengths must be multiplied by 1e-6\r\nx = x*1e-6; # switch to SI units\r\ny = y*1e-6; # switch to SI units\r\nZ = Z*1e-6; # switch to SI units\r\n# create substrate layer with an import object\r\naddimport;\r\nset(\"material\",\"SiO2 (Glass) - Palik\");\r\n# upper surface and reference height\r\nimportsurface2(Z,x,y,1);\r\nset(\"upper ref height\",0e-6); \r\n```",
    "summary": "Adds an import primitive to the simulation environment",
    "syntax": [
      {
        "syntax": "addimport;",
        "description": "Adds an import primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addimport(struct_data);",
        "description": "Adds an import primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "# generate a surface\r\nnx = 50;\r\nny = 40;\r\nx = linspace(-6,6,nx);\r\ny = linspace(-5,5,ny);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\nZ = exp(-(X^2+Y^2)/4^2) * sin(pi*Y/2);\r\n# Remember that all units are SI. We defined the surface in microns\r\n# so all lengths must be multiplied by 1e-6\r\nx = x*1e-6; # switch to SI units\r\ny = y*1e-6; # switch to SI units\r\nZ = Z*1e-6; # switch to SI units\r\n# create substrate layer with an import object\r\naddimport;\r\nset(\"material\",\"SiO2 (Glass) - Palik\");\r\n# upper surface and reference height\r\nimportsurface2(Z,x,y,1);\r\nset(\"upper ref height\",0e-6);"
  },
  {
    "name": "addimportdope",
    "description": "Adds a [doping region](https://optics.ansys.com/hc/en-us/articles/360034398054) to the simulation environment that can be used to load a custom doping profile. The custom doping profile can be created analytically using script or it can be imported from other sources such as process simulation. This command requires a CHARGE solver region to be present in the objects tree.",
    "usage": "addimportdope();",
    "category": "general",
    "markdown": "# addimportdope\r\n\r\nAdds a [doping region](https://optics.ansys.com/hc/en-us/articles/360034398054) to the\r\nsimulation environment that can be used to load a custom doping profile. The custom\r\ndoping profile can be created analytically using script or it can be imported from other\r\nsources such as process simulation. This command requires a CHARGE solver region to be\r\npresent in the objects tree.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                     |\r\n| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addimportdope;              | Add an import doping region to the simulation environment. This function does not return any data.                                                                                                                                                                                  |\r\n| addimportdope(struct_data); | Adds an import doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\nOnce the import doping object is created, the doping data can be imported from a matlab\r\n(.mat) file using the GUI or by assigning a dataset to the object using the\r\n[ importdataset ](./importdataset.md) script command. The dataset can be a rectilinear\r\nor an unstructured dataset. Doping data can be imported into the solver workspace from\r\nother tools (e.g. process simulation) using the\r\n[ Dataset builder ](https://optics.ansys.com/hc/en-us/articles/360034901713-Dataset-builder)\r\n.\r\n\r\n**Example**\r\n\r\nThe following script command will add an import doping object to the CHARGE solver\r\nregion and will load an analytic 3D doping data into it.\r\n\r\n```\r\naddimportdope;\r\nset(\"name\",\"pepi\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\n# create coordinate vectors and 3D matrix for doping profile\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nN = matrix(11,2,101) + 1e21;  # assume uniform doping concentration of 1e15 /cm3 (1e21 /m3)\r\n# create dataset\r\ndoping = rectilineardataset(\"dope\",x,y,z);\r\ndoping.addparameter(\"a\",1);  # add a dummy parameter\r\ndoping.addattribute(\"N\",N);\r\n# load data into doping object\r\nselect(\"CHARGE::pepi\");\r\nimportdataset(doping);\r\n```",
    "summary": "Adds a [doping region](https://optics",
    "syntax": [
      {
        "syntax": "addimportdope;",
        "description": "Add an import doping region to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addimportdope(struct_data);",
        "description": "Adds an import doping region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addimportdope;\r\nset(\"name\",\"pepi\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\n# create coordinate vectors and 3D matrix for doping profile\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nN = matrix(11,2,101) + 1e21;  # assume uniform doping concentration of 1e15 /cm3 (1e21 /m3)\r\n# create dataset\r\ndoping = rectilineardataset(\"dope\",x,y,z);\r\ndoping.addparameter(\"a\",1);  # add a dummy parameter\r\ndoping.addattribute(\"N\",N);\r\n# load data into doping object\r\nselect(\"CHARGE::pepi\");\r\nimportdataset(doping);"
  },
  {
    "name": "addimportedsource",
    "description": "Adds an imported source to the simulation environment.",
    "usage": "addimportedsource();",
    "category": "general",
    "markdown": "# addimportedsource\r\n\r\nAdds an imported source to the simulation environment.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                                                                                                                                                |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addimportedsource;              | Adds an imported source to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addimportedsource(struct_data); | Adds an imported source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add an imported source to the simulation environment,\r\nassign a name to it and load an E field profile from a \\*.mat file.\r\n\r\n```\r\naddimportedsource;\r\nset(\"name\",\"source2\");\r\n# Load a field profile saved in Matlab file named myfile.mat\r\nselect(\"source2\");\r\nimportdataset(\"myfile.mat\");\r\n```\r\n\r\nTo see an example of how script commands can be used to create an imported source using\r\nmonitor data go to this KB page:\r\n[ Custom source profile from monitor data ](https://optics.ansys.com/hc/en-us/articles/360034383034-Custom-source-profile-from-monitor-data)\r\n.",
    "summary": "Adds an imported source to the simulation environment",
    "syntax": [
      {
        "syntax": "addimportedsource;",
        "description": "Adds an imported source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addimportedsource(struct_data);",
        "description": "Adds an imported source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addimportedsource;\r\nset(\"name\",\"source2\");\r\n# Load a field profile saved in Matlab file named myfile.mat\r\nselect(\"source2\");\r\nimportdataset(\"myfile.mat\");"
  },
  {
    "name": "addimportgen",
    "description": "Adds an (optical) generation region to the simulation environment where the generation profile has been imported into Finite Element IDE. This command requires a CHARGE solver region to be present in the objects tree.",
    "usage": "addimportgen();",
    "category": "general",
    "markdown": "# addimportgen\r\n\r\nAdds an (optical) generation region to the simulation environment where the generation\r\nprofile has been imported into Finite Element IDE. This command requires a CHARGE solver\r\nregion to be present in the objects tree.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                                                                                                                                                                          |\r\n| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addimportgen;              | Add an import generation object to the simulation environment. This function does not return any data.                                                                                                                                                                                   |\r\n| addimportgen(struct_data); | Adds tan import generation object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\nOnce the import generation object is created, the optical generation data can be\r\nimported from a matlab (.mat) file using the GUI or by assigning a dataset to the object\r\nusing the [ importdataset ](./importdataset.md) script command. The .mat file must\r\ncontain a 3D matrix G containing the generation data on a rectilinear grid and the three\r\ncoordinate vectors x, y, z. The dataset can be either a rectilinear or an unstructured\r\ndataset.\r\n\r\n**Example**\r\n\r\nThe following script command will add an import generation object to the CHARGE solver\r\nregion and will load an analytic 3D optical generation data into it.\r\n\r\n```\r\naddimportgen;\r\nset(\"name\",\"gen_opt\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\n# create coordinate vectors and 3D matrix for doping profile\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nG = matrix(11,2,101) + 1e27;  # assume uniform generation rate of 1e21 /cm3 (1e27 /m3)\r\n# create dataset\r\ngen = rectilineardataset(\"gen\",x,y,z);\r\ngen.addparameter(\"a\",1);  # add a dummy parameter\r\ngen.addattribute(\"G\",G);\r\n# load data into doping object\r\nselect(\"CHARGE::gen_opt\");  \r\nimportdataset(gen);\r\n```",
    "summary": "Adds an (optical) generation region to the simulation environment where the generation profile has b...",
    "syntax": [
      {
        "syntax": "addimportgen;",
        "description": "Add an import generation object to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addimportgen(struct_data);",
        "description": "Adds tan import generation object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addimportgen;\r\nset(\"name\",\"gen_opt\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\n# create coordinate vectors and 3D matrix for doping profile\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nG = matrix(11,2,101) + 1e27;  # assume uniform generation rate of 1e21 /cm3 (1e27 /m3)\r\n# create dataset\r\ngen = rectilineardataset(\"gen\",x,y,z);\r\ngen.addparameter(\"a\",1);  # add a dummy parameter\r\ngen.addattribute(\"G\",G);\r\n# load data into doping object\r\nselect(\"CHARGE::gen_opt\");  \r\nimportdataset(gen);"
  },
  {
    "name": "addimportheat",
    "description": "Adds a heat source to the Finite Element IDE simulation environment where the profile of the heat source can be imported from an external source. For the CHARGE solver, the import heat source only gets applied if the \"temperature dependence\" is set to \"coupled.\"",
    "usage": "addimportheat();",
    "category": "general",
    "markdown": "# addimportheat\r\n\r\nAdds a heat source to the Finite Element IDE simulation environment where the profile of\r\nthe heat source can be imported from an external source. For the CHARGE solver, the\r\nimport heat source only gets applied if the \"temperature dependence\" is set to\r\n\"coupled.\"\r\n\r\n| **Syntax**                                 | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addimportheat;                             | Adds an import primitive to define a heat source. This format of the command is only application when only one solver is present/active in the model tree. This function does not return any data. If multiple solvers are present then use the second or fourth format.                                                                                                                                                                                      |\r\n| addimportheat(\"solver_name\");              | This format of the command will add an import heat source to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.”                                                                                                                                                                                                                                                                                                         |\r\n| addimportheat(struct_data);                | Adds an import primitive to define a heat source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data.                                                                                                                                                       |\r\n| addimportheat(\"solver_name\", struct_data); | This format of the command will add a temperature monitor to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.” Adds an import primitive to define a heat source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\nOnce the import heat source is created, the data can be imported from a matlab (.mat)\r\nfile using the GUI or by assigning a dataset to the object using the\r\n[ importdataset ](./importdataset.md) script command. The dataset can be in rectilinear\r\nor unstructured (finite-element) format.\r\n\r\n**Example**\r\n\r\nThe following script command will add an import heat source to the HEAT solver region\r\nand will load an analytic 3D heat data into it.\r\n\r\n```\r\naddimportheat(\"HEAT\");\r\nset(\"name\",\"Pin\"); \r\n# create coordinate vectors and 3D matrix for heat input\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nQ = matrix(11,2,101) + 1e15;  # assume the heat input is 1e15 W/m^3 everywhere \r\n# create dataset\r\nheat = rectilineardataset(\"Pin\",x,y,z);\r\nheat.addparameter(\"a\",1);  # add a dummy parameter\r\nheat.addattribute(\"Q\",Q); \r\n# load data into source\r\nselect(\"HEAT::Pin\"); \r\nimportdataset(heat);\r\n```",
    "summary": "Adds a heat source to the Finite Element IDE simulation environment where the profile of the heat so...",
    "syntax": [
      {
        "syntax": "addimportheat;",
        "description": "Adds an import primitive to define a heat source. This format of the command is only application when only one solver is present/active in the model tree. This function does not return any data. If multiple solvers are present then use the second or fourth format."
      },
      {
        "syntax": "addimportheat(\"solver_name\");",
        "description": "This format of the command will add an import heat source to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.”"
      },
      {
        "syntax": "addimportheat(struct_data);",
        "description": "Adds an import primitive to define a heat source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      },
      {
        "syntax": "addimportheat(\"solver_name\", struct_data);",
        "description": "This format of the command will add a temperature monitor to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.” Adds an import primitive to define a heat source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addimportheat(\"HEAT\");\r\nset(\"name\",\"Pin\"); \r\n# create coordinate vectors and 3D matrix for heat input\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nQ = matrix(11,2,101) + 1e15;  # assume the heat input is 1e15 W/m^3 everywhere \r\n# create dataset\r\nheat = rectilineardataset(\"Pin\",x,y,z);\r\nheat.addparameter(\"a\",1);  # add a dummy parameter\r\nheat.addattribute(\"Q\",Q); \r\n# load data into source\r\nselect(\"HEAT::Pin\"); \r\nimportdataset(heat);"
  },
  {
    "name": "addimportnk",
    "description": "Adds a nk import object to the FEEM simulation environment where the profile of the material with a spatially varying index can be imported from an external Matlab file.",
    "usage": "addimportnk();",
    "category": "general",
    "markdown": "# addimportnk\r\n\r\nAdds a nk import object to the FEEM simulation environment where the profile of the\r\nmaterial with a spatially varying index can be imported from an external Matlab file.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                                                                                              |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addimportnk;              | Adds an import primitive to define material with a spatially varying index profile in the FEEM solver. This function does not return any data.                                                                                                                                                                                                               |\r\n| addimportnk(struct_data); | Adds an import primitive to define material with a spatially varying index profile in the FEEM solver and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\nOnce the nk import object is created, the data can be imported from a matlab (.mat) file\r\nusing the GUI or by assigning a dataset to the object using the\r\n[ importdataset ](./importdataset.md) script command. The dataset can be in rectilinear\r\nor unstructured (finite-element) format.\r\n\r\n**Example**\r\n\r\nThe following script command will add an import (n,k) object to the FEEM solver region\r\nand will load an analytic 3D heat data into it.\r\n\r\n```\r\naddfeemsolver;\r\naddimportnk;\r\n# create coordinate vectors and 3D matrix for nk input\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nnk = matrix(11,2,101)+3.45; # assume the index input is 3.45 everywhere\r\nfor (i=1:length(x)){  \r\n# assume that index varies along x-axis \r\nnk(i,:,:)=x(i)*1e5;}\r\n# add waveguide\r\naddrect;\r\nsetname('WG');\r\nset('x min',-1e-6); \r\nset('x max',1e-6);\r\nset('y span',2e-6); \r\nset('y',0);\r\nset('z span',2e-6); \r\nset('z',1e-6);\r\n# create dataset\r\nnkmaterial = rectilineardataset(\"nk import\",x,y,z);\r\nnkmaterial.addparameter(\"lambda\",1.55e-6); # (Required) add any parameter\r\nnkmaterial.addattribute(\"nk\",nk);\r\n# load data into nk import\r\nselect(\"FEEM::nk import\");\r\nimportdataset(nkmaterial);\r\nset(\"volume type\",\"solid\");\r\nset(\"volume solid\",\"WG\");\r\nset(\"selected attribute\",\"nk\");\r\n```",
    "summary": "Adds a nk import object to the FEEM simulation environment where the profile of the material with a ...",
    "syntax": [
      {
        "syntax": "addimportnk;",
        "description": "Adds an import primitive to define material with a spatially varying index profile in the FEEM solver. This function does not return any data."
      },
      {
        "syntax": "addimportnk(struct_data);",
        "description": "Adds an import primitive to define material with a spatially varying index profile in the FEEM solver and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addfeemsolver;\r\naddimportnk;\r\n# create coordinate vectors and 3D matrix for nk input\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nnk = matrix(11,2,101)+3.45; # assume the index input is 3.45 everywhere\r\nfor (i=1:length(x)){  \r\n# assume that index varies along x-axis \r\nnk(i,:,:)=x(i)*1e5;}\r\n# add waveguide\r\naddrect;\r\nsetname('WG');\r\nset('x min',-1e-6); \r\nset('x max',1e-6);\r\nset('y span',2e-6); \r\nset('y',0);\r\nset('z span',2e-6); \r\nset('z',1e-6);\r\n# create dataset\r\nnkmaterial = rectilineardataset(\"nk import\",x,y,z);\r\nnkmaterial.addparameter(\"lambda\",1.55e-6); # (Required) add any parameter\r\nnkmaterial.addattribute(\"nk\",nk);\r\n# load data into nk import\r\nselect(\"FEEM::nk import\");\r\nimportdataset(nkmaterial);\r\nset(\"volume type\",\"solid\");\r\nset(\"volume solid\",\"WG\");\r\nset(\"selected attribute\",\"nk\");"
  },
  {
    "name": "addimporttemperature",
    "description": "Adds an import temperature source to the CHARGE solver (only applicable to non-isothermal transport). The import temperature object can be used to import a temperature map for non-isothermal simulation. A CHARGE solver region must be present in the objects tree for this command to work.",
    "usage": "addimporttemperature();",
    "category": "general",
    "markdown": "# addimporttemperature\r\n\r\nAdds an import temperature source to the CHARGE solver (only applicable to\r\nnon-isothermal transport). The import temperature object can be used to import a\r\ntemperature map for non-isothermal simulation. A CHARGE solver region must be present in\r\nthe objects tree for this command to work.\r\n\r\n| **Syntax**                         | **Description**                                                                                                                                                                                                                                                                          |\r\n| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addimporttemperature;              | Adds an import temperature source to the CHARGE solver. The source only gets applied if the \"temperature dependence\" is set to \"non-isothermal.\" This function does not return any data.                                                                                                 |\r\n| addimporttemperature(struct_data); | Adds an import temperature source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\nOnce the import temperature source is created, the data can be imported from a matlab\r\n(.mat) file using the GUI or by assigning a dataset to the object using the\r\n[ importdataset ](./importdataset.md) script command. The dataset can either be in\r\nrectilinear or unstructured (finite-element) format.\r\n\r\n**Example**\r\n\r\nThe following script command will add an import temperature source and will load an\r\nanalytic 3D temperature data into it.\r\n\r\n```\r\naddimporttemperature;\r\nset(\"name\",\"Tmap\");\r\n# create coordinate vectors and 3D matrix for temperature map\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nT = matrix(11,2,101) + 400;  # assume the temperature is 400 K everywhere\r\n# create dataset\r\ntemperature = rectilineardataset(\"temp\",x,y,z);\r\ntemperature.addparameter(\"a\",1);  # add a dummy parameter\r\ntemperature.addattribute(\"T\",T);\r\n# load data into source\r\nselect(\"CHARGE::Tmap\"); \r\nimportdataset(temperature);\r\n```",
    "summary": "Adds an import temperature source to the CHARGE solver (only applicable to non-isothermal transport)",
    "syntax": [
      {
        "syntax": "addimporttemperature;",
        "description": "Adds an import temperature source to the CHARGE solver. The source only gets applied if the \"temperature dependence\" is set to \"non-isothermal.\" This function does not return any data."
      },
      {
        "syntax": "addimporttemperature(struct_data);",
        "description": "Adds an import temperature source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addimporttemperature;\r\nset(\"name\",\"Tmap\");\r\n# create coordinate vectors and 3D matrix for temperature map\r\nx = linspace(0,1e-6,11);\r\ny = linspace(-1e-6,1e-6,2);\r\nz = linspace(0,2e-6,101);\r\nT = matrix(11,2,101) + 400;  # assume the temperature is 400 K everywhere\r\n# create dataset\r\ntemperature = rectilineardataset(\"temp\",x,y,z);\r\ntemperature.addparameter(\"a\",1);  # add a dummy parameter\r\ntemperature.addattribute(\"T\",T);\r\n# load data into source\r\nselect(\"CHARGE::Tmap\"); \r\nimportdataset(temperature);"
  },
  {
    "name": "addindex",
    "description": "Adds an index monitor to the simulation environment. In MODE an active varFDTD region needs to be present for this command to work.",
    "usage": "addindex();",
    "category": "general",
    "markdown": "# addindex\r\n\r\nAdds an index monitor to the simulation environment. In MODE an active varFDTD region\r\nneeds to be present for this command to work.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                                                                                                                              |\r\n| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addindex;              | Adds an index monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addindex(struct_data); | Adds an index monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 2D y-normal index monitor to the simulation\r\nregion and set its dimension.\r\n\r\n```\r\naddindex;\r\nset(\"name\",\"index_monitor\");\r\nset(\"monitor type\",2);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"z\",10e-6);\r\nset(\"z span\",5e-6);\r\n```\r\n\r\nIf an FDTD the index monitor holds results automatically without running simulations if\r\na solver region is present. The following script command will add a solver region\r\nfollowing the script above and will visualize the index preview.\r\n\r\n```\r\naddfdtd;\r\nn = getresult(\"index_monitor\",\"index preview\");\r\nvisualize(n);\r\n```",
    "summary": "Adds an index monitor to the simulation environment",
    "syntax": [
      {
        "syntax": "addindex;",
        "description": "Adds an index monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addindex(struct_data);",
        "description": "Adds an index monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addindex;\r\nset(\"name\",\"index_monitor\");\r\nset(\"monitor type\",2);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"z\",10e-6);\r\nset(\"z span\",5e-6);"
  },
  {
    "name": "addjfluxmonitor",
    "description": "Adds a current flux monitor to the simulation environment. This command requires the presence of a CHARGE solver region in the objects tree.",
    "usage": "addjfluxmonitor();",
    "category": "general",
    "markdown": "# addjfluxmonitor\r\n\r\nAdds a current flux monitor to the simulation environment. This command requires the\r\npresence of a CHARGE solver region in the objects tree.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                                                                                                                                    |\r\n| ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addjfluxmonitor;              | Adds a current flux monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addjfluxmonitor(struct_data); | Adds a current flux monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a 2D y-normal current flux monitor to the\r\nsimulation environment and set its dimension.\r\n\r\n```\r\naddjfluxmonitor;\r\nset(\"name\",\"current_flux\");\r\nset(\"monitor type\",7);  # 2D z-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\n```",
    "summary": "Adds a current flux monitor to the simulation environment",
    "syntax": [
      {
        "syntax": "addjfluxmonitor;",
        "description": "Adds a current flux monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addjfluxmonitor(struct_data);",
        "description": "Adds a current flux monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addjfluxmonitor;\r\nset(\"name\",\"current_flux\");\r\nset(\"monitor type\",7);  # 2D z-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);"
  },
  {
    "name": "addjob",
    "description": "Adds a simulation file to the job manager queue.",
    "usage": "addjob();",
    "category": "general",
    "markdown": "# addjob\r\n\r\nAdds a simulation file to the job manager queue.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                                                                                                                                                                   |\r\n| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addjob(filename,\"solver\"); | Add the simulation file \"filename\" to the job manager queue. The \"solver\" argument is used to select the solver to add the job to and is optional if only one solver exists (or is active) in the simulation environment. The \"solver\" argument is not supported by INTERCONNECT. |\r\n\r\n**Example**\r\n\r\nSpecify short file name. In this case, the current working directory path will be added\r\nto the filename.\r\n\r\n```\r\naddjob(\"mySimulation.fsp\");  \r\n```\r\n\r\nSpecify filename with full path.\r\n\r\n```\r\nfile=\"C:\\working\\mySimulation.fsp\";\r\naddjob(file);  \r\n```\r\n\r\nSpecify filename with the currentfilename script command.\r\n\r\n```\r\naddjob(currentfilename);  \r\n```\r\n\r\nFor a more complete example, see the runjobs script command page.",
    "summary": "Adds a simulation file to the job manager queue",
    "syntax": [
      {
        "syntax": "addjob(filename,\"solver\");",
        "description": "Add the simulation file \"filename\" to the job manager queue. The \"solver\" argument is used to select the solver to add the job to and is optional if only one solver exists (or is active) in the simulation environment. The \"solver\" argument is not supported by INTERCONNECT."
      }
    ],
    "example": "addjob(\"mySimulation.fsp\");"
  },
  {
    "name": "addlayer",
    "description": "Adds a layer to the layer builder object. The command only works if there is a layer builder object and is selected.",
    "usage": "addlayer();",
    "category": "general",
    "markdown": "# addlayer\r\n\r\nAdds a layer to the layer builder object. The command only works if there is a layer\r\nbuilder object and is selected.\r\n\r\n| **Syntax**        | **Description**                                                                                                                            |\r\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addlayer;         | Adds a layer to the selected layer builder object. The name of the layer is set to \"default name\". This function does not return any data. |\r\n| addlayer(\"name\"); | Adds a layer named \"name\"                                                                                                                  |\r\n\r\n**Example**\r\n\r\nThe following script commands will create a layer builder object and add two layers to\r\nit.\r\n\r\n```\r\naddlayerbuilder;\r\n# Layer 1 = 100 nm layer of silver\r\naddlayer(\"layer_1\");\r\nsetlayer(\"layer_1\",\"thickness\",100e-9);\r\nsetlayer(\"layer_1\",\"material\",\"Ag (Silver) - CRC\");\r\n# Layer 2 = 500 nm layer of silicon\r\naddlayer(\"layer_2\");\r\nsetlayer(\"layer_2\",\"thickness\",500e-9);\r\nsetlayer(\"layer_2\",\"material\",\"Si (Silicon)\");\r\n```",
    "summary": "Adds a layer to the layer builder object",
    "syntax": [
      {
        "syntax": "addlayer;",
        "description": "Adds a layer to the selected layer builder object. The name of the layer is set to \"default name\". This function does not return any data."
      },
      {
        "syntax": "addlayer(\"name\");",
        "description": "Adds a layer named \"name\""
      }
    ],
    "example": "addlayerbuilder;\r\n# Layer 1 = 100 nm layer of silver\r\naddlayer(\"layer_1\");\r\nsetlayer(\"layer_1\",\"thickness\",100e-9);\r\nsetlayer(\"layer_1\",\"material\",\"Ag (Silver) - CRC\");\r\n# Layer 2 = 500 nm layer of silicon\r\naddlayer(\"layer_2\");\r\nsetlayer(\"layer_2\",\"thickness\",500e-9);\r\nsetlayer(\"layer_2\",\"material\",\"Si (Silicon)\");"
  },
  {
    "name": "addlayerbuilder",
    "description": "Adds a layer builder object to the simulation environment.",
    "usage": "addlayerbuilder();",
    "category": "general",
    "markdown": "# addlayerbuilder\r\n\r\nAdds a layer builder object to the simulation environment.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                                                                                                                                    |\r\n| ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addlayerbuilder;              | Adds a layer builder object to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addlayerbuilder(struct_data); | Adds a layer builder object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will create a layer builder object and add two layers to\r\nit.\r\n\r\n```\r\naddlayerbuilder;\r\n# Layer 1: 100 nm layer of silver\r\naddlayer(\"layer_1\");\r\nsetlayer(\"layer_1\",\"thickness\",100e-9);\r\nsetlayer(\"layer_1\",\"pattern material\",\"Ag (Silver) - CRC\");\r\n# Layer 2: 500 nm layer of silicon\r\naddlayer(\"layer_2\");\r\nsetlayer(\"layer_2\",\"thickness\",500e-9);\r\nsetlayer(\"layer_2\",\"pattern material\",\"Si (\"Si (Silicon) - Palik\");\r\n```",
    "summary": "Adds a layer builder object to the simulation environment",
    "syntax": [
      {
        "syntax": "addlayerbuilder;",
        "description": "Adds a layer builder object to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addlayerbuilder(struct_data);",
        "description": "Adds a layer builder object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addlayerbuilder;\r\n# Layer 1: 100 nm layer of silver\r\naddlayer(\"layer_1\");\r\nsetlayer(\"layer_1\",\"thickness\",100e-9);\r\nsetlayer(\"layer_1\",\"pattern material\",\"Ag (Silver) - CRC\");\r\n# Layer 2: 500 nm layer of silicon\r\naddlayer(\"layer_2\");\r\nsetlayer(\"layer_2\",\"thickness\",500e-9);\r\nsetlayer(\"layer_2\",\"pattern material\",\"Si (\"Si (Silicon) - Palik\");"
  },
  {
    "name": "addmaterial",
    "description": "Adds a new material to the material database given the material model or type and returns the name of the new material. For details on available material models see: [ Material permittivity models ](https://optics.ansys.com/hc/en-us/articles/360034394634-Material-Permittivity-Models) and [ Material conductivity models ](https://optics.ansys.com/hc/en-us/articles/360034915113-Material-Conductivity-Models) .",
    "usage": "addmaterial();",
    "category": "general",
    "markdown": "# addmaterial\r\n\r\nAdds a new material to the material database given the material model or type and\r\nreturns the name of the new material. For details on available material models see:\r\n[ Material permittivity models ](https://optics.ansys.com/hc/en-us/articles/360034394634-Material-Permittivity-Models)\r\nand\r\n[ Material conductivity models ](https://optics.ansys.com/hc/en-us/articles/360034915113-Material-Conductivity-Models)\r\n.\r\n\r\n| **Syntax**                         | **Description**                                                                                                                |\r\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| ?addmaterial;                      | Lists all available material models that can be added into the material database.                                              |\r\n| out = addmaterial(\"materialtype\"); | Adds a new material and returns the name of the new material. The argument \"materialtype\" has to match correct string exactly. |\r\n\r\n**Example**\r\n\r\nThese commands add a new Conductive material, set the name to \"aluminum\", anisotropy to\r\n\"Diagonal\", and set the permittivity as well as conductivity properties for the\r\nmaterial.\r\n\r\n```\r\nA=[4;5;6];\r\nB=[1;2;3];\r\nmymaterial = addmaterial(\"Conductive\");\r\nsetmaterial(mymaterial,\"name\",\"Aluminum\");\r\nsetmaterial(\"Aluminum\", \"Anisotropy\", 1); # enable diagonal anisotropy\r\nsetmaterial(\"Aluminum\",\"Permittivity\", A);\r\nsetmaterial(\"Aluminum\",\"Conductivity\", B);\r\n```",
    "summary": "Adds a new material to the material database given the material model or type and returns the name o...",
    "syntax": [
      {
        "syntax": "?addmaterial;",
        "description": "Lists all available material models that can be added into the material database."
      },
      {
        "syntax": "out = addmaterial(\"materialtype\");",
        "description": "Adds a new material and returns the name of the new material. The argument \"materialtype\" has to match correct string exactly."
      }
    ],
    "example": "A=[4;5;6];\r\nB=[1;2;3];\r\nmymaterial = addmaterial(\"Conductive\");\r\nsetmaterial(mymaterial,\"name\",\"Aluminum\");\r\nsetmaterial(\"Aluminum\", \"Anisotropy\", 1); # enable diagonal anisotropy\r\nsetmaterial(\"Aluminum\",\"Permittivity\", A);\r\nsetmaterial(\"Aluminum\",\"Conductivity\", B);"
  },
  {
    "name": "addmaterialproperties",
    "description": "Adds a (material) property to the selected material model. A material model (in the 'materials' folder) must be selected in the objects tree for this script command to work.",
    "usage": "addmaterialproperties();",
    "category": "general",
    "markdown": "# addmaterialproperties\r\n\r\nAdds a (material) property to the selected material model. A material model (in the\r\n'materials' folder) must be selected in the objects tree for this script command to\r\nwork.\r\n\r\n| **Syntax**                                              | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addmaterialproperties(\"material_type\",\"material_name\"); | Adds a (material) property to the selected material model in the objects tree in Finite Element IDE. The property comes from one of the material databases in Finite Element IDE. The \"material_type\" argument selects the type of material property to be added. The options are \"CT\" for electrical property, \"HT\" for thermal property, and \"EM\" for optical property. The \"material_name\" argument defines the name of the material in the appropriate material database whose properties will be imported. The function does not return any data. |\r\n| addmaterialproperties(\"material_type\");                 | The \"material_type\" argument selects the type of material property to be added. The options are \"CT\" for electrical property, \"HT\" for thermal property, and \"EM\" for optical property. The function returns a list of available material names as a string.                                                                                                                                                                                                                                                                                           |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a new material to the objects tree in Finite\r\nElement IDE name it, and assign optical properties to it using a material model in the\r\noptical material database. The script will then add electrical and thermal properties to\r\nthe same material using an appropriate material model in the electrical/thermal material\r\ndatabase.\r\n\r\n```\r\naddmodelmaterial;\r\nset(\"name\",\"silicon\");\r\naddmaterialproperties(\"EM\",\"Si (Silicon) - Palik\");  # importing from optical material database\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"CT\",\"Si (Silicon)\");  # importing from electrical material database\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"HT\",\"Si (Silicon)\");  # importing from thermal material database\r\n```\r\n\r\n## NOTE: Once a material property is assigned to the material model the selection changes to the corresponding property. Therefore the material model must be re-selected before adding a new property to it.",
    "summary": "Adds a (material) property to the selected material model",
    "syntax": [
      {
        "syntax": "addmaterialproperties(\"material_type\",\"material_name\");",
        "description": "Adds a (material) property to the selected material model in the objects tree in Finite Element IDE. The property comes from one of the material databases in Finite Element IDE. The \"material_type\" argument selects the type of material property to be added. The options are \"CT\" for electrical property, \"HT\" for thermal property, and \"EM\" for optical property. The \"material_name\" argument defines the name of the material in the appropriate material database whose properties will be imported. The function does not return any data."
      },
      {
        "syntax": "addmaterialproperties(\"material_type\");",
        "description": "The \"material_type\" argument selects the type of material property to be added. The options are \"CT\" for electrical property, \"HT\" for thermal property, and \"EM\" for optical property. The function returns a list of available material names as a string."
      }
    ],
    "example": "addmodelmaterial;\r\nset(\"name\",\"silicon\");\r\naddmaterialproperties(\"EM\",\"Si (Silicon) - Palik\");  # importing from optical material database\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"CT\",\"Si (Silicon)\");  # importing from electrical material database\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"HT\",\"Si (Silicon)\");  # importing from thermal material database"
  },
  {
    "name": "addmesh",
    "description": "Adds a mesh override region to the simulation environment. The mesh override region can be used to control the size of the mesh in a certain region. In Finite Element IDE, a CHARGE solver region must be present in the objects tree for this command to work.",
    "usage": "addmesh();",
    "category": "general",
    "markdown": "# addmesh\r\n\r\nAdds a mesh override region to the simulation environment. The mesh override region can\r\nbe used to control the size of the mesh in a certain region. In Finite Element IDE, a\r\nCHARGE solver region must be present in the objects tree for this command to work.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                 |\r\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addmesh;              | Adds a mesh override region to the simulation environment. In Finite Element IDE, this command adds an electrical mesh which applies only to the 'CHARGE' solver. This function does not return any data.                                                                                                                                                                                                                       |\r\n| addmesh(struct_data); | Adds a mesh override region to the simulation environment. object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. In Finite Element IDE, this command adds an electrical mesh which applies only to the 'CHARGE' solver. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a mesh override region in FDTD, name it, set its\r\ndimension, and set the mesh constraints. The mesh object will be set to restrict the\r\nmesh in X direction only.\r\n\r\n```\r\naddmesh;\r\nset(\"name\",\"mesh_waveguide\");\r\n# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n# enable in X direction and disable in Y,Z directions\r\nset(\"override x mesh\",1);\r\nset(\"override y mesh\",0);\r\nset(\"override z mesh\",0);\r\n# restrict mesh by defining maximum step size\r\nset(\"set maximum mesh step\",1);\r\nset(\"dx\",5e-9);\r\n```",
    "summary": "Adds a mesh override region to the simulation environment",
    "syntax": [
      {
        "syntax": "addmesh;",
        "description": "Adds a mesh override region to the simulation environment. In Finite Element IDE, this command adds an electrical mesh which applies only to the 'CHARGE' solver. This function does not return any data."
      },
      {
        "syntax": "addmesh(struct_data);",
        "description": "Adds a mesh override region to the simulation environment. object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. In Finite Element IDE, this command adds an electrical mesh which applies only to the 'CHARGE' solver. This function does not return any data."
      }
    ],
    "example": "addmesh;\r\nset(\"name\",\"mesh_waveguide\");\r\n# set dimension\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n# enable in X direction and disable in Y,Z directions\r\nset(\"override x mesh\",1);\r\nset(\"override y mesh\",0);\r\nset(\"override z mesh\",0);\r\n# restrict mesh by defining maximum step size\r\nset(\"set maximum mesh step\",1);\r\nset(\"dx\",5e-9);"
  },
  {
    "name": "addmode",
    "description": "Adds a mode source to the simulation environment for FDTD. For MODE, adds an eigenmode (FDE) solver region to the simulation environment.",
    "usage": "addmode();",
    "category": "general",
    "markdown": "# addmode\r\n\r\nAdds a mode source to the simulation environment for FDTD. For MODE, adds an eigenmode\r\n(FDE) solver region to the simulation environment.\r\n\r\n## Note: The 'addmode' command is deprecated in MODE and will be removed in future releases. Please refer to [ addfde ](./addfde.md) as a replacement.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                                                                          |\r\n| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addmode;              | For FDTD: Add a mode source to the simulation environment. This function does not return any data.                                                                                                                                                                                                                                       |\r\n| addmode;              | For MODE: Add an eigenmode solver to the simulation environment.                                                                                                                                                                                                                                                                         |\r\n| addmode(struct_data); | Adds a mode source (when used in FDTD) or an eigenmode solver (when used in MODE) and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a mode source in FDTD and set its dimension and\r\ninjection axis.\r\n\r\n```\r\naddmode;\r\nset(\"injection axis\",\"x\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\n```\r\n\r\nThe following script commands will add an eigenmode (FDE) solver region in MODE on the\r\nXY plane and calculate the eigen modes.\r\n\r\n```\r\naddmode;\r\nset(\"solver type\",3);\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nfindmodes;\r\n```",
    "summary": "Adds a mode source to the simulation environment for FDTD",
    "syntax": [
      {
        "syntax": "addmode;",
        "description": "For FDTD: Add a mode source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addmode;",
        "description": "For MODE: Add an eigenmode solver to the simulation environment."
      },
      {
        "syntax": "addmode(struct_data);",
        "description": "Adds a mode source (when used in FDTD) or an eigenmode solver (when used in MODE) and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addmode;\r\nset(\"injection axis\",\"x\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);"
  },
  {
    "name": "addmodeexpansion",
    "description": "Adds a mode expansion monitor to the simulation environment. In MODE an active varFDTD region needs to be present for this command to work.",
    "usage": "addmodeexpansion();",
    "category": "general",
    "markdown": "# addmodeexpansion\r\n\r\nAdds a mode expansion monitor to the simulation environment. In MODE an active varFDTD\r\nregion needs to be present for this command to work.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                                                                                                                                                      |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addmodeexpansion;              | Adds a mode expansion monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addmodeexpansion(struct_data); | Adds a mode expansion monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add mode expansion and field monitors and then setup\r\nsome of the expansion monitor properties.\r\n\r\n```\r\n# add monitors\r\naddmodeexpansion;\r\nset(\"name\",\"mode_expansion\");\r\naddpower;\r\nset(\"name\",\"field\");\r\n# set the field monitor to be used by the expansion monitor\r\nselect(\"mode_expansion\");\r\nsetexpansion(\"input\", \"field\");\r\n# set the expansion monitor mode solver properties\r\nif (true) { \r\n# select fundamental, fundamental TE or fundamental TM mode \r\n  set(\"mode selection\",\"fundamental mode\");\r\n} else { \r\n# alternately, set expansion monitor mode solver properties,  \r\n# rather than one of the 'fundamental modes \r\n  set(\"mode selection\",\"user select\"); # use the 'user select' option \r\n  seteigensolver(\"use max index\",0); # specify a custom value for 'n' \r\n  seteigensolver(\"n\",1.1); updatemodes(3); # select the 3rd mode\r\n}\r\n```",
    "summary": "Adds a mode expansion monitor to the simulation environment",
    "syntax": [
      {
        "syntax": "addmodeexpansion;",
        "description": "Adds a mode expansion monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addmodeexpansion(struct_data);",
        "description": "Adds a mode expansion monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "# add monitors\r\naddmodeexpansion;\r\nset(\"name\",\"mode_expansion\");\r\naddpower;\r\nset(\"name\",\"field\");\r\n# set the field monitor to be used by the expansion monitor\r\nselect(\"mode_expansion\");\r\nsetexpansion(\"input\", \"field\");\r\n# set the expansion monitor mode solver properties\r\nif (true) { \r\n# select fundamental, fundamental TE or fundamental TM mode \r\n  set(\"mode selection\",\"fundamental mode\");\r\n} else { \r\n# alternately, set expansion monitor mode solver properties,  \r\n# rather than one of the 'fundamental modes \r\n  set(\"mode selection\",\"user select\"); # use the 'user select' option \r\n  seteigensolver(\"use max index\",0); # specify a custom value for 'n' \r\n  seteigensolver(\"n\",1.1); updatemodes(3); # select the 3rd mode\r\n}"
  },
  {
    "name": "addmodelmaterial",
    "description": "Adds an empty material model to the 'materials' folder in the objects tree. Different properties (electrical, thermal, or optical) can then be assigned to the material. Once created the material can be assigned to any geometry and be used in simulations using the CHARGE, HEAT, or DGTD solvers.",
    "usage": "addmodelmaterial();",
    "category": "general",
    "markdown": "# addmodelmaterial\r\n\r\nAdds an empty material model to the 'materials' folder in the objects tree. Different\r\nproperties (electrical, thermal, or optical) can then be assigned to the material. Once\r\ncreated the material can be assigned to any geometry and be used in simulations using\r\nthe CHARGE, HEAT, or DGTD solvers.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                                                                                                                                                               |\r\n| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addmodelmaterial;              | Adds a new material to the 'materials' folder in the objects tree in Finite Element IDE. This function does not return any data.                                                                                                                                                              |\r\n| addmodelmaterial(struct_data); | Adds a new material to the 'materials' and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a new material to the objects tree in Finite\r\nElement IDE, name it, and assign optical properties to it using a material model in the\r\noptical material database. The script will then add electrical and thermal properties to\r\nthe same material using an appropriate material model in the electrical/thermal material\r\ndatabase.\r\n\r\n```\r\naddmodelmaterial;\r\nset(\"name\",\"silicon\");\r\naddmaterialproperties(\"EM\",\"Si (Silicon) - Palik\");\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"CT\",\"Si (Silicon)\");\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"HT\",\"Si (Silicon)\");\r\n```\r\n\r\n## NOTE: Once a material property is assigned to the material model the selection changes to the corresponding property. Therefore the material model must be re-selected before adding a new property to it.",
    "summary": "Adds an empty material model to the 'materials' folder in the objects tree",
    "syntax": [
      {
        "syntax": "addmodelmaterial;",
        "description": "Adds a new material to the 'materials' folder in the objects tree in Finite Element IDE. This function does not return any data."
      },
      {
        "syntax": "addmodelmaterial(struct_data);",
        "description": "Adds a new material to the 'materials' and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addmodelmaterial;\r\nset(\"name\",\"silicon\");\r\naddmaterialproperties(\"EM\",\"Si (Silicon) - Palik\");\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"CT\",\"Si (Silicon)\");\r\nselect(\"materials::silicon\");\r\naddmaterialproperties(\"HT\",\"Si (Silicon)\");"
  },
  {
    "name": "addmodesource",
    "description": "Adds a mode source to the 2.5D varFDTD simulation environment. The varFDTD solver object must be set as the active solver for this command to work.",
    "usage": "addmodesource();",
    "category": "general",
    "markdown": "# addmodesource\r\n\r\nAdds a mode source to the 2.5D varFDTD simulation environment. The varFDTD solver object\r\nmust be set as the active solver for this command to work.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                                        |\r\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addmodesource;              | Adds a mode source to the varFDTD solver region. This function does not return any data.                                                                                                                                                                                                               |\r\n| addmodesource(struct_data); | Adds a mode source to the varFDTD solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a mode source to the varFDTD solver region in\r\nMODE and select the injection axis.\r\n\r\n```\r\naddmodesource;\r\nset(\"injection axis\",\"x\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\n```",
    "summary": "Adds a mode source to the 2",
    "syntax": [
      {
        "syntax": "addmodesource;",
        "description": "Adds a mode source to the varFDTD solver region. This function does not return any data."
      },
      {
        "syntax": "addmodesource(struct_data);",
        "description": "Adds a mode source to the varFDTD solver region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addmodesource;\r\nset(\"injection axis\",\"x\");\r\nset(\"x\",0);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);"
  },
  {
    "name": "addmovie",
    "description": "Adds a movie monitor to the simulation environment. Movie monitors capture a desired field component over the region spanned by the monitor for the duration of the simulation.",
    "usage": "addmovie();",
    "category": "general",
    "markdown": "# addmovie\r\n\r\nAdds a movie monitor to the simulation environment. Movie monitors capture a desired\r\nfield component over the region spanned by the monitor for the duration of the\r\nsimulation.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                                                                                                                             |\r\n| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addmovie;              | Adds a movie monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addmovie(struct_data); | Adds a movie monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a 2D z-normal movie monitor to the simulation\r\nregion, set its location and dimension, and set its resolution while keeping the aspect\r\nratio locked. Locking the aspect ratio ensures that the video will keep the shape of the\r\nmonitor data.\r\n\r\n```\r\naddmovie;\r\nset(\"name\",\"movie_1\");\r\nset(\"monitor type\",3);  # 1 = 2D x-normal,  2 = 2D y-normal,  3 = 2D z-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"lock aspect ratio\",1);\r\nset(\"horizontal resolution\",240);\r\n```",
    "summary": "Adds a movie monitor to the simulation environment",
    "syntax": [
      {
        "syntax": "addmovie;",
        "description": "Adds a movie monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addmovie(struct_data);",
        "description": "Adds a movie monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addmovie;\r\nset(\"name\",\"movie_1\");\r\nset(\"monitor type\",3);  # 1 = 2D x-normal,  2 = 2D y-normal,  3 = 2D z-normal\r\nset(\"x\",0);\r\nset(\"x span\",5e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"lock aspect ratio\",1);\r\nset(\"horizontal resolution\",240);"
  },
  {
    "name": "addobject",
    "description": "Adds an object from the object library in FDTD and MODE. The command can also be used to return the names of all the available objects and analysis groups in the objects library.",
    "usage": "addobject();",
    "category": "general",
    "markdown": "# addobject\r\n\r\nAdds an object from the object library in FDTD and MODE. The command can also be used to\r\nreturn the names of all the available objects and analysis groups in the objects\r\nlibrary.\r\n\r\n| **Syntax**              | **Description**                                                                         |\r\n| ----------------------- | --------------------------------------------------------------------------------------- |\r\n| addobject(\"script_ID\"); | Adds an object from the object library. This function does not return any data.         |\r\n| A = addobject;          | Returns names of all the objects in the library and saves it in a cell array named \"A\". |\r\n\r\n**Example**\r\n\r\nAdd a rounded cylinder object from the object library.\r\n\r\n```\r\naddobject(\"rounded_cyl\");\r\nset(\"name\",\"test_cyl\");\r\n```\r\n\r\nPrint the name of all the available elements.\r\n\r\n```\r\nA = addobject;\r\nL = length(A);\r\nfor (i = 1:L) {\r\n    ?A{i};\r\n}\r\n```",
    "summary": "Adds an object from the object library in FDTD and MODE",
    "syntax": [
      {
        "syntax": "addobject(\"script_ID\");",
        "description": "Adds an object from the object library. This function does not return any data."
      },
      {
        "syntax": "A = addobject;",
        "description": "Returns names of all the objects in the library and saves it in a cell array named \"A\"."
      }
    ],
    "example": "addobject(\"rounded_cyl\");\r\nset(\"name\",\"test_cyl\");"
  },
  {
    "name": "addparameter",
    "description": "Adds a parameter to an existing dataset.",
    "usage": "addparameter();",
    "category": "general",
    "markdown": "# addparameter\r\n\r\nAdds a parameter to an existing dataset.\r\n\r\n| **Syntax**                                    | **Description**                                                                                                                                                                                             |\r\n| --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| R.addparameter(\"p_name\", p);                  | Adds the parameter p to the existing dataset R.                                                                                                                                                             |\r\n| R.addparameter(\"p1_name\", p1, \"p2_name\", p2); | Adds the interdependent parameter p1_name, p2_name to the R dataset. The most common interdependent parameter is frequency and wavelength. Parameters that are not interdependent must be added separately. |\r\n\r\n**Examples**\r\n\r\nThis example uses a matrix dataset to store cross section (sigma) data as a function of\r\nfrequency. In this case, the cross section data sigma is the attribute, and frequency is\r\nthe parameter. To allow the user to access the frequency parameter in terms of frequency\r\nor wavelength , both frequency (f) and wavelength (c/f) are added as interdependent\r\nparameters.\r\n\r\n```\r\nsigma = matrixdataset(\"cross_section\");\r\nsigma.addparameter(\"lambda\",c/f,\"f\",f); # add parameter f and lambda\r\nsigma.addattribute(\"sigma\",CS); # add attribute CS\r\nvisualize(sigma); # visualize this dataset in the Visualizer\r\n```",
    "summary": "Adds a parameter to an existing dataset",
    "syntax": [
      {
        "syntax": "R.addparameter(\"p_name\", p);",
        "description": "Adds the parameter p to the existing dataset R."
      },
      {
        "syntax": "R.addparameter(\"p1_name\", p1, \"p2_name\", p2);",
        "description": "Adds the interdependent parameter p1_name, p2_name to the R dataset. The most common interdependent parameter is frequency and wavelength. Parameters that are not interdependent must be added separately."
      }
    ],
    "example": ""
  },
  {
    "name": "addpath",
    "description": "Adds a directory to the path.",
    "usage": "addpath();",
    "category": "general",
    "markdown": "# addpath\r\n\r\nAdds a directory to the path.\r\n\r\nThis can be helpful when your script and simulation files are located in different\r\ndirectories. Your current working directory will typically be set to the location of\r\nyour simulation files. addpath can be used to add the location of your script files to\r\nthe path, which makes it possible to call those scripts without providing the full path\r\neach time.\r\n\r\n| **Syntax**            | **Description**                                                       |\r\n| --------------------- | --------------------------------------------------------------------- |\r\n| addpath(\"directory\"); | Adds a directory to the path. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nAdds a second directory to the path.\r\n\r\n```\r\n?getpath;\r\n./  \r\nC:/Program Files/Lumerical/2020a/scripts\r\naddpath(\"C:/demo\");\r\n?getpath;\r\n./  \r\nC:/Program Files/Lumerical/2020a/scripts  \r\nC:/demo\r\n```\r\n\r\nClears the path.\r\n\r\n```\r\nclearpath;\r\n?getpath;\r\n./\r\n```",
    "summary": "Adds a directory to the path",
    "syntax": [
      {
        "syntax": "addpath(\"directory\");",
        "description": "Adds a directory to the path. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addpec",
    "description": "Adds a PEC (perfect electrical conductor) boundary condition to the DGTD or FEEM solver in Finite Element IDE. A DGTD or FEEM solver region must be present in the objects tree for this command to work. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addpec();",
    "category": "general",
    "markdown": "# addpec\r\n\r\nAdds a PEC (perfect electrical conductor) boundary condition to the DGTD or FEEM solver\r\nin Finite Element IDE. A DGTD or FEEM solver region must be present in the objects tree\r\nfor this command to work. If both solvers are present then the intended solver's name\r\nmust be provided as an argument to the script command.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                       |\r\n| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addpec;                | Adds a PEC boundary condition to the DGTD or FEEM solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addpec(\"solver_name\"); | Adds a PEC boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"DGTD\" and \"FEEM\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a PEC boundary condition to the solver already\r\npresent in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddpec;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a PEC boundary condition to the DGTD solver, name\r\nit, and assign it to the -x and +x boundaries of the simulation region.\r\n\r\n```\r\naddpec(\"DGTD\"); \r\nset(\"name\",\"PEC_x\");\r\nset(\"surface type\",\"simulation region\");\r\nset(\"x min\",1);\r\nset(\"x max\",1);\r\n```",
    "summary": "Adds a PEC (perfect electrical conductor) boundary condition to the DGTD or FEEM solver in Finite El...",
    "syntax": [
      {
        "syntax": "addpec;",
        "description": "Adds a PEC boundary condition to the DGTD or FEEM solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addpec(\"solver_name\");",
        "description": "Adds a PEC boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"DGTD\" and \"FEEM\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addperiodic",
    "description": "Adds a periodic (or Bloch) boundary condition to the 'DGTD' solver in Finite Element IDE. A DGTD solver region must be present in the objects tree for this command to work.",
    "usage": "addperiodic();",
    "category": "general",
    "markdown": "# addperiodic\r\n\r\nAdds a periodic (or Bloch) boundary condition to the 'DGTD' solver in Finite Element\r\nIDE. A DGTD solver region must be present in the objects tree for this command to work.\r\n\r\n| **Syntax**   | **Description**                                                                                  |\r\n| ------------ | ------------------------------------------------------------------------------------------------ |\r\n| addperiodic; | Adds a periodic boundary condition to the 'DGTD' solver. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a periodic boundary condition to the 'DGTD'\r\nsolver already present in the objects tree and print all available properties of the\r\nboundary condition.\r\n\r\n```\r\naddperiodic;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a periodic boundary condition in the x direction\r\nof the 'DGTD' solver.\r\n\r\n```\r\naddperiodic; \r\nset(\"x periodic\",1);\r\n```",
    "summary": "Adds a periodic (or Bloch) boundary condition to the 'DGTD' solver in Finite Element IDE",
    "syntax": [
      {
        "syntax": "addperiodic;",
        "description": "Adds a periodic boundary condition to the 'DGTD' solver. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addplanarsolid",
    "description": "Adds a planar solid primitive with the specified vertices. Planar solids offer a very convenient option to create custom, complex 3D geometries. You can find more information about planar solids in this page: [ Structures - Planar solid](https://optics.ansys.com/hc/en-us/articles/360034901573-Structures-Planar-solid).",
    "usage": "addplanarsolid();",
    "category": "general",
    "markdown": "# addplanarsolid\r\n\r\nAdds a planar solid primitive with the specified vertices. Planar solids offer a very\r\nconvenient option to create custom, complex 3D geometries. You can find more information\r\nabout planar solids in this page:\r\n[ Structures - Planar solid](https://optics.ansys.com/hc/en-us/articles/360034901573-Structures-Planar-solid).\r\n\r\n| **Syntax**                   | **Description**                                                                                                                                                                                                                                                                          |\r\n| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addplanarsolid;              | Adds an empty planar solid object.                                                                                                                                                                                                                                                       |\r\n| addplanarsolid(vtx, fct);    | Adds a planar solid object whose vertices are defined by 'vtx' and whose facets are defined by 'fct'                                                                                                                                                                                     |\r\n| addplanarsolid(struct_data); | Adds an empty planar solid object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe example below adds a planar solid cut-face box using two methods. The first method\r\nuses the facet table as a cell array and the second method uses the facet table a\r\nmatrix.\r\n\r\n```\r\nmethod_type = 1;  # choose 1 or 2 to switch between methods\r\nvtx = [0,0,0;\r\n    1,0,0;\r\n    1,1,0;\r\n    0,1,0;\r\n    0,0,2;\r\n    1,0,2;\r\n    1,1,2;\r\n    0,1,2]*1e-6;\r\n# Method 1: facet table as cell array\r\na = cell(7);\r\nfor (i = 1:7) {\r\n a{i} = cell(1);\r\n}\r\na{1}{1} = [1,4,3,2];\r\na{2}{1} = [1,5,8,4];\r\na{3}{1} = [1,2,6,5];\r\na{4}{1} = [2,3,6];\r\na{5}{1} = [3,8,6];\r\na{6}{1} = [3,4,8];\r\na{7}{1} = [5,6,8];\r\nif (method_type == 1) {\r\n addplanarsolid(vtx,a);\r\n}\r\n# Method 2: facet table as matrix\r\nb = matrix(4,1,7); # max four points per polygon, max 1 polygon per facet\r\nfor (i = 1:7) { \r\n  fpoly = a{i}{1}; \r\n  for (j = 1:length(fpoly)) { \r\n    b(j,1,i) = fpoly(j); \r\n    }\r\n  }\r\nif (method_type == 2) { \r\n  addplanarsolid; \r\n  set('vertices',vtx); # must be done first \r\n  set('facets',b);\r\n  }\r\n```",
    "summary": "Adds a planar solid primitive with the specified vertices",
    "syntax": [
      {
        "syntax": "addplanarsolid;",
        "description": "Adds an empty planar solid object."
      },
      {
        "syntax": "addplanarsolid(vtx, fct);",
        "description": "Adds a planar solid object whose vertices are defined by 'vtx' and whose facets are defined by 'fct'"
      },
      {
        "syntax": "addplanarsolid(struct_data);",
        "description": "Adds an empty planar solid object and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "method_type = 1;  # choose 1 or 2 to switch between methods\r\nvtx = [0,0,0;\r\n    1,0,0;\r\n    1,1,0;\r\n    0,1,0;\r\n    0,0,2;\r\n    1,0,2;\r\n    1,1,2;\r\n    0,1,2]*1e-6;\r\n# Method 1: facet table as cell array\r\na = cell(7);\r\nfor (i = 1:7) {\r\n a{i} = cell(1);\r\n}\r\na{1}{1} = [1,4,3,2];\r\na{2}{1} = [1,5,8,4];\r\na{3}{1} = [1,2,6,5];\r\na{4}{1} = [2,3,6];\r\na{5}{1} = [3,8,6];\r\na{6}{1} = [3,4,8];\r\na{7}{1} = [5,6,8];\r\nif (method_type == 1) {\r\n addplanarsolid(vtx,a);\r\n}\r\n# Method 2: facet table as matrix\r\nb = matrix(4,1,7); # max four points per polygon, max 1 polygon per facet\r\nfor (i = 1:7) { \r\n  fpoly = a{i}{1}; \r\n  for (j = 1:length(fpoly)) { \r\n    b(j,1,i) = fpoly(j); \r\n    }\r\n  }\r\nif (method_type == 2) { \r\n  addplanarsolid; \r\n  set('vertices',vtx); # must be done first \r\n  set('facets',b);\r\n  }"
  },
  {
    "name": "addplane",
    "description": "#",
    "usage": "addplane();",
    "category": "general",
    "markdown": "# addplane\r\n\r\n# \r\n\r\nAdds a plane wave source to the simulation environment.\r\n\r\n## For FDTD and MODE\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                                                                                                                                 |\r\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addplane;              | Adds a plane wave source to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addplane(struct_data); | Adds a plane wave source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a plane wave source in the simulation environment\r\nthat will propagate in the negative z direction. The script will set the dimension (and\r\nposition) of the source and will define the frequency range.\r\n\r\n```\r\naddplane;\r\nset(\"injection axis\",\"z\");\r\nset(\"direction\",\"backward\");\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",3e-6);\r\nset(\"wavelength start\",0.3e-6);\r\nset(\"wavelength stop\",1.2e-6);\r\n```\r\n\r\n## For DGTD:\r\n\r\nAdds a plane wave source to the 'DGTD' solver in Finite Element IDE. A DGTD solver\r\nregion must be present in the objects tree for this command to work.\r\n\r\n| **Syntax** | **Description**                                                                        |\r\n| ---------- | -------------------------------------------------------------------------------------- |\r\n| addplane;  | Adds a plane wave source to the 'DGTD' solver. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a plane wave source to the 'DGTD' solver already\r\npresent in the objects tree and print the name of all of its properties.\r\n\r\n```\r\naddplane;?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a plane wave source to the 'DGTD' solver, change\r\nits name, and set up its properties. The script then sets the solid named \"2D rectangle\"\r\nas the injection surface.\r\n\r\n```\r\naddplane; \r\nset(\"name\",\"plane_wave\");# set the propagation directionset(\"direction definition\",\"axis\");set(\"direction\",\"backward\");set(\"angle theta\",30);set(\"angle phi\",60);\r\n# set the polarization angleset(\"polarization angle\",90);\r\n# set the injection surfaceset(\"surface type\",\"solid\");set(\"solid\",\"2D rectangle\");\r\n```\r\n\r\n###",
    "summary": "#",
    "syntax": [
      {
        "syntax": "addplane;",
        "description": "Adds a plane wave source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addplane(struct_data);",
        "description": "Adds a plane wave source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addplane;\r\nset(\"injection axis\",\"z\");\r\nset(\"direction\",\"backward\");\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"y span\",5e-6);\r\nset(\"z\",3e-6);\r\nset(\"wavelength start\",0.3e-6);\r\nset(\"wavelength stop\",1.2e-6);"
  },
  {
    "name": "addpmc",
    "description": "Adds a PMC (perfect electrical conductor) boundary condition to the DGTD or FEEM solver in Finite Element IDE. A DGTD or FEEM solver region must be present in the objects tree for this command to work. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addpmc();",
    "category": "general",
    "markdown": "# addpmc\r\n\r\nAdds a PMC (perfect electrical conductor) boundary condition to the DGTD or FEEM solver\r\nin Finite Element IDE. A DGTD or FEEM solver region must be present in the objects tree\r\nfor this command to work. If both solvers are present then the intended solver's name\r\nmust be provided as an argument to the script command.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                       |\r\n| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addpmc;                | Adds a PMC boundary condition to the DGTD or FEEM solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addpmc(\"solver_name\"); | Adds a PMC boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"DGTD\" and \"FEEM\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a PMC boundary condition to the solver already\r\npresent in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddpmc;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a PMC boundary condition to the DGTD solver, name\r\nit, and assign it to the -y and +y boundaries of the simulation region.\r\n\r\n```\r\naddpmc(\"DGTD\"); \r\nset(\"name\",\"PMC_y\");\r\nset(\"surface type\",\"simulation region\");\r\nset(\"y min\",1);\r\nset(\"y max\",1);\r\n```",
    "summary": "Adds a PMC (perfect electrical conductor) boundary condition to the DGTD or FEEM solver in Finite El...",
    "syntax": [
      {
        "syntax": "addpmc;",
        "description": "Adds a PMC boundary condition to the DGTD or FEEM solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addpmc(\"solver_name\");",
        "description": "Adds a PMC boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"DGTD\" and \"FEEM\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addpml",
    "description": "Adds a PML (perfectly matched layer) boundary condition object to the DGTD or FEEM solver in Finite Element IDE. At least, one of these solvers should be present in the Objects Tree for this command to work.",
    "usage": "addpml();",
    "category": "general",
    "markdown": "# addpml\r\n\r\nAdds a PML (perfectly matched layer) boundary condition object to the DGTD or FEEM\r\nsolver in Finite Element IDE. At least, one of these solvers should be present in the\r\nObjects Tree for this command to work.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                              |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addpml;                         | Adds a PML boundary condition to the DGTD or FEEM solver. Use only when there is a single solver in the Object Tree. This function does not return any data. |\r\n| addpml(\"DGTD\"); addpml(\"FEEM\"); | When there are both DGTD and FEEM in the Object Tree, you need to specify the solver.                                                                        |\r\n\r\n**Example 1:**\r\n\r\nThe following script commands will add a PML boundary condition to the 'DGTD' solver\r\nalready present in the object tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddpml;\r\n?set;\r\n```\r\n\r\n## NOTE: When there are both DGTD and FEEM solvers in the Object Tree, running the script without any \"solver\" argument will produce the following error:\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a PML boundary condition to the 'DGTD' solver,\r\nname it, and set the values for sigma and alpha.\r\n\r\n```\r\nadddgtdsolver;\r\naddpml({\"name\":\"simple_pml\", \"sigma\":5});\r\n```\r\n\r\n## NOTE: The PML boundary condition automatically gets applied to the shell regions in the corresponding simulation region.",
    "summary": "Adds a PML (perfectly matched layer) boundary condition object to the DGTD or FEEM solver in Finite ...",
    "syntax": [
      {
        "syntax": "addpml;",
        "description": "Adds a PML boundary condition to the DGTD or FEEM solver. Use only when there is a single solver in the Object Tree. This function does not return any data."
      },
      {
        "syntax": "addpml(\"DGTD\"); addpml(\"FEEM\");",
        "description": "When there are both DGTD and FEEM in the Object Tree, you need to specify the solver."
      }
    ],
    "example": ""
  },
  {
    "name": "addpoly",
    "description": "Adds a polygon primitive to the simulation environment. The polygon object defines a polygon in the XY plane using a set of x, y coordinates (vertices) and then extrudes it in the Z direction to create a 3D geometry.",
    "usage": "addpoly();",
    "category": "general",
    "markdown": "# addpoly\r\n\r\nAdds a polygon primitive to the simulation environment. The polygon object defines a\r\npolygon in the XY plane using a set of x, y coordinates (vertices) and then extrudes it\r\nin the Z direction to create a 3D geometry.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                 |\r\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addpoly;              | Adds a polygon primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addpoly(struct_data); | Adds a polygon primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script creates a 2D matrix to store the vertices of a polygon and uses it\r\nto create a polygon primitive.\r\n\r\n```\r\nvtx = [1,0;2,2;4,2;4,1;3,1]*1e-6;  # microns\r\naddpoly;\r\nset(\"name\",\"random_polygon\");\r\nset(\"vertices\",vtx);\r\nset(\"z span\",2e-6);\r\n```",
    "summary": "Adds a polygon primitive to the simulation environment",
    "syntax": [
      {
        "syntax": "addpoly;",
        "description": "Adds a polygon primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addpoly(struct_data);",
        "description": "Adds a polygon primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "vtx = [1,0;2,2;4,2;4,1;3,1]*1e-6;  # microns\r\naddpoly;\r\nset(\"name\",\"random_polygon\");\r\nset(\"vertices\",vtx);\r\nset(\"z span\",2e-6);"
  },
  {
    "name": "addport",
    "description": "Lumerical command: addport",
    "usage": "addport();",
    "category": "general",
    "markdown": "### addport\n\nLumerical command: addport\n\n**Usage:** `addport();`",
    "summary": "Lumerical command: addport",
    "syntax": [
      {
        "syntax": "addport();",
        "description": "Lumerical command: addport"
      }
    ],
    "example": ""
  },
  {
    "name": "addproperty",
    "description": "The script command adds a property to a compound or to a scripted element.",
    "usage": "addproperty();",
    "category": "general",
    "markdown": "# addproperty\r\n\r\nThe script command adds a property to a compound or to a scripted element.\r\n\r\n| **Syntax**                                                                                                                          | **Description**                                                                             |\r\n| ----------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |\r\n| addproperty(name, property=”new_property”, category=””, type=”Number”, from=0, to=0, kind=”FixedUnit”, unit=””, default_value = \"\") | Adds a new property to a Scripted element or a Compound element with the following options: |\r\n\r\n- name: element name.\r\n- property: property name.\r\n- category: defines the folder when the property will be stored in the properties view\r\n  window.\r\n- type: defines the property type. Can be chosen from \\[\"Number\", \"String\", \"Logical\",\r\n  \"Matrix\", \"ComboChoice\", \"FileSave\", \"FileOpen\"\\], please refer to the details below.\r\n- from, to: defines the range for a \"Number\" type of property.\r\n- kind: defines the property kind. Can be chosen from \\[\"Angle\", \"Area\", \"Bandwidth\",\r\n  \"Bitrate\", \"Capacitance\", \"Current\", \"Density\", \"Dimensionless\", \"Dispersion\",\r\n  \"DispersionSlope\", \"Distance\", \"DopingDensity\", \"Energy\", \"EngineeringScale\",\r\n  \"FixedUnit\", \"Frequency\", \"Gain\", \"GainCoefficient\", \"Inductance\", \"InverseDistance\",\r\n  \"InverseVolume\", \"Loss\", \"LossCoefficient\", \"ModeDispersion\", \"NonQuantity\", \"Power\",\r\n  \"PowerSpectralDensity\", \"Resistance\", \"Temperature\", \"Time\", \"Velocity\", \"Voltage\",\r\n  \"Volume\", \"WaveguideLoss\"\\]; for the unit of all the kinds, please refer to the\r\n  details below.\r\n- unit: defines the unit of the property.\r\n- default_value: defines the default value of the property. Can be a matrix or a string.\r\n  If no default value is provided, the minimum range value will be used to initialize\r\n  the property.\r\n\r\ntype:\r\n\r\n- Number, String, Logical\r\n- Matrix: Syntax for property value [a11, a12, a13; a21 ,a22, a23]\r\n- ComboChoice: Creates a property with options to choose from. Syntax for property\r\n  value: 'choice_1;choice_2:choice_3'\r\n- FileSave: Allows a user to save a file. Syntax for property value: string with file\r\n  path.\r\n- FileOpen: Allows a user to open a file. Syntax for property value: string with file\r\n  path.\r\n\r\nkind:\r\n\r\n- Frequency, Distance, Loss, etc: 'Unit' options are updated accordingly.\r\n- FixedUnit: 'Unit' can be chosen from pre-defined units or can be user defined.\r\n- NonQuantity: 'Unit' is blank (unitless). Recommended for all types expect \"Number\".\r\n\r\n**Example**\r\n\r\nAdd property “new_property” to an existing compound element ‘COMPOUND_1’\r\n\r\n```\r\naddproperty(\"COMPOUND_1\");\r\n```\r\n\r\nAdd property “width” to an existing compound element ‘COMPOUND_1’\r\n\r\n```\r\naddproperty(\"COMPOUND_1\",\"width\");\r\n```\r\n\r\nAdd property “gain” to an existing compound element ‘COMPOUND_1’, place it on category\r\n‘Standard’\r\n\r\n```\r\naddproperty(\"COMPOUND_1\",\"gain\",\"Standard\");\r\n```\r\n\r\nAdd “temperature” property to an existing compound element ‘COMPOUND_1’, place it on\r\n‘Thermal’ category, set its type, range and unit.\r\n\r\n```\r\naddproperty(\"COMPOUND_1\",\"temperature\",\"Thermal\",\"Number\",0,100,\"Temperature\",\"C\");\r\n```",
    "summary": "The script command adds a property to a compound or to a scripted element",
    "syntax": [
      {
        "syntax": "addproperty(name, property=”new_property”, category=””, type=”Number”, from=0, to=0, kind=”FixedUnit”, unit=””, default_value = \"\")",
        "description": "Adds a new property to a Scripted element or a Compound element with the following options:"
      }
    ],
    "example": "addproperty(\"COMPOUND_1\");"
  },
  {
    "name": "addpyramid",
    "description": "Adds a [pyramid](https://optics.ansys.com/hc/en-us/articles/360034382254) primitive to the simulation environment.",
    "usage": "addpyramid();",
    "category": "general",
    "markdown": "# addpyramid\r\n\r\nAdds a [pyramid](https://optics.ansys.com/hc/en-us/articles/360034382254) primitive to\r\nthe simulation environment.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                                                 |\r\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addpyramid;              | Adds a pyramid primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addpyramid(struct_data); | Adds a pyramid primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a pyramid object to the simulation environment\r\nand sets its dimension:\r\n\r\n```\r\naddpyramid;\r\nset(\"name\",\"my_pyramid\");\r\nset(\"x span bottom\",5e-6);\r\nset(\"x span top\",3e-6);\r\nset(\"y span bottom\",4e-6);\r\nset(\"y span top\",3e-6);\r\nset(\"z span\",1e-6);\r\nset(\"material\",\"Si (Silicon) - Palik\");\r\n```\r\n\r\nFor a list of the editable properties of the added pyramid object, please see\r\n[Pyramid - Simulation Object](https://optics.ansys.com/hc/en-us/articles/360034382254).",
    "summary": "Adds a [pyramid](https://optics",
    "syntax": [
      {
        "syntax": "addpyramid;",
        "description": "Adds a pyramid primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addpyramid(struct_data);",
        "description": "Adds a pyramid primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addpyramid;\r\nset(\"name\",\"my_pyramid\");\r\nset(\"x span bottom\",5e-6);\r\nset(\"x span top\",3e-6);\r\nset(\"y span bottom\",4e-6);\r\nset(\"y span top\",3e-6);\r\nset(\"z span\",1e-6);\r\nset(\"material\",\"Si (Silicon) - Palik\");"
  },
  {
    "name": "addradiationbc",
    "description": "Adds a new radiation boundary condition to the HEAT or CHARGE solver \\[ [ Boundary Conditions (Thermal Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-) \\]. A HEAT or CHARGE solver region must be present in the objects tree before this boundary condition can be added. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addradiationbc();",
    "category": "general",
    "markdown": "# addradiationbc\r\n\r\nAdds a new radiation boundary condition to the HEAT or CHARGE solver \\[\r\n[ Boundary Conditions (Thermal Simulation) ](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\r\n\\]. A HEAT or CHARGE solver region must be present in the objects tree before this\r\nboundary condition can be added. If both solvers are present then the intended solver's\r\nname must be provided as an argument to the script command.\r\n\r\nThe radiation boundary condition can only be added to the CHARGE solver when the\r\nsolver's temperature dependency is set to 'coupled'.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                                               |\r\n| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addradiationbc;                | Adds a radiation boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addradiationbc(\"solver_name\"); | Adds a radiation boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a radiation boundary condition to the solver\r\nalready present in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddradiationbc;\r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a radiation boundary condition to the HEAT solver\r\nalready present in the objects tree. The boundary condition is then assigned to the\r\ninterface (surfaces) between silicon and air. The ambient temperature is set to 300 K\r\nand the emissivity is set to 0.9.\r\n\r\n```\r\naddradiationbc(\"HEAT\");\r\nset(\"name\",\"radiation_air\");\r\nset(\"ambient temperature\",300);\r\nset(\"emissivity\",0.9);\r\nset(\"surface type\",\"material:material\");\r\nset(\"material 1\",\"Si (Silicon)\");\r\nset(\"material 2\",\"Air\");\r\n```\r\n\r\n## NOTE: The 'materials' folder in the objects tree must already contain the materials used in the script commands to set up the boundary condition.\r\n\r\n**Example 3**\r\n\r\nThe following script commands will add a radiation boundary condition to the HEAT solver\r\nalready present in the objects tree. The boundary condition is assigned to the top (+z)\r\nsurface of the simulation region. The ambient temperature is set to 300 K and the\r\nemissivity is set to 0.9.\r\n\r\n```\r\naddradiationbc(\"HEAT\");\r\nset(\"name\",\"radiation_top\");\r\nset(\"ambient temperature\",300);\r\nset(\"emissivity\",0.9);\r\nset(\"surface type\",\"simulation region\");\r\nset(\"z max\",1);\r\n```",
    "summary": "Adds a new radiation boundary condition to the HEAT or CHARGE solver \\[ [ Boundary Conditions (Therm...",
    "syntax": [
      {
        "syntax": "addradiationbc;",
        "description": "Adds a radiation boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addradiationbc(\"solver_name\");",
        "description": "Adds a radiation boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addrect",
    "description": "Adds a rectangle primitive to the simulation environment.",
    "usage": "addrect();",
    "category": "general",
    "markdown": "# addrect\r\n\r\nAdds a rectangle primitive to the simulation environment.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                   |\r\n| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addrect;              | Adds a rectangle primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addrect(struct_data); | Adds a rectangle primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script creates a rectangle primitive, sets its dimension, and assigns a\r\nmaterial to it.\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"new_rectangle\");\r\nset(\"x\",1e-6);\r\nset(\"x span\",2e-6);\r\nset(\"y\",1e-6);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nset(\"material\",\"Si (Silicon) - Palik\");\r\n```",
    "summary": "Adds a rectangle primitive to the simulation environment",
    "syntax": [
      {
        "syntax": "addrect;",
        "description": "Adds a rectangle primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addrect(struct_data);",
        "description": "Adds a rectangle primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"new_rectangle\");\r\nset(\"x\",1e-6);\r\nset(\"x span\",2e-6);\r\nset(\"y\",1e-6);\r\nset(\"y span\",5e-6);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nset(\"material\",\"Si (Silicon) - Palik\");"
  },
  {
    "name": "addresource",
    "description": "Adds a resource to the list of available resources in resource manager.",
    "usage": "addresource();",
    "category": "general",
    "markdown": "# addresource\r\n\r\nAdds a resource to the list of available resources in resource manager.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                                                                                                               |\r\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addresource(\"solver\"); | Adds a resource to the list of available resources in resource manager. The \"solver\" argument is used to select the solver to add the resource to. The \"solver\" argument is not supported by INTERCONNECT. It also returns the resource number as an integer. |\r\n\r\n**Example**\r\n\r\nThe following line will add a resource to the DGTD solver in Finite Element IDE.\r\n\r\n```\r\naddresource(\"DGTD\");  \r\n```",
    "summary": "Adds a resource to the list of available resources in resource manager",
    "syntax": [
      {
        "syntax": "addresource(\"solver\");",
        "description": "Adds a resource to the list of available resources in resource manager. The \"solver\" argument is used to select the solver to add the resource to. The \"solver\" argument is not supported by INTERCONNECT. It also returns the resource number as an integer."
      }
    ],
    "example": "addresource(\"DGTD\");"
  },
  {
    "name": "addring",
    "description": "Adds a ring primitive to the simulation environment.",
    "usage": "addring();",
    "category": "general",
    "markdown": "# addring\r\n\r\nAdds a ring primitive to the simulation environment.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                              |\r\n| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addring;              | Adds a ring primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addring(struct_data); | Adds a ring primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will create a half-ring named \"new_ring\" with an inner\r\nradius of 5 um and an outer radius of 7 um centered at (x,y,z) = (1, 2, 0) microns. The\r\nring will have a thickness (z span) of 10 microns.\r\n\r\n```\r\naddring;  \r\nset(\"name\",\"new_ring\");  \r\nset(\"x\",1e-6);  \r\nset(\"y\",2e-6);  \r\nset(\"inner radius\",5e-6);  \r\nset(\"outer radius\",7e-6);  \r\nset(\"z\",0);  \r\nset(\"z span\",10e-6);  \r\nset(\"theta start\",0);  \r\nset(\"theta stop\",180);\r\n```",
    "summary": "Adds a ring primitive to the simulation environment",
    "syntax": [
      {
        "syntax": "addring;",
        "description": "Adds a ring primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addring(struct_data);",
        "description": "Adds a ring primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addring;  \r\nset(\"name\",\"new_ring\");  \r\nset(\"x\",1e-6);  \r\nset(\"y\",2e-6);  \r\nset(\"inner radius\",5e-6);  \r\nset(\"outer radius\",7e-6);  \r\nset(\"z\",0);  \r\nset(\"z span\",10e-6);  \r\nset(\"theta start\",0);  \r\nset(\"theta stop\",180);"
  },
  {
    "name": "addsemiconductorfromalloy",
    "description": "Converts an Alloy material to a Semiconductor material at a fixed mole fraction and adds its electrothermal material properties to the selected material model in the object tree.",
    "usage": "addsemiconductorfromalloy();",
    "category": "general",
    "markdown": "# addsemiconductorfromalloy\r\n\r\nConverts an Alloy material to a Semiconductor material at a fixed mole fraction and adds\r\nits electrothermal material properties to the selected material model in the object\r\ntree.\r\n\r\nThe alloy material parameters are obtained from the electrothermal material database,\r\nand the conversion is done by interpolating material properties from base materials at a\r\ngiven alloy mole fraction.\r\n\r\nTo use this command, first add an empty material model with\r\n[addmaterialmodel](https://optics.ansys.com/hc/en-us/articles/360034404974-addmodelmaterial-Script-command).\r\n\r\nFor further details of electrothermal material models, see\r\n[Electrical/Thermal Material Models](https://optics.ansys.com/hc/en-us/articles/360034919093-Electrical-Thermal-material-models-in-CHARGE-HEAT-and-MQW)\r\nand the page about\r\n[Semiconductors](https://optics.ansys.com/hc/en-us/articles/360034919113-Semiconductor-Material-Model-Properties).\r\nFor further information on alloy materials, see the Knowledge Base page about\r\n[Alloy Material Model Properties](https://optics.ansys.com/hc/en-us/articles/360034398494-Alloy-material-model-properties).\r\n\r\n| **Syntax**                          | **Description**                                                                                                                                                  |\r\n| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addsemiconductorfromalloy (name,x); | Converts a Ternary Alloy material to a Semiconductor material and adds its electrothermal material properties to the selected material model in the object tree: |\r\n\r\n- name: A ternary alloy material name in the electrothermal material database.\r\n- x: Alloy mole fraction.\r\n\r\nThis function does not return any data.\\\r\naddsemiconductorfromalloy (name,x,y); | This syntax is identical to above, but for a\r\nquaternary alloy. Converts a Quaternary Alloy material to a Semiconductor material and\r\nadds its electrothermal material properties to the selected material model in the object\r\ntree:\r\n\r\n- name: A quaternary alloy material name in the electrothermal material database.\r\n- x,y: Alloy mole fractions.\r\n\r\nThis function does not return any data.\r\n\r\n**Example**\r\n\r\n```\r\n#Add a ternary alloy to the simulation as Semiconductor material type  \r\naddmodelmaterial;  \r\n  \r\nset(\"name\",\"AlGaAs\");  \r\nx = 0.2; #The alloy composition is Al(x)Ga(1-x)As per convention in the database  \r\n  \r\naddsemiconductorfromalloy(\"AlGaAs (Aluminium Gallium Arsenide)\",x);  \r\n  \r\n#Add quaternary alloy to the simulation as Semiconductor material type  \r\naddmodelmaterial;  \r\n  \r\nset(\"name\",\"AlGaInAs\");  \r\nx = 0.1; #Al(x)Ga(y)In(1-x-y)As  \r\ny = 0.2;  \r\naddsemiconductorfromalloy(\"AlGaInAs\",x,y);\r\n```\r\n",
    "summary": "Converts an Alloy material to a Semiconductor material at a fixed mole fraction and adds its electro...",
    "syntax": [
      {
        "syntax": "addsemiconductorfromalloy (name,x);",
        "description": "Converts a Ternary Alloy material to a Semiconductor material and adds its electrothermal material properties to the selected material model in the object tree:"
      }
    ],
    "example": "#Add a ternary alloy to the simulation as Semiconductor material type  \r\naddmodelmaterial;  \r\n  \r\nset(\"name\",\"AlGaAs\");  \r\nx = 0.2; #The alloy composition is Al(x)Ga(1-x)As per convention in the database  \r\n  \r\naddsemiconductorfromalloy(\"AlGaAs (Aluminium Gallium Arsenide)\",x);  \r\n  \r\n#Add quaternary alloy to the simulation as Semiconductor material type  \r\naddmodelmaterial;  \r\n  \r\nset(\"name\",\"AlGaInAs\");  \r\nx = 0.1; #Al(x)Ga(y)In(1-x-y)As  \r\ny = 0.2;  \r\naddsemiconductorfromalloy(\"AlGaInAs\",x,y);"
  },
  {
    "name": "addsimulationregion",
    "description": "Adds a simulation region to the Finite Element IDE design environment. Once created the simulation region can be linked to any existing solver.",
    "usage": "addsimulationregion();",
    "category": "general",
    "markdown": "# addsimulationregion\r\n\r\nAdds a simulation region to the Finite Element IDE design environment. Once created the\r\nsimulation region can be linked to any existing solver.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                                                                                                                                                 |\r\n| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addsimulationregion;              | Adds a simulation region to the Finite Element IDE design environment. This function does not return any data.                                                                                                                                                                  |\r\n| addsimulationregion(struct_data); | Adds a simulation region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 2D y-normal simulation region, rename it, set\r\nits dimension, and assign it to the CHARGE solver (assuming that it already exists in\r\nthe objects tree).\r\n\r\n```\r\naddsimulationregion;\r\nset(\"name\",\"CHARGE simulation region\");\r\nset(\"dimension\",2);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nsetnamed(\"CHARGE\",\"simulation region\",\"CHARGE simulation region\");\r\n```",
    "summary": "Adds a simulation region to the Finite Element IDE design environment",
    "syntax": [
      {
        "syntax": "addsimulationregion;",
        "description": "Adds a simulation region to the Finite Element IDE design environment. This function does not return any data."
      },
      {
        "syntax": "addsimulationregion(struct_data);",
        "description": "Adds a simulation region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addsimulationregion;\r\nset(\"name\",\"CHARGE simulation region\");\r\nset(\"dimension\",2);  # 2D y-normal\r\nset(\"x\",0);\r\nset(\"x span\",2e-6);\r\nset(\"y\",0);\r\nset(\"z\",0);\r\nset(\"z span\",10e-6);\r\nsetnamed(\"CHARGE\",\"simulation region\",\"CHARGE simulation region\");"
  },
  {
    "name": "addsphere",
    "description": "Adds a sphere primitive to the simulation environment.",
    "usage": "addsphere();",
    "category": "general",
    "markdown": "# addsphere\r\n\r\nAdds a sphere primitive to the simulation environment.\r\n\r\n| **Syntax**              | **Description**                                                                                                                                                                                                                                                                |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addsphere;              | Adds a sphere primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addsphere(struct_data); | Adds a sphere primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will create a sphere with a radius of 5 um centered at\r\n(x,y,z) = (1, 2, 0) microns.\r\n\r\n```\r\naddsphere;\r\nset(\"name\",\"new_sphere\");\r\nset(\"x\",1e-6);\r\nset(\"y\",2e-6);\r\nset(\"z\",0);\r\nset(\"radius\",5e-6);\r\n```",
    "summary": "Adds a sphere primitive to the simulation environment",
    "syntax": [
      {
        "syntax": "addsphere;",
        "description": "Adds a sphere primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addsphere(struct_data);",
        "description": "Adds a sphere primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addsphere;\r\nset(\"name\",\"new_sphere\");\r\nset(\"x\",1e-6);\r\nset(\"y\",2e-6);\r\nset(\"z\",0);\r\nset(\"radius\",5e-6);"
  },
  {
    "name": "addstructuregroup",
    "description": "Adds a structure group to the simulation environment. Structure groups are very convenient when you want to parametrize your design. You can define different parameters for the structure group and use the \"setup\" script to create your geometry (along with monitors and/or sources) according to those parameter values.",
    "usage": "addstructuregroup();",
    "category": "general",
    "markdown": "# addstructuregroup\r\n\r\nAdds a structure group to the simulation environment. Structure groups are very\r\nconvenient when you want to parametrize your design. You can define different parameters\r\nfor the structure group and use the \"setup\" script to create your geometry (along with\r\nmonitors and/or sources) according to those parameter values.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                                                                                                                                               |\r\n| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addstructuregroup;              | Adds a structure group to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addstructuregroup(struct_data); | Adds a structure group and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nAdd a structure group and put a rectangle in it.\r\n\r\n```\r\naddstructuregroup;\r\nset(\"name\",\"group\");\r\naddrect;\r\naddtogroup(\"group\");\r\n```\r\n\r\nCreate a structure group. Add a user property named \"radius\" and set up the script in\r\nthe structure group to add two circles to the group and set their radius to the value of\r\nthe user property \"radius\".\r\n\r\n```\r\naddstructuregroup;\r\nadduserprop(\"radius\",2,0.5e-6);\r\nmyscript =      \"addcircle; \\n\";\r\nmyscript = myscript + \"copy(1e-6); \\n\";\r\nmyscript = myscript + \"selectall; \\n\";\r\nmyscript = myscript + \"set(\\\"radius\\\",radius);\";\r\nset(\"name\",\"dimer\");\r\nset(\"script\",myscript); \r\n```\r\n\r\nNOTE: The \"myscript\" string in the script above uses the escape character \\\\n for new\r\nline and \" for double quotes within the string.",
    "summary": "Adds a structure group to the simulation environment",
    "syntax": [
      {
        "syntax": "addstructuregroup;",
        "description": "Adds a structure group to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addstructuregroup(struct_data);",
        "description": "Adds a structure group and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addstructuregroup;\r\nset(\"name\",\"group\");\r\naddrect;\r\naddtogroup(\"group\");"
  },
  {
    "name": "addsurface",
    "description": "Adds a surface primitive to the simulation environment.",
    "usage": "addsurface();",
    "category": "general",
    "markdown": "# addsurface\r\n\r\nAdds a surface primitive to the simulation environment.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                                                 |\r\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addsurface;              | Adds a surface primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addsurface(struct_data); | Adds a surface primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nGo to this KB page (\r\n[ Structure - Surface ](https://optics.ansys.com/hc/en-us/articles/360034901533-Structures-Surface-Optical-)\r\n) for more details on the surface primitive and its different properties.",
    "summary": "Adds a surface primitive to the simulation environment",
    "syntax": [
      {
        "syntax": "addsurface;",
        "description": "Adds a surface primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addsurface(struct_data);",
        "description": "Adds a surface primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addsurfacerecombinationbc",
    "description": "Adds a new surface recombination boundary condition to the CHARGE solver \\[[Boundary Conditions (Electrical Simulation)](https://optics.ansys.com/hc/en-us/articles/360034918833-Boundary-Conditions-Electrical-Simulation-)\\]. A CHARGE solver region must be present in the objects tree before a surface recombination boundary condition can be added.",
    "usage": "addsurfacerecombinationbc();",
    "category": "general",
    "markdown": "# addsurfacerecombinationbc\r\n\r\nAdds a new surface recombination boundary condition to the CHARGE solver\r\n\\[[Boundary Conditions (Electrical Simulation)](https://optics.ansys.com/hc/en-us/articles/360034918833-Boundary-Conditions-Electrical-Simulation-)\\].\r\nA CHARGE solver region must be present in the objects tree before a surface\r\nrecombination boundary condition can be added.\r\n\r\n| **Syntax**                 | **Description**                                                                                                   |\r\n| -------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| addsurfacerecombinationbc; | Adds a new surface recombination boundary condition to the CHARGE solver. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a surface recombination boundary condition to the\r\nCHARGE solver (already present in the objects tree) and print all available properties\r\nof the boundary condition.\r\n\r\n```\r\naddsurfacerecombinationbc;  \r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a surface recombination boundary condition to the\r\nexisting CHARGE solver and assign it to the interface (surfaces) between silicon and\r\nsilicon dioxide. It will set the surface recombination velocity of electrons and holes\r\nto 100 cm/sec.\r\n\r\n```\r\naddsurfacerecombinationbc;  \r\n\r\nset(\"name\",\"Si_SiO2\");  \r\nset(\"surface type\",\"material:material\");  \r\nset(\"material 1\",\"Si (Silicon)\");  \r\nset(\"material 2\",\"SiO2 (Glass) - Sze\");  \r\nset(\"electron velocity\",100e-2);   # m/sec  \r\nset(\"hole velocity\",100e-2);   # m/sec  \r\nset(\"apply to majority carriers\",1);\r\n```\r\n\r\nThe \"apply to majority carriers\" option should be enabled when modeling surface\r\nrecombination at semiconductor-oxide or semiconductor-semiconductor interfaces.\r\n\r\n## NOTE: The 'materials' folder in the objects tree must already contain the materials used in the script commands to set up the boundary condition.\r\n\r\n**Example 3**\r\n\r\nThe following script commands will add a surface recombination boundary condition to the\r\ninterface (surfaces) between silicon and aluminum. It will set the surface recombination\r\nvelocity of electrons and holes to 1e7 cm/sec.\r\n\r\n```\r\naddsurfacerecombinationbc;  \r\n\r\nset(\"name\",\"Si_Al\");  \r\nset(\"surface type\",\"material:material\");  \r\nset(\"material 1\",\"Si (Silicon)\");  \r\nset(\"material 2\",\"Al (Aluminium) - CRC\");  \r\nset(\"electron velocity\",1e5);   # m/sec  \r\nset(\"hole velocity\",1e5);   # m/sec  \r\nset(\"apply to majority carriers\",0);\r\n```\r\n\r\nThe \"apply to majority carriers\" option should be disabled when modeling surface\r\nrecombination at semiconductor-metal interfaces.",
    "summary": "Adds a new surface recombination boundary condition to the CHARGE solver \\[[Boundary Conditions (Ele...",
    "syntax": [
      {
        "syntax": "addsurfacerecombinationbc;",
        "description": "Adds a new surface recombination boundary condition to the CHARGE solver. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addsweep",
    "description": "Adds a parameter sweep/optimization/Monte Carlo/S-parameter sweep item as the top-most analysis item.",
    "usage": "addsweep();",
    "category": "general",
    "markdown": "# addsweep\r\n\r\nAdds a parameter sweep/optimization/Monte Carlo/S-parameter sweep item as the top-most\r\nanalysis item.\r\n\r\n| **Syntax**      | **Description**                                                                                                                                                                                                                                                                                                                                                                                      |\r\n| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addsweep(type); | adds a parameter sweep/optimization/Monte Carlo/S-parameter sweep item as the top-most analysis item. 'type' = 0 for parameter sweep 'type' = 1 for optimization 'type' = 2 for Monte Carlo analysis 'type' = 3 for S-parameter matrix sweep in FDTD and MODE solver 'type' = 4 for Corner sweep analysis in INTERCONNECT If type is not provided, by default type 0 will be applied to add a sweep. |\r\n\r\n**Example**\r\n\r\nType = 0, for adding a **parameter sweep** analysis:\r\n\r\n```\r\naddsweep(0);\r\n?setsweep(\"sweep\");\r\n> Result:\r\nname\r\ntype  \r\nsolver\r\nnumber of points\r\nresave files after analysis\r\n```\r\n\r\nType = 1, for adding an **optimization** analysis:\r\n\r\n```\r\naddsweep(1);\r\n?setsweep(\"optimization\");\r\n> Result:\r\nname  \r\nalgorithm  \r\nmaximum generations  \r\nreset random generator  \r\ntype  \r\ngeneration size  \r\ntolerance  \r\nfirst generation script  \r\nnext generation script  \r\nuse figure of merit script  \r\nfigure of merit script\r\n```\r\n\r\nType = 2, for adding a **Monte Carlo** analysis:\r\n\r\n```\r\naddsweep(2);  \r\n?setsweep(\"Monte Carlo analysis\");\r\n> Result:\r\nname  \r\nnumber of trials  \r\nvariation  \r\nseed  \r\nenable seed  \r\nindividual trial  \r\nenable individual trial  \r\nenable spatial correlations\r\n```\r\n\r\nType = 3, for adding an **S-parameter sweep** analysis in FDTD:\r\n\r\n```\r\naddsweep(3);  \r\n?setsweep(\"s-parameter sweep\");\r\n> Result:\r\nname  \r\nexcite all ports  \r\ncalculate group delay  \r\ninvert sign  \r\nmap from  \r\nactive  \r\nport  \r\nmode  \r\nmap vector  \r\nauto symmetry  \r\nexport setup\r\n```\r\n\r\nType = 3, for adding an **S-parameter sweep** analysis in MODE:\r\n\r\n```\r\naddsweep(3);  \r\n?setsweep(\"s-parameter sweep\");\r\n> Result:\r\nname  \r\nnumber of points  \r\ncalculate group delay  \r\ngroup delay wavelength  \r\nparameter label  \r\nstart wavelength  \r\nstop wavelength  \r\ninclude group delay\r\n```\r\n\r\nType = 4, for adding a **Corner sweep** analysis in INTERCONNECT:\r\n\r\n```\r\naddsweep(4);  \r\n?getsweep(\"Corner sweep\");  \r\n> Result:  \r\nname  \r\nresave files after analysis\r\n```",
    "summary": "Adds a parameter sweep/optimization/Monte Carlo/S-parameter sweep item as the top-most analysis item",
    "syntax": [
      {
        "syntax": "addsweep(type);",
        "description": "adds a parameter sweep/optimization/Monte Carlo/S-parameter sweep item as the top-most analysis item. 'type' = 0 for parameter sweep 'type' = 1 for optimization 'type' = 2 for Monte Carlo analysis 'type' = 3 for S-parameter matrix sweep in FDTD and MODE solver 'type' = 4 for Corner sweep analysis in INTERCONNECT If type is not provided, by default type 0 will be applied to add a sweep."
      }
    ],
    "example": "addsweep(0);\r\n?setsweep(\"sweep\");\r\n> Result:\r\nname\r\ntype  \r\nsolver\r\nnumber of points\r\nresave files after analysis"
  },
  {
    "name": "addsweepparameter",
    "description": "Adds a parameter to a parameter sweep/optimization/Monte Carlo/S-parameter sweep item.",
    "usage": "addsweepparameter();",
    "category": "general",
    "markdown": "# addsweepparameter\r\n\r\nAdds a parameter to a parameter sweep/optimization/Monte Carlo/S-parameter sweep item.\r\n\r\n| **Syntax**                              | **Description**                                                                                                                                                                                                                                                                                                                                          |\r\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addsweepparameter(\"name\", \"parameter\"); | Adds a parameter to a parameter sweep/optimization/Monte Carlo/S-parameter sweep item. \"name\" is the absolute name of an analysis item. \"parameter\" could be a string (i.e. create a parameter with default values. eg. ::model::rectangle::index) or a struct which counld contain parameter, type, start, stop, unit, etc. Returns the parameter name. |\r\n\r\n**Example**\r\n\r\nThis example shows how to add a parameter to an existing optimization. This piece of\r\nscript command is taken from the example file sweep_AR_coating_example_script.lsf in the\r\nexample page\r\n[ Optimization scripting commands ](https://optics.ansys.com/hc/en-us/articles/360034922973-Optimization-scripting-commands)\r\n.\r\n\r\n```\r\n# add a sweep\r\naddsweep(0);\r\nsetsweep(\"sweep\", \"name\", \"thickness_sweep_script\");\r\nsetsweep(\"thickness_sweep_script\", \"type\", \"Ranges\");\r\nsetsweep(\"thickness_sweep_script\", \"number of points\", 10); \r\n# define the parameter thickness\r\npara = struct;\r\npara.Name = \"thickness\";\r\npara.Parameter = \"::model::AR structure::thickness\";\r\npara.Type = \"Length\";\r\npara.Start = 0.05e-6;\r\npara.Stop = 0.15e-6;\r\npara.Units = \"microns\";\r\n# add the parameter thickness to the sweep\r\naddsweepparameter(\"thickness_sweep_script\", para);\r\n```\r\n\r\nThis example shows how to add a parameter sweep which sweeps 5 values of a thickness\r\nparameter.\r\n\r\n```\r\naddsweep(0);setsweep(\"sweep\",\"name\",\"thickness_sweep\");\r\nsetsweep(\"thickness_sweep\",\"type\",\"Values\");\r\nsetsweep(\"thickness_sweep\",\"number of points\",5);\r\n# define the parameter thickness\r\npara = struct;\r\npara.Parameter = \"::model::AR structure::thickness\";\r\npara.Type = \"Length\";\r\npara.Value_1 = 0.05e-6;\r\npara.Value_2 = 0.07e-6;\r\npara.Value_3 = 0.09e-6;\r\npara.Value_4 = 0.11e-6;\r\npara.Value_5 = 0.15e-6;\r\n# add the parameter thickness to the sweep\r\naddsweepparameter(\"thickness_sweep\", para);\r\n```\r\n\r\nThis example shows how to add an S-parameter sweep and set up the rows of the S-matrix\r\nmapping table manually. This script can be used with the example in\r\n[ S-parameter matrix sweep ](https://optics.ansys.com/hc/en-us/articles/360034403214-S-parameter-matrix-sweep)\r\nand it generates the same table without using the \"auto symmetry\" option for mapping\r\nbetween rows. This manual mapping is not necessary in this case because the \"auto\r\nsymmetry\" tool will configure the table correctly with minimal effort (compare the\r\nscript below with the one under \"Scripted setup and analysis\" in\r\n[ S-parameter matrix sweep ](https://optics.ansys.com/hc/en-us/articles/360034403214-S-parameter-matrix-sweep)\r\n). Therefore, the manual setup shown here should only be used in particular cases where\r\nthe \"auto symmetry\" tool does not apply the correct mapping.\r\n\r\n```\r\n##ADD SWEEP##deletesweep(\"s-parameter sweep\"); # if a sweep task named s-parameter sweep already exists, remove it\r\naddsweep(3); # add s-parameter sweep task\r\n##SWEEP SETUP##\r\nsetsweep(\"s-parameter sweep\", \"Excite all ports\", 0); # un-check \"Excite all ports\" to define active ports manually\r\n#    Define index entries for s-matrix mapping table as a struct with fields:\r\n#    Port, Mode : Define the port and mode numbers.\r\n#    Active (0 or 1): When a entry is defined as active, a simulation will be run with the source set to the corresponding port and mode combination.\r\n#    Map from: For non-active entries this defines the entry from where the mapping is done.\r\n#    Invert sign (0 or 1): This is only used in cases where additional inversion of the modal fields is required.  \r\n#    Map vector: Array with the permutation of the output indices for the input index given by \"Map from\".   \r\n# Active entries:\r\nindex1 = struct; # Corresponds to S11,S21,...,S61\r\nindex1.Port = \"port 1\";\r\nindex1.Mode = \"mode 1\";\r\nindex1.Active = 1;\r\nindex2 = struct; # Corresponds to S12,S22,...,S62\r\nindex2.Port = \"port 1\";\r\nindex2.Mode = \"mode 2\";\r\nindex2.Active = 1;\r\nindex3 = struct; # Corresponds to S13,S23,...,S63\r\nindex3.Port = \"port 2\";\r\nindex3.Mode = \"mode 1\";\r\nindex3.Active = 1;\r\nindex4 = struct; # Corresponds to S14,S24,...,S64\r\nindex4.Port = \"port 2\";\r\nindex4.Mode = \"mode 2\";\r\nindex4.Active = 1;\r\n# Mapped entries:\r\nindex5 = struct; # Corresponds to S15,S25,...,S65\r\nindex5.Port = \"port 3\";\r\nindex5.Mode = \"mode 1\";\r\nindex5.Active = 0;\r\nindex5.%Map from% = 3;\r\nindex5.%Invert sign% = 0;\r\nindex5.%Map vector% = [1,2,5,6,3,4]; # S15=S13, S25=S23, S35=S53, S45=S63, S55=S33, S65=S43 \r\nindex6 = struct; # Corresponds to S16,S26,...,S66\r\nindex6.Port = \"port 3\";\r\nindex6.Mode = \"mode 2\";\r\nindex6.Active = 0;\r\nindex6.%Map from% = 4;\r\nindex6.%Invert sign% = 0;\r\nindex6.%Map vector% = [1,2,5,6,3,4]; # S16=S14, S26=S24, S36=S54, S46=S64, S56=S34, S66=S44 \r\n######\r\n# Add index entries to s-matrix mapping table\r\naddsweepparameter(\"s-parameter sweep\",index1);\r\naddsweepparameter(\"s-parameter sweep\",index2);\r\naddsweepparameter(\"s-parameter sweep\",index3);\r\naddsweepparameter(\"s-parameter sweep\",index4);\r\naddsweepparameter(\"s-parameter sweep\",index5);\r\naddsweepparameter(\"s-parameter sweep\",index6);\r\n```",
    "summary": "Adds a parameter to a parameter sweep/optimization/Monte Carlo/S-parameter sweep item",
    "syntax": [
      {
        "syntax": "addsweepparameter(\"name\", \"parameter\");",
        "description": "Adds a parameter to a parameter sweep/optimization/Monte Carlo/S-parameter sweep item. \"name\" is the absolute name of an analysis item. \"parameter\" could be a string (i.e. create a parameter with default values. eg. ::model::rectangle::index) or a struct which counld contain parameter, type, start, stop, unit, etc. Returns the parameter name."
      }
    ],
    "example": "# add a sweep\r\naddsweep(0);\r\nsetsweep(\"sweep\", \"name\", \"thickness_sweep_script\");\r\nsetsweep(\"thickness_sweep_script\", \"type\", \"Ranges\");\r\nsetsweep(\"thickness_sweep_script\", \"number of points\", 10); \r\n# define the parameter thickness\r\npara = struct;\r\npara.Name = \"thickness\";\r\npara.Parameter = \"::model::AR structure::thickness\";\r\npara.Type = \"Length\";\r\npara.Start = 0.05e-6;\r\npara.Stop = 0.15e-6;\r\npara.Units = \"microns\";\r\n# add the parameter thickness to the sweep\r\naddsweepparameter(\"thickness_sweep_script\", para);"
  },
  {
    "name": "addsweepresult",
    "description": "Adds a result to a sweep/optimization/Monte Carlo item.",
    "usage": "addsweepresult();",
    "category": "general",
    "markdown": "# addsweepresult\r\n\r\nAdds a result to a sweep/optimization/Monte Carlo item.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                                                                                                                                 |\r\n| --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addsweepresult(\"name\", \"result\"); | Adds a result to a sweep/optimization/Monte Carlo item. \"name\" is the absolute name of an analysis item. \"result\" could be a string (i.e. create a result with default values) or a struct which could contain results and operations. Returns the result name. |\r\n\r\n**Example**\r\n\r\nThis example shows how to add a result to an existing optimization. This piece of script\r\ncommand is taken from the example file sweep_AR_coating_example_script.lsf in the\r\nexample page\r\n[ Optimization scripting commands ](https://optics.ansys.com/hc/en-us/articles/360034922973-Optimization-scripting-commands)\r\n.\r\n\r\n```\r\n# add a sweep\r\naddsweep(0);\r\nsetsweep(\"sweep\", \"name\", \"thickness_sweep_script\");\r\nsetsweep(\"thickness_sweep_script\", \"type\", \"Ranges\");\r\nsetsweep(\"thickness_sweep_script\", \"number of points\", 10); \r\n# define the parameter thickness\r\npara = struct;\r\npara.Name = \"thickness\";\r\npara.Parameter = \"::model::AR structure::thickness\";\r\npara.Type = \"Length\";\r\npara.Start = 0.05e-6;\r\npara.Stop = 0.15e-6;\r\npara.Units = \"microns\";\r\n# add the parameter thickness to the sweep\r\naddsweepparameter(\"thickness_sweep_script\", para);\r\n# define results\r\nresult_1 = struct;\r\nresult_1.Name = \"R\";\r\nresult_1.Result = \"::model::R::T\";\r\nresult_2 = struct;\r\nresult_2.Name = \"T\";\r\nresult_2.Result = \"::model::T::T\";\r\n# add the results R & T to the sweep\r\naddsweepresult(\"thickness_sweep_script\", result_1);\r\naddsweepresult(\"thickness_sweep_script\", result_2);\r\n```",
    "summary": "Adds a result to a sweep/optimization/Monte Carlo item",
    "syntax": [
      {
        "syntax": "addsweepresult(\"name\", \"result\");",
        "description": "Adds a result to a sweep/optimization/Monte Carlo item. \"name\" is the absolute name of an analysis item. \"result\" could be a string (i.e. create a result with default values) or a struct which could contain results and operations. Returns the result name."
      }
    ],
    "example": "# add a sweep\r\naddsweep(0);\r\nsetsweep(\"sweep\", \"name\", \"thickness_sweep_script\");\r\nsetsweep(\"thickness_sweep_script\", \"type\", \"Ranges\");\r\nsetsweep(\"thickness_sweep_script\", \"number of points\", 10); \r\n# define the parameter thickness\r\npara = struct;\r\npara.Name = \"thickness\";\r\npara.Parameter = \"::model::AR structure::thickness\";\r\npara.Type = \"Length\";\r\npara.Start = 0.05e-6;\r\npara.Stop = 0.15e-6;\r\npara.Units = \"microns\";\r\n# add the parameter thickness to the sweep\r\naddsweepparameter(\"thickness_sweep_script\", para);\r\n# define results\r\nresult_1 = struct;\r\nresult_1.Name = \"R\";\r\nresult_1.Result = \"::model::R::T\";\r\nresult_2 = struct;\r\nresult_2.Name = \"T\";\r\nresult_2.Result = \"::model::T::T\";\r\n# add the results R & T to the sweep\r\naddsweepresult(\"thickness_sweep_script\", result_1);\r\naddsweepresult(\"thickness_sweep_script\", result_2);"
  },
  {
    "name": "addtemperaturebc",
    "description": "Adds a new temperature boundary condition to the HEAT or CHARGE solver \\[[Boundary Conditions (Thermal Simulation)](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\\]. A HEAT or CHARGE solver region must be present in the objects tree before this boundary condition can be added. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addtemperaturebc();",
    "category": "general",
    "markdown": "# addtemperaturebc\r\n\r\nAdds a new temperature boundary condition to the HEAT or CHARGE solver\r\n\\[[Boundary Conditions (Thermal Simulation)](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\\].\r\nA HEAT or CHARGE solver region must be present in the objects tree before this boundary\r\ncondition can be added. If both solvers are present then the intended solver's name must\r\nbe provided as an argument to the script command.\r\n\r\nThe temperature boundary condition can only be added to the CHARGE solver when the\r\nsolver's temperature dependency is set to 'coupled'.\r\n\r\n| **Syntax**                       | **Description**                                                                                                                                                                 |\r\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addtemperaturebc;                | Adds a temperature boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addtemperaturebc(\"solver_name\"); | Adds a temperature boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a temperature boundary condition to the solver\r\nalready present in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddtemperaturebc;  \r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a steady state temperature boundary condition to\r\nthe HEAT solver already present in the objects tree. It will then name the boundary\r\ncondition, assign it to the -z simulation boundary, and sweep the temperature from 300 K\r\nto 400 K in 5 steps.\r\n\r\n```\r\naddtemperaturebc(\"HEAT\");  \r\n\r\nset(\"name\",\"T_bottom\");  \r\nset(\"bc mode\",\"steady state\");  \r\nset(\"sweep type\",\"range\");  \r\nset(\"range start\",300);  \r\nset(\"range stop\",400);  \r\nset(\"range num points\",5);  \r\nset(\"surface type\",\"simulation region\");  \r\nset(\"z min\",1);\r\n```\r\n\r\n**Example 3**\r\n\r\nThe following script commands will set up a transient temperature boundary condition to\r\nthe HEAT solver where the temperature is 300 K at t = 0 which steps to 400 K between t =\r\n1 us and 1.1 us (tslew = 0.1 us) and remains at 400 K until t = 10 us. The temperature\r\nboundary condition is assigned to a surfaces with surface id = 15 and 20.\r\n\r\n```\r\naddtemperaturebc(\"HEAT\");  \r\n\r\nset(\"name\",\"T_trans\");  \r\nset(\"bc mode\",\"transient\");  \r\n\r\ntstep = [0, 1e-6, 1.1e-6, 10e-6];  \r\nTemp = [300, 300, 400, 400];  \r\n\r\nset(\"transient time steps\",tstep);  \r\nset(\"transient value table\",Temp);  \r\nset(\"surface type\",\"surface\");  \r\nset(\"surfaces\",[15, 20]);\r\n```",
    "summary": "Adds a new temperature boundary condition to the HEAT or CHARGE solver \\[[Boundary Conditions (Therm...",
    "syntax": [
      {
        "syntax": "addtemperaturebc;",
        "description": "Adds a temperature boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addtemperaturebc(\"solver_name\");",
        "description": "Adds a temperature boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addtemperaturemonitor",
    "description": "Adds a temperature monitor to the Finite Element IDE simulation environment. The monitor can only be added if the simulation environment already has a 'HEAT' or 'CHARGE' (or both) solver present.",
    "usage": "addtemperaturemonitor();",
    "category": "general",
    "markdown": "# addtemperaturemonitor\r\n\r\nAdds a temperature monitor to the Finite Element IDE simulation environment. The monitor\r\ncan only be added if the simulation environment already has a 'HEAT' or 'CHARGE' (or\r\nboth) solver present.\r\n\r\n| **Syntax**                                         | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                         |\r\n| -------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addtemperaturemonitor;                             | Adds a temperature monitor to the simulation environment. This format of the command is only application when only one solver is present in the model tree. This function does not return any data. If multiple solvers are present then use the second format                                                                                                                                                                          |\r\n| addtemperaturemonitor(\"solver_name\");              | This format of the command will add a temperature monitor to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.” For the CHARGE solver, the temperature monitor only works if the \"temperature dependence\" is set to \"non-isothermal\" or \"coupled.\"                                                                                                                                                |\r\n| addtemperaturemonitor(struct_data);                | Adds a temperature monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This format of the command is only application when only one solver is present in the model tree. This function does not return any data.                                                     |\r\n| addtemperaturemonitor(\"solver_name\", struct_data); | This format of the command will add a temperature monitor to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.” Adds a temperature monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a 2D y-normal temperature monitor to the CHARGE\r\nsolver region and set its dimension.\r\n\r\n```\r\naddtemperaturemonitor(\"CHARGE\");  \r\n\r\nset(\"name\",\"Tmap\");  \r\nset(\"monitor type\",6);  # 2D y-normal  \r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"z\",0);  \r\nset(\"z span\",10e-6);\r\n```",
    "summary": "Adds a temperature monitor to the Finite Element IDE simulation environment",
    "syntax": [
      {
        "syntax": "addtemperaturemonitor;",
        "description": "Adds a temperature monitor to the simulation environment. This format of the command is only application when only one solver is present in the model tree. This function does not return any data. If multiple solvers are present then use the second format"
      },
      {
        "syntax": "addtemperaturemonitor(\"solver_name\");",
        "description": "This format of the command will add a temperature monitor to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.” For the CHARGE solver, the temperature monitor only works if the \"temperature dependence\" is set to \"non-isothermal\" or \"coupled.\""
      },
      {
        "syntax": "addtemperaturemonitor(struct_data);",
        "description": "Adds a temperature monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This format of the command is only application when only one solver is present in the model tree. This function does not return any data."
      },
      {
        "syntax": "addtemperaturemonitor(\"solver_name\", struct_data);",
        "description": "This format of the command will add a temperature monitor to the solver defined by the argument. The \"solver name\" will be either “CHARGE” or “HEAT.” Adds a temperature monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addtemperaturemonitor(\"CHARGE\");  \r\n\r\nset(\"name\",\"Tmap\");  \r\nset(\"monitor type\",6);  # 2D y-normal  \r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"z\",0);  \r\nset(\"z span\",10e-6);"
  },
  {
    "name": "addtfsf",
    "description": "Adds a Total Field Scattered Field (TFSF) source to the simulation environment.",
    "usage": "addtfsf();",
    "category": "general",
    "markdown": "# addtfsf\r\n\r\nAdds a Total Field Scattered Field (TFSF) source to the simulation environment.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                                  |\r\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| addtfsf;              | Add a total field scattered field source to the simulation environment. This function does not return any data.                                                                                                                                                                                  |\r\n| addtfsf(struct_data); | Adds a total field scattered field source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a plane wave source in the FDTD simulation\r\nenvironment that will propagate in the negative z direction. The script will set the\r\ndimension (and position) of the source and will define the frequency range.\r\n\r\n```\r\naddtfsf;  \r\n\r\nset(\"injection axis\",\"z\");  \r\nset(\"direction\",\"backward\");  \r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",5e-6);  \r\nset(\"z\",3e-6);  \r\nset(\"z span\",6e-6);  \r\nset(\"wavelength start\",0.3e-6);  \r\nset(\"wavelength stop\",1.2e-6);\r\n```",
    "summary": "Adds a Total Field Scattered Field (TFSF) source to the simulation environment",
    "syntax": [
      {
        "syntax": "addtfsf;",
        "description": "Add a total field scattered field source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addtfsf(struct_data);",
        "description": "Adds a total field scattered field source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addtfsf;  \r\n\r\nset(\"injection axis\",\"z\");  \r\nset(\"direction\",\"backward\");  \r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",5e-6);  \r\nset(\"z\",3e-6);  \r\nset(\"z span\",6e-6);  \r\nset(\"wavelength start\",0.3e-6);  \r\nset(\"wavelength stop\",1.2e-6);"
  },
  {
    "name": "addthermalinsulatingbc",
    "description": "Adds a new insulating [(thermal) boundary condition](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-) to the HEAT or CHARGE solver. A HEAT or CHARGE solver region must be present in the objects tree before this boundary condition can be added. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addthermalinsulatingbc();",
    "category": "general",
    "markdown": "# addthermalinsulatingbc\r\n\r\nAdds a new insulating\r\n[(thermal) boundary condition](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\r\nto the HEAT or CHARGE solver. A HEAT or CHARGE solver region must be present in the\r\nobjects tree before this boundary condition can be added. If both solvers are present\r\nthen the intended solver's name must be provided as an argument to the script command.\r\n\r\nThe insulating (thermal) boundary condition can only be added to the CHARGE solver when\r\nthe solver's temperature dependency is set to 'coupled'.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                                                                           |\r\n| -------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addthermalinsulatingbc;                | Adds an insulating (thermal) boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addthermalinsulatingbc(\"solver_name\"); | Adds an insulating (thermal) boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add an insulating (thermal) boundary condition to the\r\nsolver already present in the objects tree and print all available properties of the\r\nboundary condition.\r\n\r\n```\r\naddthermalinsulatingbc;  \r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add an insulating (thermal) boundary condition to the\r\nHEAT solver already present in the objects tree. It will then name the boundary\r\ncondition and assign it to the -x and +x simulation region boundaries.\r\n\r\n```\r\naddthermalinsulatingbc(\"HEAT\");  \r\n\r\nset(\"name\",\"ins_x_bc\");  \r\nset(\"surface type\",\"simulation region\");  \r\nset(\"x min\",1);  \r\nset(\"x max\",1);\r\n```",
    "summary": "Adds a new insulating [(thermal) boundary condition](https://optics",
    "syntax": [
      {
        "syntax": "addthermalinsulatingbc;",
        "description": "Adds an insulating (thermal) boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addthermalinsulatingbc(\"solver_name\");",
        "description": "Adds an insulating (thermal) boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addthermalpowerbc",
    "description": "Adds a new thermal power boundary condition to the HEAT or CHARGE solver \\[[Boundary Conditions (Thermal Simulation)](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\\]. A HEAT or CHARGE solver region must be present in the objects tree before this boundary condition can be added. If both solvers are present then the intended solver's name must be provided as an argument to the script command.",
    "usage": "addthermalpowerbc();",
    "category": "general",
    "markdown": "# addthermalpowerbc\r\n\r\nAdds a new thermal power boundary condition to the HEAT or CHARGE solver\r\n\\[[Boundary Conditions (Thermal Simulation)](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\\].\r\nA HEAT or CHARGE solver region must be present in the objects tree before this boundary\r\ncondition can be added. If both solvers are present then the intended solver's name must\r\nbe provided as an argument to the script command.\r\n\r\nThe thermal power boundary condition can only be added to the CHARGE solver when the\r\nsolver's temperature dependency is set to 'coupled'.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                                                   |\r\n| --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addthermalpowerbc;                | Adds a thermal power boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data.                          |\r\n| addthermalpowerbc(\"solver_name\"); | Adds a thermal power boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a thermal power boundary condition to the solver\r\nalready present in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddthermalpowerbc;  \r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will add a steady state thermal power boundary condition\r\nto the HEAT solver already present in the objects tree. It will then name the boundary\r\ncondition, assign it to the solid named 'heater', and sweep the power from 1 mW to 10 mW\r\nin 5 steps.\r\n\r\n```\r\naddthermalpowerbc(\"HEAT\");  \r\n\r\nset(\"name\",\"P_in\");  \r\nset(\"bc mode\",\"steady state\");  \r\nset(\"sweep type\",\"range\");  \r\nset(\"range start\",1e-3);  \r\nset(\"range stop\",10e-3);  \r\nset(\"range num points\",5);  \r\nset(\"surface type\",\"solid\");  \r\nset(\"solid\",\"heater\");\r\n```\r\n\r\n**Example 3**\r\n\r\nThe following script commands will set up a transient thermal power boundary condition\r\nto the HEAT solver where the power applied to the solid 'heater' is set to 0 W at t = 0.\r\nThe power input then steps from 0 W to 1 mW between t = 1 us to t = 1.1 us (tslew = 0.1\r\nus). The power input is then kept at 1 mW until 10 us.\r\n\r\n```\r\naddthermalpowerbc(\"HEAT\");  \r\n\r\nset(\"name\",\"P_heater\");  \r\nset(\"bc mode\",\"transient\");  \r\n\r\ntstep = [0, 1e-6, 1.1e-6, 10e-6];  \r\nPin = [0, 0, 1e-3, 1e-3];  \r\n\r\nset(\"transient time steps\",tstep);  \r\nset(\"transient value table\",Pin);  \r\nset(\"surface type\",\"solid\");  \r\nset(\"solid\",\"heater\");\r\n```",
    "summary": "Adds a new thermal power boundary condition to the HEAT or CHARGE solver \\[[Boundary Conditions (The...",
    "syntax": [
      {
        "syntax": "addthermalpowerbc;",
        "description": "Adds a thermal power boundary condition to the HEAT or CHARGE solver (whichever is present in the objects tree). This function does not return any data."
      },
      {
        "syntax": "addthermalpowerbc(\"solver_name\");",
        "description": "Adds a thermal power boundary condition to the desired solver defined by the argument \"solver_name\". The options are \"HEAT\" and \"CHARGE\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addtime",
    "description": "Adds a time monitor to the simulation environment. The time monitor provides time-domain information for field components over the course of the simulation",
    "usage": "addtime();",
    "category": "general",
    "markdown": "# addtime\r\n\r\nAdds a time monitor to the simulation environment. The time monitor provides time-domain\r\ninformation for field components over the course of the simulation\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                            |\r\n| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addtime;              | Adds a time monitor to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addtime(struct_data); | Adds a time monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script command will add a point time monitor to the simulation region and\r\nset its position.\r\n\r\n```\r\naddtime;  \r\n\r\nset(\"name\",\"time_1\");  \r\nset(\"monitor type\",1);  # point  \r\nset(\"x\",0);  \r\nset(\"y\",0);  \r\nset(\"z\",10e-6);\r\n```",
    "summary": "Adds a time monitor to the simulation environment",
    "syntax": [
      {
        "syntax": "addtime;",
        "description": "Adds a time monitor to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addtime(struct_data);",
        "description": "Adds a time monitor and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addtime;  \r\n\r\nset(\"name\",\"time_1\");  \r\nset(\"monitor type\",1);  # point  \r\nset(\"x\",0);  \r\nset(\"y\",0);  \r\nset(\"z\",10e-6);"
  },
  {
    "name": "addtogroup",
    "description": "Adds selected objects to a group.",
    "usage": "addtogroup();",
    "category": "general",
    "markdown": "# addtogroup\r\n\r\nAdds selected objects to a group.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                       |\r\n| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addtogroup(\"group_name\"); | Adds selected object(s) to a group. If a group with name \"group_name\" already exists, then the objects are added to the existing group. Otherwise, a group named \"group_name\" is created. \"group_name\" can be an absolute path, such as \"::model::G1\" |\r\n\r\n**Example**\r\n\r\nAdd a substrate in to a group \"G2\", and subsequently move the substrate back to \"G1\"\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\naddtogroup(\"::model::G1::G2\"); #this object is added to the group \"G2\"\r\n# moves the rectangle back to G1\r\naddtogroup(\"::model::G1\");\r\n```",
    "summary": "Adds selected objects to a group",
    "syntax": [
      {
        "syntax": "addtogroup(\"group_name\");",
        "description": "Adds selected object(s) to a group. If a group with name \"group_name\" already exists, then the objects are added to the existing group. Otherwise, a group named \"group_name\" is created. \"group_name\" can be an absolute path, such as \"::model::G1\""
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\naddtogroup(\"::model::G1::G2\"); #this object is added to the group \"G2\"\r\n# moves the rectangle back to G1\r\naddtogroup(\"::model::G1\");"
  },
  {
    "name": "addtolibrary",
    "description": "Adds the selected element to the currently selected folder under Custom library.",
    "usage": "addtolibrary();",
    "category": "general",
    "markdown": "# addtolibrary\r\n\r\nAdds the selected element to the currently selected folder under Custom library.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addtolibrary (\"name\", replace); | Adds an element to the currently selected folder under Custom library. The \"name\" specified is the custom folder name. If no folder named as specified, a new folder will be generated under the Custom library. The \"replace\" is a boolean value. If \"replace\" is true, the element in the Custom library with the same name will be replaced; if \"replace\" is false, a warning message will pop up to get further action for replacing the element with the same name or not. The default value for \"replace\" is false. |\r\n\r\n**Eample**\r\n\r\n```\r\n#adds the selected element to the folder \"folder1\" under Custom library\r\naddtolibrary(\"folder1\", true);\r\n```",
    "summary": "Adds the selected element to the currently selected folder under Custom library",
    "syntax": [
      {
        "syntax": "addtolibrary (\"name\", replace);",
        "description": "Adds an element to the currently selected folder under Custom library. The \"name\" specified is the custom folder name. If no folder named as specified, a new folder will be generated under the Custom library. The \"replace\" is a boolean value. If \"replace\" is true, the element in the Custom library with the same name will be replaced; if \"replace\" is false, a warning message will pop up to get further action for replacing the element with the same name or not. The default value for \"replace\" is false."
      }
    ],
    "example": ""
  },
  {
    "name": "addtriangle",
    "description": "Adds a 3 vertex, triangle shaped polygon primitive to the simulation environment.",
    "usage": "addtriangle();",
    "category": "general",
    "markdown": "# addtriangle\r\n\r\nAdds a 3 vertex, triangle shaped polygon primitive to the simulation environment.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                  |\r\n| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addtriangle;              | Adds a triangle primitive to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| addtriangle(struct_data); | Adds a triangle primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script creates a triangle primitive and sets the coordinates of its three\r\ncorners using a 2D matrix.\r\n\r\n```\r\nvtx = [1,0;2,2;4,0]*1e-6;  # microns  \r\n\r\naddtriangle;  \r\nset(\"name\",\"new_triangle\");  \r\nset(\"vertices\",vtx);  \r\nset(\"z span\",2e-6);\r\n```",
    "summary": "Adds a 3 vertex, triangle shaped polygon primitive to the simulation environment",
    "syntax": [
      {
        "syntax": "addtriangle;",
        "description": "Adds a triangle primitive to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "addtriangle(struct_data);",
        "description": "Adds a triangle primitive and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "vtx = [1,0;2,2;4,0]*1e-6;  # microns  \r\n\r\naddtriangle;  \r\nset(\"name\",\"new_triangle\");  \r\nset(\"vertices\",vtx);  \r\nset(\"z span\",2e-6);"
  },
  {
    "name": "adduniformheat",
    "description": "Adds a constant heat source to the HEAT solver region. The input is defined as the net heat input to the volume in units of Watt. The uniform heat source can either be 2D or 3D. The heat input per unit volume (W/m 3 ) is calculated by dividing the net input power by the volume of the (3D) source. In the case of a 2D source the volume of the source is defined by setting the length in the third dimension equal to either the \"equivalent length\" of the source or the \"norm length\" of the HEAT solver.",
    "usage": "adduniformheat();",
    "category": "general",
    "markdown": "# adduniformheat\r\n\r\nAdds a constant heat source to the HEAT solver region. The input is defined as the net\r\nheat input to the volume in units of Watt. The uniform heat source can either be 2D or\r\n3D. The heat input per unit volume (W/m 3 ) is calculated by dividing the net input\r\npower by the volume of the (3D) source. In the case of a 2D source the volume of the\r\nsource is defined by setting the length in the third dimension equal to either the\r\n\"equivalent length\" of the source or the \"norm length\" of the HEAT solver.\r\n\r\n| **Syntax**                   | **Description**                                                                                                                                                                                                                                                                    |\r\n| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adduniformheat;              | Adds a constant heat source to the simulation environment. This function does not return any data.                                                                                                                                                                                 |\r\n| adduniformheat(struct_data); | Adds a constant heat source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script adds a 3D uniform heat source to the HEAT solver, sets its\r\ndimension, and assigns a net input power.\r\n\r\n```\r\nadduniformheat;  # the dafult format of a newly created heat source is 3D  \r\n\r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",5e-6);  \r\nset(\"z\",0);  \r\nset(\"z span\",10e-6);  \r\nset(\"total power\",1e-4);  #  Pin = 0.1 mW\r\n```\r\n\r\nThe following script adds a 2D y-normal uniform heat source to the HEAT solver, sets its\r\ndimension, forces the length in the third dimension to be equal to the \"norm length\" of\r\nthe HEAT solver, and assigns a net input power.\r\n\r\n```\r\nadduniformheat;    \r\n\r\nset(\"source type\",2);  # 2D y-normal  \r\nset(\"use solver norm length\",1);  \r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"z\",0);  \r\nset(\"z span\",10e-6);  \r\nset(\"total power\",1e-4);  #  Pin = 0.1 mW\r\n```",
    "summary": "Adds a constant heat source to the HEAT solver region",
    "syntax": [
      {
        "syntax": "adduniformheat;",
        "description": "Adds a constant heat source to the simulation environment. This function does not return any data."
      },
      {
        "syntax": "adduniformheat(struct_data);",
        "description": "Adds a constant heat source and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "adduniformheat;  # the dafult format of a newly created heat source is 3D  \r\n\r\nset(\"x\",0);  \r\nset(\"x span\",2e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",5e-6);  \r\nset(\"z\",0);  \r\nset(\"z span\",10e-6);  \r\nset(\"total power\",1e-4);  #  Pin = 0.1 mW"
  },
  {
    "name": "adduserprop",
    "description": "Adds a custom user property to a structure or analysis group.",
    "usage": "adduserprop();",
    "category": "general",
    "markdown": "# adduserprop\r\n\r\nAdds a custom user property to a structure or analysis group.\r\n\r\n| **Syntax**                                 | **Description**                                                                                                                                                                                                                                                                                    |\r\n| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| adduserprop(\"property name\", type, value); | Adds a user property to a selected structure group. The name is set to \"property name\". The type is an integer from 0 to 6. The corresponding variable types are 0 - number 1 - Text 2 - Length 3 - Time 4 - Frequency 5 - Material 6 - Matrix The value of the new user property is set to value. |\r\n\r\n**Example**\r\n\r\nCreate a structure group. Add a user property named \"radius\" and set up the script in\r\nthe structure group to add two circles to the group and set their radius to the value of\r\nthe user property \"radius\". Note that the myscript string uses the escape character \\\\n\r\nfor new line and \" for double quotes within the string.\r\n\r\n```\r\naddstructuregroup;\r\nadduserprop(\"radius\",2,0.5e-6);\r\nmyscript =      \"addcircle; \\n\";\r\nmyscript = myscript + \"copy(1e-6); \\n\";\r\nmyscript = myscript + \"selectall; \\n\";\r\nmyscript = myscript + \"set(\\\"radius\\\",radius);\";\r\nset(\"name\",\"dimer\");\r\nset(\"script\",myscript); \r\n```\r\n\r\nAn example for analysis group\r\n\r\n```\r\naddanalysisgroup;\r\nadduserprop(\"y span\",2,5e-6);\r\nmyscript =\" #begin\r\ny_span = %y span%;\r\naddpower;\r\nset('x',0);\r\nset('y',0);\r\nset('z',0);\r\nset('y span',y_span);\r\n\"; #end\r\nset('setup script',myscript);\r\n```",
    "summary": "Adds a custom user property to a structure or analysis group",
    "syntax": [
      {
        "syntax": "adduserprop(\"property name\", type, value);",
        "description": "Adds a user property to a selected structure group. The name is set to \"property name\". The type is an integer from 0 to 6. The corresponding variable types are 0 - number 1 - Text 2 - Length 3 - Time 4 - Frequency 5 - Material 6 - Matrix The value of the new user property is set to value."
      }
    ],
    "example": "addstructuregroup;\r\nadduserprop(\"radius\",2,0.5e-6);\r\nmyscript =      \"addcircle; \\n\";\r\nmyscript = myscript + \"copy(1e-6); \\n\";\r\nmyscript = myscript + \"selectall; \\n\";\r\nmyscript = myscript + \"set(\\\"radius\\\",radius);\";\r\nset(\"name\",\"dimer\");\r\nset(\"script\",myscript);"
  },
  {
    "name": "addvarfdtd",
    "description": "Adds a 2.5D varFDTD solver region to the MODE simulation environment.",
    "usage": "addvarfdtd();",
    "category": "general",
    "markdown": "# addvarfdtd\r\n\r\nAdds a 2.5D varFDTD solver region to the MODE simulation environment.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                                                              |\r\n| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addvarfdtd;              | Adds a 2.5D varFDTD simulation region. This function does not return any data.                                                                                                                                                                                                               |\r\n| addvarfdtd(struct_data); | Adds a 2.5D varFDTD simulation region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will add a 2.5D varFDTD solver region to the MODE\r\nsimulation environment, set its dimension and simulation time, and run the simulation.\r\n\r\n```\r\naddvarfdtd;  \r\n\r\nset(\"x\",0);  \r\nset(\"x span\",10e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",10e-6);  \r\nset(\"z\",0);  \r\nset(\"z span\",1e-6);  \r\nset(\"simulation time\",5000e-15);  # 5000 fs  \r\n\r\nrun;\r\n```",
    "summary": "Adds a 2",
    "syntax": [
      {
        "syntax": "addvarfdtd;",
        "description": "Adds a 2.5D varFDTD simulation region. This function does not return any data."
      },
      {
        "syntax": "addvarfdtd(struct_data);",
        "description": "Adds a 2.5D varFDTD simulation region and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addvarfdtd;  \r\n\r\nset(\"x\",0);  \r\nset(\"x span\",10e-6);  \r\nset(\"y\",0);  \r\nset(\"y span\",10e-6);  \r\nset(\"z\",0);  \r\nset(\"z span\",1e-6);  \r\nset(\"simulation time\",5000e-15);  # 5000 fs  \r\n\r\nrun;"
  },
  {
    "name": "addvoltagebc",
    "description": "Adds a new voltage boundary condition to the HEAT solver \\[[Boundary Conditions (Thermal Simulation)](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\\]. A HEAT solver region must be present in the objects tree before an electrical contact boundary condition can be added.",
    "usage": "addvoltagebc();",
    "category": "general",
    "markdown": "# addvoltagebc\r\n\r\nAdds a new voltage boundary condition to the HEAT solver\r\n\\[[Boundary Conditions (Thermal Simulation)](https://optics.ansys.com/hc/en-us/articles/360034398314-Boundary-Conditions-Thermal-Simulation-)\\].\r\nA HEAT solver region must be present in the objects tree before an electrical contact\r\nboundary condition can be added.\r\n\r\n| **Syntax**    | **Description**                                                                               |\r\n| ------------- | --------------------------------------------------------------------------------------------- |\r\n| addvoltagebc; | Adds a voltage boundary condition to the HEAT solver. This function does not return any data. |\r\n\r\n**Example 1**\r\n\r\nThe following script commands will add a voltage boundary condition to the CHARGE solver\r\nalready present in the objects tree and print all available properties of the boundary\r\ncondition.\r\n\r\n```\r\naddvoltagebc;  \r\n?set;\r\n```\r\n\r\n**Example 2**\r\n\r\nThe following script commands will create a voltage boundary condition with a fixed\r\nsteady state voltage assigned to a solid named cathode. The objects tree must already\r\nhave a HEAT solver and a geometry named 'cathode' present.\r\n\r\n```\r\naddvoltagebc;  \r\n\r\nset(\"name\",\"cathode\");  \r\nset(\"bc mode\",\"steady state\");  \r\nset(\"sweep type\",\"single\");  \r\nset(\"voltage\",0.2);  # setting the voltage to 0.2 V  \r\nset(\"surface type\",\"solid\");  \r\nset(\"solid\",\"cathode\");\r\n```\r\n\r\n**Example 3**\r\n\r\nThe following script commands will create a steady state voltage boundary condition\r\nnamed cathode and apply a voltage sweep over a predefined set of voltages. The objects\r\ntree must already have a HEAT solver and a geometry named 'cathode' present.\r\n\r\n```\r\naddvoltagebc;  \r\n\r\nset(\"name\",\"cathode\");  \r\nset(\"bc mode\",\"steady state\");  \r\nset(\"sweep type\",\"value\");  \r\n\r\nV = [0, 0.1, 0.2, 0.3, 0.4, 0.45, 0.5, 0.55, 0.56, 0.57, 0.58, 0.59, 0.6];  \r\nset(\"value table\",V);  \r\n\r\nset(\"surface type\",\"solid\");  \r\nset(\"solid\",\"cathode\");\r\n```\r\n\r\n**Example 4**\r\n\r\nThe following script commands will set up a transient voltage boundary condition where\r\nthe voltage is 0 V at t = 0, steps to 1 V between t = 1 us and 1.001 us (tslew = 1 ns),\r\nand remains at 1 V until t = 10 us. The boundary condition is assigned to a solid named\r\ncathode.\r\n\r\n```\r\naddvoltagebc;  \r\n\r\nset(\"name\",\"cathode_trans\");  \r\nset(\"bc mode\",\"transient\");  \r\n\r\ntstep = [0, 1e-6, 1.001e-6, 10e-6];  \r\nV = [0, 0, 1, 1];  \r\n\r\nset(\"transient time steps\",tstep);  \r\nset(\"transient value table\",V);  \r\nset(\"surface type\",\"solid\");  \r\nset(\"solid\",\"cathode\");\r\n```",
    "summary": "Adds a new voltage boundary condition to the HEAT solver \\[[Boundary Conditions (Thermal Simulation)...",
    "syntax": [
      {
        "syntax": "addvoltagebc;",
        "description": "Adds a voltage boundary condition to the HEAT solver. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "addwaveguide",
    "description": "Adds a waveguide object in the simulation space.",
    "usage": "addwaveguide();",
    "category": "general",
    "markdown": "# addwaveguide\r\n\r\nAdds a waveguide object in the simulation space.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                                                                                                                                                         |\r\n| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| addwaveguide;              | Adds a waveguide in the simulation space. This function does not return any data.                                                                                                                                                                                       |\r\n| addwaveguide(struct_data); | Adds a waveguide and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will create a bent waveguide using 4 poles. For mode\r\ndetails on how the waveguide object generates the shape of the waveguide using the poles\r\ntake a look at this KB page:\r\n[ Structures - Waveguide ](https://optics.ansys.com/hc/en-us/articles/360034382234-Structures-Waveguide)\r\n.\r\n\r\n```\r\naddwaveguide;  \r\n\r\nset(\"base width\",600e-9);  \r\nset(\"base height\",220e-9);  \r\nset(\"base angle\",70);  \r\n\r\npole = [0,0; 1,9; 6,9.8; 10,10]*1e-6;  \r\nset(\"poles\",pole);  \r\n  \r\nset(\"material\",\"Si (Silicon) - Palik\");\r\n```",
    "summary": "Adds a waveguide object in the simulation space",
    "syntax": [
      {
        "syntax": "addwaveguide;",
        "description": "Adds a waveguide in the simulation space. This function does not return any data."
      },
      {
        "syntax": "addwaveguide(struct_data);",
        "description": "Adds a waveguide and set its property using a struct containing \"property\" and value pairs. See the [struct](https://optics.ansys.com/hc/en-us/articles/360034409574-struct-Script-command) script command page for an example. This function does not return any data."
      }
    ],
    "example": "addwaveguide;  \r\n\r\nset(\"base width\",600e-9);  \r\nset(\"base height\",220e-9);  \r\nset(\"base angle\",70);  \r\n\r\npole = [0,0; 1,9; 6,9.8; 10,10]*1e-6;  \r\nset(\"poles\",pole);  \r\n  \r\nset(\"material\",\"Si (Silicon) - Palik\");"
  },
  {
    "name": "all",
    "description": "Returns 1 if all of the specified matrix entries are nonzero and returns 0 otherwise.",
    "usage": "all();",
    "category": "general",
    "markdown": "# all\r\n\r\nReturns 1 if all of the specified matrix entries are nonzero and returns 0 otherwise.\r\n\r\n| **Syntax**      | **Description**                                                                       |\r\n| --------------- | ------------------------------------------------------------------------------------- |\r\n| out = all(A);   | Will return 1 if all of the A matrix entries are nonzero and will return 0 otherwise. |\r\n| out = all(A,n); | n is an optional parameter to analyze entries in a specific dimension                 |\r\n\r\n**Example**\r\n\r\nThe following is a simple example showing how to use this command.\r\n\r\n```\r\na = [1,4,3,0.5];\r\nb = [1,3;6,0];\r\n?all(a);\r\n?all(b);\r\nresult:\r\n1\r\nresult: \r\n0  \r\n?all(b,2);\r\nresult: \r\n1  \r\n0   \r\n```",
    "summary": "Returns 1 if all of the specified matrix entries are nonzero and returns 0 otherwise",
    "syntax": [
      {
        "syntax": "out = all(A);",
        "description": "Will return 1 if all of the A matrix entries are nonzero and will return 0 otherwise."
      },
      {
        "syntax": "out = all(A,n);",
        "description": "n is an optional parameter to analyze entries in a specific dimension"
      }
    ],
    "example": "a = [1,4,3,0.5];\r\nb = [1,3;6,0];\r\n?all(a);\r\n?all(b);\r\nresult:\r\n1\r\nresult: \r\n0  \r\n?all(b,2);\r\nresult: \r\n1  \r\n0"
  },
  {
    "name": "almostequal",
    "description": "Performs an almost-equal comparison. When using floating point numbers (rather than integers), two values that are meant to be equal may not be exactly equal due to rounding errors that are always present in floating point calculations. In such cases, the almostequal function can be useful. For complex numbers, A and B, almostequal function returns true only when both the real and imaginary parts, evaluated separately, are true.",
    "usage": "almostequal();",
    "category": "general",
    "markdown": "# almostequal\r\n\r\nPerforms an almost-equal comparison. When using floating point numbers (rather than\r\nintegers), two values that are meant to be equal may not be exactly equal due to\r\nrounding errors that are always present in floating point calculations. In such cases,\r\nthe almostequal function can be useful. For complex numbers, A and B, almostequal\r\nfunction returns true only when both the real and imaginary parts, evaluated separately,\r\nare true.\r\n\r\n| **Syntax**                                             | **Description** |\r\n| ------------------------------------------------------ | --------------- |\r\n| out = almostequal(A, B);                               | Returns 1 if    |\r\n| out = almostequal(A, B, relative diff);                | Returns 1 if    |\r\n| out = almostequal(A, B, relative diff, absolute diff); | Returns 1 if    |\r\n\r\n**Examples**\r\n\r\nThis example shows the usage of the almostequal function.\r\n\r\n```\r\nA=[1,2];\r\nB=[1,1];\r\n?almostequal(A,B);\r\nresult: \r\n1 0 \r\n?almostequal(A,B,0.01,2);\r\nresult: \r\n1 1 \r\n \r\n?almostequal(1,2,1);\r\nresult: \r\n1   \r\n```",
    "summary": "Performs an almost-equal comparison",
    "syntax": [
      {
        "syntax": "out = almostequal(A, B);",
        "description": "Returns 1 if"
      },
      {
        "syntax": "out = almostequal(A, B, relative diff);",
        "description": "Returns 1 if"
      },
      {
        "syntax": "out = almostequal(A, B, relative diff, absolute diff);",
        "description": "Returns 1 if"
      }
    ],
    "example": ""
  },
  {
    "name": "amax",
    "description": "Returns the maximum value in a specified dimension of a matrix. For complex numbers, only the real part is considered.",
    "usage": "amax();",
    "category": "general",
    "markdown": "# amax\r\n\r\nReturns the maximum value in a specified dimension of a matrix. For complex numbers,\r\nonly the real part is considered.\r\n\r\n| **Syntax**       | **Description**                                             |\r\n| ---------------- | ----------------------------------------------------------- |\r\n| out = amax(x,n); | The maximum value in the specified dimension n of matrix x. |\r\n\r\n**Example**\r\n\r\nFind the maximum value of the first dimension of a matrix:\r\n\r\n```\r\nA = randmatrix(5,4);  \r\n\r\nB = amax(A,1); # vector length 4, B[i] = max(A(1:5,i))\r\n```",
    "summary": "Returns the maximum value in a specified dimension of a matrix",
    "syntax": [
      {
        "syntax": "out = amax(x,n);",
        "description": "The maximum value in the specified dimension n of matrix x."
      }
    ],
    "example": "A = randmatrix(5,4);  \r\n\r\nB = amax(A,1); # vector length 4, B[i] = max(A(1:5,i))"
  },
  {
    "name": "amin",
    "description": "Returns the minimum value in a specified dimension of a matrix. For complex numbers, only the real part is considered.",
    "usage": "amin();",
    "category": "general",
    "markdown": "# amin\r\n\r\nReturns the minimum value in a specified dimension of a matrix. For complex numbers,\r\nonly the real part is considered.\r\n\r\n| **Syntax**       | **Description**                                             |\r\n| ---------------- | ----------------------------------------------------------- |\r\n| out = amin(x,n); | The minimum value in the specified dimension n of matrix x. |\r\n\r\n**Example**\r\n\r\nFind the minimum value of the first dimension of a matrix:\r\n\r\n```\r\nA = randmatrix(5,4);\r\nB = amin(A,1); # vector length 4, B[i] = min(A(1:5,i))\r\n```",
    "summary": "Returns the minimum value in a specified dimension of a matrix",
    "syntax": [
      {
        "syntax": "out = amin(x,n);",
        "description": "The minimum value in the specified dimension n of matrix x."
      }
    ],
    "example": "A = randmatrix(5,4);\r\nB = amin(A,1); # vector length 4, B[i] = min(A(1:5,i))"
  },
  {
    "name": "analysis",
    "description": "Opens the MODE analysis window corresponding to the active solver (FDE or EME).",
    "usage": "analysis();",
    "category": "general",
    "markdown": "# analysis\r\n\r\nOpens the MODE analysis window corresponding to the active solver (FDE or EME).\r\n\r\n| **Syntax** | **Description**                                               |\r\n| ---------- | ------------------------------------------------------------- |\r\n| analysis;  | Opens the analysis window corresponding to the active solver. |",
    "summary": "Opens the MODE analysis window corresponding to the active solver (FDE or EME)",
    "syntax": [
      {
        "syntax": "analysis;",
        "description": "Opens the analysis window corresponding to the active solver."
      }
    ],
    "example": ""
  },
  {
    "name": "and",
    "description": "Is the logical AND function. Imaginary components of x and y are ignored.",
    "usage": "and();",
    "category": "general",
    "markdown": "# and\r\n\r\nIs the logical AND function. Imaginary components of x and y are ignored.\r\n\r\n| **Syntax**   | **Description**                                                                        |\r\n| ------------ | -------------------------------------------------------------------------------------- |\r\n| out = y & x; | If the real part of either or both of x,y are zero, then return 0. Otherwise return 1. |\r\n| y and x;     | Same as &.                                                                             |\r\n\r\n**Examples**\r\n\r\nThis example shows the usage of the \"&\" and AND function.\r\n\r\n```\r\n? (2) & (4);\r\nresult:\r\n1\r\n?(3 > 4) and (4 >3);\r\nresult: \r\n0 \r\n? (0+1i) & (1);\r\nresult:\r\n0\r\n```",
    "summary": "Is the logical AND function",
    "syntax": [
      {
        "syntax": "out = y & x;",
        "description": "If the real part of either or both of x,y are zero, then return 0. Otherwise return 1."
      },
      {
        "syntax": "y and x;",
        "description": "Same as &."
      }
    ],
    "example": ""
  },
  {
    "name": "angle",
    "description": "Returns the angle or phase of a complex number or matrix in radians.",
    "usage": "angle();",
    "category": "general",
    "markdown": "# angle\r\n\r\nReturns the angle or phase of a complex number or matrix in radians.\r\n\r\n| **Syntax**      | **Description**                                                    |\r\n| --------------- | ------------------------------------------------------------------ |\r\n| out = angle(x); | Returns the phase of x. The phase is evaluated between - π and π . |\r\n\r\n**Example**\r\n\r\nCalculate the phase of numbers in an array.\r\n\r\n```\r\n?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?angle(x)*180/pi;\r\nresult: \r\n0 \r\n26.5651 \r\n```",
    "summary": "Returns the angle or phase of a complex number or matrix in radians",
    "syntax": [
      {
        "syntax": "out = angle(x);",
        "description": "Returns the phase of x. The phase is evaluated between - π and π ."
      }
    ],
    "example": "?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?angle(x)*180/pi;\r\nresult: \r\n0 \r\n26.5651"
  },
  {
    "name": "annotateproperty",
    "description": "Enables ‘property’ annotation on a given ‘element’.",
    "usage": "annotateproperty();",
    "category": "general",
    "markdown": "# annotateproperty\r\n\r\nEnables ‘property’ annotation on a given ‘element’.\r\n\r\n| **Syntax**                                        | **Description**                                                                                                                                                                                 |\r\n| ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=annotateproperty (element,property,annotate); | Enables ‘property’ annotation on a given ‘element’. If ‘annotate’ is true the property is annotated, if ‘annotate’ is false the annotation is disable. The default value of ‘annotate’ is true. |\r\n\r\n**Example**\r\n\r\n```\r\naddelement(\"CW Laser\");\r\nannotateproperty(\"CWL_1\", \"linewidth\", true);\r\n```",
    "summary": "Enables ‘property’ annotation on a given ‘element’",
    "syntax": [
      {
        "syntax": "out=annotateproperty (element,property,annotate);",
        "description": "Enables ‘property’ annotation on a given ‘element’. If ‘annotate’ is true the property is annotated, if ‘annotate’ is false the annotation is disable. The default value of ‘annotate’ is true."
      }
    ],
    "example": "addelement(\"CW Laser\");\r\nannotateproperty(\"CWL_1\", \"linewidth\", true);"
  },
  {
    "name": "any",
    "description": "Returns 1 if any of the specified matrix entries are nonzero and returns 0 otherwise.",
    "usage": "any();",
    "category": "general",
    "markdown": "# any\r\n\r\nReturns 1 if any of the specified matrix entries are nonzero and returns 0 otherwise.\r\n\r\n| **Syntax**      | **Description**                                                                       |\r\n| --------------- | ------------------------------------------------------------------------------------- |\r\n| out = any(A);   | Will return 1 if any of the A matrix entries are nonzero and will return 0 otherwise. |\r\n| out = any(A,n); | n is an optional parameter to analyze entries in a specific dimension                 |\r\n\r\n**Example #1**\r\n\r\nThe following is a simple example showing how to use this command.\r\n\r\n```\r\na = [0,0,3,0];\r\nb = [1,3;6,0.1];\r\nd = [0;0;0;0];\r\n?any(a);\r\n?any(b);\r\n?any(d);\r\nresult:\r\n1\r\nresult:\r\n1  \r\nresult: \r\n0  \r\n?any(a,1);\r\nresult: \r\n0  \r\n0  \r\n1  \r\n0 \r\n```",
    "summary": "Returns 1 if any of the specified matrix entries are nonzero and returns 0 otherwise",
    "syntax": [
      {
        "syntax": "out = any(A);",
        "description": "Will return 1 if any of the A matrix entries are nonzero and will return 0 otherwise."
      },
      {
        "syntax": "out = any(A,n);",
        "description": "n is an optional parameter to analyze entries in a specific dimension"
      }
    ],
    "example": ""
  },
  {
    "name": "arrayperiodicdata",
    "description": "Generates an array of periodic data from a unit cell dataset based on a given plane of periodicity. This function is useful for obtaining the complete form of data from a periodic simulation which only contains data from one unit cell. Only unstructured datasets are supported by this command.",
    "usage": "arrayperiodicdata();",
    "category": "general",
    "markdown": "# arrayperiodicdata\r\n\r\nGenerates an array of periodic data from a unit cell dataset based on a given plane of\r\nperiodicity. This function is useful for obtaining the complete form of data from a\r\nperiodic simulation which only contains data from one unit cell. Only unstructured\r\ndatasets are supported by this command.\r\n\r\n| **Syntax**                                         | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\r\n| -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| arrayperiodicdata(dataset,'periodic_plane',count); | Unfolds data from a symmetric dataset based on a given plane of symmetry. The first argument is a 2D or 3D unstructured dataset. The second argument is the plane with respect to which data is periodic in the format [+-][xyz], e.g. “-y” and refers to the axis of the plane of periodicity (i.e. the direction for the periodicity vector will be taken from the sign, and that plane, e.g. y-normal, will be used for arraying). The third argument count is number of unit cells to copy in the array (if 1, only returns the unit cell). |\r\n\r\n**Examples**\r\n\r\nBelow is a simple example of creating a periodic array of unstructured dataset generated\r\nfrom data available in the\r\n[ unstructured_charge_example.mat ](https://lumerical.zendesk.com/hc/article_attachments/360046127913/unstructured_charge_example.mat)\r\nfile by assuming that the data is periodic in the \"-y\" direction and contains 3 unit\r\ncells.\r\n\r\n```\r\nmatlabload(\"unstructured_charge_example.mat\");\r\nx = charge.x;\r\ny = charge.y;\r\nz = charge.z;\r\nC = charge.elements;\r\ndata = unstructureddataset(\"test\",x,y,z,C);\r\nperiodic_data=arrayperiodicdata(data,'-y',3);\r\n```",
    "summary": "Generates an array of periodic data from a unit cell dataset based on a given plane of periodicity",
    "syntax": [
      {
        "syntax": "arrayperiodicdata(dataset,'periodic_plane',count);",
        "description": "Unfolds data from a symmetric dataset based on a given plane of symmetry. The first argument is a 2D or 3D unstructured dataset. The second argument is the plane with respect to which data is periodic in the format [+-][xyz], e.g. “-y” and refers to the axis of the plane of periodicity (i.e. the direction for the periodicity vector will be taken from the sign, and that plane, e.g. y-normal, will be used for arraying). The third argument count is number of unit cells to copy in the array (if 1, only returns the unit cell)."
      }
    ],
    "example": ""
  },
  {
    "name": "asapexport",
    "description": "Exports the desired monitor to a file for interfacing with BRO's ASAP. These files have the .fld extension. The monitor must be a frequency power or a frequency profile monitor.",
    "usage": "asapexport();",
    "category": "general",
    "markdown": "# asapexport\r\n\r\nExports the desired monitor to a file for interfacing with BRO's ASAP. These files have\r\nthe .fld extension. The monitor must be a frequency power or a frequency profile\r\nmonitor.\r\n\r\n| **Syntax**                                 | **Description**                                                                                                          |\r\n| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |\r\n| asapexport( \"monitorname\");                | Export data from monitorname. By default, the first frequency point is exported. This function does not return any data. |\r\n| asapexport( \"monitorname\", f);             | Exports the frequency point specified by the index f.                                                                    |\r\n| asapexport( \"monitorname\", f, \"filename\"); | Exports to the specified \"filename\" without opening a file browser window.                                               |\r\n\r\n**Examples**\r\n\r\nExport data from monitor transmission to a .fld file for ASAP. The monitor had more than\r\none frequency point, so the first point was exported by default.\r\n\r\n```\r\nasapexport(\"transmission\");\r\nWarning: prompt line 1: in asapexport: no frequency point was specified and the d-card has more than one. The first is used by default.\r\n```",
    "summary": "Exports the desired monitor to a file for interfacing with BRO's ASAP",
    "syntax": [
      {
        "syntax": "asapexport( \"monitorname\");",
        "description": "Export data from monitorname. By default, the first frequency point is exported. This function does not return any data."
      },
      {
        "syntax": "asapexport( \"monitorname\", f);",
        "description": "Exports the frequency point specified by the index f."
      },
      {
        "syntax": "asapexport( \"monitorname\", f, \"filename\");",
        "description": "Exports to the specified \"filename\" without opening a file browser window."
      }
    ],
    "example": ""
  },
  {
    "name": "asapimport",
    "description": "Imports an ASAP fld file into an ASAP source. This is equivalent to editing the properties of the Import source, and clicking on the Import Source button.",
    "usage": "asapimport();",
    "category": "general",
    "markdown": "# asapimport\r\n\r\nImports an ASAP fld file into an ASAP source. This is equivalent to editing the\r\nproperties of the Import source, and clicking on the Import Source button.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                       |\r\n| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\r\n| asapimport( \"sourcename\");             | Imports the fld file into the sourcename source. A file browser will open to select the file. This function does not return any data. |\r\n| asapimport( \"sourcename\", \"filename\"); | Specify the file to open.                                                                                                             |",
    "summary": "Imports an ASAP fld file into an ASAP source",
    "syntax": [
      {
        "syntax": "asapimport( \"sourcename\");",
        "description": "Imports the fld file into the sourcename source. A file browser will open to select the file. This function does not return any data."
      },
      {
        "syntax": "asapimport( \"sourcename\", \"filename\");",
        "description": "Specify the file to open."
      }
    ],
    "example": ""
  },
  {
    "name": "asapload",
    "description": "Loads data from an fld file from BRO's ASAP. asapload creates a d-card structure called \"fld_data\" which contains all the data in the file. If \"fld_data\" exists, it will be called \"fld_data_2\". After loading an asapfile with asapload, you can extract any desired data., which can be",
    "usage": "asapload();",
    "category": "general",
    "markdown": "# asapload\r\n\r\nLoads data from an fld file from BRO's ASAP. asapload creates a d-card structure called\r\n\"fld_data\" which contains all the data in the file. If \"fld_data\" exists, it will be\r\ncalled \"fld_data_2\". After loading an asapfile with asapload, you can extract any\r\ndesired data., which can be\r\n\r\n- Ex, Ey, Ez, Hx, Hy, Hz, x, y, z\r\n- power, frequency, wavelength, index\r\n\r\n| **Syntax**             | **Description**                                                                        |\r\n| ---------------------- | -------------------------------------------------------------------------------------- |\r\n| asapload;              | Select the file to load with the file browser. This function does not return any data. |\r\n| asapload( \"filename\"); | Loads data from an fld file called \"filename\" without a file browser.                  |\r\n\r\n**Examples**\r\n\r\nAfter loading the file, you can use ?getdata to see a list of all d-cards, or the\r\nvariables in the d-card. Data can be extracted using the getdata function. For example,\r\nthe real part of Ex can be imaged using the following code.\r\n\r\n```\r\nasapload(\"asap.ldf\");\r\n?getdata;\r\nglobal monitors:\r\n fld_data \r\n?getdata(\"fld_data\");\r\nf wavelength index power x y z Ex Ey\r\nEz Hx Hy Hz \r\nEx = getdata(\"fld_data\",\"Ex\");\r\nx = getdata(\"fld_data\",\"x\"); \r\ny = getdata(\"fld_data\",\"y\"); \r\nimage(x,y,pinch(real(Ex)));\r\n```",
    "summary": "Loads data from an fld file from BRO's ASAP",
    "syntax": [
      {
        "syntax": "asapload;",
        "description": "Select the file to load with the file browser. This function does not return any data."
      },
      {
        "syntax": "asapload( \"filename\");",
        "description": "Loads data from an fld file called \"filename\" without a file browser."
      }
    ],
    "example": ""
  },
  {
    "name": "asin",
    "description": "Calculates the inverse trigonometric sine function (arcsine). Angle units are in radians. The function is defined for complex values. Phase of a complex number is evaluated between - π and π . If x is complex, or abs(x) > 1, the following equation is used:",
    "usage": "asin();",
    "category": "general",
    "markdown": "# asin\r\n\r\nCalculates the inverse trigonometric sine function (arcsine). Angle units are in\r\nradians. The function is defined for complex values. Phase of a complex number is\r\nevaluated between - π and π . If x is complex, or abs(x) > 1, the following equation is\r\nused:\r\n\r\n$$ \\\\text{arcsin(x)} = -i\\\\text{ln(ix+}\\\\sqrt{1-x^2}) $$\r\n\r\n| **Syntax**     | **Description**                   |\r\n| -------------- | --------------------------------- |\r\n| out = asin(x); | Returns the complex arcsine of x. |\r\n\r\n**Example**\r\n\r\nCalculate asin( π /4 + i).\r\n\r\n```\r\nx=pi/4+1i;\r\n?asin(x);\r\nresult: \r\n0.537282+0.992724i  \r\n```",
    "summary": "Calculates the inverse trigonometric sine function (arcsine)",
    "syntax": [
      {
        "syntax": "out = asin(x);",
        "description": "Returns the complex arcsine of x."
      }
    ],
    "example": "x=pi/4+1i;\r\n?asin(x);\r\nresult: \r\n0.537282+0.992724i"
  },
  {
    "name": "atan",
    "description": "Calculates the inverse trigonometric tangent function (arctangent). Angle units are in radians. The function is defined for complex values. Phase of a complex number is evaluated between - π and π . If x is complex, or abs(x) > 1, the following equation is used:",
    "usage": "atan();",
    "category": "general",
    "markdown": "# atan\r\n\r\nCalculates the inverse trigonometric tangent function (arctangent). Angle units are in\r\nradians. The function is defined for complex values. Phase of a complex number is\r\nevaluated between - π and π . If x is complex, or abs(x) > 1, the following equation is\r\nused:\r\n\r\n$$ \\\\text{arctan(x)} = \\\\frac{i}{2}\\\\text{ln}(\\\\frac{i+x}{i-x}) $$\r\n\r\n| **Syntax**     | **Description**                                                           |\r\n| -------------- | ------------------------------------------------------------------------- |\r\n| out = atan(x); | Returns the complex arctangent of x. The range of atan is - π /2 to π /2. |\r\n\r\n**Example**\r\n\r\nPlot atan(y/x) for - π ≤ theta≤ π .\r\n\r\n```\r\ntheta=linspace(-pi,pi,1000);\r\nx=cos(theta);\r\ny=sin(theta);\r\nplot(theta*180/pi,atan(y/x)*180/pi,\"theta (deg)\",\"atan(y/x) (deg)\",\"atan(y/x)\");\r\nplot(y/x,atan(y/x)*180/pi,\"y/x\",\"atan(y/x) (deg)\",\"atan(y/x)\");\r\n```\r\n\r\nCalculate atan( π /4 + i).\r\n\r\n```\r\nx=pi/4+1i;\r\n?atan(x);\r\nresult: \r\n0.972497+0.50321i \r\n```",
    "summary": "Calculates the inverse trigonometric tangent function (arctangent)",
    "syntax": [
      {
        "syntax": "out = atan(x);",
        "description": "Returns the complex arctangent of x. The range of atan is - π /2 to π /2."
      }
    ],
    "example": "theta=linspace(-pi,pi,1000);\r\nx=cos(theta);\r\ny=sin(theta);\r\nplot(theta*180/pi,atan(y/x)*180/pi,\"theta (deg)\",\"atan(y/x) (deg)\",\"atan(y/x)\");\r\nplot(y/x,atan(y/x)*180/pi,\"y/x\",\"atan(y/x) (deg)\",\"atan(y/x)\");"
  },
  {
    "name": "atan2",
    "description": "Calculates the inverse trigonometric tangent function (arctangent) of y/x, returning the angle in the correct quadrant. Angle units are in radians. The function is defined for real values only.",
    "usage": "atan2();",
    "category": "general",
    "markdown": "# atan2\r\n\r\nCalculates the inverse trigonometric tangent function (arctangent) of y/x, returning the\r\nangle in the correct quadrant. Angle units are in radians. The function is defined for\r\nreal values only.\r\n\r\n| **Syntax**        | **Description**                                    |\r\n| ----------------- | -------------------------------------------------- |\r\n| out = atan2(y,x); | x,y must be real. The range of atan2 is - π to π . |\r\n\r\n**Example**\r\n\r\nPlot atan2(y,x) for - π ≤ theta≤ π .\r\n\r\n```\r\ntheta=linspace(-pi,pi,1000);\r\nx=cos(theta);\r\ny=sin(theta);\r\nplot(theta*180/pi,atan2(y,x)*180/pi,\"theta (deg)\",\"atan2(y,x) (deg)\",\"atan2(y,x)\");\r\nplot(y/x,atan2(y,x)*180/pi,\"y/x\",\"atan2(y,x) (deg)\",\"atan2(y,x)\");\r\n```\r\n\r\nCalculate atan2 at (1,1) and (1,-1). The angle is converted to degrees.\r\n\r\n```\r\n?atan2(1,1)*180/pi;\r\nresult: \r\n45 \r\n?atan2(1,-1)*180/pi;\r\nresult: \r\n135 \r\n```",
    "summary": "Calculates the inverse trigonometric tangent function (arctangent) of y/x, returning the angle in th...",
    "syntax": [
      {
        "syntax": "out = atan2(y,x);",
        "description": "x,y must be real. The range of atan2 is - π to π ."
      }
    ],
    "example": "theta=linspace(-pi,pi,1000);\r\nx=cos(theta);\r\ny=sin(theta);\r\nplot(theta*180/pi,atan2(y,x)*180/pi,\"theta (deg)\",\"atan2(y,x) (deg)\",\"atan2(y,x)\");\r\nplot(y/x,atan2(y,x)*180/pi,\"y/x\",\"atan2(y,x) (deg)\",\"atan2(y,x)\");"
  },
  {
    "name": "autoarrange",
    "description": "The script command arranges port positions and dimensions of compound or scripted elements automatically. Equivalently it can also be done by pressing ‘Arrange’ on the element port editor tab.",
    "usage": "autoarrange();",
    "category": "general",
    "markdown": "# autoarrange\r\n\r\nThe script command arranges port positions and dimensions of compound or scripted\r\nelements automatically. Equivalently it can also be done by pressing ‘Arrange’ on the\r\nelement port editor tab.\r\n\r\n| **Syntax**          | **Description**                                                                                                              |\r\n| ------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| autoarrange (name); | Arrange port positions and dimensions of compound or scripted elements automatically. This command does not return anything. |\r\n\r\n**Example**\r\n\r\nIf a compound named \"COMPOUND_1\" is created,using this command\r\n\r\n```\r\n autoarrange(\"COMPOUND_1\");\r\n```\r\n\r\nwill arrange the positions.",
    "summary": "The script command arranges port positions and dimensions of compound or scripted elements automatic...",
    "syntax": [
      {
        "syntax": "autoarrange (name);",
        "description": "Arrange port positions and dimensions of compound or scripted elements automatically. This command does not return anything."
      }
    ],
    "example": "autoarrange(\"COMPOUND_1\");"
  },
  {
    "name": "autosaveoff",
    "description": "This command turns off the feature to automatically save the current project before running a simulation.",
    "usage": "autosaveoff();",
    "category": "general",
    "markdown": "# autosaveoff\r\n\r\nThis command turns off the feature to automatically save the current project before\r\nrunning a simulation.\r\n\r\n| **Syntax**   | **Description**                                                                    |\r\n| ------------ | ---------------------------------------------------------------------------------- |\r\n| autosaveoff; | The project will not be saved automatically before running a simulation (default). |",
    "summary": "This command turns off the feature to automatically save the current project before running a simula...",
    "syntax": [
      {
        "syntax": "autosaveoff;",
        "description": "The project will not be saved automatically before running a simulation (default)."
      }
    ],
    "example": ""
  },
  {
    "name": "autosaveon",
    "description": "This command turns on the feature to automatically save the current project before running a simulation.",
    "usage": "autosaveon();",
    "category": "general",
    "markdown": "# autosaveon\r\n\r\nThis command turns on the feature to automatically save the current project before\r\nrunning a simulation.\r\n\r\nNote that this only applies to simulations, not sweeps. Running a sweep will always save\r\nthe project file before the sweep is run, regardless of the autosave setting.\r\n\r\n| **Syntax**  | **Description**                                                  |\r\n| ----------- | ---------------------------------------------------------------- |\r\n| autosaveon; | Automatically saves current project before running a simulation. |",
    "summary": "This command turns on the feature to automatically save the current project before running a simulat...",
    "syntax": [
      {
        "syntax": "autosaveon;",
        "description": "Automatically saves current project before running a simulation."
      }
    ],
    "example": ""
  },
  {
    "name": "bar",
    "description": "Plots a bar chart.",
    "usage": "bar();",
    "category": "general",
    "markdown": "# bar\r\n\r\nPlots a bar chart.\r\n\r\n| **Syntax**                               | **Description**                                                                                                                                                        |\r\n| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = bar(y);                            | Creates a bar plot where each bar corresponds to one element in y, which must be a 1D array. The figure number is returned.                                            |\r\n| bar(x,y);                                | x is a nx1 matrix. y is a nxm matrix. Creates m bar plots with n bars in the same figure for the elements in y at positions given by x. The figure number is returned. |\r\n| bar(x,y, \"x label\", \"y label\", \"title\"); | Creates a bar plot of y vs x with axis labels and a title, returns the figure number. The figure number is returned.                                                   |\r\n\r\n**Examples**\r\n\r\nThe following example generates the two bar plots shown below.\r\n\r\n```\r\nx = linspace(0,1,10);\r\ny1 = exp(-((x-0.2)/0.4)^2);\r\ny2 = exp(-((x-0.7)/0.3)^2);\r\ny = [y1,y2];\r\nbar(y1); # bar plot for y1, where each bar is labeled from 1 to 10\r\nbar(x,y); # bar plot for y1 and y2 at locations specified by x\r\n```\r\n\r\n|\\\r\n\\---|---",
    "summary": "Plots a bar chart",
    "syntax": [
      {
        "syntax": "out = bar(y);",
        "description": "Creates a bar plot where each bar corresponds to one element in y, which must be a 1D array. The figure number is returned."
      },
      {
        "syntax": "bar(x,y);",
        "description": "x is a nx1 matrix. y is a nxm matrix. Creates m bar plots with n bars in the same figure for the elements in y at positions given by x. The figure number is returned."
      },
      {
        "syntax": "bar(x,y, \"x label\", \"y label\", \"title\");",
        "description": "Creates a bar plot of y vs x with axis labels and a title, returns the figure number. The figure number is returned."
      }
    ],
    "example": ""
  },
  {
    "name": "besseli",
    "description": "Computes the modified Bessel function of the first kind.",
    "usage": "besseli();",
    "category": "general",
    "markdown": "# besseli\r\n\r\nComputes the modified Bessel function of the first kind.\r\n\r\n| **Syntax**          | **Description**                                                             |\r\n| ------------------- | --------------------------------------------------------------------------- |\r\n| out=besseli(nu, z); | \"nu\" is the order and \"z\" could be an array. Both nu and z need to be real. |\r\n\r\n**Example**\r\n\r\nThis example shows how to obtain the modified Bessel function of the first kind of the\r\narray z (for first order).\r\n\r\n```\r\nz = 0.2:0.2:1;\r\n?besseli(1,z);\r\nresult: \r\n0.100501 \r\n0.204027 \r\n0.313704 \r\n0.432865 \r\n0.565159      \r\n```",
    "summary": "Computes the modified Bessel function of the first kind",
    "syntax": [
      {
        "syntax": "out=besseli(nu, z);",
        "description": "\"nu\" is the order and \"z\" could be an array. Both nu and z need to be real."
      }
    ],
    "example": "z = 0.2:0.2:1;\r\n?besseli(1,z);\r\nresult: \r\n0.100501 \r\n0.204027 \r\n0.313704 \r\n0.432865 \r\n0.565159"
  },
  {
    "name": "besselj",
    "description": "Computes the Bessel function of the first kind.",
    "usage": "besselj();",
    "category": "general",
    "markdown": "# besselj\r\n\r\nComputes the Bessel function of the first kind.\r\n\r\n| **Syntax**          | **Description**                                                             |\r\n| ------------------- | --------------------------------------------------------------------------- |\r\n| out=besselj(nu, z); | \"nu\" is the order and \"z\" could be an array. Both nu and z need to be real. |\r\n\r\n**Example**\r\n\r\nThis example shows how to obtain the first order Bessel function of the first kind of\r\nthe array z.\r\n\r\n```\r\n>z = 0.2:0.2:1;\r\n>?besselj(1,z);\r\nresult: \r\n0.0995008 \r\n0.196027 \r\n0.286701 \r\n0.368842 \r\n0.440051     \r\n```",
    "summary": "Computes the Bessel function of the first kind",
    "syntax": [
      {
        "syntax": "out=besselj(nu, z);",
        "description": "\"nu\" is the order and \"z\" could be an array. Both nu and z need to be real."
      }
    ],
    "example": ">z = 0.2:0.2:1;\r\n>?besselj(1,z);\r\nresult: \r\n0.0995008 \r\n0.196027 \r\n0.286701 \r\n0.368842 \r\n0.440051"
  },
  {
    "name": "besselk",
    "description": "Computes the modified Bessel function of the second kind.",
    "usage": "besselk();",
    "category": "general",
    "markdown": "# besselk\r\n\r\nComputes the modified Bessel function of the second kind.\r\n\r\n| **Syntax**          | **Description**                                                             |\r\n| ------------------- | --------------------------------------------------------------------------- |\r\n| out=besselk(nu, z); | \"nu\" is the order and \"z\" could be an array. Both nu and z need to be real. |\r\n\r\n**Example**\r\n\r\nThis example shows how to obtain the modified Bessel function of the second kind of the\r\narray z (for first order).\r\n\r\n```\r\n>z = 0.2:0.2:1;\r\n>?besselk(1,z);\r\nresult: \r\n4.77597 \r\n2.18435 \r\n1.30283 \r\n0.861782 \r\n0.601907     \r\n```",
    "summary": "Computes the modified Bessel function of the second kind",
    "syntax": [
      {
        "syntax": "out=besselk(nu, z);",
        "description": "\"nu\" is the order and \"z\" could be an array. Both nu and z need to be real."
      }
    ],
    "example": ">z = 0.2:0.2:1;\r\n>?besselk(1,z);\r\nresult: \r\n4.77597 \r\n2.18435 \r\n1.30283 \r\n0.861782 \r\n0.601907"
  },
  {
    "name": "bessely",
    "description": "Computes the Bessel function of the second kind.",
    "usage": "bessely();",
    "category": "general",
    "markdown": "# bessely\r\n\r\nComputes the Bessel function of the second kind.\r\n\r\n| **Syntax**          | **Description**                                                             |\r\n| ------------------- | --------------------------------------------------------------------------- |\r\n| out=bessely(nu, z); | \"nu\" is the order and \"z\" could be an array. Both nu and z need to be real. |\r\n\r\n**Example**\r\n\r\nThis example shows how to obtain the first order Bessel function of the second kind of\r\nthe array z.\r\n\r\n```\r\n>z = 0.2:0.2:1;\r\n>?bessely(1,z);\r\nresult: \r\n-3.32382 \r\n-1.78087 \r\n-1.26039 \r\n-0.978144 \r\n-0.781213     \r\n```",
    "summary": "Computes the Bessel function of the second kind",
    "syntax": [
      {
        "syntax": "out=bessely(nu, z);",
        "description": "\"nu\" is the order and \"z\" could be an array. Both nu and z need to be real."
      }
    ],
    "example": ">z = 0.2:0.2:1;\r\n>?bessely(1,z);\r\nresult: \r\n-3.32382 \r\n-1.78087 \r\n-1.26039 \r\n-0.978144 \r\n-0.781213"
  },
  {
    "name": "bestoverlap",
    "description": "Finds the mode with highest (best) overlap between the specified D-CARD and the currently calculated modes in the mode list. Returns the name of the mode with the best overlap. This function is used for tracking the desired mode during parameter sweeps using the FDE solver.",
    "usage": "bestoverlap();",
    "category": "general",
    "markdown": "# bestoverlap\r\n\r\nFinds the mode with highest (best) overlap between the specified D-CARD and the\r\ncurrently calculated modes in the mode list. Returns the name of the mode with the best\r\noverlap. This function is used for tracking the desired mode during parameter sweeps\r\nusing the FDE solver.\r\n\r\nSee the [ overlap ](./overlap.md) function for more details about overlap and coupling\r\ncalculations.\r\n\r\n| **Syntax**                      | **Description**              |\r\n| ------------------------------- | ---------------------------- |\r\n| out = bestoverlap(\"test_mode\"); | Calculates the best overlap. |\r\n\r\n- out: a string containing the name of the mode with the best overlap\r\n- test_mode: a string containing the name of a D-CARD mode\r\n\r\n**Examples**\r\n\r\nThis example will calculate which of the current modes have the best overlap with the\r\nD-CARD named \"test_mode\". The effective index of the best mode is then returned.\r\n\r\n```\r\nmode_name = bestoverlap(\"test_mode\");  \r\nneff = getdata(mode_name,\"neff\");\r\n```",
    "summary": "Finds the mode with highest (best) overlap between the specified D-CARD and the currently calculated...",
    "syntax": [
      {
        "syntax": "out = bestoverlap(\"test_mode\");",
        "description": "Calculates the best overlap."
      }
    ],
    "example": ""
  },
  {
    "name": "bestoverlap2",
    "description": "This function is similar to [ bestoverlap ](./bestoverlap.md) but it uses [ expand2 ](./expand2.md) to get the necessary parameters, which can be useful when an evanescent mode is involved.",
    "usage": "bestoverlap2();",
    "category": "general",
    "markdown": "# bestoverlap2\r\n\r\nThis function is similar to [ bestoverlap ](./bestoverlap.md) but it uses\r\n[ expand2 ](./expand2.md) to get the necessary parameters, which can be useful when an\r\nevanescent mode is involved.\r\n\r\n| **Syntax**                       | **Description**              |\r\n| -------------------------------- | ---------------------------- |\r\n| out = bestoverlap2(\"test_mode\"); | Calculates the best overlap. |\r\n\r\n- out: a string containing the name of the mode with the best overlap\r\n- test_mode: a string containing the name of a D-CARD mode\r\n\r\nout = bestoverlap2(\"test_mode\", x,y,z); | Calculates the best overlap.\r\n\r\n- out: a string containing the name of the mode with the best overlap\r\n- test_mode: a string containing the name of a D-CARD mode\r\n\r\nMode alignment can be adjusted before best overlap is calculated.\r\n\r\n- x offset\r\n- y offset\r\n- z offset\r\n\r\nThe offset is applied to the test_mode.\r\n\r\n**Examples**\r\n\r\nThis example will calculate which of the current modes have the best overlap with the\r\nD-CARD named \"test_mode\". The effective index of the best mode is then returned.\r\n\r\n```\r\nmode_name = bestoverlap2(\"test_mode\");  \r\nneff = getdata(mode_name,\"neff\");\r\n```",
    "summary": "This function is similar to [ bestoverlap ](",
    "syntax": [
      {
        "syntax": "out = bestoverlap2(\"test_mode\");",
        "description": "Calculates the best overlap."
      }
    ],
    "example": ""
  },
  {
    "name": "break",
    "description": "Stops a script from executing.",
    "usage": "break();",
    "category": "general",
    "markdown": "# break\r\n\r\nStops a script from executing.\r\n\r\n| **Syntax** | **Description**                                                                                                           |\r\n| ---------- | ------------------------------------------------------------------------------------------------------------------------- |\r\n| break;     | Will stop a script file from executing at that line. A warning will be generated. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nThe script will stop at this line.\r\n\r\n```\r\nfor (i=1:100) {\r\n pause(1);\r\n break;\r\n}\r\nWarning: prompt line 3: break command\r\n```",
    "summary": "Stops a script from executing",
    "syntax": [
      {
        "syntax": "break;",
        "description": "Will stop a script file from executing at that line. A warning will be generated. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "buildmqwmaterial",
    "description": "Creates a struct with material parameters for use with [mqwgain](./mqwgain.md) and [mqwindex](https://optics.ansys.com/hc/en-us/articles/360041072553) commands.",
    "usage": "buildmqwmaterial();",
    "category": "general",
    "markdown": "# buildmqwmaterial\r\n\r\nCreates a struct with material parameters for use with [mqwgain](./mqwgain.md) and\r\n[mqwindex](https://optics.ansys.com/hc/en-us/articles/360041072553) commands.\r\n\r\n| **Syntax**                                                         | **Description**                                                                                                                                                                                                                                                             |\r\n| ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| result = buildmqwmaterial(location, T, matname, x);                | Ternary materials. location: string specifying the path to the database file. Alternatively, if empty struct, the default database will be used. T: temperature. matname: ternary material name. x: material composition. result: struct with material properties.          |\r\n| result = buildmqwmaterial(location, 300, matname, x, cbValley);    | same as above with the additional parameter cbValley that specifies which conduction band valleys will be included for the interpolation of parameters. Possible values: “Gamma”, “X”, “L”, or “All” (default is “Gamma”; option “All” uses the lowest band gap to select). |\r\n| result = buildmqwmaterial(location, 300, matname, x, y);           | Quaternary material with compositions x and y.                                                                                                                                                                                                                              |\r\n| result = buildmqwmaterial(location, 300, matname, x, y, cbValley); | Quaternary material with compositions x and y and the valley mixing specifier.                                                                                                                                                                                              |\r\n\r\nThe supported materials are listed in the table below:\r\n\r\n| **III-V semiconductors** | **Ternary alloys** | **Quaternary Alloys** |\r\n| ------------------------ | ------------------ | --------------------- |\r\n| AlAs                     | AlxGa1-xAs         | InxGa1-xAsyP1-y       |\r\n| GaAs                     | AlxGa1-xP          | AlxGayIn1-x-yAs       |\r\n| InAs                     | AlxIn1-xP          |                       |\r\n| AlP                      | GaAsxP1-x          |                       |\r\n| GaP                      | InxAl1-xAs         |                       |\r\n| InP                      | InAsxP1-x          |                       |\r\n| InxGa1-xAs               |                    |                       |\r\n| InxGa1-xP                |                    |                       |\r\n\r\nWhen database materials are used, the properties of ternary alloys P(AxB1−xD) are\r\ninterpolated from the corresponding properties of the base materials (P(AD) and P(BD))\r\naccording to the formula\r\n\r\n$$ P\\\\left(A_x\r\nB\\_{1-x}D\\\\right)=xP\\\\left(AD\\\\right)+\\\\left(1-x\\\\right)P\\\\left(BD\\\\right)+x\\\\left(1-x\\\\right)C,\r\n$$\r\n\r\nwhere x is the composition fraction and C is the bowing parameter (quadratic\r\ncoefficient).\r\n\r\nQuaternary alloys of type AxB1-xCyD1-y (two group III and two group V elements) are\r\ncomposed from the interpolation of ternary alloy constituents \\[1\\]:\r\n\r\n$$\r\nP\\\\left(A_xB\\_{1-x}C_yD\\_{1-y}\\\\right)=\\\\frac{x\\\\left(1-x\\\\right)\\\\left[\\\\left(1-y\\\\right)P\\\\left(A_xB\\_{1-x}D\\\\right)+yP\\\\left(A_xB\\_{1-x}C\\\\right)\\\\right]+y\\\\left(1-y\\\\right)\\\\left[xP\\\\left(AC_yD\\_{1-y}\\\\right)+\\\\left(1-x\\\\right)P\\\\left(BC_yD\\_{1-y}\\\\right)\\\\right]}{x\\\\left(1-x\\\\right)+y\\\\left(1-y\\\\right)},\r\n$$\r\n\r\nfor composition fractions x and y. For example, a combination of the properties of\r\nInxGa1−xP, InxGa1−xAs, InAsyP1−y, and GaAsyP1−y is used to define the properties of\r\nInxGa1−xAsyP1−y.\r\n\r\nQuaternary alloys of type AxByC1-x-yD (three group III elements and one group V element)\r\nare composed from the interpolation of ternary alloy constituents \\[1\\]:\r\n\r\n$$\r\nP\\\\left(A_xB_yC\\_{1-x-y}D\\\\right)=\\\\frac{xyP\\\\left(A\\_{1-u}B_uD\\\\right)+y(1-x-y)P\\\\left(B\\_{1-v}C\\_{v}D\\\\right)+x(1-x-y)P\\\\left(A\\_{1-w}C\\_{w}D\\\\right)}{xy+y(1-x-y)+x(1-x-y)},\r\n$$\r\n\r\nfor composition fractions x and y and u = (1-x+y)/2, v = (2-x-2y)/2, w = (2-2x-y)/2. For\r\nexample, a combination of the properties of Al1-uGauAs, Ga1-vInvAs, and Al1-wInwAs, is\r\nused to define the properties of AlxGayIn1-x-yAs.\r\n\r\n**result** is a struct with the following fields:\r\n\r\n| **Coefficient** | **Units** | **Description**                                                        |\r\n| --------------- | --------- | ---------------------------------------------------------------------- |\r\n| eg              | eV        | Band gap                                                               |\r\n| ep              | eV        | Energy parameter for the optical matrix element                        |\r\n| me              | 1/m0      | Electron effective mass                                                |\r\n| gamma1          |           | Luttinger parameter                                                    |\r\n| gamma2          |           | Luttinger parameter                                                    |\r\n| gamma3          |           | Luttinger parameter                                                    |\r\n| ac              | eV        | Conduction band deformation potential                                  |\r\n| av              | eV        | Valence band deformation potential                                     |\r\n| b               | eV        | Valence band deformation potential                                     |\r\n| c11             | N/m2      | Elastic stiffness coefficient                                          |\r\n| c12             | N/m2      | Elastic stiffness coefficient                                          |\r\n| lc              | m         | Lattice constant                                                       |\r\n| vb              | eV        | Valence band absolute energy (all layers should have common reference) |\r\n| eps             |           | Relative static permittivity                                           |\r\n\r\n**References**\r\n\r\n[1] Vurgaftman et al., J. Appl. Phys., 89, 5815 (2001)\r\n\r\n**Example**\r\n\r\n```\r\nmymat = buildmqwmaterial(“/home/auser/myfolder/my_material_db.json”, 300, “InAlAs”, 0.47);\r\n```",
    "summary": "Creates a struct with material parameters for use with [mqwgain](",
    "syntax": [
      {
        "syntax": "result = buildmqwmaterial(location, T, matname, x);",
        "description": "Ternary materials. location: string specifying the path to the database file. Alternatively, if empty struct, the default database will be used. T: temperature. matname: ternary material name. x: material composition. result: struct with material properties."
      },
      {
        "syntax": "result = buildmqwmaterial(location, 300, matname, x, cbValley);",
        "description": "same as above with the additional parameter cbValley that specifies which conduction band valleys will be included for the interpolation of parameters. Possible values: “Gamma”, “X”, “L”, or “All” (default is “Gamma”; option “All” uses the lowest band gap to select)."
      },
      {
        "syntax": "result = buildmqwmaterial(location, 300, matname, x, y);",
        "description": "Quaternary material with compositions x and y."
      },
      {
        "syntax": "result = buildmqwmaterial(location, 300, matname, x, y, cbValley);",
        "description": "Quaternary material with compositions x and y and the valley mixing specifier."
      }
    ],
    "example": "mymat = buildmqwmaterial(“/home/auser/myfolder/my_material_db.json”, 300, “InAlAs”, 0.47);"
  },
  {
    "name": "cadimport",
    "description": "Adds a structure to the simulation environment with structure geometry loaded from specified [STEP or CAD file](https://optics.ansys.com/hc/en-us/articles/360034398374). This command is identical to [stepimport](https://optics.ansys.com/hc/en-us/articles/360034404734-stepimport-Script-command).",
    "usage": "cadimport();",
    "category": "general",
    "markdown": "# cadimport\r\n\r\nAdds a structure to the simulation environment with structure geometry loaded from\r\nspecified [STEP or CAD file](https://optics.ansys.com/hc/en-us/articles/360034398374).\r\nThis command is identical to\r\n[stepimport](https://optics.ansys.com/hc/en-us/articles/360034404734-stepimport-Script-command).\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                |\r\n| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| stepimport(\"filename\",scale_factor); | Add new structures from a specified CAD file. The list of supported file formats can be found in the Knowledge Base article on [CAD import](https://optics.ansys.com/hc/en-us/articles/360034398374). SCALE_FACTOR (optional): |\r\n\r\n- Allowed values are 3, 0, -3, -6, -9, corresponding to the options of the STEP import\r\n  dialog in Ansys Lumerical Multiphysics™. For example, the value -9 means that a file\r\n  saved in meters will be read as if in nanometers. Structures will be imported as\r\n  \\\\(10^{-9}\\\\) times the actual size.\r\n\r\n- When 'scale_factor' is omitted, 'no scaling' is applied\r\n\r\n## This function does not return any data.<br /> Note: How to handle the \"Model size exceeds valid box\" error The geometry in the finite-element IDE cannot exceed a maximum size, a fixed number of length units. This error can be avoided by changing the solver to use a larger length unit, or by supplying a smaller 'scale_factor' argument.\r\n\r\n**Example**\r\n\r\nThe following script commands is used to create a 3D geometry based on the STEP file\r\nprovided in the Knowledge Base article on\r\n[CAD import](https://optics.ansys.com/hc/en-us/articles/360034398374).\r\n\r\n```\r\nfilename = \"stepimport.step\";  \r\ncadimport(filename);\r\n```\r\n\r\nThe following script commands is used to create a 3D geometry based on the SolidWork\r\nfile provided in the Knowledge Base article on\r\n[CAD import](https://optics.ansys.com/hc/en-us/articles/360034398374), using a scaling\r\nfactor of \\\\(10^{-6}\\\\).\r\n\r\n```\r\nfilename = \"Caliper.SLDPRT\";  \r\ncadimport(filename, -6);\r\n```",
    "summary": "Adds a structure to the simulation environment with structure geometry loaded from specified [STEP o...",
    "syntax": [
      {
        "syntax": "stepimport(\"filename\",scale_factor);",
        "description": "Add new structures from a specified CAD file. The list of supported file formats can be found in the Knowledge Base article on [CAD import](https://optics.ansys.com/hc/en-us/articles/360034398374). SCALE_FACTOR (optional):"
      }
    ],
    "example": "filename = \"stepimport.step\";  \r\ncadimport(filename);"
  },
  {
    "name": "cd",
    "description": "Changes the directory. The directory is where the file is saved by default.",
    "usage": "cd();",
    "category": "general",
    "markdown": "# cd\r\n\r\nChanges the directory. The directory is where the file is saved by default.\r\n\r\n| **Syntax**       | **Description**                                                                                                                                                          |\r\n| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| cd;              | Opens a window to browse to a directory. This function does not return any data.                                                                                         |\r\n| cd(\"directory\"); | Changes the working directory to \"directory\". Whenever you open an fsp file or run a script file, it will set the working directory to the directory of the file opened. |\r\n\r\n**Examples**\r\n\r\nMoves to the subdirectory \"data\".\r\n\r\n```\r\n?pwd;\r\nC:\\demo\r\npath=pwd;\r\ncd(path+\"\\data\");\r\n?pwd;\r\nC:\\demo\\data\r\n```",
    "summary": "Changes the directory",
    "syntax": [
      {
        "syntax": "cd;",
        "description": "Opens a window to browse to a directory. This function does not return any data."
      },
      {
        "syntax": "cd(\"directory\");",
        "description": "Changes the working directory to \"directory\". Whenever you open an fsp file or run a script file, it will set the working directory to the directory of the file opened."
      }
    ],
    "example": ""
  },
  {
    "name": "ceil",
    "description": "Rounds the input to the nearest integer greater than or equal to itself.",
    "usage": "ceil();",
    "category": "general",
    "markdown": "# ceil\r\n\r\nRounds the input to the nearest integer greater than or equal to itself.\r\n\r\n| **Syntax**     | **Description**                                         |\r\n| -------------- | ------------------------------------------------------- |\r\n| out = ceil(x); | Returns the nearest integer greater than or equal to x. |\r\n\r\n**Example**\r\n\r\nFind the nearest integer greater than or equal to 1.41:\r\n\r\n```\r\n?ceil(1.41);\r\nresult:\r\n2\r\n```",
    "summary": "Rounds the input to the nearest integer greater than or equal to itself",
    "syntax": [
      {
        "syntax": "out = ceil(x);",
        "description": "Returns the nearest integer greater than or equal to x."
      }
    ],
    "example": "?ceil(1.41);\r\nresult:\r\n2"
  },
  {
    "name": "cell",
    "description": "Creates a cell array variable with specified number of elements. The cell array element can be any data type, such as matrix, string, and dataset.",
    "usage": "cell();",
    "category": "general",
    "markdown": "# cell\r\n\r\nCreates a cell array variable with specified number of elements. The cell array element\r\ncan be any data type, such as matrix, string, and dataset.\r\n\r\nSince Lumerical 2019b R4 version, users can also declare a cell by using the braces and\r\nsquare brackets declaration method.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                                                                             |\r\n| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| a = {\"a\", \"b\", 1, 2.3} | Creates and initializes a cell array.                                                                                                                                                                                       |\r\n| a = cell(n);           | Creates a cell array with n elements.                                                                                                                                                                                       |\r\n| a{n} = \"string\";       | Adds a string to the specified element of the cell array.                                                                                                                                                                   |\r\n| a{n} = matrix(5,5);    | Adds a field of matrix of 5x5 to the specified element of the cell array.                                                                                                                                                   |\r\n| a.append(value);       | Appends a value to the end of the cell array.                                                                                                                                                                               |\r\n| a.insert(value,index); | Inserts a value at index, pushing all elements after the index back, and extending the cell array length by 1. The index must be less than or equal to the current array length, else an error will be thrown.              |\r\n| a.remove(index);       | Removes a value at the specified index, pulling all elements after the index forward, and shortening the array length by 1. The index must be less than or equal to the current array length, else an error will be thrown. |\r\n| a.pop;                 | Removes and returns the last value from the cell array.                                                                                                                                                                     |\r\n| a.clear;               | Removes all items from the cell array.                                                                                                                                                                                      |\r\n\r\n**Examples**\r\n\r\nA cell can be created and initialized quickly as follows:\r\n\r\n```\r\nmyCell = {\"a\", \"b\", 1, 2.3};   \r\n  \r\n# cell with struct  \r\nmyCellWithStruct = {\"a\", {\"b\" : 2, \"c\" : 3}};\r\n```\r\n\r\nThe above cell can also be declared more pedantically:\r\n\r\n```\r\nmyCell = cell(4);  \r\nmyCell{1} = \"a\";  \r\nmyCell{2} = \"b\";  \r\nmyCell{3} = 1;  \r\nmyCell{4} = 2.3;  \r\n\r\n# cell with struct  \r\nmyCellWithStruct = cell(2);  \r\nmyCellWithStruct{1} = \"a\";  \r\nmyCellWithStruct{2} = struct;  \r\nmyCellWithStruct{2}.b = 2;  \r\nmyCellWithStruct{2}.c = 3;\r\n```\r\n\r\nThe above declaration methods are equivalent and will produce the same output:\r\n\r\n```\r\n?myCell;  \r\nCell array with 4 elements  \r\n\r\n?myCell{1};  \r\na  \r\n\r\n?myCellWithStruct;  \r\nCell array with 2 elements  \r\n\r\n?myCellWithStruct{1};  \r\na  \r\n\r\n?myCellWithStruct{2};  \r\nStruct with fields:  \r\nb  \r\nc  \r\n\r\n?myCellWithStruct{2}.b;  \r\nresult:   \r\n2  \r\n```\r\n\r\nItems can be added, removed, and appended from the cell array with array functions:\r\n\r\n```\r\nmyCell.append(“c”); #Append “c” to the end of the cell array  \r\n?myCell{5}; #The array will be {“a”,”b”,1,2.3,”c”} after append  \r\nresult:  \r\nc  \r\n?myCell;  \r\nCell array with 5 elements  \r\n  \r\nmyCell.insert(2,matrix(2,2)); #Add a 2x2 matrix filled with zeroes at index 2  \r\n  \r\n?myCell{2}; #The array will be {“a”, matrix(2,2), ”b” ,1,2.3,”c”} after insertion  \r\n0 0   \r\n0 0   \r\n  \r\nmyCell.remove(2); #Remove the newly added matrix at index 2  \r\n?myCell(2); #The array will be {“a”,”b”,1,2.3,”c”} after removal  \r\nb  \r\n  \r\n?myCell;  \r\nCell array with 5 elements  \r\n  \r\npopped = myCell.pop; #Remove the last element (“c”) and assign it to new variable “popped”  \r\n?myCell;  \r\nCell array with 4 elements  \r\n?popped;  \r\nc  \r\n  \r\nmyCell.clear; #Clear all elements of cell array  \r\n?myCell;  \r\nCell array with 0 elements\r\n```\r\n\r\nWhen two or more objects have similar properties, such as spatial location of \"x\" and\r\n\"y\", one can define a \"cell\" with \"x\" and \"y\", and get their values:\r\n\r\n```\r\n    propxy = {\"x\",\"y\"};  \r\n    out1 = getnamed(\"rectangle\",propxy);  \r\n    out2 = getnamed(\"monitor\",propxy);  \r\n    ?out1.x;  \r\n    ?out2.y; \r\n```\r\n\r\nIn the above example, geometry \"rectangle\" and monitor \"monitor\" both have \"x\" and \"y\"\r\nproperties.",
    "summary": "Creates a cell array variable with specified number of elements",
    "syntax": [
      {
        "syntax": "a = {\"a\", \"b\", 1, 2.3}",
        "description": "Creates and initializes a cell array."
      },
      {
        "syntax": "a = cell(n);",
        "description": "Creates a cell array with n elements."
      },
      {
        "syntax": "a{n} = \"string\";",
        "description": "Adds a string to the specified element of the cell array."
      },
      {
        "syntax": "a{n} = matrix(5,5);",
        "description": "Adds a field of matrix of 5x5 to the specified element of the cell array."
      },
      {
        "syntax": "a.append(value);",
        "description": "Appends a value to the end of the cell array."
      },
      {
        "syntax": "a.insert(value,index);",
        "description": "Inserts a value at index, pushing all elements after the index back, and extending the cell array length by 1. The index must be less than or equal to the current array length, else an error will be thrown."
      },
      {
        "syntax": "a.remove(index);",
        "description": "Removes a value at the specified index, pulling all elements after the index forward, and shortening the array length by 1. The index must be less than or equal to the current array length, else an error will be thrown."
      },
      {
        "syntax": "a.pop;",
        "description": "Removes and returns the last value from the cell array."
      },
      {
        "syntax": "a.clear;",
        "description": "Removes all items from the cell array."
      }
    ],
    "example": ""
  },
  {
    "name": "centroid",
    "description": "Returns the center of mass of a polygon assuming uniform density.",
    "usage": "centroid();",
    "category": "general",
    "markdown": "# centroid\r\n\r\nReturns the center of mass of a polygon assuming uniform density.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**         | **Description**                                                                                                           |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------- |\r\n| out = centroid(V); | Returns the center of mass of V, assuming uniform density. The output is a 2x1 matrix representing the x and y positions. |\r\n\r\n**Example**\r\n\r\nCalculate the centroid of a square of side length 1:\r\n\r\n```\r\nV = [ 0,0; 1,0; 1,1; 0,1];\r\n?centroid(V);\r\nresult: \r\n0.5 0.5\r\n```",
    "summary": "Returns the center of mass of a polygon assuming uniform density",
    "syntax": [
      {
        "syntax": "out = centroid(V);",
        "description": "Returns the center of mass of V, assuming uniform density. The output is a 2x1 matrix representing the x and y positions."
      }
    ],
    "example": "V = [ 0,0; 1,0; 1,1; 0,1];\r\n?centroid(V);\r\nresult: \r\n0.5 0.5"
  },
  {
    "name": "chebin",
    "description": "Returns the Chebyshev interpolation of a sampled function. Chebyshev interpolation is useful for accurately interpolating a smooth function using a very small number of samples. The key requirement for this type of interpolation to work is that the function is sampled on the Chebyshev roots grid.",
    "usage": "chebin();",
    "category": "general",
    "markdown": "# chebin\r\n\r\nReturns the Chebyshev interpolation of a sampled function. Chebyshev interpolation is\r\nuseful for accurately interpolating a smooth function using a very small number of\r\nsamples. The key requirement for this type of interpolation to work is that the function\r\nis sampled on the Chebyshev roots grid.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                           |\r\n| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| chebin(f,x,xi,xmin,xmax) | Interpolates the function f onto the xi points. It assumes that f contains the samples of the function taken on the Chebyshev roots grid specified in x; x must be constructed by the call # x = chpts(xmin,xmax,NumPts), otherwise an error is returned. |\r\n\r\n**Example**\r\n\r\nSee example for the chpts command.",
    "summary": "Returns the Chebyshev interpolation of a sampled function",
    "syntax": [
      {
        "syntax": "chebin(f,x,xi,xmin,xmax)",
        "description": "Interpolates the function f onto the xi points. It assumes that f contains the samples of the function taken on the Chebyshev roots grid specified in x; x must be constructed by the call # x = chpts(xmin,xmax,NumPts), otherwise an error is returned."
      }
    ],
    "example": ""
  },
  {
    "name": "chebpol",
    "description": "Generates the Chebyshev polynomials of the first kind. This command can be used in combination with dcht to calculate the Chebyshev interpolation. Compared to the chebin command, using chebpol for the interpolation offers additional control over the interpolation process as it allows the user to specify the polynomial order.",
    "usage": "chebpol();",
    "category": "general",
    "markdown": "# chebpol\r\n\r\nGenerates the Chebyshev polynomials of the first kind. This command can be used in\r\ncombination with dcht to calculate the Chebyshev interpolation. Compared to the chebin\r\ncommand, using chebpol for the interpolation offers additional control over the\r\ninterpolation process as it allows the user to specify the polynomial order.\r\n\r\n| **Syntax**              | **Description**                                                                                                                          |\r\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |\r\n| chebpol(N,xi,xmin,xmax) | This command generates a matrix containing the Chebyshev polynomials of the first kind of orders zero to N-1 evaluated at the xi points. |\r\n\r\n**Example**\r\n\r\nThis example uses chebpol to interpolate function f and compares the results to the\r\noriginal points.\r\n\r\n```\r\nclear;\r\ncloseall;\r\n# Sample function on Chebyshev grid \r\nxmin = 0.0;\r\nxmax = 1.0;\r\nNc = 11;\r\nx = chpts(xmin,xmax,Nc);\r\nf = cos(2.0*pi*x)+1i*sin(2.0*pi*x); \r\nNi = 100;\r\nxi = linspace(xmin,xmax,Ni);\r\n# Chebyshev interpolation done by hand\r\ndchtf = dcht(f);\r\nTx = chebpol(length(f),xi,xmin,xmax);\r\nfi = mult(Tx,dchtf);\r\nplot(xi,fi,\"x\",\"f(x)\",\"Function Interpolated by Hand\");\r\nholdon;\r\nplot(x,f,\"x\",\"f(x)\",\"Function Interpolated by Hand\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re - Interpolated\",\"Im - Interpolated\",\"Re - Exact\",\"Im - Exact\");\r\nsetplot(\"y1 max\",1.05);\r\nsetplot(\"y1 min\",-1.05);\r\nsetplot(\"y2 max\",1.05);\r\nsetplot(\"y2 min\",-1.05);\r\n```",
    "summary": "Generates the Chebyshev polynomials of the first kind",
    "syntax": [
      {
        "syntax": "chebpol(N,xi,xmin,xmax)",
        "description": "This command generates a matrix containing the Chebyshev polynomials of the first kind of orders zero to N-1 evaluated at the xi points."
      }
    ],
    "example": "clear;\r\ncloseall;\r\n# Sample function on Chebyshev grid \r\nxmin = 0.0;\r\nxmax = 1.0;\r\nNc = 11;\r\nx = chpts(xmin,xmax,Nc);\r\nf = cos(2.0*pi*x)+1i*sin(2.0*pi*x); \r\nNi = 100;\r\nxi = linspace(xmin,xmax,Ni);\r\n# Chebyshev interpolation done by hand\r\ndchtf = dcht(f);\r\nTx = chebpol(length(f),xi,xmin,xmax);\r\nfi = mult(Tx,dchtf);\r\nplot(xi,fi,\"x\",\"f(x)\",\"Function Interpolated by Hand\");\r\nholdon;\r\nplot(x,f,\"x\",\"f(x)\",\"Function Interpolated by Hand\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re - Interpolated\",\"Im - Interpolated\",\"Re - Exact\",\"Im - Exact\");\r\nsetplot(\"y1 max\",1.05);\r\nsetplot(\"y1 min\",-1.05);\r\nsetplot(\"y2 max\",1.05);\r\nsetplot(\"y2 min\",-1.05);"
  },
  {
    "name": "chebpol1",
    "description": "Returns the first derivative of the Chebyshev polynomials of the first kind.",
    "usage": "chebpol1();",
    "category": "general",
    "markdown": "# chebpol1\r\n\r\nReturns the first derivative of the Chebyshev polynomials of the first kind.\r\n\r\n| **Syntax**               | **Description**                                                                                                                          |\r\n| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |\r\n| chebpol1(N,xi,xmin,xmax) | This command generates a matrix containing the Chebyshev polynomials of the first kind of orders zero to N-1 evaluated at the xi points. |\r\n\r\n**Example**\r\n\r\nThis example uses chebpol1 to calculate the first derivative of a function f sampled on\r\na Chebishev grid.\r\n\r\n```\r\nclear;\r\ncloseall;\r\n# Sample function on Chebyshev grid \r\nxmin = 0.0;\r\nxmax = 1.0;\r\nNc = 11;\r\nx = chpts(xmin,xmax,Nc);\r\nf = cos(2.0*pi*x)+1i*sin(2.0*pi*x); # function and\r\nfp = -2.0*pi*sin(2*pi*x)+1i*2.0*pi*cos(2.0*pi*x); # its derivative\r\nNi = 100;\r\nxi = linspace(xmin,xmax,Ni);\r\n# Function derivative from Chebyshev transform\r\ndchtf = dcht(f);\r\nTxp = chebpol1(length(f),xi,xmin,xmax);\r\nfip = mult(Txp,dchtf);\r\nplot(xi,fip,\"x\",\"f'(x)\",\"Function Derivative\");\r\nholdon;\r\nplot(x,fp,\"x\",\"f'(x)\",\"Function Derivative\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re - Interpolated\",\"Im - Interpolated\",\"Re - Exact\",\"Im - Exact\");\r\nsetplot(\"y1 max\",8);\r\nsetplot(\"y1 min\",-8);\r\nsetplot(\"y2 max\",8);\r\nsetplot(\"y2 min\",-8);\r\n```",
    "summary": "Returns the first derivative of the Chebyshev polynomials of the first kind",
    "syntax": [
      {
        "syntax": "chebpol1(N,xi,xmin,xmax)",
        "description": "This command generates a matrix containing the Chebyshev polynomials of the first kind of orders zero to N-1 evaluated at the xi points."
      }
    ],
    "example": "clear;\r\ncloseall;\r\n# Sample function on Chebyshev grid \r\nxmin = 0.0;\r\nxmax = 1.0;\r\nNc = 11;\r\nx = chpts(xmin,xmax,Nc);\r\nf = cos(2.0*pi*x)+1i*sin(2.0*pi*x); # function and\r\nfp = -2.0*pi*sin(2*pi*x)+1i*2.0*pi*cos(2.0*pi*x); # its derivative\r\nNi = 100;\r\nxi = linspace(xmin,xmax,Ni);\r\n# Function derivative from Chebyshev transform\r\ndchtf = dcht(f);\r\nTxp = chebpol1(length(f),xi,xmin,xmax);\r\nfip = mult(Txp,dchtf);\r\nplot(xi,fip,\"x\",\"f'(x)\",\"Function Derivative\");\r\nholdon;\r\nplot(x,fp,\"x\",\"f'(x)\",\"Function Derivative\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re - Interpolated\",\"Im - Interpolated\",\"Re - Exact\",\"Im - Exact\");\r\nsetplot(\"y1 max\",8);\r\nsetplot(\"y1 min\",-8);\r\nsetplot(\"y2 max\",8);\r\nsetplot(\"y2 min\",-8);"
  },
  {
    "name": "checkout",
    "description": "Checks out a licensed feature.",
    "usage": "checkout();",
    "category": "general",
    "markdown": "# checkout\r\n\r\nChecks out a licensed feature.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                                                  |\r\n| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| checkout(featureID); | Checks out and reserve a licensed feature. If the feature cannot be checked out, an error message will be shown in the Script Prompt window. The license will remain be checked out until the application quits. |\r\n\r\n**Example**\r\n\r\n```\r\ncheckout(\"INTERCONNECT_block_mode\");\r\n#If INTERCONNECT_block_mode license does not exist, the following message will be shown\r\nError: The license feature 'INTERCONNECT_block_mode' does not exist on ... \r\n```",
    "summary": "Checks out a licensed feature",
    "syntax": [
      {
        "syntax": "checkout(featureID);",
        "description": "Checks out and reserve a licensed feature. If the feature cannot be checked out, an error message will be shown in the Script Prompt window. The license will remain be checked out until the application quits."
      }
    ],
    "example": "checkout(\"INTERCONNECT_block_mode\");\r\n#If INTERCONNECT_block_mode license does not exist, the following message will be shown\r\nError: The license feature 'INTERCONNECT_block_mode' does not exist on ..."
  },
  {
    "name": "chol",
    "description": "Calculates the Cholesky lower triangular factorization or decomposition. For a given matrix A, chol returns a lower triangular matrix L such that A is the matrix product of L and its conjugate transpose. The matrix A can be real or complex but it must be Hermitian and positive-definite.",
    "usage": "chol();",
    "category": "general",
    "markdown": "# chol\r\n\r\nCalculates the Cholesky lower triangular factorization or decomposition. For a given\r\nmatrix A, chol returns a lower triangular matrix L such that A is the matrix product of\r\nL and its conjugate transpose. The matrix A can be real or complex but it must be\r\nHermitian and positive-definite.\r\n\r\n| **Syntax**   | **Description**                                                                           |\r\n| ------------ | ----------------------------------------------------------------------------------------- |\r\n| L = chol(A); | Returns a lower triangular matrix L that satisfies the equation A = mult(L,ctranspose(L)) |\r\n\r\n**Example**\r\n\r\nFind the Cholesky decomposition of a 3x3 matrix.\r\n\r\n```\r\n?A = [4, 12, -16; 12, 37, -43; -16,-43,98];\r\n?L = chol(A);\r\n?mult(L,ctranspose(L)); #This should be the same as A\r\nresult: \r\n4  12  -16  \r\n12  37  -43  \r\n-16  -43  98  \r\nresult: \r\n2+0i  0+0i  0+0i  \r\n6+0i  1+0i  0+0i  \r\n-8+0i  5+0i  3+0i  \r\nresult: \r\n4+0i  12+0i  -16+0i  \r\n12+0i  37+0i  -43+0i  \r\n-16+0i  -43+0i  98+0i  \r\n```",
    "summary": "Calculates the Cholesky lower triangular factorization or decomposition",
    "syntax": [
      {
        "syntax": "L = chol(A);",
        "description": "Returns a lower triangular matrix L that satisfies the equation A = mult(L,ctranspose(L))"
      }
    ],
    "example": "?A = [4, 12, -16; 12, 37, -43; -16,-43,98];\r\n?L = chol(A);\r\n?mult(L,ctranspose(L)); #This should be the same as A\r\nresult: \r\n4  12  -16  \r\n12  37  -43  \r\n-16  -43  98  \r\nresult: \r\n2+0i  0+0i  0+0i  \r\n6+0i  1+0i  0+0i  \r\n-8+0i  5+0i  3+0i  \r\nresult: \r\n4+0i  12+0i  -16+0i  \r\n12+0i  37+0i  -43+0i  \r\n-16+0i  -43+0i  98+0i"
  },
  {
    "name": "chpts",
    "description": "Samples function on a Chebyshev grid. Chebyshev interpolation is useful for accurately interpolating a smooth function using a very small number of samples. The key requirement for this type of interpolation to work is that the function is sampled on the Chebyshev roots grid, which can be done by using this command.",
    "usage": "chpts();",
    "category": "general",
    "markdown": "# chpts\r\n\r\nSamples function on a Chebyshev grid. Chebyshev interpolation is useful for accurately\r\ninterpolating a smooth function using a very small number of samples. The key\r\nrequirement for this type of interpolation to work is that the function is sampled on\r\nthe Chebyshev roots grid, which can be done by using this command.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                                                                                                                                                                                   |\r\n| --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| x=chpts(xmin,xmax,NumPts,option); | Returns Chebyshev roots grid on interval between xmin and xmax that can be used to sample a smooth function. NumPts defines the number of points on given interval. Option: If option=1 is selected, the vector x will not include the endpoints If option=2 is selected, the vector x will include the endpoints |\r\n\r\n**Example**\r\n\r\nThis example uses the chpts to sample a smooth function on an interval from 0 to 1 with\r\n7 points. The function is then interpolated with chebin command and compared with the\r\noriginal sampled function.\r\n\r\n```\r\n# Sample function on Chebyshev grid\r\nxmin = 0;\r\nxmax = 1;\r\nNc = 7;\r\nx = chpts(xmin,xmax,Nc,1);\r\nf = exp(1i*2*pi*x);\r\n###############################################################\r\n# Interpolation and comparison to the original sampled function\r\n# Fine sampling for display\r\nNi = 500;\r\nxi = linspace(xmin,xmax,Ni);\r\nfi = exp(1i*2*pi*xi);\r\n# Plot function and its samples on the Chebyshev grid\r\nplot(xi,fi,\"x\",\"f(x)\",\"Original Function\");\r\nholdon;\r\nplot(x,f,\"x\",\"f(x)\",\"Original Function\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re(f(x))\",\"Im(f(x))\",\"Re Cheb\",\"Im Cheb\");\r\nsetplot(\"y max\",1);\r\nsetplot(\"y min\",-1);\r\n# Chebyshev interpolation\r\nfi = chebin(f,x,xi,xmin,xmax);\r\n# Plot function and its samples on the Chebyshev grid\r\nplot(xi,fi,\"x\",\"f(x)\",\"Interpolated Function\");\r\nholdon;\r\nplot(x,f,\"x\",\"f(x)\",\"Interpolated Function\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re(f(x))\",\"Im(f(x))\",\"Re Cheb\",\"Im Cheb\");\r\nsetplot(\"y max\",1);\r\nsetplot(\"y min\",-1);\r\n```",
    "summary": "Samples function on a Chebyshev grid",
    "syntax": [
      {
        "syntax": "x=chpts(xmin,xmax,NumPts,option);",
        "description": "Returns Chebyshev roots grid on interval between xmin and xmax that can be used to sample a smooth function. NumPts defines the number of points on given interval. Option: If option=1 is selected, the vector x will not include the endpoints If option=2 is selected, the vector x will include the endpoints"
      }
    ],
    "example": "# Sample function on Chebyshev grid\r\nxmin = 0;\r\nxmax = 1;\r\nNc = 7;\r\nx = chpts(xmin,xmax,Nc,1);\r\nf = exp(1i*2*pi*x);\r\n###############################################################\r\n# Interpolation and comparison to the original sampled function\r\n# Fine sampling for display\r\nNi = 500;\r\nxi = linspace(xmin,xmax,Ni);\r\nfi = exp(1i*2*pi*xi);\r\n# Plot function and its samples on the Chebyshev grid\r\nplot(xi,fi,\"x\",\"f(x)\",\"Original Function\");\r\nholdon;\r\nplot(x,f,\"x\",\"f(x)\",\"Original Function\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re(f(x))\",\"Im(f(x))\",\"Re Cheb\",\"Im Cheb\");\r\nsetplot(\"y max\",1);\r\nsetplot(\"y min\",-1);\r\n# Chebyshev interpolation\r\nfi = chebin(f,x,xi,xmin,xmax);\r\n# Plot function and its samples on the Chebyshev grid\r\nplot(xi,fi,\"x\",\"f(x)\",\"Interpolated Function\");\r\nholdon;\r\nplot(x,f,\"x\",\"f(x)\",\"Interpolated Function\",\"plot points\");\r\nholdoff;\r\nlegend(\"Re(f(x))\",\"Im(f(x))\",\"Re Cheb\",\"Im Cheb\");\r\nsetplot(\"y max\",1);\r\nsetplot(\"y min\",-1);"
  },
  {
    "name": "clear",
    "description": "Clears all or specified stored workspace variables. This will not clear any simulation data stored in d-cards. The variables c, pi, eps0, mu0 will be reset to their default values.",
    "usage": "clear();",
    "category": "general",
    "markdown": "# clear\r\n\r\nClears all or specified stored workspace variables. This will not clear any simulation\r\ndata stored in d-cards. The variables c, pi, eps0, mu0 will be reset to their default\r\nvalues.\r\n\r\n| **Syntax**              | **Description**                                                         |\r\n| ----------------------- | ----------------------------------------------------------------------- |\r\n| clear;                  | Clears all workspace variables. This function does not return any data. |\r\n| clear(var1, var2, ...); | Clears only the workspace variables with the specified names.           |",
    "summary": "Clears all or specified stored workspace variables",
    "syntax": [
      {
        "syntax": "clear;",
        "description": "Clears all workspace variables. This function does not return any data."
      },
      {
        "syntax": "clear(var1, var2, ...);",
        "description": "Clears only the workspace variables with the specified names."
      }
    ],
    "example": ""
  },
  {
    "name": "clearanalysis",
    "description": "Clears analysis object results. This data is also cleared by switching from Analysis Mode to Layout Mode.",
    "usage": "clearanalysis();",
    "category": "general",
    "markdown": "# clearanalysis\r\n\r\nClears analysis object results. This data is also cleared by switching from Analysis\r\nMode to Layout Mode.\r\n\r\nNote: The analysis object results are calculated with the runanalysis command.\r\n\r\n| **Syntax**                             | **Description**                                                         |\r\n| -------------------------------------- | ----------------------------------------------------------------------- |\r\n| clearanalysis;                         | Clears analysis object results. This function does not return any data. |\r\n| clearanalysis( \"name1\", \"name2\", ...); | Clears data from specific analysis objects.                             |",
    "summary": "Clears analysis object results",
    "syntax": [
      {
        "syntax": "clearanalysis;",
        "description": "Clears analysis object results. This function does not return any data."
      },
      {
        "syntax": "clearanalysis( \"name1\", \"name2\", ...);",
        "description": "Clears data from specific analysis objects."
      }
    ],
    "example": ""
  },
  {
    "name": "cleardataset",
    "description": "This command clears the dataset from any current 'np Density' grid attribute. This is only useful for keeping file size small.",
    "usage": "cleardataset();",
    "category": "general",
    "markdown": "# cleardataset\r\n\r\nThis command clears the dataset from any current 'np Density' grid attribute. This is\r\nonly useful for keeping file size small.\r\n\r\n| **Syntax**    | **Description**                                      |\r\n| ------------- | ---------------------------------------------------- |\r\n| cleardataset; | Clears the dataset from the selected grid attribute. |\r\n\r\n**Examples**\r\n\r\nThis example shows how to import an unstructured dataset 'charge' to the 'np Density'\r\ngrid attribute.\r\n\r\n```\r\nselect(\"np density\");\r\nimportdataset(\"device_data.mat\");\r\ncleardataset;\r\n```",
    "summary": "This command clears the dataset from any current 'np Density' grid attribute",
    "syntax": [
      {
        "syntax": "cleardataset;",
        "description": "Clears the dataset from the selected grid attribute."
      }
    ],
    "example": ""
  },
  {
    "name": "cleardcard",
    "description": "Clears global d-cards. Only global d-cards are cleared. Local d-cards are associated with the current simulation and can only be cleared by switching from Analysis Mode to Layout Mode.",
    "usage": "cleardcard();",
    "category": "general",
    "markdown": "# cleardcard\r\n\r\nClears global d-cards. Only global d-cards are cleared. Local d-cards are associated\r\nwith the current simulation and can only be cleared by switching from Analysis Mode to\r\nLayout Mode.\r\n\r\n| **Syntax**                          | **Description**                                                        |\r\n| ----------------------------------- | ---------------------------------------------------------------------- |\r\n| cleardcard;                         | Clears all the global d-cards. This function does not return any data. |\r\n| cleardcard( \"name1\", \"name2\", ...); | Clears any number of specified d-cards.                                |",
    "summary": "Clears global d-cards",
    "syntax": [
      {
        "syntax": "cleardcard;",
        "description": "Clears all the global d-cards. This function does not return any data."
      },
      {
        "syntax": "cleardcard( \"name1\", \"name2\", ...);",
        "description": "Clears any number of specified d-cards."
      }
    ],
    "example": ""
  },
  {
    "name": "clearexcept",
    "description": "Clears the workspace variables except the specified ones.",
    "usage": "clearexcept();",
    "category": "general",
    "markdown": "# clearexcept\r\n\r\nClears the workspace variables except the specified ones.\r\n\r\n| **Syntax**      | **Description**                                       |\r\n| --------------- | ----------------------------------------------------- |\r\n| clearexcept(a); | Clears the workspace variables except for variable a. |\r\n\r\n**Examples**\r\n\r\n```\r\na = \"my string\";\r\nb = 1;\r\nd = 2;\r\nclearexcept(a);\r\n```",
    "summary": "Clears the workspace variables except the specified ones",
    "syntax": [
      {
        "syntax": "clearexcept(a);",
        "description": "Clears the workspace variables except for variable a."
      }
    ],
    "example": ""
  },
  {
    "name": "clearfunctions",
    "description": "Clears all or specified stored functions.",
    "usage": "clearfunctions();",
    "category": "general",
    "markdown": "# clearfunctions\r\n\r\nClears all or specified stored functions.\r\n\r\n| **Syntax**                         | **Description**                                                         |\r\n| ---------------------------------- | ----------------------------------------------------------------------- |\r\n| clearfunctions;                    | Clears all workspace functions. This function does not return any data. |\r\n| clearfunctions(func1, func2, ...); | Clears only the workspace functions with the specified names.           |",
    "summary": "Clears all or specified stored functions",
    "syntax": [
      {
        "syntax": "clearfunctions;",
        "description": "Clears all workspace functions. This function does not return any data."
      },
      {
        "syntax": "clearfunctions(func1, func2, ...);",
        "description": "Clears only the workspace functions with the specified names."
      }
    ],
    "example": ""
  },
  {
    "name": "clearjobs",
    "description": "Remove all jobs from the job manager queue.",
    "usage": "clearjobs();",
    "category": "general",
    "markdown": "# clearjobs\r\n\r\nRemove all jobs from the job manager queue.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                                    |\r\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| clearjobs(\"solver\"); | Remove all jobs from the job queue of the specified solver. If no solver is specified, jobs for all solvers will be removed from job manager queue. No solver argument is needed for INTERCONNECT. |\r\n\r\n**Example**\r\n\r\n```\r\nnewproject;\r\naddfdtd;\r\nadddipole;\r\naddcircle;\r\nrun;\r\nclearjobs;\r\n```",
    "summary": "Remove all jobs from the job manager queue",
    "syntax": [
      {
        "syntax": "clearjobs(\"solver\");",
        "description": "Remove all jobs from the job queue of the specified solver. If no solver is specified, jobs for all solvers will be removed from job manager queue. No solver argument is needed for INTERCONNECT."
      }
    ],
    "example": "newproject;\r\naddfdtd;\r\nadddipole;\r\naddcircle;\r\nrun;\r\nclearjobs;"
  },
  {
    "name": "clearlogwindow",
    "description": "Clears the log output log window.",
    "usage": "clearlogwindow();",
    "category": "general",
    "markdown": "# clearlogwindow\r\n\r\nClears the log output log window.\r\n\r\n| **Syntax**      | **Description**           |\r\n| --------------- | ------------------------- |\r\n| clearlogwindow; | clears output log window. |",
    "summary": "Clears the log output log window",
    "syntax": [
      {
        "syntax": "clearlogwindow;",
        "description": "clears output log window."
      }
    ],
    "example": ""
  },
  {
    "name": "clearmodedata",
    "description": "Clears mode data for a mode expansion monitor in layout mode. This is mainly useful to reduce file sizes when saving.",
    "usage": "clearmodedata();",
    "category": "general",
    "markdown": "# clearmodedata\r\n\r\nClears mode data for a mode expansion monitor in layout mode. This is mainly useful to\r\nreduce file sizes when saving.\r\n\r\n| **Syntax**     | **Description**                                           |\r\n| -------------- | --------------------------------------------------------- |\r\n| clearmodedata; | Clears mode data for the selected mode expansion monitor. |\r\n\r\n**Example**\r\n\r\nClear mode data stored in mode expansion monitor. This will make the file much smaller,\r\nwhich can be convenient when emailing simulation files.\r\n\r\n```\r\nselect(\"expansion\");\r\nclearmodedata; \r\n```",
    "summary": "Clears mode data for a mode expansion monitor in layout mode",
    "syntax": [
      {
        "syntax": "clearmodedata;",
        "description": "Clears mode data for the selected mode expansion monitor."
      }
    ],
    "example": "select(\"expansion\");\r\nclearmodedata;"
  },
  {
    "name": "clearpath",
    "description": "Removes all directories from the script path, except \"./\".",
    "usage": "clearpath();",
    "category": "general",
    "markdown": "# clearpath\r\n\r\nRemoves all directories from the script path, except \"./\".\r\n\r\n| **Syntax**              | **Description**                                        |\r\n| ----------------------- | ------------------------------------------------------ |\r\n| clearpath(\"directory\"); | Remove\"directory\" from the script path if it is there. |\r\n\r\n**Examples**\r\n\r\nSee addpath.",
    "summary": "Removes all directories from the script path, except \"",
    "syntax": [
      {
        "syntax": "clearpath(\"directory\");",
        "description": "Remove\"directory\" from the script path if it is there."
      }
    ],
    "example": ""
  },
  {
    "name": "clearportmodedata",
    "description": "Clears mode data from selected FDTD port and ports in MODE's EME solver. For more information about the port object see [ Ports ](https://optics.ansys.com/hc/en-us/articles/360034382554-Ports) .",
    "usage": "clearportmodedata();",
    "category": "general",
    "markdown": "# clearportmodedata\r\n\r\nClears mode data from selected FDTD port and ports in MODE's EME solver. For more\r\ninformation about the port object see\r\n[ Ports ](https://optics.ansys.com/hc/en-us/articles/360034382554-Ports) .\r\n\r\n| **Syntax**         | **Description**                                                              |\r\n| ------------------ | ---------------------------------------------------------------------------- |\r\n| clearportmodedata; | Clears mode data from selected port. This function does not return any data. |\r\n\r\n**Example** The following script adds a FDTD simulation region and port, then sets the\r\nname of the port, and selects the port modes then clears the selected port mode data.\r\n\r\n```\r\n# add objects  \r\naddfdtd; # add FDTD simulation region\r\naddport; # add port\r\n# set up port\r\nset(\"name\",\"input_port\"); # set the name of the port\r\nseteigensolver(\"bent waveguide\",true); # set the solver to look for modes of a bent waveguide\r\nseteigensolver(\"bend radius\",10e-6); # set bending radius to 10 um\r\nupdateportmodes(1:2); # select the first 2 modes of the port\r\n# clear the selected mode data\r\nclearportmodedata;\r\n```",
    "summary": "Clears mode data from selected FDTD port and ports in MODE's EME solver",
    "syntax": [
      {
        "syntax": "clearportmodedata;",
        "description": "Clears mode data from selected port. This function does not return any data."
      }
    ],
    "example": "# add objects  \r\naddfdtd; # add FDTD simulation region\r\naddport; # add port\r\n# set up port\r\nset(\"name\",\"input_port\"); # set the name of the port\r\nseteigensolver(\"bent waveguide\",true); # set the solver to look for modes of a bent waveguide\r\nseteigensolver(\"bend radius\",10e-6); # set bending radius to 10 um\r\nupdateportmodes(1:2); # select the first 2 modes of the port\r\n# clear the selected mode data\r\nclearportmodedata;"
  },
  {
    "name": "clearsourcedata",
    "description": "Clears source data for an imported source, or the selected mode for a mode source.",
    "usage": "clearsourcedata();",
    "category": "general",
    "markdown": "# clearsourcedata\r\n\r\nClears source data for an imported source, or the selected mode for a mode source.\r\n\r\n| **Syntax**       | **Description**                             |\r\n| ---------------- | ------------------------------------------- |\r\n| clearsourcedata; | Clears source data for the selected source. |\r\n\r\n**Example**\r\n\r\nClear source data from an imported source. This will make the file much smaller, which\r\ncan be convenient when emailing simulation files.\r\n\r\n```\r\nselect(\"source3\");\r\nclearsourcedata; \r\n```",
    "summary": "Clears source data for an imported source, or the selected mode for a mode source",
    "syntax": [
      {
        "syntax": "clearsourcedata;",
        "description": "Clears source data for the selected source."
      }
    ],
    "example": "select(\"source3\");\r\nclearsourcedata;"
  },
  {
    "name": "closeall",
    "description": "Closes all open figure windows.",
    "usage": "closeall();",
    "category": "general",
    "markdown": "# closeall\r\n\r\nCloses all open figure windows.\r\n\r\n| **Syntax** | **Description**                                                        |\r\n| ---------- | ---------------------------------------------------------------------- |\r\n| closeall;  | Close all open figure windows. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nSee exportfigure example.",
    "summary": "Closes all open figure windows",
    "syntax": [
      {
        "syntax": "closeall;",
        "description": "Close all open figure windows. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "closesession",
    "description": "An interoperability command that will close an active server session of a specified Lumerical product previously opened via automation API.",
    "usage": "closesession();",
    "category": "general",
    "markdown": "# closesession\r\n\r\nAn interoperability command that will close an active server session of a specified\r\nLumerical product previously opened via automation API.\r\n\r\n| **Syntax**       | **Description**            |\r\n| ---------------- | -------------------------- |\r\n| closesession(s); | Closes an active session s |\r\n\r\n### Example\r\n\r\nThe following code example opens Device as a server, sends local variable 'x' to Device\r\nworkspace followed by a command to manipulate the variable and the retrieves the result\r\nbefore closing the session:\r\n\r\n```\r\n#Opend Device session\r\ns2=opensession('device');\r\n#Declare local variable x\r\nx=2;\r\n#Send the local variable to Device workspace via API\r\nputremotedata(s2,'x_device',x);\r\n#Send script command to Device via API andsquare the variable\r\nevalremote(s2,\"y_device=x_device^2;\");\r\n#Get the variable from Device worksapace via API \r\n?y=getremotedata(s2,'y_device');\r\n#Close the session\r\nclosesession(s2);\r\n```",
    "summary": "An interoperability command that will close an active server session of a specified Lumerical produc...",
    "syntax": [
      {
        "syntax": "closesession(s);",
        "description": "Closes an active session s"
      }
    ],
    "example": ""
  },
  {
    "name": "colormatch",
    "description": "Returns the X, Y and Z tristimulus values calculated for a given spectral power distribution (power per unit area per unit wavelength) and a selected set of color matching functions. The colormatch function assumes that the units of wavelength for the spectral power distribution are nanometers, for example, W/(m 2 nm). The available color functions are the CIE 1931 and CIE 1964.",
    "usage": "colormatch();",
    "category": "general",
    "markdown": "# colormatch\r\n\r\nReturns the X, Y and Z tristimulus values calculated for a given spectral power\r\ndistribution (power per unit area per unit wavelength) and a selected set of color\r\nmatching functions. The colormatch function assumes that the units of wavelength for the\r\nspectral power distribution are nanometers, for example, W/(m 2 nm). The available color\r\nfunctions are the CIE 1931 and CIE 1964.\r\n\r\nThe X, Y, Z values have dimensions of power per unit area, in the units used for the\r\nspectral power distribution. The expressions for calculating the X, Y and Z values are:\r\n\r\n$$ \\\\begin{aligned} X &=\\\\int I(\\\\lambda) \\\\overline{x}(\\\\lambda) d \\\\lambda \\\\\\\\ Y\r\n&=\\\\int I(\\\\lambda) \\\\overline{y}(\\\\lambda) d \\\\lambda \\\\\\\\ Z &=\\\\int I(\\\\lambda)\r\n\\\\overline{z}(\\\\lambda) d \\\\lambda \\\\end{aligned} $$\r\n\r\nwhere I(͛λ) is the spectral power distribution and \\\\( \\\\overline{x} \\\\), \\\\(\r\n\\\\overline{y} \\\\) ,\\\\( \\\\overline{z} \\\\) are the color matching functions.\r\n\r\nReferences:\r\n\r\n[ https://en.wikipedia.org/wiki/CIE_1931_color_space ](https://en.wikipedia.org/wiki/CIE_1931_color_space)\r\n\r\nCIE Proceedings (1932), 1931. Cambridge: Cambridge University Press.\r\n\r\nCIE Proceedings (1964) Vienna Session, 1963, Vol. B, pp. 209-220 (Committee Report\r\nE-1.4.1), Bureau Central de la CIE, Paris.\r\n\r\n| **Syntax**                               | **Description**                                                                                                                                                                                   |\r\n| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| cm = colormatch(spec, lam, \"functions\"); | Returns X, Y, Z for the spectrum spec evaluated at the wavelength values in lam (units of meters), using the selected color functions. If no functions are specified, the \"CIE 1931\" set is used. |\r\n\r\n**Example**\r\n\r\nThis example shows how to calculate the X, Y, Z values for a given spectral power\r\ndistribution.\r\n\r\n```\r\n# create a dummy spectrum\r\nlambda = linspace(300e-9,700e-9,500); # note SI units (meters)\r\nspectrum = exp(-(lambda-450e-9)^2/(30e-9)^2); \r\nplot(lambda*1e9,spectrum,\"wavelength(nm)\",\"test spectrum\");\r\n \r\n?cm64 = colormatch(spectrum,lambda,\"CIE 1964\");\r\nresult:\r\n14.3731 \r\n6.07161 \r\n79.5907\r\n?cm36 = colormatch(spectrum,lambda); # \"CIE 1931\" is assumed if no color matching functions are specified\r\nresult:\r\n13.1613 \r\n2.99189 \r\n72.2623\r\n```\r\n\r\nThe following figure shows the plot of the test spectrum created by the example code.",
    "summary": "Returns the X, Y and Z tristimulus values calculated for a given spectral power distribution (power ...",
    "syntax": [
      {
        "syntax": "cm = colormatch(spec, lam, \"functions\");",
        "description": "Returns X, Y, Z for the spectrum spec evaluated at the wavelength values in lam (units of meters), using the selected color functions. If no functions are specified, the \"CIE 1931\" set is used."
      }
    ],
    "example": "# create a dummy spectrum\r\nlambda = linspace(300e-9,700e-9,500); # note SI units (meters)\r\nspectrum = exp(-(lambda-450e-9)^2/(30e-9)^2); \r\nplot(lambda*1e9,spectrum,\"wavelength(nm)\",\"test spectrum\");\r\n \r\n?cm64 = colormatch(spectrum,lambda,\"CIE 1964\");\r\nresult:\r\n14.3731 \r\n6.07161 \r\n79.5907\r\n?cm36 = colormatch(spectrum,lambda); # \"CIE 1931\" is assumed if no color matching functions are specified\r\nresult:\r\n13.1613 \r\n2.99189 \r\n72.2623"
  },
  {
    "name": "colormatchfunction",
    "description": "Returns the set of color matching functions \\\\( \\\\overline{x} \\\\), \\\\( \\\\overline{y} \\\\) ,\\\\( \\\\overline{z} \\\\) selected by the user. These functions are dimensionless. The available sets are the CIE 1931 and CIE 1964.",
    "usage": "colormatchfunction();",
    "category": "general",
    "markdown": "# colormatchfunction\r\n\r\nReturns the set of color matching functions \\\\( \\\\overline{x} \\\\), \\\\( \\\\overline{y} \\\\)\r\n,\\\\( \\\\overline{z} \\\\) selected by the user. These functions are dimensionless. The\r\navailable sets are the CIE 1931 and CIE 1964.\r\n\r\nReferences:\r\n\r\nCIE Proceedings (1932), 1931. Cambridge: Cambridge University Press.\r\n\r\nCIE Proceedings (1964) Vienna Session, 1963, Vol. B, pp. 209-220 (Committee Report\r\nE-1.4.1), Bureau Central de la CIE, Paris.\r\n\r\n| **Syntax**                           | **Description**                                                                  |\r\n| ------------------------------------ | -------------------------------------------------------------------------------- |\r\n| ?colormatchfunction;                 | Show the list of available color matching functions.                             |\r\n| M = colormatchfunction(\"functions\"); | Get the desired set of color matching functions from the list of available ones. |\r\n\r\n**Example**\r\n\r\nThis example shows how to get the list of available color matching functions and plot\r\nthem.\r\n\r\n```\r\n?colormatchfunction; #Show the list of color matching functions\r\nresult:\r\nCIE 1931\r\nCIE 1964\r\nM1 = colormatchfunction(\"CIE 1931\");\r\nM2 = colormatchfunction(\"CIE 1964\");\r\nlambda1 = pinch(M1,2,1)*1e9; #Get the wavelength values where the function M1 is evaluated (in SI units, i.e. meters) and convert to nanometers.\r\nxbar1 = pinch(M1,2,2);\r\nybar1 = pinch(M1,2,3);\r\nzbar1 = pinch(M1,2,4);\r\nlambda2 = pinch(M2,2,1)*1e9; #Get the wavelength values where the function M2 is evaluated (in SI units, i.e. meters) and convert to nanometers.\r\nxbar2 = pinch(M2,2,2);\r\nybar2 = pinch(M2,2,3);\r\nzbar2 = pinch(M2,2,4);\r\nplotxy(lambda1,xbar1,lambda1,ybar1,lambda1,zbar1,lambda2,xbar2,lambda2,ybar2,lambda2,zbar2,\"wavelength (nm)\",\"Color matching functions\");\r\nlegend(\"xbar (CIE 1931)\",\"ybar (CIE 1931)\",\"zbar (CIE 1931)\",\"xbar (CIE 1964)\",\"ybar (CIE 1964)\",\"zbar (CIE 1964)\");\r\n```\r\n\r\nThe following figure shows the output of the example code.",
    "summary": "Returns the set of color matching functions \\\\( \\\\overline{x} \\\\), \\\\( \\\\overline{y} \\\\) ,\\\\( \\\\over...",
    "syntax": [
      {
        "syntax": "?colormatchfunction;",
        "description": "Show the list of available color matching functions."
      },
      {
        "syntax": "M = colormatchfunction(\"functions\");",
        "description": "Get the desired set of color matching functions from the list of available ones."
      }
    ],
    "example": "?colormatchfunction; #Show the list of color matching functions\r\nresult:\r\nCIE 1931\r\nCIE 1964\r\nM1 = colormatchfunction(\"CIE 1931\");\r\nM2 = colormatchfunction(\"CIE 1964\");\r\nlambda1 = pinch(M1,2,1)*1e9; #Get the wavelength values where the function M1 is evaluated (in SI units, i.e. meters) and convert to nanometers.\r\nxbar1 = pinch(M1,2,2);\r\nybar1 = pinch(M1,2,3);\r\nzbar1 = pinch(M1,2,4);\r\nlambda2 = pinch(M2,2,1)*1e9; #Get the wavelength values where the function M2 is evaluated (in SI units, i.e. meters) and convert to nanometers.\r\nxbar2 = pinch(M2,2,2);\r\nybar2 = pinch(M2,2,3);\r\nzbar2 = pinch(M2,2,4);\r\nplotxy(lambda1,xbar1,lambda1,ybar1,lambda1,zbar1,lambda2,xbar2,lambda2,ybar2,lambda2,zbar2,\"wavelength (nm)\",\"Color matching functions\");\r\nlegend(\"xbar (CIE 1931)\",\"ybar (CIE 1931)\",\"zbar (CIE 1931)\",\"xbar (CIE 1964)\",\"ybar (CIE 1964)\",\"zbar (CIE 1964)\");"
  },
  {
    "name": "colormatchuv",
    "description": "Returns the u' and v' chromaticity values calculated for a given spectral power distribution (power per unit area per unit wavelength) and a selected set of color matching functions. The colormatchuv function assumes that the units of wavelength for the spectral power distribution are nanometers, for example, W/(m 2 nm). The available color functions are the CIE 1931 and CIE 1964.",
    "usage": "colormatchuv();",
    "category": "general",
    "markdown": "# colormatchuv\r\n\r\nReturns the u' and v' chromaticity values calculated for a given spectral power\r\ndistribution (power per unit area per unit wavelength) and a selected set of color\r\nmatching functions. The colormatchuv function assumes that the units of wavelength for\r\nthe spectral power distribution are nanometers, for example, W/(m 2 nm). The available\r\ncolor functions are the CIE 1931 and CIE 1964.\r\n\r\nThe u' and v' values are dimensionless and they are related to the X, Y and Z values by:\r\n\r\n$$ u^{\\\\prime}=\\\\frac{4 X}{X+15 Y+3 Z}, v^{\\\\prime}=\\\\frac{9 Y}{X+15 Y+3 Z} $$\r\n\r\nReferences:\r\n\r\n[ https://en.wikipedia.org/wiki/CIE_1931_color_space ](%25LINK_CAPTION%25)\r\n\r\n[ http://en.wikipedia.org/wiki/CIELUV ](%25LINK_CAPTION%25)\r\n\r\nCIE Proceedings (1932), 1931. Cambridge: Cambridge University Press.\r\n\r\nCIE Proceedings (1964) Vienna Session, 1963, Vol. B, pp. 209-220 (Committee Report\r\nE-1.4.1), Bureau Central de la CIE, Paris.\r\n\r\n| **Syntax**                                               | **Description**                                                                                                                                                                                  |\r\n| -------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| cmuv = colormatchuv(colormatch(spec, lam, \"functions\")); | Returns u', v' for the spectrum spec evaluated at the wavelength values in lam (units of meters), using the selected color functions. If no functions are specified, the \"CIE 1931\" set is used. |\r\n\r\n**Example**\r\n\r\nThis example shows how to calculate the u', v' values for a given spectral power\r\ndistribution.\r\n\r\n```\r\n# create a dummy spectrum\r\nlambda = linspace(300e-9,700e-9,500); # note SI units (meters)\r\nspectrum = exp(-(lambda-450e-9)^2/(30e-9)^2); \r\nplot(lambda*1e9,spectrum,\"wavelength(nm)\",\"test spectrum\");\r\n \r\n?cmuv64 = colormatchuv( colormatch(spectrum,lambda,\"CIE 1964\") );\r\nresult:\r\n0.167023 \r\n0.158749 \r\n?cmuv36 = colormatchuv( colormatch(spectrum,lambda) );\r\nresult:\r\n0.191558 \r\n0.0979782\r\n```\r\n\r\nThe following figure shows the plot of the test spectrum created by the example code.",
    "summary": "Returns the u' and v' chromaticity values calculated for a given spectral power distribution (power ...",
    "syntax": [
      {
        "syntax": "cmuv = colormatchuv(colormatch(spec, lam, \"functions\"));",
        "description": "Returns u', v' for the spectrum spec evaluated at the wavelength values in lam (units of meters), using the selected color functions. If no functions are specified, the \"CIE 1931\" set is used."
      }
    ],
    "example": "# create a dummy spectrum\r\nlambda = linspace(300e-9,700e-9,500); # note SI units (meters)\r\nspectrum = exp(-(lambda-450e-9)^2/(30e-9)^2); \r\nplot(lambda*1e9,spectrum,\"wavelength(nm)\",\"test spectrum\");\r\n \r\n?cmuv64 = colormatchuv( colormatch(spectrum,lambda,\"CIE 1964\") );\r\nresult:\r\n0.167023 \r\n0.158749 \r\n?cmuv36 = colormatchuv( colormatch(spectrum,lambda) );\r\nresult:\r\n0.191558 \r\n0.0979782"
  },
  {
    "name": "colormatchxy",
    "description": "Returns the x and y chromaticity values calculated for a given spectral power distribution (power per unit area per unit wavelength) and a selected set of color matching functions. The colormatchxy function assumes that the units of wavelength for the spectral power distribution are nanometers, for example, W/(m 2 nm). The available color functions are the CIE 1931 and CIE 1964.",
    "usage": "colormatchxy();",
    "category": "general",
    "markdown": "# colormatchxy\r\n\r\nReturns the x and y chromaticity values calculated for a given spectral power\r\ndistribution (power per unit area per unit wavelength) and a selected set of color\r\nmatching functions. The colormatchxy function assumes that the units of wavelength for\r\nthe spectral power distribution are nanometers, for example, W/(m 2 nm). The available\r\ncolor functions are the CIE 1931 and CIE 1964.\r\n\r\nThe x and y values are dimensionless and they are related to the X, Y, and Z values by:\r\n\r\n$$ x=\\\\frac{X}{X+Y+Z}, y=\\\\frac{Y}{X+Y+Z} $$\r\n\r\n| **Syntax**                                               | **Description**                                                                                                                                                                                |\r\n| -------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| cmxy = colormatchxy(colormatch(spec, lam, \"functions\")); | Returns x, y for the spectrum spec evaluated at the wavelength values in lam (units of meters), using the selected color functions. If no functions are specified, the \"CIE 1931\" set is used. |\r\n\r\n**Example**\r\n\r\nThis example shows how to calculate the x, y values for a given spectral power\r\ndistribution.\r\n\r\n```\r\n# create a dummy spectrum  \r\nlambda = linspace(300e-9,700e-9,500); # note SI units (meters)  \r\nspectrum = exp(-(lambda-450e-9)^2/(30e-9)^2);   \r\nplot(lambda*1e9,spectrum,\"wavelength(nm)\",\"test spectrum\");  \r\n  \r\n?cmxy64 = colormatchxy( colormatch(spectrum,lambda,\"CIE 1964\") );  \r\nresult:  \r\n0.14368   \r\n0.0606946   \r\n?cmxy36 = colormatchxy( colormatch(spectrum,lambda) );  \r\nresult:  \r\n0.148857   \r\n0.033839\r\n```\r\n\r\nThe following figure shows the plot of the test spectrum created by the example code.\r\n\r\n### Related Publications\r\n\r\n1. <https://en.wikipedia.org/wiki/CIE_1931_color_space>\r\n1. CIE Proceedings (1932), 1931. Cambridge: Cambridge University Press.\r\n1. CIE Proceedings (1964) Vienna Session, 1963, Vol. B, pp. 209-220 (Committee Report\r\n   E-1.4.1), Bureau Central de la CIE, Paris.",
    "summary": "Returns the x and y chromaticity values calculated for a given spectral power distribution (power pe...",
    "syntax": [
      {
        "syntax": "cmxy = colormatchxy(colormatch(spec, lam, \"functions\"));",
        "description": "Returns x, y for the spectrum spec evaluated at the wavelength values in lam (units of meters), using the selected color functions. If no functions are specified, the \"CIE 1931\" set is used."
      }
    ],
    "example": "# create a dummy spectrum  \r\nlambda = linspace(300e-9,700e-9,500); # note SI units (meters)  \r\nspectrum = exp(-(lambda-450e-9)^2/(30e-9)^2);   \r\nplot(lambda*1e9,spectrum,\"wavelength(nm)\",\"test spectrum\");  \r\n  \r\n?cmxy64 = colormatchxy( colormatch(spectrum,lambda,\"CIE 1964\") );  \r\nresult:  \r\n0.14368   \r\n0.0606946   \r\n?cmxy36 = colormatchxy( colormatch(spectrum,lambda) );  \r\nresult:  \r\n0.148857   \r\n0.033839"
  },
  {
    "name": "conj",
    "description": "Returns the complex conjugate of a number or matrix.",
    "usage": "conj();",
    "category": "general",
    "markdown": "# conj\r\n\r\nReturns the complex conjugate of a number or matrix.\r\n\r\n| **Syntax**     | **Description**                     |\r\n| -------------- | ----------------------------------- |\r\n| out = conj(x); | Returns the complex conjugate of x. |\r\n\r\n**Example**\r\n\r\nCalculate the complex conjugate of numbers in an array.\r\n\r\n```\r\n?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?conj(x);\r\nresult: \r\n0+0i \r\n2-1i \r\n```",
    "summary": "Returns the complex conjugate of a number or matrix",
    "syntax": [
      {
        "syntax": "out = conj(x);",
        "description": "Returns the complex conjugate of x."
      }
    ],
    "example": "?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?conj(x);\r\nresult: \r\n0+0i \r\n2-1i"
  },
  {
    "name": "connect",
    "description": "Connects one element to another via the specified ports.",
    "usage": "connect();",
    "category": "general",
    "markdown": "# connect\r\n\r\nConnects one element to another via the specified ports.\r\n\r\n| **Syntax**                                         | **Description**                                          |\r\n| -------------------------------------------------- | -------------------------------------------------------- |\r\n| connect(\"element1\", \"port1\", \"element2\", \"port2\"); | Connects \"port1\" of \"element1\" to \"element2\" or \"port2\". |\r\n\r\n**Example**\r\n\r\nTo connect the port_1 of a \"Straight Waveguide_1\",to port_2 of a \"Waveguide Coupler_1\"\r\n\r\n```\r\nconnect(\"Straight Waveguide_1\",\"port 1\",\"Waveguide Coupler_1\",\"port 2\");\r\n```",
    "summary": "Connects one element to another via the specified ports",
    "syntax": [
      {
        "syntax": "connect(\"element1\", \"port1\", \"element2\", \"port2\");",
        "description": "Connects \"port1\" of \"element1\" to \"element2\" or \"port2\"."
      }
    ],
    "example": "connect(\"Straight Waveguide_1\",\"port 1\",\"Waveguide Coupler_1\",\"port 2\");"
  },
  {
    "name": "constructgeneratormatrix",
    "description": "Constructs a symmetric coding generator matrix. This command is especially useful together with the FEC block.",
    "usage": "constructgeneratormatrix();",
    "category": "general",
    "markdown": "# constructgeneratormatrix\r\n\r\nConstructs a symmetric coding generator matrix. This command is especially useful\r\ntogether with the FEC block.\r\n\r\n| **Syntax**                                                   | **Description**                                                                                                                                                                                                               |\r\n| ------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| constructgeneratormatrix(parityin, generatorout, parityout); | Constructs a symmetric coding generator matrix ‘generatorout’ and the correspondent parity check matrix ‘parityout’ from a input parity check matrix ‘parityin’. The input and the generated files are AList formatted files. |\r\n| **Example**                                                  |                                                                                                                                                                                                                               |\r\n\r\n```\r\nconstructgeneratormatrix(\"hamming_7_4_1_h.alist\", \"hamming_7_4_1_g.alist\", \"hamming_7_4_1_h.alist\");\r\n```",
    "summary": "Constructs a symmetric coding generator matrix",
    "syntax": [
      {
        "syntax": "constructgeneratormatrix(parityin, generatorout, parityout);",
        "description": "Constructs a symmetric coding generator matrix ‘generatorout’ and the correspondent parity check matrix ‘parityout’ from a input parity check matrix ‘parityin’. The input and the generated files are AList formatted files."
      }
    ],
    "example": ""
  },
  {
    "name": "conv2",
    "description": "Returns the Convolution of two 2-dimensional arrays.",
    "usage": "conv2();",
    "category": "general",
    "markdown": "# conv2\r\n\r\nReturns the Convolution of two 2-dimensional arrays.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                       |\r\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = conv2(A,B,mode) | Computes the convolution of two 2-d dimensional matrices A and B. mode = 'full': computes the full convolution of A and B. 'same': computes the central part of the full convolution, result matrix C is restricted to the size of A, |\r\n\r\n**Example**\r\n\r\nIn the following example, we computes the 'full' and 'same' convolution results of\r\nmatrices A and B:\r\n\r\n```\r\nmatA = [-5;-4;-3;-2;-1;0;1;2;3;4;5]*pi;\r\nmatB = [-3,-2,-1,0];\r\nmatCFull = conv2(matA, matB, 'full');\r\nmatCSame = conv2(matA, matB, 'same');\r\n>?matCFull;\r\nresult: \r\n47.1239  31.4159  15.708  0  \r\n37.6991  25.1327  12.5664  0  \r\n28.2743  18.8496  9.42478  0  \r\n18.8496  12.5664  6.28319  0  \r\n9.42478  6.28319  3.14159  0  \r\n0  0  0  0  \r\n-9.42478  -6.28319  -3.14159  0  \r\n-18.8496  -12.5664  -6.28319  0  \r\n-28.2743  -18.8496  -9.42478  0  \r\n-37.6991  -25.1327  -12.5664  0  \r\n-47.1239  -31.4159  -15.708  0   \r\n>?matCSame;\r\nresult: \r\n15.708  \r\n12.5664  \r\n9.42478  \r\n6.28319  \r\n3.14159  \r\n0  \r\n-3.14159  \r\n-6.28319  \r\n-9.42478  \r\n-12.5664  \r\n-15.708 \r\n```",
    "summary": "Returns the Convolution of two 2-dimensional arrays",
    "syntax": [
      {
        "syntax": "out = conv2(A,B,mode)",
        "description": "Computes the convolution of two 2-d dimensional matrices A and B. mode = 'full': computes the full convolution of A and B. 'same': computes the central part of the full convolution, result matrix C is restricted to the size of A,"
      }
    ],
    "example": "matA = [-5;-4;-3;-2;-1;0;1;2;3;4;5]*pi;\r\nmatB = [-3,-2,-1,0];\r\nmatCFull = conv2(matA, matB, 'full');\r\nmatCSame = conv2(matA, matB, 'same');\r\n>?matCFull;\r\nresult: \r\n47.1239  31.4159  15.708  0  \r\n37.6991  25.1327  12.5664  0  \r\n28.2743  18.8496  9.42478  0  \r\n18.8496  12.5664  6.28319  0  \r\n9.42478  6.28319  3.14159  0  \r\n0  0  0  0  \r\n-9.42478  -6.28319  -3.14159  0  \r\n-18.8496  -12.5664  -6.28319  0  \r\n-28.2743  -18.8496  -9.42478  0  \r\n-37.6991  -25.1327  -12.5664  0  \r\n-47.1239  -31.4159  -15.708  0   \r\n>?matCSame;\r\nresult: \r\n15.708  \r\n12.5664  \r\n9.42478  \r\n6.28319  \r\n3.14159  \r\n0  \r\n-3.14159  \r\n-6.28319  \r\n-9.42478  \r\n-12.5664  \r\n-15.708"
  },
  {
    "name": "convertnportsparametersweep",
    "description": "Converts the textual S-Parameter sweep file (.txt file) to a binary file (.idat file).",
    "usage": "convertnportsparametersweep();",
    "category": "general",
    "markdown": "# convertnportsparametersweep\r\n\r\nConverts the textual S-Parameter sweep file (.txt file) to a binary file (.idat file).\r\n\r\n| **Syntax**                                                                                                                    | **Description**                                                                       |\r\n| ----------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |\r\n| convertnportsparametersweep(\"filename\")                                                                                       | Converts the textual S-Parameter sweep file \"filename\" to a binary file (.idat file). |\r\n| **Example** The following script converts the S-Parameter sweep file \"s_para_sweep.txt\" to a binary file \"s_para_sweep.idat\". |                                                                                       |\r\n\r\n```\r\nconvertnportsparametersweep(\"s_para_sweep.txt\")\r\n```",
    "summary": "Converts the textual S-Parameter sweep file (",
    "syntax": [
      {
        "syntax": "convertnportsparametersweep(\"filename\")",
        "description": "Converts the textual S-Parameter sweep file \"filename\" to a binary file (.idat file)."
      }
    ],
    "example": ""
  },
  {
    "name": "copy",
    "description": "Creates a copy of the selected objects. The copied objects will typically be identical (same name, position, etc). For some objects that must have a unique name, '\\_1' will be appended to the name.",
    "usage": "copy();",
    "category": "general",
    "markdown": "# copy\r\n\r\nCreates a copy of the selected objects. The copied objects will typically be identical\r\n(same name, position, etc). For some objects that must have a unique name, '\\_1' will be\r\nappended to the name.\r\n\r\n| **Syntax**      | **Description**                                        |\r\n| --------------- | ------------------------------------------------------ |\r\n| copy;           | Copy the selected objects.                             |\r\n| copy(dx);       | Same as copy; but with a specified move of dx.         |\r\n| copy(dx,dy);    | Same as copy; but with a specified move of dx, dy.     |\r\n| copy(dx,dy,dz); | Same as copy; but with a specified move of dx, dy, dz. |\r\n\r\n**Example**\r\n\r\nCreates a copy of the object named substrate. The copy will be located 1um in the y\r\ndirection from the original object.\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\ncopy(0, 1e-6,0); \r\n```",
    "summary": "Creates a copy of the selected objects",
    "syntax": [
      {
        "syntax": "copy;",
        "description": "Copy the selected objects."
      },
      {
        "syntax": "copy(dx);",
        "description": "Same as copy; but with a specified move of dx."
      },
      {
        "syntax": "copy(dx,dy);",
        "description": "Same as copy; but with a specified move of dx, dy."
      },
      {
        "syntax": "copy(dx,dy,dz);",
        "description": "Same as copy; but with a specified move of dx, dy, dz."
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\ncopy(0, 1e-6,0);"
  },
  {
    "name": "copydcard",
    "description": "Will create a global copy of any d-card currently in memory.",
    "usage": "copydcard();",
    "category": "general",
    "markdown": "# copydcard\r\n\r\nWill create a global copy of any d-card currently in memory.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                                                                                                                    |\r\n| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| copydcard( \"name\");            | Will create a global copy of any d-card currently in memory called \"name\". By default, the new name will be \"::global_name\". For example, copydcard(\"mode1\"); sends mode1 to the deck, named global_mode1. This function does not return any data. |\r\n| copydcard( \"name\", \"newname\"); | Will create a global copy of any d-card currently in memory called \"name\". The new name will be \"::newname\".                                                                                                                                       |\r\n\r\n**Examples**\r\n\r\nSending modes to the d-card and run overlap analysis, eg, in the FDE solver\r\n\r\n```\r\ncopydcard(\"mode1\",\"test_mode1\");\r\ncopydcard(\"mode2\",\"test_mode2\");\r\n?overlap(\"test_mode1\",\"test_mode2\");\r\n```\r\n\r\nSending field profiles to the d-card and run overlap analysis, eg, in the FDTD solver\r\n\r\n```\r\ncopydcard(\"::model::R\",\"test_mode1\"); # for the fields recorded by R, where R is the monitor name\r\ncopydcard(\"::model::T\",\"test_mode2\"); # for the fields recorded by T, where T is the monitor name\r\n?overlap(\"test_mode1\",\"test_mode2\");\r\n```",
    "summary": "Will create a global copy of any d-card currently in memory",
    "syntax": [
      {
        "syntax": "copydcard( \"name\");",
        "description": "Will create a global copy of any d-card currently in memory called \"name\". By default, the new name will be \"::global_name\". For example, copydcard(\"mode1\"); sends mode1 to the deck, named global_mode1. This function does not return any data."
      },
      {
        "syntax": "copydcard( \"name\", \"newname\");",
        "description": "Will create a global copy of any d-card currently in memory called \"name\". The new name will be \"::newname\"."
      }
    ],
    "example": ""
  },
  {
    "name": "copymaterial",
    "description": "Makes a copy of a material in the material database.",
    "usage": "copymaterial();",
    "category": "general",
    "markdown": "# copymaterial\r\n\r\nMakes a copy of a material in the material database.\r\n\r\n| **Syntax**                          | **Description**                                                          |\r\n| ----------------------------------- | ------------------------------------------------------------------------ |\r\n| out = copymaterial(\"materialname\"); | Creates a copy of the material \"materialname\". The new name is returned. |",
    "summary": "Makes a copy of a material in the material database",
    "syntax": [
      {
        "syntax": "out = copymaterial(\"materialname\");",
        "description": "Creates a copy of the material \"materialname\". The new name is returned."
      }
    ],
    "example": ""
  },
  {
    "name": "copysweep",
    "description": "Copies a sweep/optimization/Monte Carlo analysis item to clipboard.",
    "usage": "copysweep();",
    "category": "general",
    "markdown": "# copysweep\r\n\r\nCopies a sweep/optimization/Monte Carlo analysis item to clipboard.\r\n\r\n| **Syntax**         | **Description**                                                                                                                                                           |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| copysweep(\"name\"); | Copies a sweep/optimization/Monte Carlo analysis item to clipboard. \"name\" is the absolute name of a sweep/optimization/Monte Carlo analysis (eg. ::optimization::sweep1) |\r\n\r\n**Example**\r\n\r\nThis example copies the sweep \"thickness_sweep\" to the clipboard and pastes it back to\r\nthe \"Optimizations and Sweeps\" tab again. Please download the example file from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\ncopysweep(\"thickness_sweep\");\r\npastesweep(\"\");\r\n```",
    "summary": "Copies a sweep/optimization/Monte Carlo analysis item to clipboard",
    "syntax": [
      {
        "syntax": "copysweep(\"name\");",
        "description": "Copies a sweep/optimization/Monte Carlo analysis item to clipboard. \"name\" is the absolute name of a sweep/optimization/Monte Carlo analysis (eg. ::optimization::sweep1)"
      }
    ],
    "example": "copysweep(\"thickness_sweep\");\r\npastesweep(\"\");"
  },
  {
    "name": "copytoclipboard",
    "description": "Copies the selected objects into the system clipboard. Equivalent to 'Ctrl-C'.",
    "usage": "copytoclipboard();",
    "category": "general",
    "markdown": "# copytoclipboard\r\n\r\nCopies the selected objects into the system clipboard. Equivalent to 'Ctrl-C'.\r\n\r\n| **Syntax**       | **Description**                                 |\r\n| ---------------- | ----------------------------------------------- |\r\n| copytoclipboard; | Copies selected objects to the system clipboard |\r\n\r\n**Examples**\r\n\r\nThis example shows how to use the copy/paste to clipboard functions to copy an object\r\nfrom a different simulation file into the current simulation file.\r\n\r\n```\r\n# specify file and object names\r\ncurrent_file = currentfilename;\r\ntemplate_file = \"C:\\temp\\myObjects.fsp\";\r\nobject_name = \"my_grating\";\r\nsave; #save current file; # save current file\r\nload(template_file);    # load template file\r\nselect(object_name);    # select object\r\ncopytoclipboard;      # copy object to clipboard\r\nload(current_file);     # load original file\r\npastefromclipboard;     # paste object into file\r\n```",
    "summary": "Copies the selected objects into the system clipboard",
    "syntax": [
      {
        "syntax": "copytoclipboard;",
        "description": "Copies selected objects to the system clipboard"
      }
    ],
    "example": ""
  },
  {
    "name": "corrcoef",
    "description": "Calculates the correlation matrix. The input can be one matrix, which contains the observations of a set of random variables, or two matrices, each one representing a vector of observations.",
    "usage": "corrcoef();",
    "category": "general",
    "markdown": "# corrcoef\r\n\r\nCalculates the correlation matrix. The input can be one matrix, which contains the\r\nobservations of a set of random variables, or two matrices, each one representing a\r\nvector of observations.\r\n\r\n| **Syntax**                   | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| corrcoef(A); corrcoef(A, B); | Calculate the correlation matrix. R = corrcoef(A) returns the matrix of correlation coefficients for A, where the columns of A represent random variables and the rows represent observations. R = corrcoef(A, B) returns the correlation coefficients between two random variables A and B. If A and B are vectors of observations with equal length, corrcoef(A, B) is the 2-by-2 correlation matrix; if A and B are matrices of observations, corrcoef(A, B) treats A and B as vectors and is equivalent to corrcoef(A(1:lenght(A)), B(1:length(B))). A and B must have equal size. |\r\n\r\n**Example**\r\n\r\nThe following examples illustrate how to find the covariance matrix.\r\n\r\n```\r\nA = [1,2;3,4];\r\nB = [1.1,2.7; 2.5, 4.3];\r\n?corrcoef(A,B);\r\n?corrcoef(A(1:length(A)),B(1:length(B)));\r\nresult: \r\n1  0.92621  \r\n0.92621  1  \r\nresult: \r\n1  0.92621  \r\n0.92621  1  \r\n```",
    "summary": "Calculates the correlation matrix",
    "syntax": [
      {
        "syntax": "corrcoef(A); corrcoef(A, B);",
        "description": "Calculate the correlation matrix. R = corrcoef(A) returns the matrix of correlation coefficients for A, where the columns of A represent random variables and the rows represent observations. R = corrcoef(A, B) returns the correlation coefficients between two random variables A and B. If A and B are vectors of observations with equal length, corrcoef(A, B) is the 2-by-2 correlation matrix; if A and B are matrices of observations, corrcoef(A, B) treats A and B as vectors and is equivalent to corrcoef(A(1:lenght(A)), B(1:length(B))). A and B must have equal size."
      }
    ],
    "example": "A = [1,2;3,4];\r\nB = [1.1,2.7; 2.5, 4.3];\r\n?corrcoef(A,B);\r\n?corrcoef(A(1:length(A)),B(1:length(B)));\r\nresult: \r\n1  0.92621  \r\n0.92621  1  \r\nresult: \r\n1  0.92621  \r\n0.92621  1"
  },
  {
    "name": "corrtransf",
    "description": "Calculates the transformation matrix to generate multiple sequences of correlated random variables.",
    "usage": "corrtransf();",
    "category": "general",
    "markdown": "# corrtransf\r\n\r\nCalculates the transformation matrix to generate multiple sequences of correlated random\r\nvariables.\r\n\r\n| **Syntax**     | **Description**                                                                                                                 |\r\n| -------------- | ------------------------------------------------------------------------------------------------------------------------------- |\r\n| corrtransf(A); | Calculate the transformation matrix to generate multiple sequences of correlated random variables given a correlation matrix A. |\r\n\r\n**Example**\r\n\r\nThis is a simple example of the command.\r\n\r\n```\r\nA = [1,2;3,4];\r\n?corrtransf(cov(A));\r\nresult: \r\n-1  -1  \r\n-4.09555e-009  4.09555e-009 \r\n```",
    "summary": "Calculates the transformation matrix to generate multiple sequences of correlated random variables",
    "syntax": [
      {
        "syntax": "corrtransf(A);",
        "description": "Calculate the transformation matrix to generate multiple sequences of correlated random variables given a correlation matrix A."
      }
    ],
    "example": "A = [1,2;3,4];\r\n?corrtransf(cov(A));\r\nresult: \r\n-1  -1  \r\n-4.09555e-009  4.09555e-009"
  },
  {
    "name": "cos",
    "description": "Calculates the trigonometric cosine function. Angle units are in radians. The function is defined for complex angles. Phase of a complex number is evaluated between - π and π .",
    "usage": "cos();",
    "category": "general",
    "markdown": "# cos\r\n\r\nCalculates the trigonometric cosine function. Angle units are in radians. The function\r\nis defined for complex angles. Phase of a complex number is evaluated between - π and π\r\n.\r\n\r\n| **Syntax**    | **Description**                  |\r\n| ------------- | -------------------------------- |\r\n| out = cos(x); | Returns the complex cosine of x. |\r\n\r\n**Example**\r\n\r\nCalculate cos( π /4 + i).\r\n\r\n```\r\ntheta=pi/4+1i;\r\n?cos(theta);\r\nresult: \r\n1.09112-0.830993i \r\n```",
    "summary": "Calculates the trigonometric cosine function",
    "syntax": [
      {
        "syntax": "out = cos(x);",
        "description": "Returns the complex cosine of x."
      }
    ],
    "example": "theta=pi/4+1i;\r\n?cos(theta);\r\nresult: \r\n1.09112-0.830993i"
  },
  {
    "name": "coupling",
    "description": "Returns the complex coupling coefficient between two modes. The power coupling can be calculated with the overlap function, or by the following formula.",
    "usage": "coupling();",
    "category": "general",
    "markdown": "# coupling\r\n\r\nReturns the complex coupling coefficient between two modes. The power coupling can be\r\ncalculated with the overlap function, or by the following formula.\r\n\r\nPower_Coupling = | coupling | 2\r\n\r\nReference: Allan W. Snyder and John D. Love, Optical Waveguide Theory. Chapman & Hall,\r\nLondon, England, 1983.\r\n\r\nSee the overlap function for more details about overlap and coupling calculations.\r\n\r\n## Note: coupling command is deprecated, consider using [ expand ](./expand.md)\r\n\r\n| **Syntax**                    | **Description** |\r\n| ----------------------------- | --------------- |\r\n| out = coupling(mode2, mode1); |                 |\r\n\r\n- mode2, mode1: the mode names\r\n- out: the coupling coefficient\r\n\r\nout = coupling(mode2, mode1, x, y); | Mode alignment can be adjusted before coupling is\r\ncalculated.\r\n\r\n- x offset\r\n- y offset\r\n\r\n**Examples**\r\n\r\nThis example shows how to use the overlap command to calculate the overlap and power\r\ncoupling between two modes.\r\n\r\n```\r\ncopydcard(\"mode1\",\"test_mode1\");  \r\ncopydcard(\"mode2\",\"test_mode2\");  \r\n\r\nout = overlap(\"test_mode1\",\"test_mode2\");  \r\n\r\n?out(1);  # overlap  \r\n?out(2);  # power coupling  \r\n?coupling(\"test_mode1\",\"test_mode2\"); # the complex coupling coefficient  \r\n?abs(coupling(\"test_mode1\",\"test_mode2\"))^2; # same as out(2), the power coupling\r\n```",
    "summary": "Returns the complex coupling coefficient between two modes",
    "syntax": [],
    "example": ""
  },
  {
    "name": "cov",
    "description": "Calculates the covariance matrix. The input can be one matrix, which contains the observations of a set of random variables, or two matrices, each one representing a vector of observations.",
    "usage": "cov();",
    "category": "general",
    "markdown": "# cov\r\n\r\nCalculates the covariance matrix. The input can be one matrix, which contains the\r\nobservations of a set of random variables, or two matrices, each one representing a\r\nvector of observations.\r\n\r\n| **Syntax**         | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| cov(A); cov(A, B); | Calculate the covariance matrix. C = cov(A) returns the covariance. A is a matrix where columns represent random variables and rows represent observations; C is the covariance matrix with the corresponding column variances along the diagonal. C = cov(A, B) returns the covariance between two random variables A and B. If A and B are vectors of observations with equal length, cov(A, B) is the 2-by-2 covariance matrix; if A and B are matrices of observations, cov(A, B) treats A and B as vectors and is equivalent to cov(A(1:lenght(A)), B(1:length(B))). A and B must have equal size. |\r\n\r\n**Example**\r\n\r\nThe following examples illustrate how to find the covariance matrix.\r\n\r\n```\r\nA = [1,2;3,4];\r\nB = [1.1,2.7; 2.5, 4.3];\r\n?cov(A,B);\r\n?cov(A(1:length(A)),B(1:length(B)));\r\nresult: \r\n1.25  1.175  \r\n1.175  1.2875  \r\nresult: \r\n1.25  1.175  \r\n1.175  1.2875  \r\n```",
    "summary": "Calculates the covariance matrix",
    "syntax": [
      {
        "syntax": "cov(A); cov(A, B);",
        "description": "Calculate the covariance matrix. C = cov(A) returns the covariance. A is a matrix where columns represent random variables and rows represent observations; C is the covariance matrix with the corresponding column variances along the diagonal. C = cov(A, B) returns the covariance between two random variables A and B. If A and B are vectors of observations with equal length, cov(A, B) is the 2-by-2 covariance matrix; if A and B are matrices of observations, cov(A, B) treats A and B as vectors and is equivalent to cov(A(1:lenght(A)), B(1:length(B))). A and B must have equal size."
      }
    ],
    "example": "A = [1,2;3,4];\r\nB = [1.1,2.7; 2.5, 4.3];\r\n?cov(A,B);\r\n?cov(A(1:length(A)),B(1:length(B)));\r\nresult: \r\n1.25  1.175  \r\n1.175  1.2875  \r\nresult: \r\n1.25  1.175  \r\n1.175  1.2875"
  },
  {
    "name": "cp",
    "description": "Copies a file. The copy can be created in a specified path.",
    "usage": "cp();",
    "category": "general",
    "markdown": "# cp\r\n\r\nCopies a file. The copy can be created in a specified path.\r\n\r\n| **Syntax**                         | **Description**                                                             |\r\n| ---------------------------------- | --------------------------------------------------------------------------- |\r\n| cp(\"file1\",\"file2\");               | Makes a copy of file1 called file2. This function does not return any data. |\r\n| cp(\"path1\\\\file1\",\"path2\\\\file2\"); | Copies file1 in path1 to file2 in path2.                                    |\r\n\r\n**Note** : This command cannot be used while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Examples**\r\n\r\nMakes a copy of \"myscript.lsf\" in c:\\\\working called \"temp.lsf\".\r\n\r\n```\r\ncp(\"c:\\myscript.lsf\",\"c:\\working\\temp.lsf\");\r\n```",
    "summary": "Copies a file",
    "syntax": [
      {
        "syntax": "cp(\"file1\",\"file2\");",
        "description": "Makes a copy of file1 called file2. This function does not return any data."
      },
      {
        "syntax": "cp(\"path1\\\\file1\",\"path2\\\\file2\");",
        "description": "Copies file1 in path1 to file2 in path2."
      }
    ],
    "example": ""
  },
  {
    "name": "createbeam",
    "description": "Creates a new Gaussian beam that is accessible from the deck/global workspace. The Gaussian beam has the properties specified in the Overlap analysis -> Beam tab of the eigensolver analysis window.",
    "usage": "createbeam();",
    "category": "general",
    "markdown": "# createbeam\r\n\r\nCreates a new Gaussian beam that is accessible from the deck/global workspace. The\r\nGaussian beam has the properties specified in the Overlap analysis -> Beam tab of the\r\neigensolver analysis window.\r\n\r\n| **Syntax**        | **Description**                                                                                                                                                                                                             |\r\n| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| createbeam;       | Creates a Gaussian beam in the deck/global workspace. Returns the name of the Gaussian beam created, which is by default \"gaussian#\" (# being the total number of Gaussian beams already existing in the current deck + 1). |\r\n| out = createbeam; | Creates a Gaussian beam in the deck/global workspace and saves its name in the variable \"out\".                                                                                                                              |\r\n\r\n**Example**\r\n\r\nThe following script command will create a Gaussian beam in the deck and print its name\r\nin the script prompt.\r\n\r\n```\r\n?createbeam;\r\n```",
    "summary": "Creates a new Gaussian beam that is accessible from the deck/global workspace",
    "syntax": [
      {
        "syntax": "createbeam;",
        "description": "Creates a Gaussian beam in the deck/global workspace. Returns the name of the Gaussian beam created, which is by default \"gaussian#\" (# being the total number of Gaussian beams already existing in the current deck + 1)."
      },
      {
        "syntax": "out = createbeam;",
        "description": "Creates a Gaussian beam in the deck/global workspace and saves its name in the variable \"out\"."
      }
    ],
    "example": "?createbeam;"
  },
  {
    "name": "createcompound",
    "description": "The script command creates a compound element with the currently selected elements.",
    "usage": "createcompound();",
    "category": "general",
    "markdown": "# createcompound\r\n\r\nThe script command creates a compound element with the currently selected elements.\r\n\r\n| **Syntax**      | **Description**                                                  |\r\n| --------------- | ---------------------------------------------------------------- |\r\n| createcompound; | Creates a compound element with the currently selected elements. |\r\n\r\n**Example**\r\n\r\nSuppose a \"Straight Waveguide_1\" and a \"Waveguide Coupler_1_1\" are added and connected\r\nin the schematic editor, using those scripts will create a compound\r\n\r\n```\r\nselect(\"Straight Waveguide_1\");\r\nselect(\"Waveguide Coupler_1_1\");\r\ncreatecompound;\r\n```\r\n\r\nwith a default name \"COMPOUND_1\".",
    "summary": "The script command creates a compound element with the currently selected elements",
    "syntax": [
      {
        "syntax": "createcompound;",
        "description": "Creates a compound element with the currently selected elements."
      }
    ],
    "example": "select(\"Straight Waveguide_1\");\r\nselect(\"Waveguide Coupler_1_1\");\r\ncreatecompound;"
  },
  {
    "name": "createsphericalsurface",
    "description": "Creates a triangulated spherical surface or a segmented circular arc. It can be used to define the far-field points for a far field projection as these are often specified using a spherical surface (3D simulations) or a circular arc (2D simulations).",
    "usage": "createsphericalsurface();",
    "category": "general",
    "markdown": "# createsphericalsurface\r\n\r\nCreates a triangulated spherical surface or a segmented circular arc. It can be used to\r\ndefine the far-field points for a far field projection as these are often specified\r\nusing a spherical surface (3D simulations) or a circular arc (2D simulations).\r\n\r\n| **Syntax**                                                                      | **Description**                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = createsphericalsurface([theta1,theta2],[phi1,phi2], [X,Y,Z],radius,lmax); | Creates an unstructured data set with a triangulated surface or a segmented arc. Their dimensions are specified by the input angles, orientation axis and radius. The coarseness of the triangulation (or line segmentation) is specified as the maximum separation between adjacent points. The output data set contains the IDs of each element (triangles or lines) and the corresponding areas (only for triangles). |\r\n\r\n| **Parameter** |          | **Default value** | **Type** | **Description**                                                                                    |\r\n| ------------- | -------- | ----------------- | -------- | -------------------------------------------------------------------------------------------------- |\r\n| theta1        | optional | 0                 | number   | Starting value of the elevation angle (theta) range in radians with respect to the reference axis. |\r\n| theta2        | optional | pi                | number   | End value of the elevation angle (theta) range in radians with respect to the reference axis.      |\r\n| phi1          | optional | 0                 | number   | Starting value of the azimuthal angle (phi) range in radians with respect to the reference axis.   |\r\n| phi2          | optional | 2\\*pi             | number   | End value of the azimuthal angle (phi) range in radians with respect to the reference axis.        |\r\n| [X,Y,Z]       | optional | [0,0,1]           | vector   | Orientation axis: [1,0,0] for X-axis, [0,1,0] for Y-axis and [0,0,1] for Z-axis.                   |\r\n| radius        | optional | 1                 | number   | Radius of the sphere or arc to be created in meters.                                               |\r\n| lmax          | optional | 0.2               | number   | Maximum separation between two adjacent data points on far field location in meters.               |\r\n\r\n**Example 1**\r\n\r\nThis example creates a spherical surface and performs a far field projection using the\r\nnear field data from a surface monitor named \"monitor\".\r\n\r\n```\r\nsurf = createsphericalsurface([0,pi/4],[0,2*pi],[0,0,1],1,0.1);\r\nE_near = getresult(\"DGTD::monitor\",\"fields\");\r\nE_far = near2far(E_near,surf);\r\nvisualize(E_far); \r\n```\r\n\r\n**Example 2**\r\n\r\nThis example creates an arc (in the XZ plane) and performs a far field projection using\r\nthe near field data from a line monitor called \"monitor\" (also in the XZ plane).\r\n\r\n```\r\nsurf = createsphericalsurface([pi/2,pi/2],[pi,2*pi],[0,1,0],1,0.1);\r\nE_near = getresult(\"DGTD::monitor\",\"fields\");\r\nE_far = near2far(E_near,surf);\r\nvisualize(E_far); \r\n```",
    "summary": "Creates a triangulated spherical surface or a segmented circular arc",
    "syntax": [
      {
        "syntax": "out = createsphericalsurface([theta1,theta2],[phi1,phi2], [X,Y,Z],radius,lmax);",
        "description": "Creates an unstructured data set with a triangulated surface or a segmented arc. Their dimensions are specified by the input angles, orientation axis and radius. The coarseness of the triangulation (or line segmentation) is specified as the maximum separation between adjacent points. The output data set contains the IDs of each element (triangles or lines) and the corresponding areas (only for triangles)."
      }
    ],
    "example": ""
  },
  {
    "name": "cross",
    "description": "Calculates the vector cross product of two matrices, which must have the same size. The cross product will be computed on the first dimension that has a size of 3. There must be at least one dimension with a size of 3.",
    "usage": "cross();",
    "category": "general",
    "markdown": "# cross\r\n\r\nCalculates the vector cross product of two matrices, which must have the same size. The\r\ncross product will be computed on the first dimension that has a size of 3. There must\r\nbe at least one dimension with a size of 3.\r\n\r\nAssume that A,B are 2D matrices, where the second dimension contains the vector\r\ncomponents. The size of the second dimension must be 3. Then the elements of C will be\r\ncalculated with the standard cross product formulas.\r\n\r\n$$ \\\\begin{array}{l}{\\\\mathbf{C}(i, 1)=+\\\\mathbf{A}(i, 2) \\\\mathbf{B}(i,\r\n3)-\\\\mathbf{A}(i, 3) \\\\mathbf{B}(i, 2)} \\\\\\\\ {\\\\mathbf{C}(i, 2)=-\\\\mathbf{A}(i, 1)\r\n\\\\mathbf{B}(i, 3)+\\\\mathbf{A}(i, 3) \\\\mathbf{B}(i, 1)} \\\\\\\\ {\\\\mathbf{C}(i,\r\n3)=+\\\\mathbf{A}(i, 1) \\\\mathbf{B}(i, 2)-\\\\mathbf{A}(i, 2) \\\\mathbf{B}(i, 1)}\\\\end{array}\r\n$$\r\n\r\n| **Syntax**       | **Description**                      |\r\n| ---------------- | ------------------------------------ |\r\n| C = cross(A, B); | Returns the cross product of A and B |\r\n\r\n**Example**\r\n\r\nCalculate the cross product of (1,1,0) and (0,1,0).\r\n\r\n```\r\nA=[1,1,0];\r\nB=[0,1,0];\r\n?C=cross(A,B);\r\nreturn: \r\n0  0  1\r\n```",
    "summary": "Calculates the vector cross product of two matrices, which must have the same size",
    "syntax": [
      {
        "syntax": "C = cross(A, B);",
        "description": "Returns the cross product of A and B"
      }
    ],
    "example": "A=[1,1,0];\r\nB=[0,1,0];\r\n?C=cross(A,B);\r\nreturn: \r\n0  0  1"
  },
  {
    "name": "ctranspose",
    "description": "Transposes a 1D or 2D matrix and takes the complex conjugate of each element. The resulting matrix is the conjugate transpose or Hermitian transpose.",
    "usage": "ctranspose();",
    "category": "general",
    "markdown": "# ctranspose\r\n\r\nTransposes a 1D or 2D matrix and takes the complex conjugate of each element. The\r\nresulting matrix is the conjugate transpose or Hermitian transpose.\r\n\r\n| **Syntax**         | **Description**                                                                        |\r\n| ------------------ | -------------------------------------------------------------------------------------- |\r\n| y = ctranspose(x); | If x is an N x M matrix, then y will be M x N, where the entries are y(j,i)=x(i,j) * . |\r\n\r\n**Example**\r\n\r\nSimple example of how to find the conjugate transpose of a 2D complex matrix.\r\n\r\n```\r\n?B = [1+3i,2,3+7i;4,5+2i,6];\r\n?BCT = ctranspose(B); # conjugate transpose of A\r\nresult:\r\n1+3i  2+0i  3+7i  \r\n4+0i  5+2i  6+0i  \r\nresult: \r\n1-3i  4+-0i  \r\n2+-0i  5-2i  \r\n3-7i  6+-0i  \r\n```",
    "summary": "Transposes a 1D or 2D matrix and takes the complex conjugate of each element",
    "syntax": [
      {
        "syntax": "y = ctranspose(x);",
        "description": "If x is an N x M matrix, then y will be M x N, where the entries are y(j,i)=x(i,j) * ."
      }
    ],
    "example": "?B = [1+3i,2,3+7i;4,5+2i,6];\r\n?BCT = ctranspose(B); # conjugate transpose of A\r\nresult:\r\n1+3i  2+0i  3+7i  \r\n4+0i  5+2i  6+0i  \r\nresult: \r\n1-3i  4+-0i  \r\n2+-0i  5-2i  \r\n3-7i  6+-0i"
  },
  {
    "name": "currentfilename",
    "description": "Returns the current project filename and directory.",
    "usage": "currentfilename();",
    "category": "general",
    "markdown": "# currentfilename\r\n\r\nReturns the current project filename and directory.\r\n\r\n| **Syntax**             | **Description**                                                                                                             |\r\n| ---------------------- | --------------------------------------------------------------------------------------------------------------------------- |\r\n| out = currentfilename; | Returns the current filename as a string. If the current filename is not defined, this function returns an empty string \"\". |\r\n\r\n**Examples**\r\n\r\nGets the current filename.\r\n\r\n```\r\n?out=currentfilename;\r\nC:/Users/myname/Documents/FDTD/myfile.fsp\r\n```",
    "summary": "Returns the current project filename and directory",
    "syntax": [
      {
        "syntax": "out = currentfilename;",
        "description": "Returns the current filename as a string. If the current filename is not defined, this function returns an empty string \"\"."
      }
    ],
    "example": ""
  },
  {
    "name": "currentscriptname",
    "description": "Returns the current script filename and directory.",
    "usage": "currentscriptname();",
    "category": "general",
    "markdown": "# currentscriptname\r\n\r\nReturns the current script filename and directory.\r\n\r\n| **Syntax**               | **Description**                                                                                                              |\r\n| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| out = currentscriptname; | Returns the current script filename as a string. If entered in the script prompt, this function returns the string \"prompt\". |\r\n\r\n**Examples**\r\n\r\nGets the current script filename.\r\n\r\n```\r\n?out=currentscriptname;\r\nC:/Users/myname/Documents/FDTD/myfile.lsf\r\n```",
    "summary": "Returns the current script filename and directory",
    "syntax": [
      {
        "syntax": "out = currentscriptname;",
        "description": "Returns the current script filename as a string. If entered in the script prompt, this function returns the string \"prompt\"."
      }
    ],
    "example": ""
  },
  {
    "name": "customlibrary",
    "description": "Returns the location (path) of the Custom library.",
    "usage": "customlibrary();",
    "category": "general",
    "markdown": "# customlibrary\r\n\r\nReturns the location (path) of the Custom library.\r\n\r\n| **Syntax**           | **Description**                              |\r\n| -------------------- | -------------------------------------------- |\r\n| out = customlibrary; | Returns the directory of the custom library. |\r\n\r\n**Example**\r\n\r\n```\r\n?out = customlibrary;\r\n>C:/Users\r\n```",
    "summary": "Returns the location (path) of the Custom library",
    "syntax": [
      {
        "syntax": "out = customlibrary;",
        "description": "Returns the directory of the custom library."
      }
    ],
    "example": "?out = customlibrary;\r\n>C:/Users"
  },
  {
    "name": "cwnorm",
    "description": "Uses CW normalization. All simulation data will be normalized to the injected source power. Most users prefer to do their analysis in the CW normalization state, since it removes any effect caused by the finite pulse length of the source. It also converts the units of all electromagnetic fields to be the same as in the time domain. Note, this command works in both the Layout and Analysis mode.",
    "usage": "cwnorm();",
    "category": "general",
    "markdown": "# cwnorm\r\n\r\nUses CW normalization. All simulation data will be normalized to the injected source\r\npower. Most users prefer to do their analysis in the CW normalization state, since it\r\nremoves any effect caused by the finite pulse length of the source. It also converts the\r\nunits of all electromagnetic fields to be the same as in the time domain. Note, this\r\ncommand works in both the Layout and Analysis mode.\r\n\r\nThis function controls the checkbox located in Settings - Normalization state.\r\n\r\n| **Syntax**          | **Description**                                                                                                |\r\n| ------------------- | -------------------------------------------------------------------------------------------------------------- |\r\n| cwnorm;             | Use CW normalization. Uses the first active source in the Object tree; This function does not return any data. |\r\n| cwnorm(norm_option) | norm_option: 1 (first source), 2 (average of all sources)                                                      |\r\n\r\n**Example**\r\n\r\nThis example shows how to switch to the cwnorm state.\r\n\r\n```\r\ncwnorm; # normalized to the first active source  \r\n  \r\ncwnorm(1); # normalized to the first active source  \r\ncwnorm(2); # normalized to the average of all the sources\r\n```",
    "summary": "Uses CW normalization",
    "syntax": [
      {
        "syntax": "cwnorm;",
        "description": "Use CW normalization. Uses the first active source in the Object tree; This function does not return any data."
      },
      {
        "syntax": "cwnorm(norm_option)",
        "description": "norm_option: 1 (first source), 2 (average of all sources)"
      }
    ],
    "example": "cwnorm; # normalized to the first active source  \r\n  \r\ncwnorm(1); # normalized to the first active source  \r\ncwnorm(2); # normalized to the average of all the sources"
  },
  {
    "name": "czt",
    "description": "Returns the chirped z-transform of a set of data. The czt function is often more convenient than the standard fft functions because you can specify an arbitrary range of k.",
    "usage": "czt();",
    "category": "general",
    "markdown": "# czt\r\n\r\nReturns the chirped z-transform of a set of data. The czt function is often more\r\nconvenient than the standard fft functions because you can specify an arbitrary range of\r\nk.\r\n\r\n$$ E_k[m]=czt(E_x,x,k)=\\\\sum_nE_x[n].e^{ix[n]k[m]} $$\r\n\r\n$$\r\nE_k[m1,m2]=czt(E_x,x1,x2,k1,k2)=\\\\sum\\_{n1,n2}E_x[n1,n2].e^{ix1[n1]k1[m1]+ix2[n2]k2[m2]}\r\n$$\r\n\r\n| **Syntax**         | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = czt(Ex,t,w); | Returns the chirped z-transform of Ex, function of t, at each desired angular frequency w. Note that w must be a linearly spaced set of angular frequencies but can cover any range. It is also possible for inverse transform, ie out=czt(Ex,w,t), see the interpolation example below for details. E can be a matrix where one of the two dimensions is the same as length. The Z-transform is computed along the dimension that matches length, and the output vector will be a matrix where the matched dimension is length(kx) and the other dimension is the same as E. This functionality allows to compute multiple 1D Z-transforms with a single function call. |\r\n| czt(Ex,x,y,kx,ky); | The two dimensional chirped z-transform. kx and ky must be linearly spaced sets of wavenumbers but can cover any range.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n\r\n**Example**\r\n\r\nThis example uses the czt function to determine the frequency components of a signal, as\r\nshown in the following figure.\r\n\r\n```\r\nt=linspace(0,50,1000);   # sec\r\nf=linspace(0,3,200);    # Hz\r\nx_t=sin(t) + cos(t*2*pi);  # x(t)\r\nx_f=czt(x_t,t,f*2*pi);   # x(f)\r\nplot(f,abs(x_f),\"f (Hz)\"); \r\n```\r\n\r\nThe following is an example of Fourier based interpolation. We can use the fftw function\r\nto create the w vector (option3, which shifts the data, is required). A factor of 1/N is\r\nnecessary for the inverse transform. Also, notice the minus sign on the w vector for the\r\ninverse transform. It is possible to use czt to re-sample 2D data.\r\n\r\n```\r\ninitial_res = 21;\r\nfinal_res = 200;\r\n# Initial data\r\nt=linspace(-10,10,initial_res);\r\ny=sin(t)*exp(-t^2/30);\r\nplot(t,y,\"t\",\"y\",\"Initial\");\r\n# fourier transform\r\nw=fftw(t,3);\r\ny_w=czt(y,t,w);\r\nplot(w,abs(y_w)^2,\"w\",\"y_w\");\r\n# re-sample data at 10x\r\nt_hi=linspace(min(t),max(t),final_res);\r\ny_hi=1/length(w)*czt(y_w,-w,t_hi); # inverse transform\r\nplot(t_hi,real(y_hi),\"t\",\"y\",\"Final\");\r\n```",
    "summary": "Returns the chirped z-transform of a set of data",
    "syntax": [
      {
        "syntax": "out = czt(Ex,t,w);",
        "description": "Returns the chirped z-transform of Ex, function of t, at each desired angular frequency w. Note that w must be a linearly spaced set of angular frequencies but can cover any range. It is also possible for inverse transform, ie out=czt(Ex,w,t), see the interpolation example below for details. E can be a matrix where one of the two dimensions is the same as length. The Z-transform is computed along the dimension that matches length, and the output vector will be a matrix where the matched dimension is length(kx) and the other dimension is the same as E. This functionality allows to compute multiple 1D Z-transforms with a single function call."
      },
      {
        "syntax": "czt(Ex,x,y,kx,ky);",
        "description": "The two dimensional chirped z-transform. kx and ky must be linearly spaced sets of wavenumbers but can cover any range."
      }
    ],
    "example": "t=linspace(0,50,1000);   # sec\r\nf=linspace(0,3,200);    # Hz\r\nx_t=sin(t) + cos(t*2*pi);  # x(t)\r\nx_f=czt(x_t,t,f*2*pi);   # x(f)\r\nplot(f,abs(x_f),\"f (Hz)\");"
  },
  {
    "name": "dcht",
    "description": "Returns the Chebyshev interpolation coefficients. The amplitude of the coefficients decreases exponentially and the last coefficient offers an estimate of the relative accuracy of the interpolation.",
    "usage": "dcht();",
    "category": "general",
    "markdown": "# dcht\r\n\r\nReturns the Chebyshev interpolation coefficients. The amplitude of the coefficients\r\ndecreases exponentially and the last coefficient offers an estimate of the relative\r\naccuracy of the interpolation.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                   |\r\n| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| coeff=dcht(f,option); | Returns the Chebyshev interpolation coefficients of a sampled function f. The function f must be sampled on a Chebyshev roots grid. Option: If option=1 is selected, the vector x will not include the endpoints If option=2 is selected, the vector x will include the endpoints |\r\n\r\n**Example**\r\n\r\nThis example shows how to obtain interpolation coefficients from a sampled function:\r\n\r\n```\r\nNc = 15;         # Number of sample points\r\nxmin = 0;\r\nxmax = 1;\r\nx = chpts(xmin,xmax,Nc,1); # Returns Chebyshev roots grid on interval between xmin and xmax\r\nf = exp(1i*2*pi*x);    # Function sampling using Chebyshev grid\r\ncoeff = dcht(f,1);     # Get interpolation coefficients\r\n?abs(coeff);\r\nresult: \r\n0.304242  \r\n0.569231  \r\n0.970868  \r\n0.666917  \r\n0.302849  \r\n0.104282  \r\n0.0290919  \r\n0.00684063  \r\n0.00139224  \r\n0.000250007  \r\n4.01899e-005  \r\n5.85025e-006  \r\n7.78278e-007  \r\n9.53372e-008  \r\n1.094e-008      \r\n```",
    "summary": "Returns the Chebyshev interpolation coefficients",
    "syntax": [
      {
        "syntax": "coeff=dcht(f,option);",
        "description": "Returns the Chebyshev interpolation coefficients of a sampled function f. The function f must be sampled on a Chebyshev roots grid. Option: If option=1 is selected, the vector x will not include the endpoints If option=2 is selected, the vector x will include the endpoints"
      }
    ],
    "example": "Nc = 15;         # Number of sample points\r\nxmin = 0;\r\nxmax = 1;\r\nx = chpts(xmin,xmax,Nc,1); # Returns Chebyshev roots grid on interval between xmin and xmax\r\nf = exp(1i*2*pi*x);    # Function sampling using Chebyshev grid\r\ncoeff = dcht(f,1);     # Get interpolation coefficients\r\n?abs(coeff);\r\nresult: \r\n0.304242  \r\n0.569231  \r\n0.970868  \r\n0.666917  \r\n0.302849  \r\n0.104282  \r\n0.0290919  \r\n0.00684063  \r\n0.00139224  \r\n0.000250007  \r\n4.01899e-005  \r\n5.85025e-006  \r\n7.78278e-007  \r\n9.53372e-008  \r\n1.094e-008"
  },
  {
    "name": "debug",
    "description": "Opens the debug utility window. This command is useful for debugging purposes. When this command is used, script will run to the line before the debug command. Then user can start to call other commands to test commands that have been run. Once the utility window is closed, the script lines will continue to run. Multiple debug commands are allowed.",
    "usage": "debug();",
    "category": "general",
    "markdown": "# debug\r\n\r\nOpens the debug utility window. This command is useful for debugging purposes. When this\r\ncommand is used, script will run to the line before the debug command. Then user can\r\nstart to call other commands to test commands that have been run. Once the utility\r\nwindow is closed, the script lines will continue to run. Multiple debug commands are\r\nallowed.\r\n\r\n| **Syntax** | **Description**                                                                       |\r\n| ---------- | ------------------------------------------------------------------------------------- |\r\n| debug;     | Opens the debug utility window. This command can also be used in the analysis script. |\r\n\r\n**Examples**\r\n\r\nThis example shows how to use the debug command. This below example shows an error on\r\nline 3.\r\n\r\n```\r\nx=linspace(1,10,10);\r\ny=linspace(1,10,5);\r\n?x*y;\r\nError: prompt line 3: matrix arguments of * are not the same size\r\nx=linspace(1,10,10);\r\ny=linspace(1,10,5);\r\ndebug; # opens the debug utility window.\r\n?x*y;\r\n```",
    "summary": "Opens the debug utility window",
    "syntax": [
      {
        "syntax": "debug;",
        "description": "Opens the debug utility window. This command can also be used in the analysis script."
      }
    ],
    "example": ""
  },
  {
    "name": "del",
    "description": "Deletes a file. A path can be specified.",
    "usage": "del();",
    "category": "general",
    "markdown": "# del\r\n\r\nDeletes a file. A path can be specified.\r\n\r\n| **Syntax**                       | **Description**                                                      |\r\n| -------------------------------- | -------------------------------------------------------------------- |\r\n| del(\"filename\"); rm(\"filename\"); | Deletes the file \"filename\". This function does not return any data. |\r\n\r\n**Note** : This command cannot be used while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Examples**\r\n\r\nDeletes a file.\r\n\r\n```\r\ndel(\"project_name.fsp\") # deletes the file in the current working directory\r\ndel(\"C:\\Downloads\\project_name.fsp\") # deletes the file in a path specified\r\n```",
    "summary": "Deletes a file",
    "syntax": [
      {
        "syntax": "del(\"filename\"); rm(\"filename\");",
        "description": "Deletes the file \"filename\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "delete",
    "description": "Deletes selected objects.",
    "usage": "delete();",
    "category": "general",
    "markdown": "# delete\r\n\r\nDeletes selected objects.\r\n\r\n| **Syntax** | **Description**                                                   |\r\n| ---------- | ----------------------------------------------------------------- |\r\n| delete;    | Deletes selected objects. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nCreate an object and then delete it, just for illustration.\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\ndelete;\r\n```",
    "summary": "Deletes selected objects",
    "syntax": [
      {
        "syntax": "delete;",
        "description": "Deletes selected objects. This function does not return any data."
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\ndelete;"
  },
  {
    "name": "deleteall",
    "description": "Deletes all objects in the current group scope.",
    "usage": "deleteall();",
    "category": "general",
    "markdown": "# deleteall\r\n\r\nDeletes all objects in the current group scope.\r\n\r\n| **Syntax** | **Description**                                                                         |\r\n| ---------- | --------------------------------------------------------------------------------------- |\r\n| deleteall; | Deletes all objects in the current group scope. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThis function is often used in creating a group, eg.,\r\n[Structure Groups](https://optics.ansys.com/hc/en-us/articles/360034382434-Structure-Groups).",
    "summary": "Deletes all objects in the current group scope",
    "syntax": [
      {
        "syntax": "deleteall;",
        "description": "Deletes all objects in the current group scope. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "deletematerial",
    "description": "Deletes a material from the material database.",
    "usage": "deletematerial();",
    "category": "general",
    "markdown": "# deletematerial\r\n\r\nDeletes a material from the material database.\r\n\r\n| **Syntax**                      | **Description**                                                     |\r\n| ------------------------------- | ------------------------------------------------------------------- |\r\n| deletematerial(\"materialname\"); | Deletes a material named \"materialname\" from the material database. |",
    "summary": "Deletes a material from the material database",
    "syntax": [
      {
        "syntax": "deletematerial(\"materialname\");",
        "description": "Deletes a material named \"materialname\" from the material database."
      }
    ],
    "example": ""
  },
  {
    "name": "deleteresource",
    "description": "Removes the selected resource from the list of available resources in resource manager.",
    "usage": "deleteresource();",
    "category": "general",
    "markdown": "# deleteresource\r\n\r\nRemoves the selected resource from the list of available resources in resource manager.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                                                                                                                                                                                                                  |\r\n| -------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| deleteresource(\"solver\",resource_num); | Removes the selected resource from the list of available resources in resource manager. The \"solver\" argument is used to select the solver to delete the resource from. The \"solver\" argument is not supported by INTERCONNECT. resource_num is the number (row number in resource manager list) for the resource to be deleted. |\r\n\r\n**Example**\r\n\r\nThe following line will delete the second resource from the DGTD solver in DEVICE.\r\n\r\n```\r\ndeleteresource(\"DGTD\",\"2\");  \r\n```",
    "summary": "Removes the selected resource from the list of available resources in resource manager",
    "syntax": [
      {
        "syntax": "deleteresource(\"solver\",resource_num);",
        "description": "Removes the selected resource from the list of available resources in resource manager. The \"solver\" argument is used to select the solver to delete the resource from. The \"solver\" argument is not supported by INTERCONNECT. resource_num is the number (row number in resource manager list) for the resource to be deleted."
      }
    ],
    "example": "deleteresource(\"DGTD\",\"2\");"
  },
  {
    "name": "deletesweep",
    "description": "Deletes a specified parameter sweep, optimization, or Monte Carlo analysis task.",
    "usage": "deletesweep();",
    "category": "general",
    "markdown": "# deletesweep\r\n\r\nDeletes a specified parameter sweep, optimization, or Monte Carlo analysis task.\r\n\r\n| **Syntax**           | **Description**                                                                        |\r\n| -------------------- | -------------------------------------------------------------------------------------- |\r\n| deletesweep(\"name\"); | Deletes the sweep, optimization, or Monte Carlo analysis task with the specified name. |\r\n\r\n**Examples**\r\n\r\nThis example shows how to delete a task named \"thickness_sweep\". Please download the\r\nexample file from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\ndeletesweep(\"thickness_sweep\");\r\n```",
    "summary": "Deletes a specified parameter sweep, optimization, or Monte Carlo analysis task",
    "syntax": [
      {
        "syntax": "deletesweep(\"name\");",
        "description": "Deletes the sweep, optimization, or Monte Carlo analysis task with the specified name."
      }
    ],
    "example": ""
  },
  {
    "name": "designmode",
    "description": "In INTERCONNECT, this script command can be used to determine whether the simulation file is currently in DESIGN mode or in ANALYSIS mode. It is important to use this command to check the status of the project file once it is opened to avoid running into an error during the subsequent operations if the file is not in the desired mode.",
    "usage": "designmode();",
    "category": "general",
    "markdown": "# designmode\r\n\r\nIn INTERCONNECT, this script command can be used to determine whether the simulation\r\nfile is currently in DESIGN mode or in ANALYSIS mode. It is important to use this\r\ncommand to check the status of the project file once it is opened to avoid running into\r\nan error during the subsequent operations if the file is not in the desired mode.\r\n\r\n| **Syntax**   | **Description**                                         |\r\n| ------------ | ------------------------------------------------------- |\r\n| ?designmode; | Returns 1 if in DESIGN mode, and 0 if in ANALYSIS mode. |\r\n\r\n**Example**\r\n\r\nThe following script commands will first load a project file named \"test.icp\". The aim\r\nof the script is to add a new optical oscilloscope to the existing circuit. However, if\r\nthe file is in ANALYSIS mode then the \"addelement\" command will create an error. To\r\navoid this, the script command \"designmode\" is first used to determine the status of the\r\nfile. Then an \"if/else\" statement is used to add the element directly if the file is\r\nalready in DESIGN mode or to add the element after switching to DESIGN mode first if the\r\nfile is in ANALYSIS mode.\r\n\r\n```\r\nload(\"test.icp\");\r\nstatus = designmode;\r\nif (status == 1) {\r\n    addelement(\"Optical Oscilloscope\");\r\n}\r\nelse {\r\n    switchtodesign;\r\n    addelement(\"Optical Oscilloscope\");\r\n}\r\n```",
    "summary": "In INTERCONNECT, this script command can be used to determine whether the simulation file is current...",
    "syntax": [
      {
        "syntax": "?designmode;",
        "description": "Returns 1 if in DESIGN mode, and 0 if in ANALYSIS mode."
      }
    ],
    "example": "load(\"test.icp\");\r\nstatus = designmode;\r\nif (status == 1) {\r\n    addelement(\"Optical Oscilloscope\");\r\n}\r\nelse {\r\n    switchtodesign;\r\n    addelement(\"Optical Oscilloscope\");\r\n}"
  },
  {
    "name": "dipolepower",
    "description": "Returns the power injected into the simulation region by a dipole source. In 3D simulations, the units will be in Watts if cwnorm is used, and Watts/Hertz2 if nonorm is used.",
    "usage": "dipolepower();",
    "category": "general",
    "markdown": "# dipolepower\r\n\r\nReturns the power injected into the simulation region by a dipole source. In 3D\r\nsimulations, the units will be in Watts if cwnorm is used, and Watts/Hertz2 if nonorm is\r\nused.\r\n\r\nThe dipolepower script command returns the power that was injected into the simulation\r\nregion, and is equivalent to measuring the power transmitted out of a small box\r\nsurrounding the dipole. In contrast, [sourcepower](./sourcepower.md) will return the\r\npower that the dipole would radiate in a homogeneous material. dipolepower and\r\nsourcepower are equivalent for dipoles in a homogeneous medium.\r\n\r\nAdvanced notes:\r\n\r\n- If the dipole is located within a dispersive medium (with a non-zero imaginary part of\r\n  the refractive index), then the results of this function are not reliable. In such\r\n  situations, using a box of monitors around the dipole is recommended.\r\n- Numerical errors in this calculation may become noticeable when very small simulation\r\n  mesh sizes are used. If the mesh step is the order of, or smaller than, λ/1000,\r\n  verifying the dipolepower results by measuring the radiated power with a small box of\r\n  monitors surrounding the dipole is recommended.\r\n\r\nPlease visit the [Support Center](https://www.lumerical.com/support/) for more\r\nassistance if you are using a dipole in a dispersive medium.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                               |\r\n| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = dipolepower(f);       | Returns the amount of power radiated by the dipole source, at frequency points f. (f in Hz)                                                                                   |\r\n| out = dipolepower(f, name); | This option allows you to obtain the power radiated by a single dipole, rather than the sum of all dipoles. This option is only needed for simulations with multiple dipoles. |\r\n\r\n**Examples**\r\n\r\nSee the\r\n[Dipoles - Radiated Power](https://optics.ansys.com/hc/en-us/articles/360034382794-Sources-Dipoles)\r\npage and the\r\n[Fluorescence enhancement](https://apps.lumerical.com/fluorescence-enhancement.html)\r\napplication example.",
    "summary": "Returns the power injected into the simulation region by a dipole source",
    "syntax": [
      {
        "syntax": "out = dipolepower(f);",
        "description": "Returns the amount of power radiated by the dipole source, at frequency points f. (f in Hz)"
      },
      {
        "syntax": "out = dipolepower(f, name);",
        "description": "This option allows you to obtain the power radiated by a single dipole, rather than the sum of all dipoles. This option is only needed for simulations with multiple dipoles."
      }
    ],
    "example": ""
  },
  {
    "name": "dir",
    "description": "Lists files in a directory. Files other than Lumerical project files are also listed.",
    "usage": "dir();",
    "category": "general",
    "markdown": "# dir\r\n\r\nLists files in a directory. Files other than Lumerical project files are also listed.\r\n\r\n| **Syntax**                                     | **Description**                                                                |\r\n| ---------------------------------------------- | ------------------------------------------------------------------------------ |\r\n| out = dir; out = ls;                           | The output is a string. Use ?dir; to write the value to the screen.            |\r\n| out = dir(\"directory\"); out = ls(\"directory\"); | Lists the files in the specified directory. For example, ?ls(\"C:\\\\Downloads\"); |\r\n\r\n**Example**\r\n\r\nUses the splitstring command to get the contents of a directory in a cell (ie. string)\r\narray. Then loop through the array looking for all FDTD project files (.fsp).\r\n\r\n```\r\nfiles = splitstring(dir,endl);    # directory contents in a cell(string) array\r\nfor(i=1:length(files)) {          # loop over all files\r\n if (findstring(files{i},\"fsp\") != -1) {  # look for 'fsp' files\r\n  if (fileexists(files{i})) {     # check if the file exists\r\n   ?files{i};               # output file name\r\n   load(files{i});            # load file\r\n  }\r\n }\r\n}\r\n```",
    "summary": "Lists files in a directory",
    "syntax": [
      {
        "syntax": "out = dir; out = ls;",
        "description": "The output is a string. Use ?dir; to write the value to the screen."
      },
      {
        "syntax": "out = dir(\"directory\"); out = ls(\"directory\");",
        "description": "Lists the files in the specified directory. For example, ?ls(\"C:\\\\Downloads\");"
      }
    ],
    "example": "files = splitstring(dir,endl);    # directory contents in a cell(string) array\r\nfor(i=1:length(files)) {          # loop over all files\r\n if (findstring(files{i},\"fsp\") != -1) {  # look for 'fsp' files\r\n  if (fileexists(files{i})) {     # check if the file exists\r\n   ?files{i};               # output file name\r\n   load(files{i});            # load file\r\n  }\r\n }\r\n}"
  },
  {
    "name": "disabledesignkit",
    "description": "Disables a design kit in the Design Kits folder.",
    "usage": "disabledesignkit();",
    "category": "general",
    "markdown": "# disabledesignkit\r\n\r\nDisables a design kit in the Design Kits folder.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                                                    |\r\n| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| disabledesignkit(\"name\", [\"version\"]); | Disables a design kit that is already installed to the Design Kit folder with the version number \"version\". The \"version\" is optional, default is an empty string. |\r\n\r\n**Example**\r\n\r\n```\r\n#disables the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\ndisabledesignkit(\"LCML\", \"v1.1\");\r\n```",
    "summary": "Disables a design kit in the Design Kits folder",
    "syntax": [
      {
        "syntax": "disabledesignkit(\"name\", [\"version\"]);",
        "description": "Disables a design kit that is already installed to the Design Kit folder with the version number \"version\". The \"version\" is optional, default is an empty string."
      }
    ],
    "example": "#disables the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\ndisabledesignkit(\"LCML\", \"v1.1\");"
  },
  {
    "name": "disconnect",
    "description": "Disconnects one element to another via the specified ports.",
    "usage": "disconnect();",
    "category": "general",
    "markdown": "# disconnect\r\n\r\nDisconnects one element to another via the specified ports.\r\n\r\n| **Syntax**                                            | **Description**                                                                 |\r\n| ----------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| disconnect(\"element1\", \"port1\", \"element2\", \"port2\"); | Deletes the connection between \"port1\" of \"element1\" and \"port2\" of \"element2\". |\r\n\r\n**Example**\r\n\r\nTo disconnect the port_1 of a \"Straight Waveguide_1\" and the port_2 of a \"Waveguide\r\nCoupler_1\"\r\n\r\n```\r\ndisconnect(\"Straight Waveguide_1\",\"port 1\",\"Waveguide Coupler_1\",\"port 2\");\r\n```",
    "summary": "Disconnects one element to another via the specified ports",
    "syntax": [
      {
        "syntax": "disconnect(\"element1\", \"port1\", \"element2\", \"port2\");",
        "description": "Deletes the connection between \"port1\" of \"element1\" and \"port2\" of \"element2\"."
      }
    ],
    "example": "disconnect(\"Straight Waveguide_1\",\"port 1\",\"Waveguide Coupler_1\",\"port 2\");"
  },
  {
    "name": "dot",
    "description": "Retrieves the parameters and attributes of datasets. This is not the math dot product function, see the [ dot](./dot_cmd.md) command.",
    "usage": "dot();",
    "category": "general",
    "markdown": "# .\r\n\r\nRetrieves the parameters and attributes of datasets. This is not the math dot product\r\nfunction, see the [ dot](./dot_cmd.md) command.\r\n\r\n| **Syntax**         | **Description**                                                                                           |\r\n| ------------------ | --------------------------------------------------------------------------------------------------------- |\r\n| result = A.result; | Retrieves the parameter or attribute \"result\" from the existing dataset A. The result is a scalar matrix. |\r\n\r\n**Examples**\r\n\r\nThis example retrieves the dataset results \"E\" from a profile monitor, and then uses the\r\n[ getparameter ](./getparameter.md) command to get the \"f\" parameter, and the\r\n[ getattribute ](./getattribute.md) command to get the \"Ex\" and \"E2\" attributes from the\r\ndataset. Note that f, Ex and E2 are all scalar matrices, like the results one would get\r\nwith the [ getdata ](./getdata.md) command.\r\n\r\n```\r\nE = getresult(\"profile\",\"E\");\r\nf = E.getparameter(\"f\");  # the parameter f\r\nEx = E.getattribute(\"Ex\"); # the x component of the electric field\r\nE2 = E.getattribute(\"E2\"); # the electric field intensity, note that this only works if E is a vector\r\n```\r\n\r\nNote that one can also use the \".\" operator to retrieve the parameters and attributes\r\ndirectly. For example:\r\n\r\n```\r\nE = getresult(\"profile\",\"E\");\r\nf = E.f;  # the parameter f\r\nEx = E.Ex; # the x component of the electric field\r\nE2 = E.E2; # the electric field intensity, note that this only works if E is a vector\r\n```",
    "summary": "Retrieves the parameters and attributes of datasets",
    "syntax": [
      {
        "syntax": "result = A.result;",
        "description": "Retrieves the parameter or attribute \"result\" from the existing dataset A. The result is a scalar matrix."
      }
    ],
    "example": ""
  },
  {
    "name": "eig",
    "description": "Finds the eigenvalue and/or eigenvector of a matrix. The matrix has to be square.",
    "usage": "eig();",
    "category": "general",
    "markdown": "# eig\r\n\r\nFinds the eigenvalue and/or eigenvector of a matrix. The matrix has to be square.\r\n\r\n| **Syntax**                     | **Description**                                            |\r\n| ------------------------------ | ---------------------------------------------------------- |\r\n| out = eig(A); out = eig(A, 1); | Returns the eigenvalues of matrix A.                       |\r\n| out = eig(A, 2);               | Returns the eigenvectors of matrix A.                      |\r\n| out = eig(A, 3);               | Returns both the eigenvalues and eigenvectors of matrix A. |\r\n\r\n**Example**\r\n\r\nA simple example showing the different options for the results from the eigenvalue\r\ncalculation.\r\n\r\n```\r\nA = [ 1, 2; 2, 4];\r\n?eig(A);\r\nresult: \r\n0 \r\n5 \r\n?eig(A,1);\r\nresult: \r\n0 \r\n5 \r\n?eig(A,2);\r\nresult: \r\n-0.894427 -0.447214 \r\n0.447214 -0.894427 \r\n?eig(A,3);\r\nresult(i,j,1):\r\n0 0 \r\n0 5 \r\nresult(i,j,2):\r\n-0.894427 -0.447214 \r\n0.447214 -0.894427 \r\n```",
    "summary": "Finds the eigenvalue and/or eigenvector of a matrix",
    "syntax": [
      {
        "syntax": "out = eig(A); out = eig(A, 1);",
        "description": "Returns the eigenvalues of matrix A."
      },
      {
        "syntax": "out = eig(A, 2);",
        "description": "Returns the eigenvectors of matrix A."
      },
      {
        "syntax": "out = eig(A, 3);",
        "description": "Returns both the eigenvalues and eigenvectors of matrix A."
      }
    ],
    "example": "A = [ 1, 2; 2, 4];\r\n?eig(A);\r\nresult: \r\n0 \r\n5 \r\n?eig(A,1);\r\nresult: \r\n0 \r\n5 \r\n?eig(A,2);\r\nresult: \r\n-0.894427 -0.447214 \r\n0.447214 -0.894427 \r\n?eig(A,3);\r\nresult(i,j,1):\r\n0 0 \r\n0 5 \r\nresult(i,j,2):\r\n-0.894427 -0.447214 \r\n0.447214 -0.894427"
  },
  {
    "name": "emepropagate",
    "description": "Propagates fields for EME profile monitor and calculates s-matrix and user s-matrix results, as well as any error diagnostic results when in Analysis mode using EME solver. This is equivalent to clicking the \"eme propagate\" button.",
    "usage": "emepropagate();",
    "category": "general",
    "markdown": "# emepropagate\r\n\r\nPropagates fields for EME profile monitor and calculates s-matrix and user s-matrix\r\nresults, as well as any error diagnostic results when in Analysis mode using EME solver.\r\nThis is equivalent to clicking the \"eme propagate\" button.\r\n\r\n| **Syntax**    | **Description**                                                                                                          |\r\n| ------------- | ------------------------------------------------------------------------------------------------------------------------ |\r\n| emepropagate; | Propagate fields and s-matrix results. This is equivalent to the \"eme propagate\" button in the graphical user interface. |\r\n\r\n**Examples**\r\n\r\nThis code will set up the group spans column in the EME analysis window then propagate\r\nusing the EME solver.\r\n\r\n```\r\n# set group spans to 1 micron  \r\nsetemeanalysis(\"group spans\",[1e-6;1e-6;1e-6]);  \r\n\r\n# propagate eme  \r\nemepropagate;\r\n```",
    "summary": "Propagates fields for EME profile monitor and calculates s-matrix and user s-matrix results, as well...",
    "syntax": [
      {
        "syntax": "emepropagate;",
        "description": "Propagate fields and s-matrix results. This is equivalent to the \"eme propagate\" button in the graphical user interface."
      }
    ],
    "example": ""
  },
  {
    "name": "emesweep",
    "description": "When in Analysis mode using EME solver, runs either propagation sweep tool which sweeps the length of a cell group span or mode convergence sweep tool which sweeps the number of modes. .",
    "usage": "emesweep();",
    "category": "general",
    "markdown": "# emesweep\r\n\r\nWhen in Analysis mode using EME solver, runs either propagation sweep tool which sweeps\r\nthe length of a cell group span or mode convergence sweep tool which sweeps the number\r\nof modes. .\r\n\r\n| **Syntax**                               | **Description**             |\r\n| ---------------------------------------- | --------------------------- |\r\n| emesweep; emesweep(\"propagation sweep\"); | Run propagation sweep.      |\r\n| emesweep(\"wavelength sweep\");            | Run wavelength sweep.       |\r\n| emesweep(\"mode convergence sweep\");      | Run mode convergence sweep. |\r\n\r\n**Examples**\r\n\r\nThis code will set up, run and collect the user s-matrix result from the propagation\r\nsweep tool in Analysis mode. The result from the propagation sweep is packaged in a\r\ndataset called \"S\".\r\n\r\n```\r\n# set propagation sweep settings  \r\nsetemeanalysis(\"propagation sweep\",1);  \r\nsetemeanalysis(\"parameter\",\"group span 2\");  \r\nsetemeanalysis(\"start\",10e-6);  \r\nsetemeanalysis(\"stop\",200e-6);  \r\nsetemeanalysis(\"number of points\",10);  \r\n  \r\nemesweep;  \r\n  \r\nS = getemesweep('S');  \r\n\r\n# plot S21 vs group span  \r\ns21 = S.s21;  \r\ngroup_span = S.group_span_2;  \r\nplot(group_span,abs(s21)^2);\r\n```\r\n\r\nThis code will set up, run and collect the user s-matrix result from the mode\r\nconvergence sweep tool in Analysis mode. The result from the mode convergence sweep is\r\npackaged in a dataset called \"S_mode_convergence_sweep\".\r\n\r\n```\r\n# set mode convergence sweep settings  \r\nstart_mode = 4; #set smaller number of modes for convergence test  \r\nmode_interval = 1; #set mode interval for convergence test  \r\nsetnamed(\"EME\",\"number of modes for all cell groups\",25);   \r\nsetemeanalysis(\"mode convergence sweep\", 1);  \r\nsetemeanalysis(\"start mode\", start_mode);  \r\nsetemeanalysis(\"mode interval\", mode_interval);  \r\n\r\n# run mode convergence sweep tool  \r\nemesweep(\"mode convergence sweep\");  \r\n\r\n# get mode convergence sweep result  \r\nS = getemesweep(\"S_mode_convergence_sweep\");  \r\n\r\n# plot S21 vs number of modes  \r\ns21 = S.s21;  \r\nmodes = S.modes;  \r\nplot(modes, abs(s21)^2);\r\n```",
    "summary": "When in Analysis mode using EME solver, runs either propagation sweep tool which sweeps the length o...",
    "syntax": [
      {
        "syntax": "emesweep; emesweep(\"propagation sweep\");",
        "description": "Run propagation sweep."
      },
      {
        "syntax": "emesweep(\"wavelength sweep\");",
        "description": "Run wavelength sweep."
      },
      {
        "syntax": "emesweep(\"mode convergence sweep\");",
        "description": "Run mode convergence sweep."
      }
    ],
    "example": ""
  },
  {
    "name": "enabledesignkit",
    "description": "Enables a design kit in the Design Kits folder.",
    "usage": "enabledesignkit();",
    "category": "general",
    "markdown": "# enabledesignkit\r\n\r\nEnables a design kit in the Design Kits folder.\r\n\r\n| **Syntax**                            | **Description**                                                                                                                                                   |\r\n| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| enabledesignkit(\"name\", [\"version\"]); | Enables a design kit that is already installed to the Design Kit folder with the version number \"version\". The \"version\" is optional, default is an empty string. |\r\n\r\n**Example**\r\n\r\n```\r\n#enables the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\nenabledesignkit(\"LCML\", \"v1.1\");\r\n```",
    "summary": "Enables a design kit in the Design Kits folder",
    "syntax": [
      {
        "syntax": "enabledesignkit(\"name\", [\"version\"]);",
        "description": "Enables a design kit that is already installed to the Design Kit folder with the version number \"version\". The \"version\" is optional, default is an empty string."
      }
    ],
    "example": "#enables the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\nenabledesignkit(\"LCML\", \"v1.1\");"
  },
  {
    "name": "encryptscript",
    "description": "Save a copy of the specified script file in an encrypted format. The new file will have a .lsfx file extension. Encrypting a script allows a script to be shared with others, without allowing them to see the contents of the script.",
    "usage": "encryptscript();",
    "category": "general",
    "markdown": "# encryptscript\r\n\r\nSave a copy of the specified script file in an encrypted format. The new file will have\r\na .lsfx file extension. Encrypting a script allows a script to be shared with others,\r\nwithout allowing them to see the contents of the script.\r\n\r\n| **Syntax**                                        | **Description**                                                                                                              |\r\n| ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| encryptscript(\"filename.lsf\");                    | Recommended: Encrypt a copy of the script, not compatible with earlier versions. The new file will be named \"filename.lsfx\". |\r\n| encryptscript(\"filename.lsf\", 1);                 | Legacy: Encrypt a copy of the script, compatible with earlier versions.                                                      |\r\n| encryptscript(\"filename.lsf\", \"new_filename\");    | Specify an alternate file name, not compatible with earlier versions. The new file will be named \"filename.lsfx\".            |\r\n| encryptscript(\"filename.lsf\", \"new_filename\", 1); | Specify an alternate file name, compatible with earlier versions. The new file will be named \"filename.lsfx\".                |\r\n\r\nScripts encrypted with 2020B will not be compatible with 2020A and earlier, unless the\r\nadditional argument (1) is passed to encryptscript specifying legacy compatibility.\r\nScripts encrypted with 2020A and earlier will continue to be compatible with later\r\nversions.\r\n\r\n### Example\r\n\r\nIf the script file is already encrypted, user can run the script file by entering the\r\nname of the file in the Script Prompt. However, user will not be able to see the content\r\nof the file.\r\n\r\n```\r\nfilename # it will run the encrypted script file filename.lsfx\r\n```",
    "summary": "Save a copy of the specified script file in an encrypted format",
    "syntax": [
      {
        "syntax": "encryptscript(\"filename.lsf\");",
        "description": "Recommended: Encrypt a copy of the script, not compatible with earlier versions. The new file will be named \"filename.lsfx\"."
      },
      {
        "syntax": "encryptscript(\"filename.lsf\", 1);",
        "description": "Legacy: Encrypt a copy of the script, compatible with earlier versions."
      },
      {
        "syntax": "encryptscript(\"filename.lsf\", \"new_filename\");",
        "description": "Specify an alternate file name, not compatible with earlier versions. The new file will be named \"filename.lsfx\"."
      },
      {
        "syntax": "encryptscript(\"filename.lsf\", \"new_filename\", 1);",
        "description": "Specify an alternate file name, compatible with earlier versions. The new file will be named \"filename.lsfx\"."
      }
    ],
    "example": ""
  },
  {
    "name": "end",
    "description": "Specifies the last index of an array.",
    "usage": "end();",
    "category": "general",
    "markdown": "# end\r\n\r\nSpecifies the last index of an array.\r\n\r\n| **Syntax**  | **Description**                                                         |\r\n| ----------- | ----------------------------------------------------------------------- |\r\n| y=x(3:end); | y will be the submatrix of x, from the 3rd element to the last element. |\r\n\r\n**Examples**\r\n\r\nCreate a vector, then access a portion of that matrix.\r\n\r\n```\r\na=l:5;     # a will be vector (1, 2, 3, 4, 5)\r\n?b=a(4:end);  # b will be vector (4, 5) \r\n```\r\n\r\nRetrieve elements from matrices using 'end' to mean last index. You may use 'end' in any\r\nmathematical expression that results in indexing. Nested use of 'end' should work\r\nproperly.\r\n\r\n```\r\nA = randmatrix(5,4);\r\n?A(3:end,2);      # equivalent to A(3:5,2)\r\n?A(1:end-2,2);    # equivalent to A(3:5-2,2)\r\n?A(end-1:-1:1,2); # equivalent to A(5-1:-1:1,2)\r\n?A(1:end);        # equivalent to A(1:20) and A(:)\r\nB = [1,0,1,1];\r\n?A( sum(B(2:end)):end, 1);  # equivalent to A( sum(B(2:4)):5, 1)\r\n?end+4;           # error: \"context error - 'end' may only be used when indexing a matrix\"\r\n```",
    "summary": "Specifies the last index of an array",
    "syntax": [
      {
        "syntax": "y=x(3:end);",
        "description": "y will be the submatrix of x, from the 3rd element to the last element."
      }
    ],
    "example": ""
  },
  {
    "name": "endl",
    "description": "Adds an end of line character to a string",
    "usage": "endl();",
    "category": "general",
    "markdown": "# endl\r\n\r\nAdds an end of line character to a string\r\n\r\n| **Syntax**                  | **Description**                             |\r\n| --------------------------- | ------------------------------------------- |\r\n| out = \"line1\"+endl+\"line2\"; | Add an end of line character to the string. |\r\n\r\n**Example**\r\n\r\nUse an end of line character in a string.\r\n\r\n```\r\n?out = \"line1\"+endl+\"line2\";\r\nline1\r\nline2\r\n```",
    "summary": "Adds an end of line character to a string",
    "syntax": [
      {
        "syntax": "out = \"line1\"+endl+\"line2\";",
        "description": "Add an end of line character to the string."
      }
    ],
    "example": "?out = \"line1\"+endl+\"line2\";\r\nline1\r\nline2"
  },
  {
    "name": "erf",
    "description": "Calculates the error function as defined by the following equation:",
    "usage": "erf();",
    "category": "general",
    "markdown": "# erf\r\n\r\nCalculates the error function as defined by the following equation:\r\n\r\n$$ \\\\operatorname{erf}(z)=\\\\frac{2}{\\\\sqrt{\\\\pi}} \\\\int\\_{0}^{z} \\\\exp\r\n\\\\left(-t^{2}\\\\right) d t $$\r\n\r\n| **Syntax**  | **Description**                                                                     |\r\n| ----------- | ----------------------------------------------------------------------------------- |\r\n| out=erf(z); | Returns error function of z where z is a scalar number or matrix of scalar numbers. |\r\n\r\n**Example**\r\n\r\nPlot the error function from z=-5 to 5.\r\n\r\n```\r\nz=linspace(-5,5,50); # generate vector of numbers from -5 to 5 with 50 points\r\nerf_z = erf(z);\r\nplot(z,erf_z,\"z\",\"erf\");\r\n```\r\n\r\nThe following figure shows the plot created by the example code.",
    "summary": "Calculates the error function as defined by the following equation:",
    "syntax": [
      {
        "syntax": "out=erf(z);",
        "description": "Returns error function of z where z is a scalar number or matrix of scalar numbers."
      }
    ],
    "example": "z=linspace(-5,5,50); # generate vector of numbers from -5 to 5 with 50 points\r\nerf_z = erf(z);\r\nplot(z,erf_z,\"z\",\"erf\");"
  },
  {
    "name": "erfc",
    "description": "Calculates the complementary error function as defined by the following equation:",
    "usage": "erfc();",
    "category": "general",
    "markdown": "# erfc\r\n\r\nCalculates the complementary error function as defined by the following equation:\r\n\r\n$$ \\\\operatorname{erfc}(z)=1-\\\\frac{2}{\\\\sqrt{\\\\pi}} \\\\int\\_{0}^{z} \\\\exp\r\n\\\\left(-t^{2}\\\\right) d t $$\r\n\r\n| **Syntax**   | **Description**                                                                                       |\r\n| ------------ | ----------------------------------------------------------------------------------------------------- |\r\n| out=erfc(z); | Returns the complementary error function of z where z is a scalar number or matrix of scalar numbers. |\r\n\r\n**Example**\r\n\r\nPlot the complementary error function from z=-5 to 5.\r\n\r\n```\r\nz=linspace(-5,5,50); # generate vector of numbers from -5 to 5 with 50 points\r\nerfc_z = erfc(z);\r\nplot(z,erfc_z,\"z\",\"erfc\");\r\n```\r\n\r\nThe following figure shows the plot created by the example code.",
    "summary": "Calculates the complementary error function as defined by the following equation:",
    "syntax": [
      {
        "syntax": "out=erfc(z);",
        "description": "Returns the complementary error function of z where z is a scalar number or matrix of scalar numbers."
      }
    ],
    "example": "z=linspace(-5,5,50); # generate vector of numbers from -5 to 5 with 50 points\r\nerfc_z = erfc(z);\r\nplot(z,erfc_z,\"z\",\"erfc\");"
  },
  {
    "name": "erfcinv",
    "description": "Calculates the inverse complementary error function as defined by the following equation in relationship to the inverse error function erfinv :",
    "usage": "erfcinv();",
    "category": "general",
    "markdown": "# erfcinv\r\n\r\nCalculates the inverse complementary error function as defined by the following equation\r\nin relationship to the inverse error function erfinv :\r\n\r\n$$ erfcinv(1-z)=erfinv(z) $$\r\n\r\n| **Syntax**      | **Description**                                                                                                                                                            |\r\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=erfcinv(z); | Returns the inverse complementary error function of z where z is a scalar number or matrix of scalar numbers. For inputs outside the interval (0, 2), erfcinv returns NaN. |\r\n\r\n**Example**\r\n\r\nPlot the inverse complementary error function for 0\r\n\r\n```\r\nz=0.01:0.05:1.99; \r\nerfcinv_z = erfcinv(z);\r\nplot(z,erfcinv_z,\"z\",\"erf\");\r\n```\r\n\r\nThe following figure shows the plot created by the example code.",
    "summary": "Calculates the inverse complementary error function as defined by the following equation in relation...",
    "syntax": [
      {
        "syntax": "out=erfcinv(z);",
        "description": "Returns the inverse complementary error function of z where z is a scalar number or matrix of scalar numbers. For inputs outside the interval (0, 2), erfcinv returns NaN."
      }
    ],
    "example": "z=0.01:0.05:1.99; \r\nerfcinv_z = erfcinv(z);\r\nplot(z,erfcinv_z,\"z\",\"erf\");"
  },
  {
    "name": "erfinv",
    "description": "Calculates the inverse error function as defined by the following equation:",
    "usage": "erfinv();",
    "category": "general",
    "markdown": "# erfinv\r\n\r\nCalculates the inverse error function as defined by the following equation:\r\n\r\n$$ \\\\operatorname{erfinv}(z)=\\\\sum\\_{k=0}^{\\\\infty} \\\\frac{c\\_{k}}{2\r\nk+1}\\\\left(\\\\frac{\\\\sqrt{\\\\pi}}{2} z\\\\right)^{2 k+1} $$\r\n\r\n| **Syntax**     | **Description**                                                                                                                                              |\r\n| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out=erfinv(z); | Returns the inverse error function of z where z is a scalar number or matrix of scalar numbers. For inputs outside the interval (-1, 1), erfinv returns NaN. |\r\n\r\n**Example**\r\n\r\nPlot the inverse error function for -1\r\n\r\n```\r\nz=[-0.99:0.01:0.99];\r\nerfinv_z = erfinv(z);\r\nplot(z,erfinv_z,\"z\",\"erfinv\");\r\n```\r\n\r\nThe following figure shows the plot created by the example code.",
    "summary": "Calculates the inverse error function as defined by the following equation:",
    "syntax": [
      {
        "syntax": "out=erfinv(z);",
        "description": "Returns the inverse error function of z where z is a scalar number or matrix of scalar numbers. For inputs outside the interval (-1, 1), erfinv returns NaN."
      }
    ],
    "example": "z=[-0.99:0.01:0.99];\r\nerfinv_z = erfinv(z);\r\nplot(z,erfinv_z,\"z\",\"erfinv\");"
  },
  {
    "name": "eval",
    "description": "Executes a string containing Lumerical's scripting language.",
    "usage": "eval();",
    "category": "general",
    "markdown": "# eval\r\n\r\nExecutes a string containing Lumerical's scripting language.\r\n\r\n| **Syntax**    | **Description**                                                                           |\r\n| ------------- | ----------------------------------------------------------------------------------------- |\r\n| eval(string); | Executes the Lumerical script commands in string. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nExecute a string as a command.\r\n\r\n```\r\neval(\"x=1+2;\");\r\n?x;\r\n3\r\n```",
    "summary": "Executes a string containing Lumerical's scripting language",
    "syntax": [
      {
        "syntax": "eval(string);",
        "description": "Executes the Lumerical script commands in string. This function does not return any data."
      }
    ],
    "example": "eval(\"x=1+2;\");\r\n?x;\r\n3"
  },
  {
    "name": "evalremote",
    "description": "An interoperability command that will send a script commnad(s) to the server product and executes it there",
    "usage": "evalremote();",
    "category": "general",
    "markdown": "# evalremote\r\n\r\nAn interoperability command that will send a script commnad(s) to the server product and\r\nexecutes it there\r\n\r\n| **Syntax**              | **Description**                                                          |\r\n| ----------------------- | ------------------------------------------------------------------------ |\r\n| evalremote(s,\"y=x^2;\"); | Sends command y=x^2; to the server via an open session s and executes it |\r\n\r\n### Example\r\n\r\nThe following code example opens Device as a server, sends local variable 'x' to Device\r\nworkspace followed by a command to manipulate the variable and the retrieves the result\r\nbefore closing the session:\r\n\r\n```\r\n#Opend Device session\r\ns2=opensession('device');\r\n#Declare local variable x\r\nx=2;\r\n#Send the local variable to Device workspace via API\r\nputremotedata(s2,'x_device',x);\r\n#Send script command to Device via API andsquare the variable\r\nevalremote(s2,\"y_device=x_device^2;\");\r\n#Get the variable from Device worksapace via API \r\n?y=getremotedata(s2,'y_device');\r\n#Close the session\r\nclosesession(s2);\r\n```",
    "summary": "An interoperability command that will send a script commnad(s) to the server product and executes it...",
    "syntax": [
      {
        "syntax": "evalremote(s,\"y=x^2;\");",
        "description": "Sends command y=x^2; to the server via an open session s and executes it"
      }
    ],
    "example": ""
  },
  {
    "name": "exist",
    "description": "Returns a number based on type of the string used in the command.",
    "usage": "exist();",
    "category": "general",
    "markdown": "# exist\r\n\r\nReturns a number based on type of the string used in the command.\r\n\r\n| **Syntax** | **Description**                                                                                                                                                                                                                                                                                                         |\r\n| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| exist(\"x\") | Returns 0 if there is no variable, operator, built-in function or script file (x.lsf) in the current script path 1 if x is a variable, example: x=5; ?exist(“x”); 2 if x is an operator or built in keyword, example: ?exist(“\\*”) or ?exist(“for”); 3 if x is a script file in the current script path, called “x.lsf” |\r\n\r\n**Examples**\r\n\r\nThe following simple examples show the usage of the exist command\r\n\r\n```\r\na = 1:10;\r\n?exist(\"a\");\r\nresult: \r\n1  \r\n?exist(\"farfield3d\");\r\nresult: \r\n2 \r\n```",
    "summary": "Returns a number based on type of the string used in the command",
    "syntax": [
      {
        "syntax": "exist(\"x\")",
        "description": "Returns 0 if there is no variable, operator, built-in function or script file (x.lsf) in the current script path 1 if x is a variable, example: x=5; ?exist(“x”); 2 if x is an operator or built in keyword, example: ?exist(“\\*”) or ?exist(“for”); 3 if x is a script file in the current script path, called “x.lsf”"
      }
    ],
    "example": ""
  },
  {
    "name": "exit",
    "description": "Exits the application.",
    "usage": "exit();",
    "category": "general",
    "markdown": "# exit\r\n\r\nExits the application.\r\n\r\n| **Syntax**    | **Description**                                                                 |\r\n| ------------- | ------------------------------------------------------------------------------- |\r\n| exit;         | Exits the application. Same as exit(1); This function does not return any data. |\r\n| exit(option); | Exits the application. The option can be                                        |\r\n\r\n- 1: Prompt user if a file needs saving before exiting.\r\n- 2: Force the application to exit without prompting the user.\r\n\r\nThe default option is 1.\r\n\r\n**Examples**\r\n\r\nExits the application, and prompt user to save data.\r\n\r\n```\r\nexit(1);\r\n```",
    "summary": "Exits the application",
    "syntax": [
      {
        "syntax": "exit;",
        "description": "Exits the application. Same as exit(1); This function does not return any data."
      },
      {
        "syntax": "exit(option);",
        "description": "Exits the application. The option can be"
      }
    ],
    "example": ""
  },
  {
    "name": "exp",
    "description": "Calculates the natural exponential function. Input can be complex.",
    "usage": "exp();",
    "category": "general",
    "markdown": "# exp\r\n\r\nCalculates the natural exponential function. Input can be complex.\r\n\r\n| **Syntax**    | **Description**               |\r\n| ------------- | ----------------------------- |\r\n| out = exp(x); | The natural exponential of x. |\r\n\r\n**Example**\r\n\r\nTo calculate e, use exp(1);\r\n\r\n```\r\n?exp(1);\r\nresult: \r\n2.71828 \r\n```\r\n\r\nTo multiply 1+1i by 30 degrees\r\n\r\n```\r\nx=1+1i;\r\n?x * exp(1i*pi/6);\r\nresult: \r\n0.366025+1.36603i \r\n```",
    "summary": "Calculates the natural exponential function",
    "syntax": [
      {
        "syntax": "out = exp(x);",
        "description": "The natural exponential of x."
      }
    ],
    "example": "?exp(1);\r\nresult: \r\n2.71828"
  },
  {
    "name": "expand",
    "description": "Returns the expansion coefficients between the fields recorded at two arbitrary DFT monitors, saved in two D-CARDs, or saved in two rectilinear datasets. The coefficients are defined according to:",
    "usage": "expand();",
    "category": "general",
    "markdown": "# expand\r\n\r\nReturns the expansion coefficients between the fields recorded at two arbitrary DFT\r\nmonitors, saved in two D-CARDs, or saved in two rectilinear datasets. The coefficients\r\nare defined according to:\r\n\r\n$$ \\\\begin{array}{l}{a=0.25 *\\\\left(\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{1}\r\n\\\\times \\\\mathbf{H}_{2}^{*}}{N}+\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{2}^{\\*}\r\n\\\\times \\\\mathbf{H}_{1}}{\\\\operatorname{conj}(N)}\\\\right)} \\\\\\\\ {b=0.25\r\n*\\\\left(\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{1} \\\\times\r\n\\\\mathbf{H}_{2}^{*}}{N}-\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{2}^{\\*} \\\\times\r\n\\\\mathbf{H}_{1}}{\\\\operatorname{con} j(N)}\\\\right)} \\\\\\\\ {N=0.5^{*} \\\\int d\r\n\\\\mathbf{S}\\\\cdot \\\\mathbf{E}_{2} \\\\times \\\\mathbf{H}_{2}^{*}} \\\\\\\\ {P=0.5 * \\\\int d\r\n\\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{1} \\\\times \\\\mathbf{H}_{1}^{\\*}}\\\\end{array} $$\r\n\r\nFor more detail on how to use this command, definitions on the parameters and how to\r\ninterpret the results, please see\r\n[ Using Mode Expansion Monitors](https://optics.ansys.com/hc/en-us/articles/360034902433-Using-Mode-Expansion-Monitors).\r\nNote that real(N) is the power of the waveguide mode. conj(N) is equal to N if this is a\r\nreal number. For the unconjugated coefficients, see [ expand2](./expand2.md).\r\n\r\n| **Syntax**                    | **Description**                                                    |\r\n| ----------------------------- | ------------------------------------------------------------------ |\r\n| expand(mode1,mode_ref,x,y,z); | Outputs the expansion coefficients between the fields of two modes |\r\n\r\n- mode1, mode_ref: field information, with \\\\(\\\\mathbf{E}_{1}\\\\),\\\\(\\\\mathbf{H}_{1}\\\\)\r\n  contained in mode1, and \\\\(\\\\mathbf{E}_{2}\\\\),\\\\(\\\\mathbf{H}_{2}\\\\) contained in\r\n  mode_ref. Can be in one of the following formats:\r\n  1. ```\r\n        1. Frequency domain monitor names, string input, e.g. “monitor1”\r\n     ```\r\n     2. Mode D-CARDs containing field information, string input, e.g. “mode1”\r\n     1. Rectilinear datasets, see below for more information\r\n- x,y,z: spatial displacement of the fields from monitor1 with respect to those from\r\n  monitor_ref\r\n\r\n## Using Rectilinear Datasets\r\n\r\nStarting in 2024R2.3, rectilinear datasets with arbitrary field profiles are supported\r\nin addition to monitor names and D-CARDs.\r\n\r\nRectilinear datasets **cannot** be mixed with other input types, however, data can be\r\nextracted from modes using the\r\n[getresult script command](https://optics.ansys.com/hc/en-us/articles/360034409854-getresult-Script-command),\r\nshown in the examples below.\r\n\r\nWhen using rectilinear datasets, they should contain attribute names ‘E’ and ‘H’, which\r\nwill be used as the electric and magnetic fields, respectively. If no attribute name ‘E’\r\nis found, the first attribute of the dataset is assumed to be the electric field. If no\r\nattribute ‘H’ is found, the first attribute of the dataset after the electric field\r\nattribute is assumed to be the magnetic field.\r\n\r\n**Example**\r\n\r\nThe following script expands the fields from monitor \"R\" onto the reference monitor\r\n\"R_ref\":\r\n\r\n```\r\nM = expand(\"R\",\"R_ref\",0,0,0);\r\nf = getdata(\"R\",\"f\");\r\na = pinch(M,1,1);\r\nb = pinch(M,1,2);\r\nn = pinch(M,1,3);\r\np = pinch(M,1,4);\r\nS11 = b;\r\n```\r\n\r\nThe following script expands the fields from monitor “R” onto reference monitor “R_ref”\r\nby first converting them to rectilinear datasets using getresult. The result is\r\nidentical to above.\r\n\r\n```\r\n# example using rectilinear datasets  \r\n#First, obtain rectilinear dataset from monitors using getresult  \r\n#These datasets could have been imported from elsewhere as well  \r\nEH1 = getresult(\"R\",\"E\");  \r\nH1 = getresult(\"R\",\"H\");  \r\nEH1.addattribute(\"H\",H1.H);  \r\nEH2 = getresult(\"R_ref\",\"E\");  \r\nH2 = getresult(\"R_ref\",\"H\");  \r\nEH2.addattribute(\"R_ref\",H2.H);  \r\n  \r\nM = expand(EH1,EH2,0,0,0);  \r\nf = EH1.f;  \r\na = pinch(M,1,1);  \r\nb = pinch(M,1,2);  \r\nn = pinch(M,1,3);  \r\np = pinch(M,1,4);  \r\nS11 = b;\r\n```",
    "summary": "Returns the expansion coefficients between the fields recorded at two arbitrary DFT monitors, saved ...",
    "syntax": [
      {
        "syntax": "expand(mode1,mode_ref,x,y,z);",
        "description": "Outputs the expansion coefficients between the fields of two modes"
      }
    ],
    "example": "M = expand(\"R\",\"R_ref\",0,0,0);\r\nf = getdata(\"R\",\"f\");\r\na = pinch(M,1,1);\r\nb = pinch(M,1,2);\r\nn = pinch(M,1,3);\r\np = pinch(M,1,4);\r\nS11 = b;"
  },
  {
    "name": "expand2",
    "description": "Returns the expansion coefficients in the unconjugated form between the fields recorded at two arbitrary DFT monitors or saved in D-CARDs, or saved in two rectilinear datasets. The coefficients in the unconjugated form are defined according to:",
    "usage": "expand2();",
    "category": "general",
    "markdown": "# expand2\r\n\r\nReturns the expansion coefficients in the unconjugated form between the fields recorded\r\nat two arbitrary DFT monitors or saved in D-CARDs, or saved in two rectilinear datasets.\r\nThe coefficients in the unconjugated form are defined according to:\r\n\r\n$$ \\\\begin{array}{l}{a=0.25^{*}\\\\left(\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{1}\r\n\\\\times \\\\mathbf{H}_{2}}{N}+\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{2} \\\\times\r\n\\\\mathbf{H}_{1}}{N}\\\\right)} \\\\\\\\ {b=0.25^{*}\\\\left(\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot\r\n\\\\mathbf{E}_{1} \\\\times \\\\mathbf{H}_{2}}{N}-\\\\frac{\\\\int d \\\\mathbf{S} \\\\cdot\r\n\\\\mathbf{E}_{2} \\\\times \\\\mathbf{H}_{1}}{N}\\\\right)} \\\\\\\\ {N=0.5 * \\\\int d\r\n\\\\mathbf{S}\\\\cdot \\\\mathbf{E}_{2} \\\\times \\\\mathbf{H}_{2}} \\\\\\\\ {P=0.5^{\\*} \\\\int d\r\n\\\\mathbf{S} \\\\cdot \\\\mathbf{E}_{1} \\\\times \\\\mathbf{H}_{1}}\\\\end{array} $$\r\n\r\nFor more detail on how to use this command, definitions on the parameters and how to\r\ninterpret the results, please see\r\n[ Using Mode Expansion Monitors ](https://optics.ansys.com/hc/en-us/articles/360034902433-Using-Mode-Expansion-Monitors)\r\n.\r\n\r\n| **Syntax**                     | **Description**                                                                             |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------- |\r\n| expand2(mode1,mode_ref,x,y,z); | Outputs the expansion coefficients between the fields of two modes in the unconjugated form |\r\n\r\n- mode1, mode_ref: field information, with \\\\(\\\\mathbf{E}_{1},\\\\mathbf{H}_{1}\\\\)\r\n  contained in mode1, and \\\\(\\\\mathbf{E}_{2},\\\\mathbf{H}_{2}\\\\) contained in mode_ref.\r\n  Can be in one of the following formats:\r\n  - ```\r\n      1. Frequency domain monitor names, string input, e.g. “monitor1”\r\n    ```\r\n    2. Mode D-CARDs containing field information, string input, e.g. “mode1”\r\n    1. Rectilinear datasets, see below for more info\r\n- x,y,z: spatial displacement of the fields from monitor1 with respect to those from\r\n  monitor_ref\r\n\r\n## Using Rectilinear Datasets\r\n\r\nStarting in 2024R2.3, rectilinear datasets with arbitrary field profiles are supported\r\nin addition to monitor names and D-CARDs.\r\n\r\nRectilinear datasets **cannot** be mixed with other input types, however, data can be\r\nextracted from modes using the\r\n[getresult script command](https://optics.ansys.com/hc/en-us/articles/360034409854-getresult-Script-command),\r\nshown in the examples below.\r\n\r\nWhen using rectilinear datasets, they should contain attribute names ‘E’ and ‘H’, which\r\nwill be used as the electric and magnetic fields, respectively. If no attribute name ‘E’\r\nis found, the first attribute of the dataset is assumed to be the electric field. If no\r\nattribute ‘H’ is found, the first attribute of the dataset after the electric field\r\nattribute is assumed to be the magnetic field.\r\n\r\n**Example**\r\n\r\nThe following script expands the fields from monitor \"R\" onto the reference monitor\r\n\"R_ref\" in the unconjugated form:\r\n\r\n```\r\nM = expand2(\"R\",\"R_ref\",0,0,0);  \r\nf = getdata(\"R\",\"f\");\r\na = pinch(M,1,1);\r\nb = pinch(M,1,2);\r\nn = pinch(M,1,3);\r\np = pinch(M,1,4);\r\nS11 = b;\r\n```\r\n\r\nThe following script expands the fields from monitor “R” onto reference monitor “R_ref”\r\nby first converting them to rectilinear datasets using getresult. The result is\r\nidentical to above.\r\n\r\n```\r\n# example using rectilinear datasets  \r\n#First, obtain rectilinear dataset from monitors using getresult  \r\n#These datasets could have been imported from elsewhere as well  \r\nEH1 = getresult(\"R\",\"E\");  \r\nH1 = getresult(\"R\",\"H\");  \r\nEH1.addattribute(\"H\",H1.H);  \r\nEH2 = getresult(\"R_ref\",\"E\");  \r\nH2 = getresult(\"R_ref\",\"H\");  \r\nEH2.addattribute(\"R_ref\",H2.H);  \r\n  \r\nM = expand2(EH1,EH2,0,0,0);  \r\nf = EH1.f;  \r\na = pinch(M,1,1);  \r\nb = pinch(M,1,2);  \r\nn = pinch(M,1,3);  \r\np = pinch(M,1,4);  \r\nS11 = b;\r\n```",
    "summary": "Returns the expansion coefficients in the unconjugated form between the fields recorded at two arbit...",
    "syntax": [
      {
        "syntax": "expand2(mode1,mode_ref,x,y,z);",
        "description": "Outputs the expansion coefficients between the fields of two modes in the unconjugated form"
      }
    ],
    "example": "M = expand2(\"R\",\"R_ref\",0,0,0);  \r\nf = getdata(\"R\",\"f\");\r\na = pinch(M,1,1);\r\nb = pinch(M,1,2);\r\nn = pinch(M,1,3);\r\np = pinch(M,1,4);\r\nS11 = b;"
  },
  {
    "name": "exportcsvresults",
    "description": "This script command can export the results of a simulation to comma separated value formatted files, which can be opened by Microsoft Excel.",
    "usage": "exportcsvresults();",
    "category": "general",
    "markdown": "# exportcsvresults\r\n\r\nThis script command can export the results of a simulation to comma separated value\r\nformatted files, which can be opened by Microsoft Excel.\r\n\r\n| **Syntax**                                  | **Description**                                                                                     |\r\n| ------------------------------------------- | --------------------------------------------------------------------------------------------------- |\r\n| exportcsvresults(\"filename\")                | exports the results of the entire simulation to multiple .cvs files, named filename_elementname.csv |\r\n| exportcsvresults(\"filename\", \"elementname\") | exports the results of the specified element to a .cvs file, named filename_elementname.csv         |\r\n\r\n| **Parameter** | **Type** | **Description**       |\r\n| ------------- | -------- | --------------------- |\r\n| filename      | string   | name of the .csv file |\r\n| elementname   | string   | name of the element.  |",
    "summary": "This script command can export the results of a simulation to comma separated value formatted files,...",
    "syntax": [
      {
        "syntax": "exportcsvresults(\"filename\")",
        "description": "exports the results of the entire simulation to multiple .cvs files, named filename_elementname.csv"
      },
      {
        "syntax": "exportcsvresults(\"filename\", \"elementname\")",
        "description": "exports the results of the specified element to a .cvs file, named filename_elementname.csv"
      }
    ],
    "example": ""
  },
  {
    "name": "exportfigure",
    "description": "Exports the current figure to a JPG image. If the file extension is not specified, \".jpg\" will be used. The image size will be the same as the figure window size.",
    "usage": "exportfigure();",
    "category": "general",
    "markdown": "# exportfigure\r\n\r\nExports the current figure to a JPG image. If the file extension is not specified,\r\n\".jpg\" will be used. The image size will be the same as the figure window size.\r\n\r\nIf a file is overwritten or if the export fails, a warning will be generated.\r\n\r\n| **Syntax**                          | **Description**                                                                                                                       |\r\n| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\r\n| exportfigure(\"filename\");           | Exports the current figure to a JPG image with the name \"filename\". The exported image will have the same size as the current figure. |\r\n| exportfigure(\"filename\",xres,yres); | The exported image will have the specified resolution, xres,yres, in the x,y directions respectively.                                 |\r\n\r\n**Example**\r\n\r\nCreate two figures, then select the first and export it to a .jpg file. All the\r\npreviously opened figure windows are closed beforehand using closeall.\r\n\r\n```\r\ncloseall;\r\nx=linspace(0,10,100);\r\ny1=sin(x);\r\ny2=y1^2;\r\nplot(x,y1,\"x\",\"y\",\"title\");\r\nplot(x,y2,\"x\",\"y\",\"title\");\r\nselectfigure(1);\r\nexportfigure(\"sine.jpg\");\r\n```",
    "summary": "Exports the current figure to a JPG image",
    "syntax": [
      {
        "syntax": "exportfigure(\"filename\");",
        "description": "Exports the current figure to a JPG image with the name \"filename\". The exported image will have the same size as the current figure."
      },
      {
        "syntax": "exportfigure(\"filename\",xres,yres);",
        "description": "The exported image will have the specified resolution, xres,yres, in the x,y directions respectively."
      }
    ],
    "example": "closeall;\r\nx=linspace(0,10,100);\r\ny1=sin(x);\r\ny2=y1^2;\r\nplot(x,y1,\"x\",\"y\",\"title\");\r\nplot(x,y2,\"x\",\"y\",\"title\");\r\nselectfigure(1);\r\nexportfigure(\"sine.jpg\");"
  },
  {
    "name": "exporthtml",
    "description": "Generates an html file describing an element.",
    "usage": "exporthtml();",
    "category": "general",
    "markdown": "# exporthtml\r\n\r\nGenerates an html file describing an element.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                        |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| exporthtml (element_name) | Generates an html file describing a custom element. The file lists the element type, symbol, and the list of properties. This command works only for elements in the Custom folder or its sub-folders. |\r\n\r\n**Example**\r\n\r\n```\r\naddelement(\"CW Laser\");\r\n# add element to the Custom folder\r\naddtolibrary;\r\n# add element to the sub folder \"test_folder\" of Custom folder\r\naddtolibrary(\"test_folder\");\r\n# export html page the CW Laser element in Custom\r\nexporthtml(\"CWL_1\");\r\n# export html page of the CW Laser element in \"test_folder\"\r\nexporthtml(\"test_folder::CWL_1\");\r\n# export html pages of all elements in the \"test folder\"\r\nexporthtml(\"test_folder\");\r\n```",
    "summary": "Generates an html file describing an element",
    "syntax": [
      {
        "syntax": "exporthtml (element_name)",
        "description": "Generates an html file describing a custom element. The file lists the element type, symbol, and the list of properties. This command works only for elements in the Custom folder or its sub-folders."
      }
    ],
    "example": "addelement(\"CW Laser\");\r\n# add element to the Custom folder\r\naddtolibrary;\r\n# add element to the sub folder \"test_folder\" of Custom folder\r\naddtolibrary(\"test_folder\");\r\n# export html page the CW Laser element in Custom\r\nexporthtml(\"CWL_1\");\r\n# export html page of the CW Laser element in \"test_folder\"\r\nexporthtml(\"test_folder::CWL_1\");\r\n# export html pages of all elements in the \"test folder\"\r\nexporthtml(\"test_folder\");"
  },
  {
    "name": "exportimage",
    "description": "Exports an image of the current circuit schematic.",
    "usage": "exportimage();",
    "category": "general",
    "markdown": "# exportimage\r\n\r\nExports an image of the current circuit schematic.\r\n\r\n| **Syntax**             | **Description**                                                                                                                                                                                                                      |\r\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| exportimage(filename); | Exports an image of the current circuit schematic. If the file has ‘png’ or no extension, a PNG (Portable Network Graphics) will be created. If the file has ‘svg’ extension, a SVG (Scalable Vector Graphics) file will be created. |\r\n\r\n**Example**\r\n\r\n```\r\nexportimage(\"schematic.png\");\r\n```",
    "summary": "Exports an image of the current circuit schematic",
    "syntax": [
      {
        "syntax": "exportimage(filename);",
        "description": "Exports an image of the current circuit schematic. If the file has ‘png’ or no extension, a PNG (Portable Network Graphics) will be created. If the file has ‘svg’ extension, a SVG (Scalable Vector Graphics) file will be created."
      }
    ],
    "example": "exportimage(\"schematic.png\");"
  },
  {
    "name": "exportlib",
    "description": "Exports the .lib file for a CML in the Custom folder.",
    "usage": "exportlib();",
    "category": "general",
    "markdown": "# exportlib\r\n\r\nExports the .lib file for a CML in the Custom folder.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                                                                                                                                                   |\r\n| --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| exportlib(name, path, overwrite); | Exports the .lib file for a CML in the Custom folder. name, the CML name in Custom path, where to save the exported .lib file. Use the current working directory if path is not provided. overwrite, boolean value to indicate whether or not to overwrite the file if it exists. |\r\n\r\n**Example**\r\n\r\n```\r\n#exports the \".lib\" file for \"dk.cml\"\r\nexportlib(\"dk.cml\", \"C:/Users/xxx\", true);\r\n```",
    "summary": "Exports the ",
    "syntax": [
      {
        "syntax": "exportlib(name, path, overwrite);",
        "description": "Exports the .lib file for a CML in the Custom folder. name, the CML name in Custom path, where to save the exported .lib file. Use the current working directory if path is not provided. overwrite, boolean value to indicate whether or not to overwrite the file if it exists."
      }
    ],
    "example": "#exports the \".lib\" file for \"dk.cml\"\r\nexportlib(\"dk.cml\", \"C:/Users/xxx\", true);"
  },
  {
    "name": "exportnetlist",
    "description": "Export a netlist for the current circuit.",
    "usage": "exportnetlist();",
    "category": "general",
    "markdown": "# exportnetlist\r\n\r\nExport a netlist for the current circuit.\r\n\r\n| **Syntax**                                                                                | **Description**                                                                                                                                                                                                                                                                                                                                                                 |\r\n| ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| exportnetlist; exportnetlist (filename); exportnetlist (element,filename,overwrite=true); | Export a netlist for the current circuit. ‘filename’ is the output netlist name, ‘element’ is the compound element to be exported. If ‘overwrite’ is true, any existing netlist file with the same name as ‘filename’ will be overwritten. If ‘element’ is not provided, the currently selected compound element will be exported, otherwise the root element will be exported. |\r\n\r\n### Example\r\n\r\n```\r\n>exportnetlist;\r\n>exportnetlist(\"circuit.spi\");\r\n```",
    "summary": "Export a netlist for the current circuit",
    "syntax": [
      {
        "syntax": "exportnetlist; exportnetlist (filename); exportnetlist (element,filename,overwrite=true);",
        "description": "Export a netlist for the current circuit. ‘filename’ is the output netlist name, ‘element’ is the compound element to be exported. If ‘overwrite’ is true, any existing netlist file with the same name as ‘filename’ will be overwritten. If ‘element’ is not provided, the currently selected compound element will be exported, otherwise the root element will be exported."
      }
    ],
    "example": ""
  },
  {
    "name": "exportsweep",
    "description": "Exports S-parameter results from an S-parameter sweep task to a .dat file which can be loaded by the [Optical N-Port S-parameter](**%20to%20be%20defined%20**) element in INTERCONNECT.",
    "usage": "exportsweep();",
    "category": "general",
    "markdown": "# exportsweep\r\n\r\nExports S-parameter results from an S-parameter sweep task to a .dat file which can be\r\nloaded by the [Optical N-Port S-parameter](**%20to%20be%20defined%20**) element in\r\nINTERCONNECT.\r\n\r\n| **Syntax**                                     | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| exportsweep(\"sweep_name\",\"filename\",\"format\"); | Exports S-parameter results from the specified S-parameter sweep task to a .dat file with specified file name in the current working directory. The \"format\" can be either \"lumerical\" or \"touchstone\" formats, and if not specified the \"lumerical\" format will be used. The \"touchstone\" format will be format v1.1. If the maximum passivity over the frequency range is larger than 1.03 or the maximum reciprocity error over the frequency range exceeds 0.03, a warning message will appear in the script prompt when you export the data. If a file of the same name already exists, the existing file will be overwritten. This function does not return any data. |\r\n\r\nNote that Touchstone format v1.1 doesn't handle different modes, so the number of\r\n\"ports\" is really the number of effective ports (port/mode combinations).\r\n\r\n**Example**\r\n\r\nThe following code can be used to export S-parameter data to a Touchstone file called\r\ns_params.s4p.\r\n\r\n```\r\nexportsweep(\"s-parameter sweep\",\"s_params.s4p\", \"touchstone\"); \r\n```",
    "summary": "Exports S-parameter results from an S-parameter sweep task to a ",
    "syntax": [
      {
        "syntax": "exportsweep(\"sweep_name\",\"filename\",\"format\");",
        "description": "Exports S-parameter results from the specified S-parameter sweep task to a .dat file with specified file name in the current working directory. The \"format\" can be either \"lumerical\" or \"touchstone\" formats, and if not specified the \"lumerical\" format will be used. The \"touchstone\" format will be format v1.1. If the maximum passivity over the frequency range is larger than 1.03 or the maximum reciprocity error over the frequency range exceeds 0.03, a warning message will appear in the script prompt when you export the data. If a file of the same name already exists, the existing file will be overwritten. This function does not return any data."
      }
    ],
    "example": "exportsweep(\"s-parameter sweep\",\"s_params.s4p\", \"touchstone\");"
  },
  {
    "name": "exportview",
    "description": "This command captures your simulation setup as shown in the specified view and exports it as a static image into \\*png file. This script command is an alternative to the view export available from the GUI menu in your Lumerical tools.",
    "usage": "exportview();",
    "category": "general",
    "markdown": "# exportview\r\n\r\nThis command captures your simulation setup as shown in the specified view and exports\r\nit as a static image into \\*png file. This script command is an alternative to the view\r\nexport available from the GUI menu in your Lumerical tools.\r\n\r\n| **Syntax**                                    | **Description**                                                                                                                                                                               |\r\n| --------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| exportview(\"filename\");                       | Captures the current scene in the default \"perspective\" view and saves it as filename.png.                                                                                                    |\r\n| exportview(\"example_filename\",\"perspective\"); | Optional: Captures the scene in the specified view. The options are:XY, XZ, YZ, perspective Note: This optional argument is not available in Finite Element IDE since it offers only one view |\r\n\r\n**Example**\r\n\r\nType in exportview(\"ring_modulator_v2_XY\",\"XY\"); in prompt to save the current XY view\r\nof your simulation as \"ring_modulator_v2_XY.png\" in the current path.",
    "summary": "This command captures your simulation setup as shown in the specified view and exports it as a stati...",
    "syntax": [
      {
        "syntax": "exportview(\"filename\");",
        "description": "Captures the current scene in the default \"perspective\" view and saves it as filename.png."
      },
      {
        "syntax": "exportview(\"example_filename\",\"perspective\");",
        "description": "Optional: Captures the scene in the specified view. The options are:XY, XZ, YZ, perspective Note: This optional argument is not available in Finite Element IDE since it offers only one view"
      }
    ],
    "example": ""
  },
  {
    "name": "extractstructure",
    "description": "Creates an a polygon (in 2D) or a planar solid (in 3D) using the finite-element geometric data stored in an unstructured dataset.",
    "usage": "extractstructure();",
    "category": "general",
    "markdown": "# extractstructure\r\n\r\nCreates an a polygon (in 2D) or a planar solid (in 3D) using the finite-element\r\ngeometric data stored in an unstructured dataset.\r\n\r\n| **Syntax**                                                                                                    | **Description**                                                                                                                                              |\r\n| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| extractstructure(D);                                                                                          | Creates a polygon for 2D data and a planar solid for 3D data. The parameter D is the input unstructured dataset. This function does not return any data.     |\r\n| extractstructure(D, Rel_Coplanar_Tol);                                                                        | Same as the above command, but the relative tolerance to merge coplanar elements will be set to the value specified.                                         |\r\n| extractstructure(D, Rel_Coplanar_Tol, Smoothing_Pass_Count);                                                  | Same as the above command, but uses Laplacian smoothing on the surface mesh. The number of iteration is defined by the value specified.                      |\r\n| extractstructure(D, Rel_Coplanar_Tol, Smoothing_Pass_Count, Smoothing_Angle_Coplanar_Tol);                    | Same as the above command, but the allowed angular difference between triangles around a vertex where the vertex can be moved is set to the value specified. |\r\n| extractstructure(D, Rel_Coplanar_Tol, Smoothing_Pass_Count, Smoothing_Angle_Coplanar_Tol, Allow_Tessalation); | Same as the above command, but allows re-triangulation of the facets.                                                                                        |\r\n\r\n| **Parameters**               | **Type**             | **Description**                                                                                                                                               |\r\n| ---------------------------- | -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| D                            | unstructured dataset | Input data that is used to create the structure.                                                                                                              |\r\n| Rel_Coplanar_Tol             | number               | (optional) Relative tolerance to merge coplanar elements. The default value is 1e-6.                                                                          |\r\n| Smoothing_Pass_Count         | number               | (optional) In 3D only. Enables Laplacian smoothing on the surface mesh before surface extraction. The default value is 0 and the maximum allowed value is 20. |\r\n| Smoothing_Angle_Coplanar_Tol | number               | (optional) Sets the allowed angular difference between triangles around a vertex where the vertex can be moved. The default value is 0.001.                   |\r\n| Allow_Tessalation            | number               | (optional) In 3D only. Allows re-triangulation of the facets.                                                                                                 |\r\n\r\n**Example**\r\n\r\nRun the script file\r\n[extract_2d.lsf](/hc/article_attachments/360045274574/extract_2d.lsf) with the CHARGE\r\nproject file [geom2d.ldev](/hc/article_attachments/360046126993/geom2d.ldev) for a 2D\r\nexample of this command. Here, we use the ID of the \"CHARGE\" solver region to single out\r\nany part of the structure with ID = 3, which would correspond to the semiconductor\r\nmaterial in this example and then construct an object (polygon) in that shape.",
    "summary": "Creates an a polygon (in 2D) or a planar solid (in 3D) using the finite-element geometric data store...",
    "syntax": [
      {
        "syntax": "extractstructure(D);",
        "description": "Creates a polygon for 2D data and a planar solid for 3D data. The parameter D is the input unstructured dataset. This function does not return any data."
      },
      {
        "syntax": "extractstructure(D, Rel_Coplanar_Tol);",
        "description": "Same as the above command, but the relative tolerance to merge coplanar elements will be set to the value specified."
      },
      {
        "syntax": "extractstructure(D, Rel_Coplanar_Tol, Smoothing_Pass_Count);",
        "description": "Same as the above command, but uses Laplacian smoothing on the surface mesh. The number of iteration is defined by the value specified."
      },
      {
        "syntax": "extractstructure(D, Rel_Coplanar_Tol, Smoothing_Pass_Count, Smoothing_Angle_Coplanar_Tol);",
        "description": "Same as the above command, but the allowed angular difference between triangles around a vertex where the vertex can be moved is set to the value specified."
      },
      {
        "syntax": "extractstructure(D, Rel_Coplanar_Tol, Smoothing_Pass_Count, Smoothing_Angle_Coplanar_Tol, Allow_Tessalation);",
        "description": "Same as the above command, but allows re-triangulation of the facets."
      }
    ],
    "example": ""
  },
  {
    "name": "eye",
    "description": "Creates a 2D identity matrix.",
    "usage": "eye();",
    "category": "general",
    "markdown": "# eye\r\n\r\nCreates a 2D identity matrix.\r\n\r\n| **Syntax**    | **Description**                               |\r\n| ------------- | --------------------------------------------- |\r\n| I = eye;      | Returns a 1x1 matrix, value 1.0.              |\r\n| I = eye(n);   | Returns nxn identity matrix.                  |\r\n| I = eye(n,m); | Returns nxm matrix with ones on main diagonal |\r\n\r\n**Examples**\r\n\r\nFollowing are some examples and the results of the script command usage.\r\n\r\n```\r\n?eye;\r\nresult: \r\n1 \r\n?eye(3);\r\nresult: \r\n1 0 0 \r\n0 1 0 \r\n0 0 1 \r\n?eye(2,3);\r\nresult: \r\n1 0 0 \r\n0 1 0 \r\n?eye(3,2);\r\nresult: \r\n1 0 \r\n0 1 \r\n0 0 \r\n```",
    "summary": "Creates a 2D identity matrix",
    "syntax": [
      {
        "syntax": "I = eye;",
        "description": "Returns a 1x1 matrix, value 1.0."
      },
      {
        "syntax": "I = eye(n);",
        "description": "Returns nxn identity matrix."
      },
      {
        "syntax": "I = eye(n,m);",
        "description": "Returns nxm matrix with ones on main diagonal"
      }
    ],
    "example": ""
  },
  {
    "name": "farfield2d",
    "description": "Projects a given power or field profile monitor or a rectilinear dataset to the far field to a 1 meter radius semi-circle. The electric field intensity |E| 2 is returned. Farfield2d does not use a set of linearly spaced angles for the projection, use [farfieldangle - Script command](https://optics.ansys.com/hc/en-us/articles/360034930653) to get the appropriate angle vector.",
    "usage": "farfield2d();",
    "category": "general",
    "markdown": "# farfield2d\r\n\r\nProjects a given power or field profile monitor or a rectilinear dataset to the far\r\nfield to a 1 meter radius semi-circle. The electric field intensity |E| 2 is returned.\r\nFarfield2d does not use a set of linearly spaced angles for the projection, use\r\n[farfieldangle - Script command](https://optics.ansys.com/hc/en-us/articles/360034930653)\r\nto get the appropriate angle vector.\r\n\r\n| **Syntax**                                                                | **Description**                                                                                                                                                                                                                                                                |\r\n| ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = farfield2d(\"mname\", f, n, illumination, periods, index, direction); | Projects a given power or field profile monitor to the far field at the specified frequency points. The result is an NxM matrix where the first dimension is the resolution of the far field projection, and the second dimension is the number of frequency points projected. |\r\n| out = farfield2d(dataset, f, n, illumination, periods, index, direction); | Projects a given rectilinear dataset to the far field at the specified frequency points. The result is an NxM matrix where the first dimension is the resolution of the far field projection, and the second dimension is the number of frequency points projected.            |\r\n\r\n| **Parameter** |          | **Default value**           | **Type** | **Description**                                                                                                                                       |\r\n| ------------- | -------- | --------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| mname         | required |                             | string   | Name of the monitor                                                                                                                                   |\r\n| dataset       | required |                             | dataset  | Rectilinear dataset containing both E and H                                                                                                           |\r\n| f             | optional | 1                           | vector   | Index of the desired frequency point. f can be a single value, or a vector of frequency points. Multithreaded projection was introduced since R2016b. |\r\n| n             | optional | 2000                        | number   | The number of points in the far field.                                                                                                                |\r\n| illumination  | optional | 1                           | number   | For periodic structures Gaussian illumination: 1 Plane wave illumination: 2                                                                           |\r\n| periods       | optional | 1                           | number   | number of periods to be used                                                                                                                          |\r\n| index         | optional | value at monitor center     | number   | The index of the material to use for the projection.                                                                                                  |\r\n| direction     | optional | direction of max power flow | number   | Direction: this can be +1 or -1.                                                                                                                      |\r\n\r\n**Example**\r\n\r\nThis example plots the far field projection of a 1D monitor called monitor. In this\r\nexample the second frequency point is projected. If the monitor only contains data at\r\none frequency, the second argument is not required.\r\n\r\n```\r\nE2=farfield2d(\"monitor\",2,501);\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,E2,\"angle (deg)\",\"|E|^2 far field\"); \r\n```\r\n\r\nThe following example plots the far field projection of a rectilinear dataset. Here, the\r\ndataset is from a 1D monitor.\r\n\r\n```\r\ndataset=getresult(\"monitor\", \"E\");  \r\ndataset.addattribute(\"H\",getattribute(getresult(\"monitor\",\"H\"),\"H\"));  \r\n  \r\nE2=farfield2d(dataset,2,501);  \r\ntheta=farfieldangle(dataset,2,501);  \r\nplot(theta,E2,\"angle (deg)\",\"|E|^2 far field\"); \r\n```\r\n\r\nFor additional examples see\r\n[ Far field projection ](https://optics.ansys.com/hc/en-us/articles/360034914713) .",
    "summary": "Projects a given power or field profile monitor or a rectilinear dataset to the far field to a 1 met...",
    "syntax": [
      {
        "syntax": "out = farfield2d(\"mname\", f, n, illumination, periods, index, direction);",
        "description": "Projects a given power or field profile monitor to the far field at the specified frequency points. The result is an NxM matrix where the first dimension is the resolution of the far field projection, and the second dimension is the number of frequency points projected."
      },
      {
        "syntax": "out = farfield2d(dataset, f, n, illumination, periods, index, direction);",
        "description": "Projects a given rectilinear dataset to the far field at the specified frequency points. The result is an NxM matrix where the first dimension is the resolution of the far field projection, and the second dimension is the number of frequency points projected."
      }
    ],
    "example": "E2=farfield2d(\"monitor\",2,501);\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,E2,\"angle (deg)\",\"|E|^2 far field\");"
  },
  {
    "name": "farfield2dintegrate",
    "description": "Calculates the integral of the far field projection over some range of theta in 2D simulation. Angles are specified in degrees, but the integral is done in radians.",
    "usage": "farfield2dintegrate();",
    "category": "general",
    "markdown": "# farfield2dintegrate\r\n\r\nCalculates the integral of the far field projection over some range of theta in 2D\r\nsimulation. Angles are specified in degrees, but the integral is done in radians.\r\n\r\n$$ \\\\int\\_{\\\\theta} E^{2}(\\\\theta) d \\\\theta $$\r\n\r\n| **Syntax**                                               | **Description**                         |\r\n| -------------------------------------------------------- | --------------------------------------- |\r\n| out = farfield2dintegrate(E2, theta, halfangle, theta0); | Integrate 2D far field projection data. |\r\n\r\n| **Parameter** |          | **Default value** | **Type** | **Description**                                                                                                                                        |\r\n| ------------- | -------- | ----------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| E2            | required |                   | matrix   | E field data from farfield2d                                                                                                                           |\r\n| theta         | required |                   | matrix   | Theta from farfieldangle                                                                                                                               |\r\n| halfangle     | optional | 90                | vector   | Half angle (in degrees) of the integration region. Must have same length as theta0 or length 1. Half angle should be between 0 to 90 degrees.          |\r\n| theta0        | optional | 0                 | vector   | Center angle (in degrees) theta of the integration region. Must have same length as halfangle or length 1. Theta0 should be between -90 to 90 degrees. |\r\n\r\n**Example**\r\n\r\nCalculate the fraction of power in the far field from 20 to 70 degrees.\r\n\r\n```\r\nm=\"monitor1\";\r\nE2=farfield2d(m);\r\ntheta=farfieldangle(m);\r\n?farfield2dintegrate(E2,theta,25,45) / farfield2dintegrate(E2,theta);\r\n```",
    "summary": "Calculates the integral of the far field projection over some range of theta in 2D simulation",
    "syntax": [
      {
        "syntax": "out = farfield2dintegrate(E2, theta, halfangle, theta0);",
        "description": "Integrate 2D far field projection data."
      }
    ],
    "example": "m=\"monitor1\";\r\nE2=farfield2d(m);\r\ntheta=farfieldangle(m);\r\n?farfield2dintegrate(E2,theta,25,45) / farfield2dintegrate(E2,theta);"
  },
  {
    "name": "farfield3d",
    "description": "Projects a given power or field profile monitor or a rectilinear dataset to the far field in a 3D simulation. The electric field intensity |E| 2 is returned.",
    "usage": "farfield3d();",
    "category": "general",
    "markdown": "# farfield3d\r\n\r\nProjects a given power or field profile monitor or a rectilinear dataset to the far\r\nfield in a 3D simulation. The electric field intensity |E| 2 is returned.\r\n\r\n| **Syntax**                                                                               | **Description**                                                                                                                                                                                                                                                                                                                          |\r\n| ---------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = farfield3d(\"mname\",f, na, nb, illumination, periodsa, periodsb, index, direction); | Projects a given power or field profile monitor to the far field. This returns an NxM matrix if 1 frequency point is projected, or a NxMxP matrix if more than 1 frequency point is projected, where N and M correspond to the resolution of the projection (na, and nb), and P corresponds to the number of frequency points projected. |\r\n| out = farfield3d(dataset,f, na, nb, illumination, periodsa, periodsb, index, direction); | Projects a given rectilinear dataset to the far field. This returns an NxM matrix if 1 frequency point is projected, or a NxMxP matrix if more than 1 frequency point is projected, where N and M correspond to the resolution of the projection (na, and nb), and P corresponds to the number of frequency points projected.            |\r\n\r\n| **Parameter** |          | **Default value**           | **Type** | **Description**                                                                                                                                                                                     |\r\n| ------------- | -------- | --------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| mname         | required |                             | string   | Name of the monitor                                                                                                                                                                                 |\r\n| dataset       | required |                             | dataset  | Rectilinear dataset containing both E and H                                                                                                                                                         |\r\n| f             | optional | 1                           | vector   | Index of the desired frequency point. This can be a single number or a vector. Multithreaded projection to allow multiple frequency points to be projected simultaneously was introduced in R2016b. |\r\n| na            | optional | 150                         | number   | The number of points in the far field.                                                                                                                                                              |\r\n| nb            | optional | 150                         | number   | The number of points in the far field.                                                                                                                                                              |\r\n| illumination  | optional | 1                           | number   | For periodic structures. Gaussian illumination: 1 Plane wave illumination: 2                                                                                                                        |\r\n| periodsa      | optional | 1                           | number   | number of periods to be used for periodic illumination                                                                                                                                              |\r\n| periodsb      | optional | 1                           | number   | number of periods to be used for periodic illumination                                                                                                                                              |\r\n| index         | optional | value at monitor center     | number   | The index of the material to use for the projection.                                                                                                                                                |\r\n| direction     | optional | direction of max power flow | number   | Direction: this can be +1 or -1.                                                                                                                                                                    |\r\n\r\nThe following table summarizes how to interpret the ux, uy coordinate vectors and\r\nperiods input properties for various monitor orientations.\r\n\r\n| **Monitor orientation** | **Monitor surface normal** | **'na', 'ux', 'periods a' correspond to** | **'nb', 'uy', 'periods b' correspond to** |\r\n| ----------------------- | -------------------------- | ----------------------------------------- | ----------------------------------------- |\r\n| XY plane                | Z                          | x axis                                    | y axis                                    |\r\n| XZ plane                | Y                          | x axis                                    | z axis                                    |\r\n| YZ plane                | X                          | y axis                                    | z axis                                    |\r\n\r\n**Example**\r\n\r\nThis example images the far field projection of a 2D monitor called monitor. In this\r\nexample the second frequency point is projected. If the monitor only contains data at\r\none frequency, the second argument is not required.\r\n\r\n```\r\nE = farfield3d(\"monitor\",2); \r\nux = farfieldux(\"monitor\",2); \r\nuy = farfielduy(\"monitor\",2); \r\nimage(ux,uy,E,\"\",\"\",\"title\",\"polar\"); \r\n```\r\n\r\nThe following example images the far field projection of a rectilinear dataset. Here,\r\nthe dataset is from a 2D monitor.\r\n\r\n```\r\ndataset=getresult(\"monitor\", \"E\");  \r\ndataset.addattribute(\"H\",getattribute(getresult(\"monitor\",\"H\"),\"H\"));  \r\n  \r\nE = farfield3d(dataset,2);   \r\nux = farfieldux(dataset,2);   \r\nuy = farfielduy(dataset,2);   \r\nimage(ux,uy,E,\"\",\"\",\"title\",\"polar\"); \r\n```",
    "summary": "Projects a given power or field profile monitor or a rectilinear dataset to the far field in a 3D si...",
    "syntax": [
      {
        "syntax": "out = farfield3d(\"mname\",f, na, nb, illumination, periodsa, periodsb, index, direction);",
        "description": "Projects a given power or field profile monitor to the far field. This returns an NxM matrix if 1 frequency point is projected, or a NxMxP matrix if more than 1 frequency point is projected, where N and M correspond to the resolution of the projection (na, and nb), and P corresponds to the number of frequency points projected."
      },
      {
        "syntax": "out = farfield3d(dataset,f, na, nb, illumination, periodsa, periodsb, index, direction);",
        "description": "Projects a given rectilinear dataset to the far field. This returns an NxM matrix if 1 frequency point is projected, or a NxMxP matrix if more than 1 frequency point is projected, where N and M correspond to the resolution of the projection (na, and nb), and P corresponds to the number of frequency points projected."
      }
    ],
    "example": "E = farfield3d(\"monitor\",2); \r\nux = farfieldux(\"monitor\",2); \r\nuy = farfielduy(\"monitor\",2); \r\nimage(ux,uy,E,\"\",\"\",\"title\",\"polar\");"
  },
  {
    "name": "farfield3dintegrate",
    "description": "Integrates the far field projection over a cone centered at theta0 and phi0, with a width specified by halfangle for 3D simulations. The far field electric field is a function of the direction cosines (ux,uy), but farfield3dintegrate automatically does the change of variables. Similarly, angles are specified in degrees, but converted to radians before the integral is calculated. See the farfield3d documentation for information on interpreting ux, uy, na, nb for various monitor orientations.",
    "usage": "farfield3dintegrate();",
    "category": "general",
    "markdown": "# farfield3dintegrate\r\n\r\nIntegrates the far field projection over a cone centered at theta0 and phi0, with a\r\nwidth specified by halfangle for 3D simulations. The far field electric field is a\r\nfunction of the direction cosines (ux,uy), but farfield3dintegrate automatically does\r\nthe change of variables. Similarly, angles are specified in degrees, but converted to\r\nradians before the integral is calculated. See the farfield3d documentation for\r\ninformation on interpreting ux, uy, na, nb for various monitor orientations.\r\n\r\n$$ \\\\iint\\_{\\\\theta, \\\\phi} E^{2}(u x, u y) \\\\sin (\\\\theta) d \\\\theta d \\\\phi $$\r\n\r\n| **Syntax**                                                      | **Description**                         |\r\n| --------------------------------------------------------------- | --------------------------------------- |\r\n| out = farfield3dintegrate(E2, ux, uy, halfangle, theta0, phi0); | Integrate 3D far field projection data. |\r\n\r\n| **Parameter** |          | **Default value** | **Type** | **Description**                                                                                                                                            |\r\n| ------------- | -------- | ----------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| E2            | required |                   | matrix   | E field data from farfield3d                                                                                                                               |\r\n| ux            | required |                   | vector   | ux data from farfieldux. Note that the result should be a vector, so it is sufficient to perform the farfieldux script command for only 1 frequency point. |\r\n| uy            | required |                   | vector   | uy data from farfielduy. Note that the result should be a vector, so it is sufficient to perform the farfieldux script command for only 1 frequency point. |\r\n| halfangle     | optional | 90                | vector   | Half angle of the integration cone. unit in degrees. must have length L or 1. Half angle should be between 0 to 90 degrees.                                |\r\n| theta0        | optional | 0                 | vector   | Center angle theta of the integration cone. unit in degrees. must have length L or 1. Theta0 should be between 0 to 90 degrees.                            |\r\n| phi0          | optional | 0                 | vector   | Center angle phi of the integration cone. unit in degrees. must have length L or 1. Phi0 should be between 0 to 360 degrees.                               |\r\n\r\n**Example**\r\n\r\nCalculate the fraction of power from the source that is transmitted into the far field\r\nwithin in a 30 degree cone centered at theta=phi=0.\r\n\r\n```\r\nm=\"monitor1\";\r\nres = 201;\r\nE2 = farfield3d(m,1,res,res);\r\nux = farfieldux(m,1,res,res);\r\nuy = farfielduy(m,1,res,res);\r\nhalfangle=30;\r\ntheta0=0;\r\nphi0=0;\r\ncone_30 = farfield3dintegrate(E2, ux, uy, halfangle, theta0, phi0); # integrate over 30 degree cone\r\ntotal = farfield3dintegrate(E2, ux, uy); # integrate over entire hemisphere\r\nT   = transmission(m); # fraction of source power transmitted into far field \r\n?cone_30/total;  # fraction of far field power within a 30 degree cone\r\n?cone_30/total*T; # fraction of source power transmitted into the far field within a 30 degree cone\r\n```",
    "summary": "Integrates the far field projection over a cone centered at theta0 and phi0, with a width specified ...",
    "syntax": [
      {
        "syntax": "out = farfield3dintegrate(E2, ux, uy, halfangle, theta0, phi0);",
        "description": "Integrate 3D far field projection data."
      }
    ],
    "example": "m=\"monitor1\";\r\nres = 201;\r\nE2 = farfield3d(m,1,res,res);\r\nux = farfieldux(m,1,res,res);\r\nuy = farfielduy(m,1,res,res);\r\nhalfangle=30;\r\ntheta0=0;\r\nphi0=0;\r\ncone_30 = farfield3dintegrate(E2, ux, uy, halfangle, theta0, phi0); # integrate over 30 degree cone\r\ntotal = farfield3dintegrate(E2, ux, uy); # integrate over entire hemisphere\r\nT   = transmission(m); # fraction of source power transmitted into far field \r\n?cone_30/total;  # fraction of far field power within a 30 degree cone\r\n?cone_30/total*T; # fraction of source power transmitted into the far field within a 30 degree cone"
  },
  {
    "name": "farfieldangle",
    "description": "Returns the vector of angles, in degrees, corresponding to the data from farfield2d for a 2D simulation. Used for 2D simulations. This is required because the farfield2d does not use a set of linearly spaced angles for the projection. It is often useful to re-interpolate the data onto a set of linearly spaced angles using the interp or spline functions.",
    "usage": "farfieldangle();",
    "category": "general",
    "markdown": "# farfieldangle\r\n\r\nReturns the vector of angles, in degrees, corresponding to the data from farfield2d for\r\na 2D simulation. Used for 2D simulations. This is required because the farfield2d does\r\nnot use a set of linearly spaced angles for the projection. It is often useful to\r\nre-interpolate the data onto a set of linearly spaced angles using the interp or spline\r\nfunctions.\r\n\r\n| **Syntax**                                    | **Description**                                                      |\r\n| --------------------------------------------- | -------------------------------------------------------------------- |\r\n| theta = farfieldangle( \"mname\", f, n, index); | Returns the matrix of angles corresponding to the data in farfield2d |\r\n| theta = farfieldangle( dataset, f, n, index); | Returns the matrix of angles corresponding to the data in farfield2d |\r\n\r\n| **Parameter** |          | **Default value**       | **Type** | **Description**                                                                                                                                                                                                                               |\r\n| ------------- | -------- | ----------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| mname         | required |                         | string   | Name of the monitor from which far field is calculated                                                                                                                                                                                        |\r\n| dataset       | required |                         | dataset  | Rectilinear dataset containing both E and H                                                                                                                                                                                                   |\r\n| f             | optional | 1                       | vector   | Index of the desired frequency point. This can be a single number or a vector. If f is a vector, the second dimension of theta will match the length of the vector of frequency points. Multithreaded projection was introduced since R2016b. |\r\n| n             | optional | 2000                    | number   | The number of points in the far field.                                                                                                                                                                                                        |\r\n| index         | optional | value at monitor center | number   | The index of the material to use for the projection.                                                                                                                                                                                          |\r\n\r\n**Example**\r\n\r\nThis example plots the far field projection of a 1D monitor called monitor. In this\r\nexample the second frequency point is projected. If the monitor only contains data at\r\none frequency, the second argument is not required. For the example of far field\r\nprojection of a rectilinear dataset see [farfield2d](./farfield2d.md).\r\n\r\n```\r\nE2=farfield2d(\"monitor\",2,501);\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,E2,\"angle (deg)\",\"|E|^2 far field\"); \r\n```\r\n\r\nFor additional examples see\r\n[ Far field projection ](https://optics.ansys.com/hc/en-us/articles/360034914713) .",
    "summary": "Returns the vector of angles, in degrees, corresponding to the data from farfield2d for a 2D simulat...",
    "syntax": [
      {
        "syntax": "theta = farfieldangle( \"mname\", f, n, index);",
        "description": "Returns the matrix of angles corresponding to the data in farfield2d"
      },
      {
        "syntax": "theta = farfieldangle( dataset, f, n, index);",
        "description": "Returns the matrix of angles corresponding to the data in farfield2d"
      }
    ],
    "example": "E2=farfield2d(\"monitor\",2,501);\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,E2,\"angle (deg)\",\"|E|^2 far field\");"
  },
  {
    "name": "farfieldexact",
    "description": "Projects complete complex vector fields to specific locations. It is expected to be correct down to distances on the order of one wavelength. The projections from multiple monitors can be added to create a total far field projection - see [ Projections from a monitor box ](https://optics.ansys.com/hc/en-us/articles/360034915613-Projections-from-a-monitor-box) .",
    "usage": "farfieldexact();",
    "category": "general",
    "markdown": "# farfieldexact\r\n\r\nProjects complete complex vector fields to specific locations. It is expected to be\r\ncorrect down to distances on the order of one wavelength. The projections from multiple\r\nmonitors can be added to create a total far field projection - see\r\n[ Projections from a monitor box ](https://optics.ansys.com/hc/en-us/articles/360034915613-Projections-from-a-monitor-box)\r\n.\r\n\r\nfarfieldexact projects any surface fields to a series of points defined by vector lists.\r\nThe x,y, z coordinates of each evaluation point are taken element-by-element from the\r\nvector lists. i.e., the i-th point in a 2D simulation would be at [x(i),y(i)]. This\r\ncommand can return either the E field or the E and H fields of the projection.\r\n\r\n3D\r\n\r\nVectors lists x,y,z must have the same length L or be length 1. When only the E field is\r\nreturned, the data is returned in a matrix of dimension Lx3. The first index represents\r\npositions defined by one element from each of x,y, z. [x(i),y(i),z(i)]; the second index\r\nrepresents Ex, Ey, and Ez. When both E and H fields are returned, the data is returned\r\nas a dataset with the E and H fields packaged with the corresponding x,y,z and\r\nfrequency/wavelength.\r\n\r\n2D\r\n\r\nVector lists x, y must have the same length L or be length 1. When only the E field is\r\nreturned, the data is returned in the form of a matrix that is of dimension Lx3. The\r\nfirst index represents positions defined by one element from each of x,y. [x(i),y(i)];\r\nThe second index represents Ex, Ey, and Ez. When both E and H fields are returned, the\r\ndata is returned as a dataset with the E and H fields packaged with the corresponding\r\nx,y, and frequency/wavelength.\r\n\r\n| **Syntax**                                       | **Description**                                                                                                 |\r\n| ------------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |\r\n| out = farfieldexact(\"mname\", x, y, f, index);    | 2D far field exact projection. Returns E field only.                                                            |\r\n| out = farfieldexact(dataset, x, y, f, index);    | 2D far field exact projection. Returns E field only.                                                            |\r\n| out = farfieldexact(\"mname\", x, y, opt);         | 2D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options. |\r\n| out = farfieldexact(dataset, x, y, opt);         | 2D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options. |\r\n| out = farfieldexact(\"mname\", x, y, z, f, index); | 3D far field exact projection. Returns E field only.                                                            |\r\n| out = farfieldexact(dataset, x, y, z, f, index); | 3D far field exact projection. Returns E field only.                                                            |\r\n| out = farfieldexact(\"mname\", x, y, z, opt);      | 3D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options  |\r\n| out = farfieldexact(dataset, x, y, z, opt);      | 3D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options  |\r\n\r\n| **Parameter** | **Default** | **Default value**       | **Type** | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| ------------- | ----------- | ----------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| mname         | required    |                         | string   | name of the monitor from which far field is calculated                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| dataset       | required    |                         | dataset  | Rectilinear dataset containing both E and H                                                                                                                                                                                                                                                                                                                                                                                                      |\r\n| x             | required    |                         | vector   | x coordinates of points where far field is calculated. must have length L or 1.                                                                                                                                                                                                                                                                                                                                                                  |\r\n| y             | required    |                         | vector   | y coordinates of points where far field is calculated. must have length L or 1.                                                                                                                                                                                                                                                                                                                                                                  |\r\n| z             | required    |                         | vector   | z coordinates of points where far field is calculated. must have length L or 1.                                                                                                                                                                                                                                                                                                                                                                  |\r\n| f             | optional    | 1                       | vector   | Index of the desired frequency point. This can be a single number or a vector. Multithreaded projection was introduced since R2016b.                                                                                                                                                                                                                                                                                                             |\r\n| index         | optional    | value at monitor centre | number   | The index of the material to use for the projection.                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| opt           | optional    |                         | struct   | the 'opt' parameter includes the following options: \"field\": This parameter is optional. It defines the return field, can either be \"E\" or \"E and H\". \"f\": This parameter is optional. It defines the index of the desired frequency point. This can be a single number or a vector. Multi-threaded projection was introduced since R2016b. \"index\": This parameter is optional. It defines the index of the material to use for the projection. |\r\n\r\n\\[[Note:]\\] When using a dataset, the default value of the refractive index is 1.\r\n\r\n**Example**\r\n\r\nThis example shows how to calculate |E|^2 and |H|^2 on a straight line at y=0, z=1, for\r\nx from -1 to 1 meters. For the example of far field projection of a rectilinear dataset\r\nsee [farfield3d](./farfield3d.md).\r\n\r\n```\r\n# Define far field position vector\r\nres=100;\r\nx=linspace(-1,1,res);\r\ny=0;\r\nz=1;\r\n# do far field projection\r\nE_H_far=farfieldexact(\"monitor\",x,y,z,{\"field\":\"E and H\", \"f\":1});\r\nE_far = E_H_far.E;\r\nH_far = E_H_far.H;\r\nE2_far = sum(abs(E_far)^2,2); # E2 = |Ex|^2 + |Ey|^2 + |Ez|^2\r\nH2_far = sum(abs(H_far)^2,2); # H2 = |Hx|^2 + |Hy|^2 + |Hz|^2\r\n# plot results\r\nplot(x,E2_far,\"x\",\"y\",\"|E|^2 on line at y=0, z=1\");\r\nplot(x,H2_far,\"x\",\"y\",\"|H|^2 on line at y=0, z=1\");\r\n```\r\n\r\nThis example shows how to sum the results from a box of monitors (typically surrounding\r\na scattering particle).\r\n\r\nNote: See the online section on\r\n[ Far field projections ](https://optics.ansys.com/hc/en-us/articles/360034914713) for\r\nmore information on why a negative sign is required on some terms.\r\n\r\n```\r\nphi = linspace(0,360,201);\r\nE2_xy = matrix(length(phi));\r\nE2_yz = matrix(length(phi));\r\nx = -sin(phi*pi/180);\r\ny = cos(phi*pi/180);\r\nz = 0;\r\ntemp = farfieldexact(\"x2\",x,y,z,{\"field\":\"E\"}) + farfieldexact(\"y2\",x,y,z,{\"field\":\"E\"}) + farfieldexact(\"z2\",x,y,z,{\"field\":\"E\"})\r\n   - farfieldexact(\"x1\",x,y,z,{\"field\":\"E\"}) - farfieldexact(\"y1\",x,y,z,{\"field\":\"E\"}) - farfieldexact(\"z1\",x,y,z,{\"field\":\"E\"});\r\nE2_xy = sum(abs(temp)^2,2); # E2 = |Ex|^2 + |Ey|^2 + |Ez|^2\r\nplot(phi, E2_xy,\"Phi (deg)\",\"|E|^2\",\"in XY plane\");\r\n```\r\n\r\nThe following example shows how farfieldexact and farfieldexact3d output data\r\ndifferently.\r\n\r\nWhen x=[1 2], y=[1 2], z=[0],\r\n\r\nfarfieldexact: The result is a 2\\*3 matrix. First dimension is position;second is field\r\ncomponent. This calculates the far field at the positions [1,1,0] and [2,2,0] .\r\n\r\nfarfielexact3d: The result is a 2*2*1\\*3 matrix. First three dimensions are positions;\r\nthe fourth dimension is field component. This calculates the far field at the positions\r\n[x,y,z] = [1,1,0], [1,2,0], [2,1,0], [2,2,0].\r\n\r\n```\r\nx=1:2;\r\ny=1:2;\r\nz=0;\r\nm=\"monitor\";\r\nE_far=farfieldexact(m,x,y,z,{\"field\":\"E\"});\r\n?size(E_far);\r\n result: \r\n 2 3 \r\n```",
    "summary": "Projects complete complex vector fields to specific locations",
    "syntax": [
      {
        "syntax": "out = farfieldexact(\"mname\", x, y, f, index);",
        "description": "2D far field exact projection. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact(dataset, x, y, f, index);",
        "description": "2D far field exact projection. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact(\"mname\", x, y, opt);",
        "description": "2D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options."
      },
      {
        "syntax": "out = farfieldexact(dataset, x, y, opt);",
        "description": "2D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options."
      },
      {
        "syntax": "out = farfieldexact(\"mname\", x, y, z, f, index);",
        "description": "3D far field exact projection. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact(dataset, x, y, z, f, index);",
        "description": "3D far field exact projection. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact(\"mname\", x, y, z, opt);",
        "description": "3D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options"
      },
      {
        "syntax": "out = farfieldexact(dataset, x, y, z, opt);",
        "description": "3D far field exact projection. Returns E field or E and H fields. Refer to the following table for the options"
      }
    ],
    "example": "# Define far field position vector\r\nres=100;\r\nx=linspace(-1,1,res);\r\ny=0;\r\nz=1;\r\n# do far field projection\r\nE_H_far=farfieldexact(\"monitor\",x,y,z,{\"field\":\"E and H\", \"f\":1});\r\nE_far = E_H_far.E;\r\nH_far = E_H_far.H;\r\nE2_far = sum(abs(E_far)^2,2); # E2 = |Ex|^2 + |Ey|^2 + |Ez|^2\r\nH2_far = sum(abs(H_far)^2,2); # H2 = |Hx|^2 + |Hy|^2 + |Hz|^2\r\n# plot results\r\nplot(x,E2_far,\"x\",\"y\",\"|E|^2 on line at y=0, z=1\");\r\nplot(x,H2_far,\"x\",\"y\",\"|H|^2 on line at y=0, z=1\");"
  },
  {
    "name": "farfieldexact2d",
    "description": "This function projects complete complex vector fields to specific locations. It is expected to be correct down to distances on the order of one wavelength. The projections from multiple monitors can be added to create a total far field projection - see [ Projections from a monitor box ](https://optics.ansys.com/hc/en-us/articles/360034915613-Projections-from-a-monitor-box) .",
    "usage": "farfieldexact2d();",
    "category": "general",
    "markdown": "# farfieldexact2d\r\n\r\nThis function projects complete complex vector fields to specific locations. It is\r\nexpected to be correct down to distances on the order of one wavelength. The projections\r\nfrom multiple monitors can be added to create a total far field projection - see\r\n[ Projections from a monitor box ](https://optics.ansys.com/hc/en-us/articles/360034915613-Projections-from-a-monitor-box)\r\n.\r\n\r\nfarfieldexact2d projects any surface to the grid points defined by the vectors x, y. If\r\nonly E field is returned as the result, the data is returned in the form of a matrix\r\nthat is of dimension NxMxPx3 where N is the length of the x vector, M is the length of\r\nthe y vector, P is the number of frequency points, and the final index represents Ex,\r\nEy, and Ez. Note that N and M can be 1; when they are both 1, the function is the same\r\nas farfieldexact. If both E and H fileds are returned, the data is returned as a dataset\r\nwith the E and H fields packaged with the corresponding x,y, and frequency/wavelength.\r\n\r\n| **Syntax**                                       | **Description**                                                                                                                                                                                |\r\n| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = farfieldexact2d( \"mname\", x, y, f, index); | Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y. Returns E field only.                                                            |\r\n| out = farfieldexact2d( dataset, x, y, f, index); | Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y. Returns E field only.                                                                       |\r\n| out = farfieldexact2d( \"mname\", x, y, opt);      | Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y. Returns E filed or E and H fields. Refer to the following table for the options. |\r\n| out = farfieldexact2d( dataset, x, y, opt);      | Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y. Returns E filed or E and H fields. Refer to the following table for the options.            |\r\n\r\n| **Parameter** |          | **Default value**       | **Type** | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| ------------- | -------- | ----------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| mname         | required |                         | string   | name of the monitor from which far field is calculated.                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| dataset       | required |                         | dataset  | Rectilinear dataset containing both E and H                                                                                                                                                                                                                                                                                                                                                                                                      |\r\n| x             | required |                         | vector   | x coordinates of the grid points where far field is calculated.                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| y             | required |                         | vector   | y coordinates of the grid points where far field is calculated.                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| f             | optional | 1                       | vector   | Index of the desired frequency point. This can be a single number or a vector. Multithreaded projection was introduced since R2016b.                                                                                                                                                                                                                                                                                                             |\r\n| index         | optional | index at monitor center | number   | The index of the material to use for the projection.                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| opt           | optional |                         | struct   | the 'opt' parameter includes the following options: \"field\": This parameter is optional. It defines the return field, can either be \"E\" or \"E and H\". \"f\": This parameter is optional. It defines the index of the desired frequency point. This can be a single number or a vector. Multi-threaded projection was introduced since R2016b. \"index\": This parameter is optional. It defines the index of the material to use for the projection. |\r\n\r\n\\[[Note:]\\] When using a dataset, the default value of the refractive index is 1.\r\n\r\n**Example**\r\n\r\nSee example in farfieldexact3d function description.",
    "summary": "This function projects complete complex vector fields to specific locations",
    "syntax": [
      {
        "syntax": "out = farfieldexact2d( \"mname\", x, y, f, index);",
        "description": "Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact2d( dataset, x, y, f, index);",
        "description": "Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact2d( \"mname\", x, y, opt);",
        "description": "Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y. Returns E filed or E and H fields. Refer to the following table for the options."
      },
      {
        "syntax": "out = farfieldexact2d( dataset, x, y, opt);",
        "description": "Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y. Returns E filed or E and H fields. Refer to the following table for the options."
      }
    ],
    "example": ""
  },
  {
    "name": "farfieldexact3d",
    "description": "The three dimension form of farfieldexact2d. This function projects complete complex vector fields to specific locations. It is expected to be correct down to distances on the order of one wavelength. The projections from multiple monitors can be added to create a total far field projection - see [ Projections from a monitor box ](https://optics.ansys.com/hc/en-us/articles/360034915613-Projections-from-a-monitor-box) .",
    "usage": "farfieldexact3d();",
    "category": "general",
    "markdown": "# farfieldexact3d\r\n\r\nThe three dimension form of farfieldexact2d. This function projects complete complex\r\nvector fields to specific locations. It is expected to be correct down to distances on\r\nthe order of one wavelength. The projections from multiple monitors can be added to\r\ncreate a total far field projection - see\r\n[ Projections from a monitor box ](https://optics.ansys.com/hc/en-us/articles/360034915613-Projections-from-a-monitor-box)\r\n.\r\n\r\nfarfieldexact3d projects any surface to the grid points defined by the vectors x,y and\r\nz. If only E field is returned as the result, the data is returned in a matrix of\r\ndimension NxMxKx3 if one frequency point is projected, and NxMxKx3xP if more than one\r\nfrequency point is projected where N is the length of the vector x, M the length of the\r\nvector y, K is the length of the vector z, P is the number of frequency points, and the\r\nfourth index represents Ex, Ey, and Ez. Note that N, M and K can be 1, and when they are\r\nall 1, the function is the same as farfieldexact. If both E and H fileds are returned,\r\nthe data is returned as a dataset with the E and H fields packaged with the\r\ncorresponding x,y,z and frequency/wavelength.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                              |\r\n| --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = farfieldexact3d( \"mname\", x, y, z, f, index); | Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y,z. Returns E field only.                                                        |\r\n| out = farfieldexact3d( dataset, x, y, z, f, index); | Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y,z. Returns E field only.                                                                   |\r\n| out = farfieldexact3d( \"mname\", x, y, z, opt);      | Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y,z. Returns E field or E and H fields. Refer to the table below for the options. |\r\n| out = farfieldexact3d( dataset, x, y, z, opt);      | Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y,z. Returns E field or E and H fields. Refer to the table below for the options.            |\r\n\r\n| **Parameter** |          | **Default value**       | **Type** | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| ------------- | -------- | ----------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| mname         | required |                         | string   | name of the monitor from which far field is calculated                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| x             | required |                         | vector   | x coordinates of the grid points where far field is calculated                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| y             | required |                         | vector   | y coordinates of the grid points where far field is calculated                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| z             | required |                         | vector   | z coordinates of the grid points where far field is calculated                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| f             | optional | 1                       | vector   | Index of the desired frequency point. This can be a single number or a vector. Multithreaded projection was introduced since R2016b.                                                                                                                                                                                                                                                                                                             |\r\n| index         | optional | value at monitor centre | number   | The index of the material to use for the projection.                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| opt           | optional |                         | struct   | the 'opt' parameter includes the following options: \"field\": This parameter is optional. It defines the return field, can either be \"E\" or \"E and H\". \"f\": This parameter is optional. It defines the index of the desired frequency point. This can be a single number or a vector. Multi-threaded projection was introduced since R2016b. \"index\": This parameter is optional. It defines the index of the material to use for the projection. |\r\n\r\n\\[[Note:]\\] When using a dataset, the default value of the refractive index is 1.\r\n\r\n**Example**\r\n\r\nThis 3D example calculates the far field electric field intensity on a 2mm x 2mm image\r\nplane located a distance of z=+1.5mm from the simulation region. For the example of far\r\nfield projection of a rectilinear dataset see [farfield3d](./farfield3d.md).\r\n\r\n```\r\nmname=\"trans\";    # Monitor name\r\nnum=25;       # resolution\r\n# define far field plane to image fields\r\nx=linspace(-1e-3,1e-3,num); \r\ny=x;\r\nz=1.5e-3;\r\n# compute far field\r\nE=farfieldexact3d(mname,x,y,z,{\"field\":\"E\"}); \r\n# select component\r\nEx=pinch(E,4,1); \r\nEy=pinch(E,4,2);\r\nEz=pinch(E,4,3);\r\n# image intensity\r\nE2= abs(Ex)^2 + abs(Ey)^2 + abs(Ez)^2;\r\nimage(x*1e3,y*1e3,E2,\"x (mm)\",\"y (mm)\",\"Electric field at z=1.5mm from source\"); \r\n```\r\n\r\nThe following example shows how farfieldexact and farfieldexact3d output data\r\ndifferently.\r\n\r\nWhen x=[1 2], y=[1 2], z=[0],\r\n\r\nfarfieldexact: The result is a 2\\*3 matrix. First dimension is position;second is field\r\ncomponent. This calculates the far field at the positions [1,1,0] and [2,2,0] .\r\n\r\nfarfielexact3d: The result is a 2*2*1\\*3 matrix. First three dimensions are positions;\r\nthe fourth dimension is field component. This calculates the far field at the positions\r\n[x,y,z] = [1,1,0], [1,2,0], [2,1,0], [2,2,0].\r\n\r\n```\r\nx=1:2;\r\ny=1:2;\r\nz=0;\r\nm=\"monitor\";\r\nE_far=farfieldexact3d(m,x,y,z,{\"field\":\"E\"});\r\n?size(E_far);\r\n result: \r\n 2 2 1 3  \r\n```",
    "summary": "The three dimension form of farfieldexact2d",
    "syntax": [
      {
        "syntax": "out = farfieldexact3d( \"mname\", x, y, z, f, index);",
        "description": "Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y,z. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact3d( dataset, x, y, z, f, index);",
        "description": "Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y,z. Returns E field only."
      },
      {
        "syntax": "out = farfieldexact3d( \"mname\", x, y, z, opt);",
        "description": "Projects a given power or field profile monitor to the far field at grid points specified by the vectors x,y,z. Returns E field or E and H fields. Refer to the table below for the options."
      },
      {
        "syntax": "out = farfieldexact3d( dataset, x, y, z, opt);",
        "description": "Projects a given rectilinear dataset to the far field at grid points specified by the vectors x,y,z. Returns E field or E and H fields. Refer to the table below for the options."
      }
    ],
    "example": "mname=\"trans\";    # Monitor name\r\nnum=25;       # resolution\r\n# define far field plane to image fields\r\nx=linspace(-1e-3,1e-3,num); \r\ny=x;\r\nz=1.5e-3;\r\n# compute far field\r\nE=farfieldexact3d(mname,x,y,z,{\"field\":\"E\"}); \r\n# select component\r\nEx=pinch(E,4,1); \r\nEy=pinch(E,4,2);\r\nEz=pinch(E,4,3);\r\n# image intensity\r\nE2= abs(Ex)^2 + abs(Ey)^2 + abs(Ez)^2;\r\nimage(x*1e3,y*1e3,E2,\"x (mm)\",\"y (mm)\",\"Electric field at z=1.5mm from source\");"
  },
  {
    "name": "farfieldfilter",
    "description": "Sets or gets the filter width for far field filter which is used to remove ripples in the far field projection due to clipping of the near fields. It should be used when the near fields at the edge of the monitor are small but not precisely zero.",
    "usage": "farfieldfilter();",
    "category": "general",
    "markdown": "# farfieldfilter\r\n\r\nSets or gets the filter width for far field filter which is used to remove ripples in\r\nthe far field projection due to clipping of the near fields. It should be used when the\r\nnear fields at the edge of the monitor are small but not precisely zero.\r\n\r\nThe bumpy blue line of the figure shows the near field electric field that will be used\r\nfor a far field projection. In this case, the field does not go to zero at the edge of\r\nthe monitor, which will lead to ripples in the far field projection. The green line\r\nshows the spatial filter that will be applied to the fields, ensuring they go to zero.\r\nThe filter parameter defines the width of the filter by the following formula:\r\nα=(a)/(a+b).\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                    |\r\n| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = farfieldfilter; | Get the current far field filter setting.                                                                                                                                                                                                          |\r\n| farfieldfilter(α);    | Set the current far field filter setting. α=(a)/(a+b). The far field filter has a single input parameter, which is a number between 0 and 1. By default, it is 0, which turns the filter off. This filter is applied to all far field projections. |\r\n\r\n## Note: Periodic structures The far field filter option should not be used for periodic structures. Set it to zero when using the 'assume periodic' option.\r\n\r\n**Example**\r\n\r\n[ Far field projection - spatial filtering ](https://optics.ansys.com/hc/en-us/articles/360034394314-FFP-Spatial-filtering)",
    "summary": "Sets or gets the filter width for far field filter which is used to remove ripples in the far field ...",
    "syntax": [
      {
        "syntax": "out = farfieldfilter;",
        "description": "Get the current far field filter setting."
      },
      {
        "syntax": "farfieldfilter(α);",
        "description": "Set the current far field filter setting. α=(a)/(a+b). The far field filter has a single input parameter, which is a number between 0 and 1. By default, it is 0, which turns the filter off. This filter is applied to all far field projections."
      }
    ],
    "example": ""
  },
  {
    "name": "farfieldpolar2d",
    "description": "Projects a given power or field profile monitor or a rectilinear dataset to the far field to a 1 meter radius semi-circle. This is similar to the farfield2d script command except the complex electric fields are returned, rather than field intensity. The data is returned as matrix of NxP if one frequency point is projected, or NxPx3 when multiple frequency points are projected where N is the resolution of the far field projection, P is the number frequency points projected, and the last index refers to E r , E θ and E z , in cylindrical coordinates. For TM simulations, this function gives precisely the result of farfieldvector2d because the only non-zero field component is Ez.",
    "usage": "farfieldpolar2d();",
    "category": "general",
    "markdown": "# farfieldpolar2d\r\n\r\nProjects a given power or field profile monitor or a rectilinear dataset to the far\r\nfield to a 1 meter radius semi-circle. This is similar to the farfield2d script command\r\nexcept the complex electric fields are returned, rather than field intensity. The data\r\nis returned as matrix of NxP if one frequency point is projected, or NxPx3 when multiple\r\nfrequency points are projected where N is the resolution of the far field projection, P\r\nis the number frequency points projected, and the last index refers to E r , E θ and E z\r\n, in cylindrical coordinates. For TM simulations, this function gives precisely the\r\nresult of farfieldvector2d because the only non-zero field component is Ez.\r\n\r\n| **Syntax**                           | **Description**                                                          |\r\n| ------------------------------------ | ------------------------------------------------------------------------ |\r\n| out = farfieldpolar2d( \"mname\",...); | Returns the polar complex electric fields. Same arguments as farfield2d. |\r\n| out = farfieldpolar2d( dataset,...); | Returns the polar complex electric fields. Same arguments as farfield2d. |\r\n\r\n**Example**\r\n\r\nThis example plots the amplitude of the Er component of the far field projection of a 1D\r\nmonitor called \"monitor\". In this example the second frequency point is projected. If\r\nthe monitor only contains data at one frequency, the second argument is not required.\r\nFor the example of far field projection of a rectilinear dataset see\r\n[farfield2d](./farfield2d.md).\r\n\r\n```\r\nE=farfieldpolar2d(\"monitor\",2,501);\r\nEr = abs(pinch(E,2,1)); # amplitude of Er\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,Er,\"angle (deg)\",\"Er far field\"); \r\n```\r\n\r\nFor additional examples see\r\n[ Far field projection](https://optics.ansys.com/hc/en-us/articles/360034914713).",
    "summary": "Projects a given power or field profile monitor or a rectilinear dataset to the far field to a 1 met...",
    "syntax": [
      {
        "syntax": "out = farfieldpolar2d( \"mname\",...);",
        "description": "Returns the polar complex electric fields. Same arguments as farfield2d."
      },
      {
        "syntax": "out = farfieldpolar2d( dataset,...);",
        "description": "Returns the polar complex electric fields. Same arguments as farfield2d."
      }
    ],
    "example": "E=farfieldpolar2d(\"monitor\",2,501);\r\nEr = abs(pinch(E,2,1)); # amplitude of Er\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,Er,\"angle (deg)\",\"Er far field\");"
  },
  {
    "name": "farfieldpolar3d",
    "description": "The function farfieldpolar3d is similar to farfield3d, but it returns the complex electric fields, rather than field intensity. The data is returned as matrix of NxMx3 (if one frequency point is projected) or NxMx3xP (if more than 1 frequency point is projected), where N and M are spatial indices, the third index refers to E r , E θ and E φ , in spherical coordinates, and P is the number of frequency points. The components E r , E θ and E φ are the complex components of the electric field vector. See the farfield3d documentation for information on interpreting ux, uy, na, nb for various monitor orientations.",
    "usage": "farfieldpolar3d();",
    "category": "general",
    "markdown": "# farfieldpolar3d\r\n\r\nThe function farfieldpolar3d is similar to farfield3d, but it returns the complex\r\nelectric fields, rather than field intensity. The data is returned as matrix of NxMx3\r\n(if one frequency point is projected) or NxMx3xP (if more than 1 frequency point is\r\nprojected), where N and M are spatial indices, the third index refers to E r , E θ and E\r\nφ , in spherical coordinates, and P is the number of frequency points. The components E\r\nr , E θ and E φ are the complex components of the electric field vector. See the\r\nfarfield3d documentation for information on interpreting ux, uy, na, nb for various\r\nmonitor orientations.\r\n\r\nNote: When viewing far fields from the GUI with the visualizer, three Attributes are\r\navailable: E2, Ep, Es. E2 corresponds to |E|^2, Ep to Etheta, and Es to Ephi.\r\n\r\n| **Syntax**                           | **Description**                                                              |\r\n| ------------------------------------ | ---------------------------------------------------------------------------- |\r\n| out = farfieldpolar3d( \"mname\",...); | Returns the spherical complex electric fields. Same arguments as farfield3d. |\r\n| out = farfieldpolar3d( dataset,...); | Returns the spherical complex electric fields. Same arguments as farfield3d. |\r\n\r\n**Example**\r\n\r\nSee example in the [farfield3d ](./farfield3d.md) function description.",
    "summary": "The function farfieldpolar3d is similar to farfield3d, but it returns the complex electric fields, r...",
    "syntax": [
      {
        "syntax": "out = farfieldpolar3d( \"mname\",...);",
        "description": "Returns the spherical complex electric fields. Same arguments as farfield3d."
      },
      {
        "syntax": "out = farfieldpolar3d( dataset,...);",
        "description": "Returns the spherical complex electric fields. Same arguments as farfield3d."
      }
    ],
    "example": ""
  },
  {
    "name": "farfieldsettings",
    "description": "Sets the parameters available in the Far field settings window for far field calculations. To get the available parameters for far field settings, as is shown below, right click on a frequency-domain field monitor and visualize the far field. then select the Far field settings.",
    "usage": "farfieldsettings();",
    "category": "general",
    "markdown": "# farfieldsettings\r\n\r\nSets the parameters available in the Far field settings window for far field\r\ncalculations. To get the available parameters for far field settings, as is shown below,\r\nright click on a frequency-domain field monitor and visualize the far field. then select\r\nthe Far field settings.\r\n\r\n______________________________________________________________________\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                 |\r\n| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| farfieldsettings(\"property\", value); | Set the far field filter settings for far field calculations. These settings are applied to all far field projections. Value can be a number or string. This function does not return any data. |\r\n\r\n**Example**\r\n\r\n```\r\nfarfieldsettings(\"far field filter\",0.2);farfieldsettings(\"override near field mesh\",1);\r\nfarfieldsettings(\"near field samples per wavelength\",5);\r\n```",
    "summary": "Sets the parameters available in the Far field settings window for far field calculations",
    "syntax": [
      {
        "syntax": "farfieldsettings(\"property\", value);",
        "description": "Set the far field filter settings for far field calculations. These settings are applied to all far field projections. Value can be a number or string. This function does not return any data."
      }
    ],
    "example": "farfieldsettings(\"far field filter\",0.2);farfieldsettings(\"override near field mesh\",1);\r\nfarfieldsettings(\"near field samples per wavelength\",5);"
  },
  {
    "name": "farfieldspherical",
    "description": "Interpolates far field data (3D simulations) from E(ux,uy) to spherical coordinates E(theta,phi) 1D array. The far field projections functions generally return the projection as a function of ux,uy (direction cosines). farfieldspherical can be used to interpolate this data into the more common units of theta, phi. See the farfield3d documentation for information on interpreting ux, uy, na, nb for various monitor orientations.",
    "usage": "farfieldspherical();",
    "category": "general",
    "markdown": "# farfieldspherical\r\n\r\nInterpolates far field data (3D simulations) from E(ux,uy) to spherical coordinates\r\nE(theta,phi) 1D array. The far field projections functions generally return the\r\nprojection as a function of ux,uy (direction cosines). farfieldspherical can be used to\r\ninterpolate this data into the more common units of theta, phi. See the farfield3d\r\ndocumentation for information on interpreting ux, uy, na, nb for various monitor\r\norientations.\r\n\r\n| **Syntax**                                        | **Description**                                                                       |\r\n| ------------------------------------------------- | ------------------------------------------------------------------------------------- |\r\n| out = farfieldspherical( E2, ux, uy, theta, phi); | Interpolate far field data to spherical coordinates. The output has a size of (MxN,1) |\r\n\r\n| **Parameter** |          | **Default value** | **Type** | **Description**                                                                                                                                            |\r\n| ------------- | -------- | ----------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| E2            | required |                   | matrix   | E field data from farfield3d                                                                                                                               |\r\n| ux            | required |                   | vector   | ux data from farfieldux. Note that the result should be a vector, so it is sufficient to perform the farfieldux script command for only 1 frequency point. |\r\n| uy            | required |                   | vector   | uy data from farfielduy. Note that the result should be a vector, so it is sufficient to perform the farfieldux script command for only 1 frequency point. |\r\n| theta         | required |                   | vector   | theta vector, in degrees. Must have length M or 1.                                                                                                         |\r\n| phi           | required |                   | vector   | phi vector, in degrees. Must have length N or 1.                                                                                                           |\r\n\r\n**Example**\r\n\r\nCreate a plot of the E2_far vs theta, for phi=0.\r\n\r\n```\r\nm=\"Monitor1\";  # Monitor name\r\nres = 201;    # projection resolution\r\nE2 = farfield3d(m,1,res,res);\r\nux = farfieldux(m,1,res,res);\r\nuy = farfielduy(m,1,res,res);\r\ntheta = linspace(-90,90,100); \r\nphi = 0;\r\nplot(theta, farfieldspherical(E2,ux,uy,theta,phi) ,\"theta\", \"E^2\", \"E^2 at phi=0\");\r\n```\r\n\r\nInterpolate field data to a grid of theta and phi angles.\r\n\r\n```\r\ntheta = linspace(-90,90,10);\r\nphi = linspace(0,45,11);\r\nTheta = meshgridx(theta,phi);\r\nPhi = meshgridy(theta,phi);\r\nE2_angle = farfieldspherical(E2,ux,uy,Theta,Phi);  \r\nE2_angle = reshape(E2_angle, [length(theta), length(phi)]);  \r\nimage(theta, phi, E2_angle, \"theta\",\"phi\",\"E2\");\r\n```",
    "summary": "Interpolates far field data (3D simulations) from E(ux,uy) to spherical coordinates E(theta,phi) 1D ...",
    "syntax": [
      {
        "syntax": "out = farfieldspherical( E2, ux, uy, theta, phi);",
        "description": "Interpolate far field data to spherical coordinates. The output has a size of (MxN,1)"
      }
    ],
    "example": "m=\"Monitor1\";  # Monitor name\r\nres = 201;    # projection resolution\r\nE2 = farfield3d(m,1,res,res);\r\nux = farfieldux(m,1,res,res);\r\nuy = farfielduy(m,1,res,res);\r\ntheta = linspace(-90,90,100); \r\nphi = 0;\r\nplot(theta, farfieldspherical(E2,ux,uy,theta,phi) ,\"theta\", \"E^2\", \"E^2 at phi=0\");"
  },
  {
    "name": "farfieldux",
    "description": "Returns the matrix of ux corresponding to the far field data from farfield3d for a 3D simulation. See the farfield3d documentation for information on interpreting ux, uy, na, nb for various monitor orientations.",
    "usage": "farfieldux();",
    "category": "general",
    "markdown": "# farfieldux\r\n\r\nReturns the matrix of ux corresponding to the far field data from farfield3d for a 3D\r\nsimulation. See the farfield3d documentation for information on interpreting ux, uy, na,\r\nnb for various monitor orientations.\r\n\r\n| **Syntax**                               | **Description**                                                                                                                                                        |\r\n| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = farfieldux(\"mname\",f,na,nb,index); | See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points. |\r\n| out = farfieldux(dataset,f,na,nb,index); | See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points. |\r\n\r\n**Example**\r\n\r\nSee example in the [farfield3d](./farfield3d.md) function description.",
    "summary": "Returns the matrix of ux corresponding to the far field data from farfield3d for a 3D simulation",
    "syntax": [
      {
        "syntax": "out = farfieldux(\"mname\",f,na,nb,index);",
        "description": "See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points."
      },
      {
        "syntax": "out = farfieldux(dataset,f,na,nb,index);",
        "description": "See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points."
      }
    ],
    "example": ""
  },
  {
    "name": "farfielduy",
    "description": "Returns the matrix of uy corresponding to the far field data from farfield3d for a 3D simulation. See the farfield3d documentation for information on interpreting ux, uy, na, nb for various monitor orientations.",
    "usage": "farfielduy();",
    "category": "general",
    "markdown": "# farfielduy\r\n\r\nReturns the matrix of uy corresponding to the far field data from farfield3d for a 3D\r\nsimulation. See the farfield3d documentation for information on interpreting ux, uy, na,\r\nnb for various monitor orientations.\r\n\r\n| **Syntax**                               | **Description**                                                                                                                                                        |\r\n| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = farfielduy(\"mname\",f,na,nb,index); | See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points. |\r\n| out = farfielduy(dataset,f,na,nb,index); | See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points. |\r\n\r\n**Example**\r\n\r\nSee example in the [farfield3d](./farfield3d.md) function description.",
    "summary": "Returns the matrix of uy corresponding to the far field data from farfield3d for a 3D simulation",
    "syntax": [
      {
        "syntax": "out = farfielduy(\"mname\",f,na,nb,index);",
        "description": "See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points."
      },
      {
        "syntax": "out = farfielduy(dataset,f,na,nb,index);",
        "description": "See farfield3d help. Arguments are same as for farfield3d. Note that the result is an NxM matrix where N is the spatial index and M is the number of frequency points."
      }
    ],
    "example": ""
  },
  {
    "name": "farfieldvector2d",
    "description": "Projects a given power or field profile monitor or a rectilinear dataset to the far field to a 1 meter radius semi-circle. This is similar to the farfield2d script command except the complex electric fields are returned, rather than field intensity. The data is returned as matrix of NxP if one frequency point is projected, or NxPx3 when multiple frequency points are projected where N is the resolution of the far field projection, P is the number frequency points projected, and the last index refers to Ex, Ey and Ez which are the complex components of the electric field vector in Cartesian coordinates.",
    "usage": "farfieldvector2d();",
    "category": "general",
    "markdown": "# farfieldvector2d\r\n\r\nProjects a given power or field profile monitor or a rectilinear dataset to the far\r\nfield to a 1 meter radius semi-circle. This is similar to the farfield2d script command\r\nexcept the complex electric fields are returned, rather than field intensity. The data\r\nis returned as matrix of NxP if one frequency point is projected, or NxPx3 when multiple\r\nfrequency points are projected where N is the resolution of the far field projection, P\r\nis the number frequency points projected, and the last index refers to Ex, Ey and Ez\r\nwhich are the complex components of the electric field vector in Cartesian coordinates.\r\n\r\n| **Syntax**                            | **Description**                                                              |\r\n| ------------------------------------- | ---------------------------------------------------------------------------- |\r\n| out = farfieldvector2d( \"mname\",...); | Returns the Cartesian complex electric fields. Same arguments as farfield2d. |\r\n| out = farfieldvector2d( dataset,...); | Returns the Cartesian complex electric fields. Same arguments as farfield2d. |\r\n\r\n**Example**\r\n\r\nThis example plots the amplitude of the Ex component of the far field projection of a 1D\r\nmonitor called \"monitor\". In this example the second frequency point is projected. If\r\nthe monitor only contains data at one frequency, the second argument is not required.\r\nFor the example of far field projection of a rectilinear dataset see\r\n[farfield2d](./farfield2d.md).\r\n\r\n```\r\nE=farfieldvector2d(\"monitor\",2,501);\r\nEx = abs(pinch(E,2,1)); # amplitude of Ex\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,Ex,\"angle (deg)\",\"Ex far field\"); \r\n```\r\n\r\nFor additional examples see\r\n[ Far field projection ](https://optics.ansys.com/hc/en-us/articles/360034914713) .",
    "summary": "Projects a given power or field profile monitor or a rectilinear dataset to the far field to a 1 met...",
    "syntax": [
      {
        "syntax": "out = farfieldvector2d( \"mname\",...);",
        "description": "Returns the Cartesian complex electric fields. Same arguments as farfield2d."
      },
      {
        "syntax": "out = farfieldvector2d( dataset,...);",
        "description": "Returns the Cartesian complex electric fields. Same arguments as farfield2d."
      }
    ],
    "example": "E=farfieldvector2d(\"monitor\",2,501);\r\nEx = abs(pinch(E,2,1)); # amplitude of Ex\r\ntheta=farfieldangle(\"monitor\",2,501);\r\nplot(theta,Ex,\"angle (deg)\",\"Ex far field\");"
  },
  {
    "name": "farfieldvector3d",
    "description": "The function farfieldvector3d is similar to farfield3d, but it returns the complex electric fields, rather than field intensity. The data is returned as matrix of NxMx3 (if one frequency point is projected) or NxMx3xP (if more than 1 frequency point is projected), where N and M are spatial indices, the third index refers to Ex, Ey and Ez in spherical coordinates, and P is the number of frequency points. The components Ex, Ey and Ez are the complex components of the electric field vector. See the farfield3d documentation for information on interpreting ux, uy, na, nb for various monitor orientations.",
    "usage": "farfieldvector3d();",
    "category": "general",
    "markdown": "# farfieldvector3d\r\n\r\nThe function farfieldvector3d is similar to farfield3d, but it returns the complex\r\nelectric fields, rather than field intensity. The data is returned as matrix of NxMx3\r\n(if one frequency point is projected) or NxMx3xP (if more than 1 frequency point is\r\nprojected), where N and M are spatial indices, the third index refers to Ex, Ey and Ez\r\nin spherical coordinates, and P is the number of frequency points. The components Ex, Ey\r\nand Ez are the complex components of the electric field vector. See the farfield3d\r\ndocumentation for information on interpreting ux, uy, na, nb for various monitor\r\norientations.\r\n\r\n| **Syntax**                            | **Description**                                                              |\r\n| ------------------------------------- | ---------------------------------------------------------------------------- |\r\n| out = farfieldvector3d( \"mname\",...); | Returns the cartesian complex electric fields. Same arguments as farfield3d. |\r\n| out = farfieldvector3d( dataset,...); | Returns the cartesian complex electric fields. Same arguments as farfield3d. |\r\n\r\n**Example**\r\n\r\nSee example in the [farfield3d](./farfield3d.md) function description.\r\n\r\n[Understanding field polarization in far field projections](https://optics.ansys.com/hc/en-us/search/click?data=BAh7DjoHaWRsKwjB0cDTUwA6D2FjY291bnRfaWRpA02AjDoJdHlwZUkiDGFydGljbGUGOgZFVDoIdXJsSSJ2aHR0cHM6Ly9vcHRpY3MuYW5zeXMuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAzNDkxNDc1My1VbmRlcnN0YW5kaW5nLWZpZWxkLXBvbGFyaXphdGlvbi1pbi1mYXItZmllbGQtcHJvamVjdGlvbnMGOwhUOg5zZWFyY2hfaWRJIilkYjc4YzM5Yy1iOWU1LTRjNWUtYjE0NC02MGQzNjA4MGRkYWIGOwhGOglyYW5raQg6C2xvY2FsZUkiCmVuLXVzBjsIVDoKcXVlcnlJIhNmYXJmaWVsZHZlY3RvcgY7CFQ6EnJlc3VsdHNfY291bnRpEg%3D%3D--90007a278d7628d12a8c14265df095c4975dd311)",
    "summary": "The function farfieldvector3d is similar to farfield3d, but it returns the complex electric fields, ...",
    "syntax": [
      {
        "syntax": "out = farfieldvector3d( \"mname\",...);",
        "description": "Returns the cartesian complex electric fields. Same arguments as farfield3d."
      },
      {
        "syntax": "out = farfieldvector3d( dataset,...);",
        "description": "Returns the cartesian complex electric fields. Same arguments as farfield3d."
      }
    ],
    "example": ""
  },
  {
    "name": "feval",
    "description": "Evaluates a string as script file. This function is useful for running script files that are not in your path and files with spaces in the name.",
    "usage": "feval();",
    "category": "general",
    "markdown": "# feval\r\n\r\nEvaluates a string as script file. This function is useful for running script files that\r\nare not in your path and files with spaces in the name.\r\n\r\n| **Syntax**       | **Description**                                                                              |\r\n| ---------------- | -------------------------------------------------------------------------------------------- |\r\n| feval(filename); | Execute string containing the name of a script file. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nRun the script file C:\\\\temp\\\\example.lsf.\r\n\r\n```\r\nfeval(\"C:\\temp\\example.lsf\");\r\n```",
    "summary": "Evaluates a string as script file",
    "syntax": [
      {
        "syntax": "feval(filename);",
        "description": "Execute string containing the name of a script file. This function does not return any data."
      }
    ],
    "example": "feval(\"C:\\temp\\example.lsf\");"
  },
  {
    "name": "fft",
    "description": "Computes the 1D, 2D, or 3D Fast Fourier Transform (FFT) of a matrix. In the 1D case, the transform is given by",
    "usage": "fft();",
    "category": "general",
    "markdown": "# fft\r\n\r\nComputes the 1D, 2D, or 3D Fast Fourier Transform (FFT) of a matrix. In the 1D case, the\r\ntransform is given by\r\n\r\n$$ E_w[m]=\\\\text{fft}(E_x)=\\\\sum\\_{n-1}^NE_x[n]. e^{(\\\\frac{2\\\\pi i}{N})(n-1)(m-1)} $$\r\n\r\nThe FFT, inverse FFT, and all associated functions have an option (option 1 below) that\r\ncontrols the format used to store the frequency domain data. When working with spectral\r\ndata it is not possible to switch between formats; there are no functions to convert\r\nbetween formats. This implies that if you use option 1=n to produce a spectrum with\r\n\\[[||fft]\\], then you must also use option 1=n if you want to pass that same spectral\r\ndata to \\[[||invfft]\\]. Similarly, if you use option1 = n for \\[[||fft]\\], then you also\r\nneed to use option 1=n with \\[[||fftw]\\] to get the proper frequency vector\r\ncorresponding to your spectrum. \\[[||invfft]\\] and \\[[||fftk]\\] work in the same way.\r\n\r\n| **Syntax**                     | **Description**                                                                                   |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------------- |\r\n| out = fft(Ex);                 | Returns the fast Fourier transform of Ex. Ex can be 1D, 2D or 3D.                                 |\r\n| out = fft(Ex,option1,option2); | option1 This option controls the format used to store the frequency domain data. The options are: |\r\n\r\n- 1 : the standard FFT (zero frequency is at the first element of the matrix). This is\r\n  the default option.\r\n- 2 : zero frequency is the first element, but only data up to and including the Nyquist\r\n  frequency is stored. This option is only useful for real-valued, 1D time/spatial\r\n  signals.\r\n- 3 : the FFT is shifted so zero frequency is the central element of the spectrum (more\r\n  precisely, this means the zero frequency point is at the element floor(N/2 + 1), where\r\n  N is the number of samples).\r\n\r\noption2 This option is either a 1, 2 or 3 element vector depending on whether Ex is 1D,\r\n2D or 3D. For each dimension, specify a value of either 0, 1 or N to obtain the desired\r\n0 padding options.\r\n\r\n- 0: no zero padding.\r\n- 1: zero padding up to the next power of 2 longer than the length of Ex (default).\r\n- N: zero pad up to length N if N > length(Ex), where the length of Ex is the length in\r\n  a specific dimension. If N \\<= length(Ex), it will zero pad up to the next power of 2\r\n  longer than the length of Ex. For the fastest results, N should be a power of 2 and\r\n  can be entered, for example, as 2^12.\r\n\r\n## Note: FFT Conventions There are different, but equivalent conventions for defining Fourier transforms. Lumerical defines the forward FFT using a positive sign in the exponential term, and the inverse FFT using a negative sign in the exponential term. However, some other packages (e.g. MATLAB) use the opposite convention, with a negative sign in the exponential for the forward FFT and a positive sign in the exponential for the inverse FFT. To convert between the different FFT conventions, switch the \\[[||invfft]\\] and \\[[||fft]\\] and rescale the results. For a signal y with N elements, this can be done as follows: fft(y,1,0) (Lumerical) \\\\(\\\\Longleftrightarrow\\\\) ifft(y)\\*N (MATLAB) invfft(y,1,0) (Lumerical) \\\\(\\\\Longleftrightarrow\\\\) fft(y)/N (MATLAB)\r\n\r\n### Example\r\n\r\nThis example transforms a time signal with 60 and 100 rad/s angular frequency components\r\ninto the frequency domain. The function \\[[||fftw]\\] is used to get the correct\r\nfrequency vector. If this was a spatial signal, then \\[[||fftk]\\] should be used in\r\nplace of \\[[||fftw]\\].\r\n\r\n```\r\nt=linspace(0,1,1000);    # time signal\r\nw1=100;           # frequency, in rad/s\r\nw2=60;            # frequency, in rad/s\r\nx=0.5*(sin(w1*t)+sin(w2*t)); # the signal\r\nplot(t,x,\"time\",\"signal\");\r\no1=2;            # option 1\r\no2=1;            # option 2\r\ny=fft(x,o1,o2);       # fft\r\nw=fftw(t,o1,o2);       # frequency signal\r\nplot(w,abs(y),\"freq (rad/sec)\",\"amplitude\");\r\n```\r\n\r\nThis example shows how to calculate the FFT of the electric field intensity (i.e.,\r\ncombining all three field components) recorded by a time monitor in the attachment. If\r\nyou want to filter the high-frequency data, set option1 to 2.\r\n\r\n```\r\n# get data from point time monitor\r\nm = \"time\";\r\nt = getdata(m,\"t\");\r\nEx = getdata(m,\"Ex\");\r\nEy = getdata(m,\"Ey\");\r\nEz = getdata(m,\"Ez\");\r\n# option1 = 1 -> standard fft\r\n# option1 = 2 -> remove high frequency data\r\noption1 = 2;\r\n# do fft of each component\r\nf  = fftw(t, option1)/2/pi;\r\nExw = fft(Ex, option1);  # fft each component separately\r\nEyw = fft(Ey, option1);\r\nEzw = fft(Ez, option1);\r\nE2w = abs(Exw)^2+abs(Eyw)^2+abs(Ezw)^2; # combine field components\r\nplot(f/1e12,E2w,\"f (THz)\",\"|E(f)|^2\",\"fft E^2 intensity\"); \r\n```\r\n\r\nThe following figures show the resulting plot for both the standard transform and the\r\noption to remove the high-frequency data (option1 = 1 or 2).",
    "summary": "Computes the 1D, 2D, or 3D Fast Fourier Transform (FFT) of a matrix",
    "syntax": [
      {
        "syntax": "out = fft(Ex);",
        "description": "Returns the fast Fourier transform of Ex. Ex can be 1D, 2D or 3D."
      },
      {
        "syntax": "out = fft(Ex,option1,option2);",
        "description": "option1 This option controls the format used to store the frequency domain data. The options are:"
      }
    ],
    "example": ""
  },
  {
    "name": "fftk",
    "description": "Returns the spatial wavevector kx associated with the Fourier transform of a function of x.",
    "usage": "fftk();",
    "category": "general",
    "markdown": "# fftk\r\n\r\nReturns the spatial wavevector kx associated with the Fourier transform of a function of\r\nx.\r\n\r\n$$ k=\\\\text{fftk}(x)=\\\\frac{2\\\\pi}{dx.M}[0,...,(M-1)] $$\r\n\r\nwhere M=length(x).\r\n\r\nfftk and all related functions have an option (option 1 below) that controls the format\r\nused to store the frequency domain data. When working with spectral data it is not\r\npossible to switch between formats; there are no functions to convert between formats.\r\nThis implies that if you use option1=n to produce a spectrum with fft, then you must\r\nalso use option1=n if you want to pass that same spectral data to invfft. Similarly, if\r\nyou use option1=n for fft, then you also need to use option1=n with fftw to get the\r\nproper frequency vector corresponding to your spectrum. invfft and fftk work in the same\r\nway.\r\n\r\n| **Syntax**               | **Description**                                                                            |\r\n| ------------------------ | ------------------------------------------------------------------------------------------ |\r\n| out = fftk(x);           | Returns the spatial wavevector kx associated with a fourier transform of a function of x.. |\r\n| fftk(x,option1,option2); | option1                                                                                    |\r\n\r\n- 1 : the standard FFT (zero frequency is at the first element of the matrix). This is\r\n  the default option.\r\n\r\n- 2 : zero frequency is the first element, but frequencies above the Nyquist frequency\r\n  are removed.\r\n\r\n- 3 : the FFT is shifted so zero frequency is the central element of the spectrum (more\r\n  precisely, this means the zero frequency point is at element floor(N/2 + 1), where N\r\n  is the number of samples). Both positive and negative frequencies are seen\r\n\r\noption2\r\n\r\n- 0: no zero padding.\r\n- 1: zero padding up to the next power of 2 longer than the length of Ex (default).\r\n- N: zero pad up to length N if N > length(t). If N \\<= length(t), it will zero pad up\r\n  to the next power of 2 longer than the length of t. For the fastest results, N should\r\n  be a power of 2 and can be entered, for example, as 2^12.\r\n\r\n**Example**\r\n\r\nIf Ex is a 2D matrix of spatial field values where Ex contains the field values along\r\nthe axis vectors x and y, then the following code will image the field and the fourier\r\ntransform of Ex.\r\n\r\n```\r\nimage(x,y,Ex);\r\nIx = abs( fft(Ex) )^2; \r\nkx = fftk(x); \r\nky = fftk(y); \r\nimage(kx,ky,Ix); \r\n```",
    "summary": "Returns the spatial wavevector kx associated with the Fourier transform of a function of x",
    "syntax": [
      {
        "syntax": "out = fftk(x);",
        "description": "Returns the spatial wavevector kx associated with a fourier transform of a function of x.."
      },
      {
        "syntax": "fftk(x,option1,option2);",
        "description": "option1"
      }
    ],
    "example": "image(x,y,Ex);\r\nIx = abs( fft(Ex) )^2; \r\nkx = fftk(x); \r\nky = fftk(y); \r\nimage(kx,ky,Ix);"
  },
  {
    "name": "fftw",
    "description": "Returns the angular frequency vector corresponding to time vector t.",
    "usage": "fftw();",
    "category": "general",
    "markdown": "# fftw\r\n\r\nReturns the angular frequency vector corresponding to time vector t.\r\n\r\n$$ w=\\\\text{fftw}(t)=\\\\frac{2\\\\pi}{dt.M}[0,...,(M-1)] $$\r\n\r\nwhere M=length(t) .\r\n\r\nfftw and all related functions have an option (option 1 below) that controls the format\r\nused to store the frequency domain data. When working with spectral data it is not\r\npossible to switch between formats; there are no functions to convert between formats.\r\nThis implies that if you use option1=n to produce a spectrum with fft, then you must\r\nalso use option1=n if you want to pass that same spectral data to invfft. Similarly, if\r\nyou use option1=n for fft, then you also need to use option1=n with fftw to get the\r\nproper frequency vector corresponding to your spectrum. invfft and fftk work in the same\r\nway.\r\n\r\n| **Syntax**               | **Description**                                                      |\r\n| ------------------------ | -------------------------------------------------------------------- |\r\n| out = fftw(t);           | Returns the angular frequency vector corresponding to time vector t. |\r\n| fftw(t,option1,option2); | option1                                                              |\r\n\r\n- 1 : the standard FFT (zero frequency is at the first element of the matrix). This is\r\n  the default option.\r\n\r\n- 2 : zero frequency is the first element, but frequencies above the Nyquist frequency\r\n  are removed.\r\n\r\n- 3 : the FFT is shifted so zero frequency is the central element of the spectrum (more\r\n  precisely, this means the zero frequency point is at element floor(N/2 + 1), where N\r\n  is the number of samples). Both positive and negative frequencies are seen\r\n\r\noption2\r\n\r\n- 0: no zero padding.\r\n- 1: zero padding up to the next power of 2 longer than the length of Ex (default).\r\n- N: zero pad up to length N if N > length(t). If N \\<= length(t), it will zero pad up\r\n  to the next power of 2 longer than the length of t. For the fastest results, N should\r\n  be a power of 2 and can be entered, for example, as 2^12.\r\n\r\n**Example**\r\n\r\nSee fft or fftk examples.",
    "summary": "Returns the angular frequency vector corresponding to time vector t",
    "syntax": [
      {
        "syntax": "out = fftw(t);",
        "description": "Returns the angular frequency vector corresponding to time vector t."
      },
      {
        "syntax": "fftw(t,option1,option2);",
        "description": "option1"
      }
    ],
    "example": ""
  },
  {
    "name": "filebasename",
    "description": "Gets the file basename from a string.",
    "usage": "filebasename();",
    "category": "general",
    "markdown": "# filebasename\r\n\r\nGets the file basename from a string.\r\n\r\n| **Syntax**                                     | **Description**                        |\r\n| ---------------------------------------------- | -------------------------------------- |\r\n| out = filebasename( \"location/filename.ext\" ); | Returns the file basename as a string. |\r\n\r\n**Examples**\r\n\r\nIsolates the file basename from the full filename.\r\n\r\n```\r\n?filebasename(\"C:\\Users\\myname\\Documents\\FDTD Files\\test.fsp\");\r\ntest\r\n```",
    "summary": "Gets the file basename from a string",
    "syntax": [
      {
        "syntax": "out = filebasename( \"location/filename.ext\" );",
        "description": "Returns the file basename as a string."
      }
    ],
    "example": ""
  },
  {
    "name": "filedirectory",
    "description": "Gets the file directory from a string.",
    "usage": "filedirectory();",
    "category": "general",
    "markdown": "# filedirectory\r\n\r\nGets the file directory from a string.\r\n\r\n| **Syntax**                                      | **Description**                         |\r\n| ----------------------------------------------- | --------------------------------------- |\r\n| out = filedirectory( \"location/filename.ext\" ); | Returns the file directory as a string. |\r\n\r\n**Examples**\r\n\r\nIsolates the file directory from the full filename.\r\n\r\n```\r\n?filedirectory(\"C:\\Users\\myname\\Documents\\FDTD Files\\test.fsp\");\r\nC:/Users/myname/Documents/FDTD Files\r\n```",
    "summary": "Gets the file directory from a string",
    "syntax": [
      {
        "syntax": "out = filedirectory( \"location/filename.ext\" );",
        "description": "Returns the file directory as a string."
      }
    ],
    "example": ""
  },
  {
    "name": "fileexists",
    "description": "Checks if a file exists. The file extension (ie, .fsp, .lms, etc) must be specified. By default, the entire path will be searched.",
    "usage": "fileexists();",
    "category": "general",
    "markdown": "# fileexists\r\n\r\nChecks if a file exists. The file extension (ie, .fsp, .lms, etc) must be specified. By\r\ndefault, the entire path will be searched.\r\n\r\n| **Syntax**                              | **Description**                                                    |\r\n| --------------------------------------- | ------------------------------------------------------------------ |\r\n| out = fileexists(\"filename\");           | Returns 1 if the file exists Returns 0 if the file does not exist. |\r\n| out = fileexists(\"c:\\\\temp\\\\file.txt\"); | Search for a file not in the path                                  |\r\n\r\n**Examples**\r\n\r\nChecks if a file exists before opening it.\r\n\r\n```\r\nfilename=\"simulation.fsp\";\r\nif (fileexists(filename)) {\r\n load(filename);\r\n}\r\n```\r\n\r\nLoad a simulation project file, if it exists. First check current directory, then check\r\nup one directory.\r\n\r\n```\r\nfilename=\"simulation.fsp\";\r\nif (fileexists(file)) {\r\n load(filename);\r\n} else {\r\n file = \"../\"+file;\r\n if (fileexists(file)) {\r\n  load(filename);\r\n } else {\r\n  ?\"File not found.\";\r\n }\r\n}\r\n```",
    "summary": "Checks if a file exists",
    "syntax": [
      {
        "syntax": "out = fileexists(\"filename\");",
        "description": "Returns 1 if the file exists Returns 0 if the file does not exist."
      },
      {
        "syntax": "out = fileexists(\"c:\\\\temp\\\\file.txt\");",
        "description": "Search for a file not in the path"
      }
    ],
    "example": ""
  },
  {
    "name": "fileexpand",
    "description": "Expands a file name by replacing any environmental variables.",
    "usage": "fileexpand();",
    "category": "general",
    "markdown": "# fileexpand\r\n\r\nExpands a file name by replacing any environmental variables.\r\n\r\n| **Syntax**            | **Description**                                                                       |\r\n| --------------------- | ------------------------------------------------------------------------------------- |\r\n| fileexpand(filename); | Expands a file name by replacing any environmental variables (defined by setsetting). |\r\n\r\n### Example\r\n\r\nExpand a filename containing the variable LOCAL\r\n\r\n```\r\n?getsetting;\r\nLOCAL=C:\\Users\r\n?fileexpand(\"$LOCAL\\data.txt\");\r\n```",
    "summary": "Expands a file name by replacing any environmental variables",
    "syntax": [
      {
        "syntax": "fileexpand(filename);",
        "description": "Expands a file name by replacing any environmental variables (defined by setsetting)."
      }
    ],
    "example": ""
  },
  {
    "name": "fileextension",
    "description": "Gets the file extension from a string.",
    "usage": "fileextension();",
    "category": "general",
    "markdown": "# fileextension\r\n\r\nGets the file extension from a string.\r\n\r\n| **Syntax**                        | **Description**                         |\r\n| --------------------------------- | --------------------------------------- |\r\n| out = fileextension( \"name.ext\"); | Returns the file extension as a string. |\r\n\r\n**Examples**\r\n\r\nIsolates the file extension from the full filename.\r\n\r\n```\r\n?fileextension(\"C:/Users/myname/Documents/FDTD/myfile.fsp\");\r\nfsp\r\n```\r\n\r\nUses the following code to check with product you are using. This can be helpful if you\r\nare trying to write scripts that will be shared between multiple products.\r\n\r\n```\r\nsave(\"myfile\");\r\nif(fileextension(currentfilename)==\"fsp\") { ?\"Using FDTD\"; }\r\nif(fileextension(currentfilename)==\"lms\") { ?\"Using MODE\"; }\r\nif(fileextension(currentfilename)==\"ldev\") { ?\"Using Finite Element IDE\"; }\r\nif(fileextension(currentfilename)==\"icp\") { ?\"Using INTERCONNECT\"; }\r\n```",
    "summary": "Gets the file extension from a string",
    "syntax": [
      {
        "syntax": "out = fileextension( \"name.ext\");",
        "description": "Returns the file extension as a string."
      }
    ],
    "example": ""
  },
  {
    "name": "fileopendialog",
    "description": "Calls the standard windows file open dialog.",
    "usage": "fileopendialog();",
    "category": "general",
    "markdown": "# fileopendialog\r\n\r\nCalls the standard windows file open dialog.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                        |\r\n| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = fileopendialog;         | Brings up the open file dialog box and returns the path that the user selects.                                                         |\r\n| out = fileopendialog(\".ext\"); | Brings up the open file dialog box, displaying only files with the extension .ext. Returns the path of the file that the user selects. |\r\n\r\n**Examples**\r\n\r\nAllow a user to select a simulation file to load into CAD from the file open dialog box.\r\n\r\n```\r\n load(fileopendialog(\"*.fsp\")); \r\n```",
    "summary": "Calls the standard windows file open dialog",
    "syntax": [
      {
        "syntax": "out = fileopendialog;",
        "description": "Brings up the open file dialog box and returns the path that the user selects."
      },
      {
        "syntax": "out = fileopendialog(\".ext\");",
        "description": "Brings up the open file dialog box, displaying only files with the extension .ext. Returns the path of the file that the user selects."
      }
    ],
    "example": ""
  },
  {
    "name": "filesavedialog",
    "description": "Calls the standard windows file save dialog.",
    "usage": "filesavedialog();",
    "category": "general",
    "markdown": "# filesavedialog\r\n\r\nCalls the standard windows file save dialog.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                        |\r\n| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = filesavedialog;         | Brings up the save file dialog box and returns the path that the user selects.                                                         |\r\n| out = filesavedialog(\".ext\"); | Brings up the save file dialog box, displaying only files with the extension .ext. Returns the path of the file that the user selects. |\r\n\r\n**Examples**\r\n\r\nSave the current simulation to a path chosen by the user.\r\n\r\n```\r\n save(filesavedialog(\"*.fsp\")); \r\n```\r\n\r\n###",
    "summary": "Calls the standard windows file save dialog",
    "syntax": [
      {
        "syntax": "out = filesavedialog;",
        "description": "Brings up the save file dialog box and returns the path that the user selects."
      },
      {
        "syntax": "out = filesavedialog(\".ext\");",
        "description": "Brings up the save file dialog box, displaying only files with the extension .ext. Returns the path of the file that the user selects."
      }
    ],
    "example": ""
  },
  {
    "name": "find",
    "description": "Searchs for entries in a matrix that meet some condition. The indices of those values are returned. For multi-dimensional matrices, the find function will still return a single index. This is useful when using the output from find in a loop.",
    "usage": "find();",
    "category": "general",
    "markdown": "# find\r\n\r\nSearchs for entries in a matrix that meet some condition. The indices of those values\r\nare returned. For multi-dimensional matrices, the find function will still return a\r\nsingle index. This is useful when using the output from find in a loop.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                        |\r\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = find(x,n);            | Will return the index of the first element in x that corresponds to the closest value to 'n'.                                                          |\r\n| out = find(x==n);           | Will return the index of all elements in x that have a value exactly equal to 'n'. If 0 is returned, indicates that no element of value 'n' was found. |\r\n| out = find(x);              | Will return the index of all non-zero elements in x. If 0 is returned, indicates that no element of non-zero value was found.                          |\r\n| out = find(x>n);            | Will return the indices of all values of x that are greater than 'n'.                                                                                  |\r\n| out = find((x>=n) & (x\\<m)) | Will return the indices of all values of x that are greater than or equal to 'n', AND less than 'm'.                                                   |\r\n\r\n**Example**\r\n\r\nThe following two examples show the basic output from the find function.\r\n\r\n```\r\nx = -2:7;\r\n?find(x>5);\r\nresult: \r\n9 \r\n10\r\nx = linspace(0,10e-6,100);\r\n?x( find(x,5e-6) );\r\nresult: \r\n5.05051e-006 \r\n```\r\n\r\nThis example shows the equivalent usage of the find function for the example above but\r\nwith one argument rather than two:\r\n\r\n```\r\nminDiff=min(abs(x-5e-6));\r\nclosestIndices=find(abs(x-5e-6)==minDiff);\r\n?x(closestIndices(1));\r\nresult: \r\n5.05051e-006  \r\n```\r\n\r\nThis example shows the output of find for multi-dimensional data. A single index is\r\nreturned. Data can be accessed from a matrix in the same manner.\r\n\r\n```\r\nx = matrix(2,2);\r\nx(2,2) = 7;\r\n?find(x,7);\r\nresult:\r\n4\r\n?x(4);\r\nresult:\r\n7\r\n```\r\n\r\nThis example shows how to use the find function to set all values in a matrix that are\r\nlarger than 10 to exactly 10.\r\n\r\n```\r\nx = linspace(0,20,200);\r\ny = sin(x)*11;\r\ny2 = y;\r\nn = find(y>10);\r\ny(n) = y(n)*0+10;\r\nplot(x,y,y2);\r\n```\r\n\r\nThis example shows how to convert the single index returned by the find function into\r\nindividual i,j,k matrix indices. This particular example returns the index value of the\r\nmaximum intensity value, given a particular monitor data.\r\n\r\n```\r\n#Get the monitor data\r\nE = getresult(\"monitor\",\"E\");\r\n#Get the position and frequency data from the dataset E\r\nx = E.x;\r\ny = E.y;\r\nf = E.f;\r\n#Get the length of the properties\r\nnx = length(x);\r\nny = length(y);\r\nnz = length(z);\r\nnf = length(f);\r\n#Get the intensity values\r\ne2 = E.E2;\r\n#Get the maximum intensity value\r\nindexE2 = find(e2, max(e2));\r\n#Create the grids that will be used to extract the actual position values\r\nX = meshgrid3dx(x,y,f);\r\nY = meshgrid3dy(x,y,f);\r\nF = meshgrid3dz(x,y,f);\r\n#Create the grids that will be used to extract the index values\r\nX2 = meshgrid3dx(1:nx,1:ny,1:nf);\r\nY2 = meshgrid3dy(1:nx,1:ny,1:nf);\r\nF2 = meshgrid3dz(1:nx,1:ny,1:nf);\r\n#Output the values of the position and the index\r\n?X(indexE2);\r\n?Y(indexE2);\r\n?F(indexE2);\r\n?X2(indexE2);\r\n?Y2(indexE2);\r\n?F2(indexE2);\r\n```\r\n\r\nThis example shows another way of how to convert the single index returned by the find\r\nfunction into individual i,j,k matrix indices.\r\n\r\n```\r\n# create example matrix\r\na = randmatrix(3,4,5);\r\n# find matrix index of value closest to 0.5\r\nindex = find(a,0.5);\r\n?\"Single index access: a(\"+num2str(index)+\") = \"+num2str(a(index));\r\n# convert index to row, col indices \r\nmatrix_size = size(a);\r\nindices = matrix(length(matrix_size));\r\n# do for each dimension\r\nfor (i = 1:length(matrix_size)) { \r\n mod_dividend = index;\r\n mod_divisor = matrix_size(i);\r\n mod_remainder = mod(mod_dividend,mod_divisor);\r\n if (mod_remainder == 0) { mod_remainder = matrix_size(i); }\r\n indices(i) = mod_remainder;\r\n # remove this dimension from further calculations\r\n index = (index+(matrix_size(i)-mod_remainder))/matrix_size(i);\r\n}\r\n?\"multi indice access: a(\"+num2str(indices(1))+\",\"+\r\n              num2str(indices(2))+\",\"+\r\n              num2str(indices(3))+\")=\"+\r\n              num2str(a(indices(1),indices(2),indices(3)));\r\n```",
    "summary": "Searchs for entries in a matrix that meet some condition",
    "syntax": [
      {
        "syntax": "out = find(x,n);",
        "description": "Will return the index of the first element in x that corresponds to the closest value to 'n'."
      },
      {
        "syntax": "out = find(x==n);",
        "description": "Will return the index of all elements in x that have a value exactly equal to 'n'. If 0 is returned, indicates that no element of value 'n' was found."
      },
      {
        "syntax": "out = find(x);",
        "description": "Will return the index of all non-zero elements in x. If 0 is returned, indicates that no element of non-zero value was found."
      },
      {
        "syntax": "out = find(x>n);",
        "description": "Will return the indices of all values of x that are greater than 'n'."
      },
      {
        "syntax": "out = find((x>=n) & (x\\<m))",
        "description": "Will return the indices of all values of x that are greater than or equal to 'n', AND less than 'm'."
      }
    ],
    "example": "x = -2:7;\r\n?find(x>5);\r\nresult: \r\n9 \r\n10\r\nx = linspace(0,10e-6,100);\r\n?x( find(x,5e-6) );\r\nresult: \r\n5.05051e-006"
  },
  {
    "name": "findmodes",
    "description": "Calculates the modes supported by the structure using the current calculation settings. This function is the script equivalent to the \"Calculate Modes\" button. Each mode will be saved as a D-CARD named \"modeX\", where X is the xth mode found. The D-CARD saves data such as effective index and mode profile.",
    "usage": "findmodes();",
    "category": "general",
    "markdown": "# findmodes\r\n\r\nCalculates the modes supported by the structure using the current calculation settings.\r\nThis function is the script equivalent to the \"Calculate Modes\" button. Each mode will\r\nbe saved as a D-CARD named \"modeX\", where X is the xth mode found. The D-CARD saves data\r\nsuch as effective index and mode profile.\r\n\r\n| **Syntax**   | **Description**                               |\r\n| ------------ | --------------------------------------------- |\r\n| n=findmodes; | n will be equal to the number of modes found. |\r\n\r\n**Example**\r\n\r\nTo perform a frequency sweep on the first mode and plot the dispersion:\r\n\r\n```\r\nswitchtolayout;  \r\n\r\nfindmodes;  \r\nselectmode(1);  \r\nsetanalysis(\"track selected mode\",1);  \r\nsetanalysis(\"detailed dispersion calculation\",1);  \r\n\r\nfrequencysweep;  \r\nD=getdata(\"frequencysweep\",\"D\");  \r\nf=getdata(\"frequencysweep\",\"f_D\");  \r\n\r\nplot(c/f*1e6,D*1e6,\"Wavelength (um)\", \"Dispersion (ps/nm/km)\");\r\n```",
    "summary": "Calculates the modes supported by the structure using the current calculation settings",
    "syntax": [
      {
        "syntax": "n=findmodes;",
        "description": "n will be equal to the number of modes found."
      }
    ],
    "example": "switchtolayout;  \r\n\r\nfindmodes;  \r\nselectmode(1);  \r\nsetanalysis(\"track selected mode\",1);  \r\nsetanalysis(\"detailed dispersion calculation\",1);  \r\n\r\nfrequencysweep;  \r\nD=getdata(\"frequencysweep\",\"D\");  \r\nf=getdata(\"frequencysweep\",\"f_D\");  \r\n\r\nplot(c/f*1e6,D*1e6,\"Wavelength (um)\", \"Dispersion (ps/nm/km)\");"
  },
  {
    "name": "findpeaks",
    "description": "Returns the position of peaks in a matrix. A peak (or local maximum) is defined as a data point that is larger than its nearest neighbors.",
    "usage": "findpeaks();",
    "category": "general",
    "markdown": "# findpeaks\r\n\r\nReturns the position of peaks in a matrix. A peak (or local maximum) is defined as a\r\ndata point that is larger than its nearest neighbors.\r\n\r\n| **Syntax**          | **Description**                                                                                                                                                                                                                                                                  |\r\n| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = findpeaks(y); | Returns the position of the peak with the largest value in y. The length of y must be at least 2. If no peak is found in the data, a value of 1 is returned.                                                                                                                     |\r\n| findpeaks(y,n);     | Returns a matrix containing the positions of the largest n peaks found in the data. The returned values are ordered from largest to smallest. The returned matrix is always of dimension nX1. If less than n peaks are found, the remaining values of the returned matrix are 1. |\r\n\r\n**Example**\r\n\r\nThe following example calculates the location of the two largest peaks in a data set.\r\n\r\n```\r\nx=linspace(-20,20,1000);\r\ny=x*cos(x);\r\n?pos=findpeaks(y,2);\r\nplot(x,y);\r\n?\"largest peak is at x=\" + num2str(x(pos(1)));\r\n?\"largest peak height is y=\" + num2str(y(pos(1)));\r\n?\"2nd largest peak is at x=\" + num2str(x(pos(2)));\r\n?\"2nd largest peak height is y=\" + num2str(y(pos(2)));\r\nresult: \r\n973 \r\n107 \r\nlargest peak is at x=18.9189\r\nlargest peak height is y=18.8734\r\n2nd largest peak is at x=-15.7558\r\n2nd largest peak height is y=15.7378\r\n```",
    "summary": "Returns the position of peaks in a matrix",
    "syntax": [
      {
        "syntax": "out = findpeaks(y);",
        "description": "Returns the position of the peak with the largest value in y. The length of y must be at least 2. If no peak is found in the data, a value of 1 is returned."
      },
      {
        "syntax": "findpeaks(y,n);",
        "description": "Returns a matrix containing the positions of the largest n peaks found in the data. The returned values are ordered from largest to smallest. The returned matrix is always of dimension nX1. If less than n peaks are found, the remaining values of the returned matrix are 1."
      }
    ],
    "example": "x=linspace(-20,20,1000);\r\ny=x*cos(x);\r\n?pos=findpeaks(y,2);\r\nplot(x,y);\r\n?\"largest peak is at x=\" + num2str(x(pos(1)));\r\n?\"largest peak height is y=\" + num2str(y(pos(1)));\r\n?\"2nd largest peak is at x=\" + num2str(x(pos(2)));\r\n?\"2nd largest peak height is y=\" + num2str(y(pos(2)));\r\nresult: \r\n973 \r\n107 \r\nlargest peak is at x=18.9189\r\nlargest peak height is y=18.8734\r\n2nd largest peak is at x=-15.7558\r\n2nd largest peak height is y=15.7378"
  },
  {
    "name": "findproperty",
    "description": "This command returns a cell containing all elements in the circuit that have a certain property.",
    "usage": "findproperty();",
    "category": "general",
    "markdown": "# findproperty\r\n\r\nThis command returns a cell containing all elements in the circuit that have a certain\r\nproperty.\r\n\r\n| **Syntax**                          | **Description**                                                                                                                                                                                                                            |\r\n| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| findproperty (property, recursive); | Returns a cell containing all elements in the circuit that have property ‘property’. If recursive is true, it will return a flat list (hierarchical) with all the elements in the current scope. The default value for recursive is false. |",
    "summary": "This command returns a cell containing all elements in the circuit that have a certain property",
    "syntax": [
      {
        "syntax": "findproperty (property, recursive);",
        "description": "Returns a cell containing all elements in the circuit that have property ‘property’. If recursive is true, it will return a flat list (hierarchical) with all the elements in the current scope. The default value for recursive is false."
      }
    ],
    "example": ""
  },
  {
    "name": "findpropertyvalue",
    "description": "This command returns a cell containing all elements in the circuit that have a certain property with a certain value.",
    "usage": "findpropertyvalue();",
    "category": "general",
    "markdown": "# findpropertyvalue\r\n\r\nThis command returns a cell containing all elements in the circuit that have a certain\r\nproperty with a certain value.\r\n\r\n| **Syntax**                                      | **Description**                                                                                                                                                                                                                                               |\r\n| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| findpropertyvalue (property, value, recursive); | Returns a cell containing all elements in the circuit that have property ‘property’ with value ‘value’, if recursive is true, it will return a flat list (hierarchical) with all the elements in the current scope. The default value for recursive is false. |",
    "summary": "This command returns a cell containing all elements in the circuit that have a certain property with...",
    "syntax": [
      {
        "syntax": "findpropertyvalue (property, value, recursive);",
        "description": "Returns a cell containing all elements in the circuit that have property ‘property’ with value ‘value’, if recursive is true, it will return a flat list (hierarchical) with all the elements in the current scope. The default value for recursive is false."
      }
    ],
    "example": ""
  },
  {
    "name": "findresonances",
    "description": "Returns the frequency, decay constant, Q-factor, amplitude and phase of resonances extracted from the time trace of a purely real or complex signal within a frequency range \\\\( [f\\_{\\\\text{min}}, f\\_{\\\\text{max}}] \\\\) specified by the user. The findresonances script command uses a harmonic inversion method called filter diagonalization (see Ref. [1]) to approximate the time signal by a superposition of exponentially decaying harmonic oscillations of the form",
    "usage": "findresonances();",
    "category": "general",
    "markdown": "# findresonances\r\n\r\nReturns the frequency, decay constant, Q-factor, amplitude and phase of resonances\r\nextracted from the time trace of a purely real or complex signal within a frequency\r\nrange \\\\( [f\\_{\\\\text{min}}, f\\_{\\\\text{max}}] \\\\) specified by the user. The\r\nfindresonances script command uses a harmonic inversion method called filter\r\ndiagonalization (see Ref. [1]) to approximate the time signal by a superposition of\r\nexponentially decaying harmonic oscillations of the form\r\n\r\n$$ s(t) \\\\approx \\\\sum\\_{k=1}^{N} A_k \\\\cos(2 \\\\pi f_k t - \\\\phi_k) e^{- \\\\alpha_k t}\r\n\\\\text{, for real signals}$$\r\n\r\n$$ s(t) \\\\approx \\\\sum\\_{k=1}^{N} A_k e^{-i (2 \\\\pi f_k t - \\\\phi_k)} e^{- \\\\alpha_k t}\r\n\\\\text{, for complex signals}$$\r\n\r\nHere \\\\( N \\\\) is the number of resonances and each resonance is characterized by four\r\nreal-valued parameters:\r\n\r\n- \\\\( f_k \\\\): Resonance frequency.\r\n- \\\\( \\\\alpha_k \\\\): Decay constant, where \\\\( \\\\alpha_k \\\\ge 0 \\\\). Alternatively, the\r\n  decay is described by the Q-factor \\\\( Q_k = \\\\omega_k / 2 \\\\alpha \\\\), where \\\\(\r\n  \\\\omega_k = 2 \\\\pi f_k \\\\) is the corresponding angular frequency.\r\n- \\\\( A_k \\\\): Amplitude.\r\n- \\\\( \\\\phi_k \\\\): Phase.\r\n\r\nAdditionally, findresonances returns an error estimate that can be used to identify\r\nspurious resonances reported by the script command. This estimate is a measure of\r\nrelative confidence, i.e. it is only meaningful by comparison between the estimates for\r\nall resonances found. If the value of the error estimate for a resonance stands out as\r\nsignificantly larger than the rest, there is a higher chance that it is a spurious\r\nresonance.\r\n\r\nImportant notes:\r\n\r\n- The signal to analyze should start only after all sources have stopped injecting\r\n  energy into the system. When the rising part of the signal is not removed,\r\n  findresonances may report spurious resonances and, in particular, wrong Q-factors.\r\n- The longer the provided signal, the more accurate the reported modes will be. However,\r\n  the Q-factors are much more sensitive to this than the resonance frequencies. It is\r\n  often possible to obtain very accurate frequency information from only a few\r\n  oscillation periods, while accurate Q-factors require significantly more data.\r\n- To reliably find modes, they must be excited with sufficient energy in the simulation.\r\n  It is important to make sure the excitation bandwidth is comparable to or larger than\r\n  the frequency window \\\\( [f\\_{\\\\text{min}}, f\\_{\\\\text{max}}] \\\\).\r\n- Results are more reliable near the center of the frequency interval \\\\(\r\n  [f\\_{\\\\text{min}}, f\\_{\\\\text{max}}] \\\\). When scanning large frequency intervals, it\r\n  can be useful to run findresonances with multiple overlapping frequency windows.\r\n- Exciting a small frequency range helps to reduce the noise in the calculation.\r\n  Therefore, for a careful analysis of a resonance with known frequency, excite the\r\n  system with a narrow band pulse centered at the resonant frequency.\r\n- This script command cannot find reliably resonances with very low Q-factor (\\\\(Q\r\n  \\\\lesssim 10\\\\)). Especially when there are modes with both high and low Q-factors,\r\n  then the low-Q resonance will not be very accurate.\r\n\r\n### References:\r\n\r\n[1] V. A. Mandelshtam and H. S. Taylor, \"Harmonic inversion of time signals and its\r\napplication,\" J. Chem. Phys., vol. 107, no. 17, p. 6756-6769 (1997).\r\n\r\n| **Syntax**                                              | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = findresonances(time, signal, frequency_interval); | Returns the resonance parameters extracted from the signal vs. time data. The result _out_ is a Nx6 real-valued matrix, where N is the number of resonances found within the range specified by frequency_interval. If no resonances are found, the matrix out will be empty. The 6 columns of _out_ correspond to: **[frequency, decay_constant, Q_factor, amplitude, phase, error_estimate]** The inputs time and signal must be one-dimensional arrays; time must be real-valued, while signal can be real- or complex-valued. The input frequency_interval is a real-valued array with two entries \\\\( [f\\_{\\\\text{min}}, f\\_{\\\\text{max}}] \\\\) bounding the frequency range for the search. |\r\n\r\n**Example**\r\n\r\nThe following example shows how to extract the resonances from a superposition of two\r\ndecaying sinusoidal signals. We sample the same signal over time intervals of different\r\nduration and show that the results are the same. For this simple analytical signal only\r\na few oscillation periods are required to get accurate values for all the resonant\r\nparameters. In practice, more complicated signals (for example, a signal from a time\r\nmonitor in a FDTD simulation) might require more oscillation periods, especially for\r\naccurate decay or Q-factor values, as explained above in Important notes. Finally, note\r\nthat the error estimates for the two resonances are roughly within the same order of\r\nmagnitude, so their reliability is comparable.\r\n\r\n```\r\n# Resonant frequencies, decay constants, amplitudes and phases of the analytical signal:\r\nf1 = 1.765;\r\nalpha1 = 0.005;\r\nampl1=1.3;\r\nphase1 = 0.4;\r\nf2 = 2.345;\r\nalpha2 = 0.012;\r\nampl2= 0.45;\r\nphase2 = 1.234;\r\n# Time intervals of the signal:\r\nt_long = linspace(0,20,201);\r\nt_short = t_long(1:20);\r\n# Signal:\r\nsignal_long = ampl1*cos(2*pi*f1*t_long - phase1)*exp(-alpha1*t_long) + ampl2*cos(2*pi*f2*t_long - phase2)*exp(-alpha2*t_long);\r\nsignal_short = ampl1*cos(2*pi*f1*t_short - phase1)*exp(-alpha1*t_short) + ampl2*cos(2*pi*f2*t_short - phase2)*exp(-alpha2*t_short);\r\n# Find resonances:\r\nres_long = findresonances(t_long, signal_long, [1.5,3]);\r\nres_short = findresonances(t_short, signal_short, [1.5,3]);\r\n# Plot signal and show results:\r\nplotxy(t_long, signal_long, t_short, signal_short, \"time\", \"signal\");\r\nlegend(\"long signal\", \"short signal\");\r\n?\"***Long signal***\";\r\n?\"Resonant frequencies: \" + num2str(transpose(res_long(:,1)));\r\n?\"Decay constant:       \" + num2str(transpose(res_long(:,2)));\r\n?\"Q-factor:             \" + num2str(transpose(res_long(:,3)));\r\n?\"Amplitude:            \" + num2str(transpose(res_long(:,4)));\r\n?\"Phase:                \" + num2str(transpose(res_long(:,5)));\r\n?\"Error estimate:       \" + num2str(transpose(res_long(:,6)));\r\n?\"***Short signal***\";\r\n?\"Resonant frequencies: \" + num2str(transpose(res_short(:,1)));\r\n?\"Decay constant:       \" + num2str(transpose(res_short(:,2)));\r\n?\"Q-factor:             \" + num2str(transpose(res_short(:,3)));\r\n?\"Amplitude:            \" + num2str(transpose(res_short(:,4)));\r\n?\"Phase:                \" + num2str(transpose(res_short(:,5)));\r\n?\"Error estimate:       \" + num2str(transpose(res_short(:,6)));\r\nresult: \r\n***Long signal***\r\nResonant frequencies: 1.765 2.345\r\nDecay constant:       0.005 0.012\r\nQ-factor:             1108.98 613.92\r\nAmplitude:            1.3 0.45\r\nPhase:                0.4 1.234\r\nError estimate:       1.02591e-015 1.07493e-015\r\n***Short signal***\r\nResonant frequencies: 1.765 2.345\r\nDecay constant:       0.005 0.012\r\nQ-factor:             1108.98 613.92\r\nAmplitude:            1.3 0.45\r\nPhase:                0.4 1.234\r\nError estimate:       3.13843e-016 1.64344e-015\r\n```",
    "summary": "Returns the frequency, decay constant, Q-factor, amplitude and phase of resonances extracted from th...",
    "syntax": [
      {
        "syntax": "out = findresonances(time, signal, frequency_interval);",
        "description": "Returns the resonance parameters extracted from the signal vs. time data. The result _out_ is a Nx6 real-valued matrix, where N is the number of resonances found within the range specified by frequency_interval. If no resonances are found, the matrix out will be empty. The 6 columns of _out_ correspond to: [frequency, decay_constant, Q_factor, amplitude, phase, error_estimate] The inputs time and signal must be one-dimensional arrays; time must be real-valued, while signal can be real- or complex-valued. The input frequency_interval is a real-valued array with two entries \\\\( [f\\_{\\\\text{min}}, f\\_{\\\\text{max}}] \\\\) bounding the frequency range for the search."
      }
    ],
    "example": "# Resonant frequencies, decay constants, amplitudes and phases of the analytical signal:\r\nf1 = 1.765;\r\nalpha1 = 0.005;\r\nampl1=1.3;\r\nphase1 = 0.4;\r\nf2 = 2.345;\r\nalpha2 = 0.012;\r\nampl2= 0.45;\r\nphase2 = 1.234;\r\n# Time intervals of the signal:\r\nt_long = linspace(0,20,201);\r\nt_short = t_long(1:20);\r\n# Signal:\r\nsignal_long = ampl1*cos(2*pi*f1*t_long - phase1)*exp(-alpha1*t_long) + ampl2*cos(2*pi*f2*t_long - phase2)*exp(-alpha2*t_long);\r\nsignal_short = ampl1*cos(2*pi*f1*t_short - phase1)*exp(-alpha1*t_short) + ampl2*cos(2*pi*f2*t_short - phase2)*exp(-alpha2*t_short);\r\n# Find resonances:\r\nres_long = findresonances(t_long, signal_long, [1.5,3]);\r\nres_short = findresonances(t_short, signal_short, [1.5,3]);\r\n# Plot signal and show results:\r\nplotxy(t_long, signal_long, t_short, signal_short, \"time\", \"signal\");\r\nlegend(\"long signal\", \"short signal\");\r\n?\"***Long signal***\";\r\n?\"Resonant frequencies: \" + num2str(transpose(res_long(:,1)));\r\n?\"Decay constant:       \" + num2str(transpose(res_long(:,2)));\r\n?\"Q-factor:             \" + num2str(transpose(res_long(:,3)));\r\n?\"Amplitude:            \" + num2str(transpose(res_long(:,4)));\r\n?\"Phase:                \" + num2str(transpose(res_long(:,5)));\r\n?\"Error estimate:       \" + num2str(transpose(res_long(:,6)));\r\n?\"***Short signal***\";\r\n?\"Resonant frequencies: \" + num2str(transpose(res_short(:,1)));\r\n?\"Decay constant:       \" + num2str(transpose(res_short(:,2)));\r\n?\"Q-factor:             \" + num2str(transpose(res_short(:,3)));\r\n?\"Amplitude:            \" + num2str(transpose(res_short(:,4)));\r\n?\"Phase:                \" + num2str(transpose(res_short(:,5)));\r\n?\"Error estimate:       \" + num2str(transpose(res_short(:,6)));\r\nresult: \r\n***Long signal***\r\nResonant frequencies: 1.765 2.345\r\nDecay constant:       0.005 0.012\r\nQ-factor:             1108.98 613.92\r\nAmplitude:            1.3 0.45\r\nPhase:                0.4 1.234\r\nError estimate:       1.02591e-015 1.07493e-015\r\n***Short signal***\r\nResonant frequencies: 1.765 2.345\r\nDecay constant:       0.005 0.012\r\nQ-factor:             1108.98 613.92\r\nAmplitude:            1.3 0.45\r\nPhase:                0.4 1.234\r\nError estimate:       3.13843e-016 1.64344e-015"
  },
  {
    "name": "findstring",
    "description": "Returns the position of a given substring in a string.",
    "usage": "findstring();",
    "category": "general",
    "markdown": "# findstring\r\n\r\nReturns the position of a given substring in a string.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                                  |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| pos = findstring(s,s1);    | Returns the position of the first instance substring s1 in s. If s1 is not found in s, it returns -1.                                            |\r\n| pos = findstring(s,s1,p0); | Returns the position of the first instance substring s1 in s, starting at position p0. If s1 is not found in s, starting from p0, it returns -1. |\r\n\r\n**Example**\r\n\r\nThese are some examples of how to find a substring in a string.\r\n\r\n```\r\n?findstring(\"test12test34\",\"test34\");\r\nresult: \r\n7\r\n?findstring(\"test12test34\",\"test\");\r\nresult: \r\n1\r\n?findstring(\"test12test34\",\"test\",4);\r\nresult: \r\n7\r\n?findstring(\"test12test34\",\"test\",8);\r\nresult: \r\n-1\r\n```",
    "summary": "Returns the position of a given substring in a string",
    "syntax": [
      {
        "syntax": "pos = findstring(s,s1);",
        "description": "Returns the position of the first instance substring s1 in s. If s1 is not found in s, it returns -1."
      },
      {
        "syntax": "pos = findstring(s,s1,p0);",
        "description": "Returns the position of the first instance substring s1 in s, starting at position p0. If s1 is not found in s, starting from p0, it returns -1."
      }
    ],
    "example": "?findstring(\"test12test34\",\"test34\");\r\nresult: \r\n7\r\n?findstring(\"test12test34\",\"test\");\r\nresult: \r\n1\r\n?findstring(\"test12test34\",\"test\",4);\r\nresult: \r\n7\r\n?findstring(\"test12test34\",\"test\",8);\r\nresult: \r\n-1"
  },
  {
    "name": "finite",
    "description": "Returns 1 (true) if a value is finite. Numbers such as NaN or #1.INF return 0 (false).",
    "usage": "finite();",
    "category": "general",
    "markdown": "# finite\r\n\r\nReturns 1 (true) if a value is finite. Numbers such as NaN or #1.INF return 0 (false).\r\n\r\n| **Syntax**       | **Description**                                                                                                         |\r\n| ---------------- | ----------------------------------------------------------------------------------------------------------------------- |\r\n| out = finite(x); | Returns a matrix of the same size as x. The values are 1 for values of x that are finite and 0 for values that are NaN. |\r\n\r\n**Example**\r\n\r\nThis example shows the different outputs of the finite function.\r\n\r\n```\r\n?finite([1/0, 2, -3.4]);\r\nresult: \r\n0  1  1   \r\n```",
    "summary": "Returns 1 (true) if a value is finite",
    "syntax": [
      {
        "syntax": "out = finite(x);",
        "description": "Returns a matrix of the same size as x. The values are 1 for values of x that are finite and 0 for values that are NaN."
      }
    ],
    "example": "?finite([1/0, 2, -3.4]);\r\nresult: \r\n0  1  1"
  },
  {
    "name": "fitnormpdf",
    "description": "Fits any real-valued data, y = f(x), where x is a real valued argument, with the normal (Gaussian) probability density function (PDF) defined as:",
    "usage": "fitnormpdf();",
    "category": "general",
    "markdown": "# fitnormpdf\r\n\r\nFits any real-valued data, y = f(x), where x is a real valued argument, with the normal\r\n(Gaussian) probability density function (PDF) defined as:\r\n\r\n$$ f(x)=\\\\frac{A}{\\\\sqrt{2\\\\pi \\\\sigma^{2}}}e^{-\\\\frac{(x-\\\\mu)^{2}}{2\\\\sigma^{2}}} $$\r\n\r\nwhere µ is the mean and σ is the standard deviation of the normal distribution and A is\r\na normalization factor.\r\n\r\n| **Syntax**                                                           | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| p = fitnormpdf(x, y)                                                 | Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| p = fitnormpdf(x, y, normalize)                                      | Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). **Optional argument:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\r\n| p = fitnormpdf(x, y, normalize, fit_threshold)                       | Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). **Optional arguments:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold.                                                                                                                                                                                                                                                                                                                      |\r\n| p = fitnormpdf(x, y, normalize, fit_threshold, max_iter)             | Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). **Optional arguments:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters.                                                                                                                |\r\n| p = fitnormpdf(x, y, normalize, fit_threshold, max_iter, report_fit) | Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). **Optional arguments:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters. report_fit = 0 (default) or 1. If set to 1, a report on the fit quality will be provided in the script prompt. |\r\n\r\n**Example**\r\n\r\nIn the following example, an experimentally measured 1D doping profile is fitted with\r\nnormal (Gaussian) probability density function using the fitnormpdf script command. The\r\nexample then plots the measured data and the fitted distribution on the same plot.\r\n\r\n```\r\nx = [0.00175681 ; 0.0225484 ; 0.0340938 ; 0.0620684 ; 0.0726683 ; 0.0992729 ; 0.125007 ; 0.148238 ; 0.169105 ; 0.200233 ; 0.225537];\r\ny = [2.58715e+020 ; 3.23242e+020 ; 3.70291e+020 ; 2.81076e+020 ; 1.97757e+020 ; 6.47495e+019 ; 1.09791e+019 ; 2.81586e+018 ; 7.95827e+017 ; 3.40914e+017 ; 1.53187e+017];\r\np = fitnormpdf(x,y,0,sqrt(2e-16),400,1);\r\nyfit = p(1)*normpdf(x, p(2), p(3));\r\nplot(x,yfit,\"x (um)\", \"N (1/cm3)\", \"normpdf\",\"log10y\");\r\nholdon;\r\nplot(x,y,\"xx\",\"yy\",\"title1\",\"log10y, plot points\");\r\nholdoff;\r\nlegend(\"fit\",\"measured\");\r\n```",
    "summary": "Fits any real-valued data, y = f(x), where x is a real valued argument, with the normal (Gaussian) p...",
    "syntax": [
      {
        "syntax": "p = fitnormpdf(x, y)",
        "description": "Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3)."
      },
      {
        "syntax": "p = fitnormpdf(x, y, normalize)",
        "description": "Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). Optional argument: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1)."
      },
      {
        "syntax": "p = fitnormpdf(x, y, normalize, fit_threshold)",
        "description": "Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). Optional arguments: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold."
      },
      {
        "syntax": "p = fitnormpdf(x, y, normalize, fit_threshold, max_iter)",
        "description": "Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). Optional arguments: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters."
      },
      {
        "syntax": "p = fitnormpdf(x, y, normalize, fit_threshold, max_iter, report_fit)",
        "description": "Fits the data, y = f(x), with the normal (Gaussian) probability density function (defined in the equation above) and returns the values for A = p(1), µ = p(2), and σ = p(3). Optional arguments: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters. report_fit = 0 (default) or 1. If set to 1, a report on the fit quality will be provided in the script prompt."
      }
    ],
    "example": "x = [0.00175681 ; 0.0225484 ; 0.0340938 ; 0.0620684 ; 0.0726683 ; 0.0992729 ; 0.125007 ; 0.148238 ; 0.169105 ; 0.200233 ; 0.225537];\r\ny = [2.58715e+020 ; 3.23242e+020 ; 3.70291e+020 ; 2.81076e+020 ; 1.97757e+020 ; 6.47495e+019 ; 1.09791e+019 ; 2.81586e+018 ; 7.95827e+017 ; 3.40914e+017 ; 1.53187e+017];\r\np = fitnormpdf(x,y,0,sqrt(2e-16),400,1);\r\nyfit = p(1)*normpdf(x, p(2), p(3));\r\nplot(x,yfit,\"x (um)\", \"N (1/cm3)\", \"normpdf\",\"log10y\");\r\nholdon;\r\nplot(x,y,\"xx\",\"yy\",\"title1\",\"log10y, plot points\");\r\nholdoff;\r\nlegend(\"fit\",\"measured\");"
  },
  {
    "name": "fitpearson4pdf",
    "description": "Fits any real-valued data, y = f(x), where x is a real valued argument, to the Pearson IV probability density function (PDF). The Pearson PDF is described by:",
    "usage": "fitpearson4pdf();",
    "category": "general",
    "markdown": "# fitpearson4pdf\r\n\r\nFits any real-valued data, y = f(x), where x is a real valued argument, to the Pearson\r\nIV probability density function (PDF). The Pearson PDF is described by:\r\n\r\n$$\r\n\\\\frac{1}{f(x)}\\\\frac{df}{dx}=\\\\frac{(x-\\\\lambda)+a\\_{0}}{b\\_{0}+b\\_{1}(x-\\\\lambda)+b\\_{2}(x-\\\\lambda)^{2}}\r\n$$\r\n\r\nIt is categorized as type IV when the discriminant b0 +b1 x+b2 x 2 has no real roots.\r\nThe Pearson IV PDF is typically defined in terms of the coefficients a0 ,b0 ,b1 and b2\r\nthat depend on the variance σ2 , skewness γ1 , and kurtosis β2 .\r\n\r\n| **Syntax**                                                           | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\r\n| -------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| p = fitpearson4pdf(x, y)                                             | Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| p = fitpearson4pdf(x, y, normalize)                                  | Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). **Optional argument:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum [p(1) = 1].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| p = fitpearson4pdf(x, y, normalize, fit_threshold)                   | Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). **Optional arguments:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum [p(1) = 1]. fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold.                                                                                                                                                                                                                                                                                                                   |\r\n| p = fitpearson4pdf(x, y, normalize, fit_threshold, max_iter)         | Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). **Optional arguments:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum [p(1) = 1]. fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters.                                                                                                             |\r\n| p = fitnormpdf(x, y, normalize, fit_threshold, max_iter, report_fit) | Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). **Optional arguments:** normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters. report_fit = 0 (default) or 1. If set to 1, a report on the fit quality will be provided in the script prompt. |\r\n\r\n**Example**\r\n\r\nIn the following example, an experimentally measured 1D doping profile is fitted with\r\nPearson IV probability density function using the fitpearson4pdf script command. The\r\nexample then plots the measured data and the fitted distribution on the same plot.\r\n\r\n```\r\nx = [0.00175681 ; 0.0225484 ; 0.0340938 ; 0.0620684 ; 0.0726683 ; 0.0992729 ; 0.125007 ; 0.148238 ; 0.169105 ; 0.200233 ; 0.225537];\r\ny = [2.58715e+020 ; 3.23242e+020 ; 3.70291e+020 ; 2.81076e+020 ; 1.97757e+020 ; 6.47495e+019 ; 1.09791e+019 ; 2.81586e+018 ; 7.95827e+017 ; 3.40914e+017 ; 1.53187e+017];\r\np = fitpearson4pdf(x,y,0,sqrt(1e-18),800,1);\r\nyfit = p(1) * pearson4pdf( x, p(2), p(3), p(4), p(5) );\r\nplot(x,yfit,\"x (um)\", \"N (1/cm3)\", \"pearson4pdf\",\"log10y\");\r\nholdon;\r\nplot(x,y,\"xx\",\"yy\",\"title1\",\"log10y, plot points\");\r\nholdoff;\r\nlegend(\"fit\",\"measured\");\r\n```",
    "summary": "Fits any real-valued data, y = f(x), where x is a real valued argument, to the Pearson IV probabilit...",
    "syntax": [
      {
        "syntax": "p = fitpearson4pdf(x, y)",
        "description": "Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1)."
      },
      {
        "syntax": "p = fitpearson4pdf(x, y, normalize)",
        "description": "Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). Optional argument: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum [p(1) = 1]."
      },
      {
        "syntax": "p = fitpearson4pdf(x, y, normalize, fit_threshold)",
        "description": "Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). Optional arguments: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum [p(1) = 1]. fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold."
      },
      {
        "syntax": "p = fitpearson4pdf(x, y, normalize, fit_threshold, max_iter)",
        "description": "Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). Optional arguments: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum [p(1) = 1]. fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters."
      },
      {
        "syntax": "p = fitnormpdf(x, y, normalize, fit_threshold, max_iter, report_fit)",
        "description": "Fits the data, y = f(x), with the Pearson IV probability density function (defined in the equations above) and returns the values for mean = p(2), variance = p(3), skewness = p(4), kurtosis = p(5), and a normalization factor = p(1). Optional arguments: normalize = 0 (default) or 1. If set to 1, the fit amplitude is relative to a distribution with a unit maximum (A = 1). fit_threshold = relative tolerance for the fitting convergence (default = 2e-8). Fitting will stop when the relative change in the parameters falls below this threshold. max_iter = maximum number of iteration during the fit (default = 400). The fitting will stop when the number of iteration reaches this value even if the fit_threshold is not met for all parameters. report_fit = 0 (default) or 1. If set to 1, a report on the fit quality will be provided in the script prompt."
      }
    ],
    "example": "x = [0.00175681 ; 0.0225484 ; 0.0340938 ; 0.0620684 ; 0.0726683 ; 0.0992729 ; 0.125007 ; 0.148238 ; 0.169105 ; 0.200233 ; 0.225537];\r\ny = [2.58715e+020 ; 3.23242e+020 ; 3.70291e+020 ; 2.81076e+020 ; 1.97757e+020 ; 6.47495e+019 ; 1.09791e+019 ; 2.81586e+018 ; 7.95827e+017 ; 3.40914e+017 ; 1.53187e+017];\r\np = fitpearson4pdf(x,y,0,sqrt(1e-18),800,1);\r\nyfit = p(1) * pearson4pdf( x, p(2), p(3), p(4), p(5) );\r\nplot(x,yfit,\"x (um)\", \"N (1/cm3)\", \"pearson4pdf\",\"log10y\");\r\nholdon;\r\nplot(x,y,\"xx\",\"yy\",\"title1\",\"log10y, plot points\");\r\nholdoff;\r\nlegend(\"fit\",\"measured\");"
  },
  {
    "name": "flip",
    "description": "Flips (reverses the order of) a matrix along a given dimension.",
    "usage": "flip();",
    "category": "general",
    "markdown": "# flip\r\n\r\nFlips (reverses the order of) a matrix along a given dimension.\r\n\r\n| **Syntax**        | **Description**                             |\r\n| ----------------- | ------------------------------------------- |\r\n| C = flip(A, dim); | Flips the matrix A along the dimension dim. |\r\n\r\n**Example**\r\n\r\nReverse the order of rows and columns of a 2x3 matrix.\r\n\r\n```\r\n?A=[1,2,3;4,5,6];\r\n?B=flip(A,1); # flip (reverse) order of rows\r\n?B=flip(A,2); # flip (reverse) order of columns \r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n4 5 6 \r\n1 2 3 \r\nresult: \r\n3 2 1 \r\n6 5 4 \r\n```",
    "summary": "Flips (reverses the order of) a matrix along a given dimension",
    "syntax": [
      {
        "syntax": "C = flip(A, dim);",
        "description": "Flips the matrix A along the dimension dim."
      }
    ],
    "example": "?A=[1,2,3;4,5,6];\r\n?B=flip(A,1); # flip (reverse) order of rows\r\n?B=flip(A,2); # flip (reverse) order of columns \r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n4 5 6 \r\n1 2 3 \r\nresult: \r\n3 2 1 \r\n6 5 4"
  },
  {
    "name": "flipelement",
    "description": "Flips element in the schematic editor.",
    "usage": "flipelement();",
    "category": "general",
    "markdown": "# flipelement\r\n\r\nFlips element in the schematic editor.\r\n\r\n| **Syntax**              | **Description**                        |\r\n| ----------------------- | -------------------------------------- |\r\n| flipelement(\"element\"); | Flips element in the schematic editor. |",
    "summary": "Flips element in the schematic editor",
    "syntax": [
      {
        "syntax": "flipelement(\"element\");",
        "description": "Flips element in the schematic editor."
      }
    ],
    "example": ""
  },
  {
    "name": "floor",
    "description": "Rounds the input to the nearest integer less than or equal to itself.",
    "usage": "floor();",
    "category": "general",
    "markdown": "# floor\r\n\r\nRounds the input to the nearest integer less than or equal to itself.\r\n\r\n| **Syntax**      | **Description**                                      |\r\n| --------------- | ---------------------------------------------------- |\r\n| out = floor(X); | Returns the nearest integer less than or equal to X. |\r\n\r\n**Example**\r\n\r\nFind the nearest integer greater than or equal to 1.41:\r\n\r\n```\r\n?floor(1.41);\r\nresult: \r\n1  \r\n```",
    "summary": "Rounds the input to the nearest integer less than or equal to itself",
    "syntax": [
      {
        "syntax": "out = floor(X);",
        "description": "Returns the nearest integer less than or equal to X."
      }
    ],
    "example": "?floor(1.41);\r\nresult: \r\n1"
  },
  {
    "name": "for",
    "description": "Starts a for loop to allow some operations to be repeated a number of times. A while loop can be implemented when using the three argument version of a for loop.",
    "usage": "for();",
    "category": "general",
    "markdown": "# for\r\n\r\nStarts a for loop to allow some operations to be repeated a number of times. A while\r\nloop can be implemented when using the three argument version of a for loop.\r\n\r\n| **Syntax**                           | **Description**                                                                                                       |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------- |\r\n| for(x=1:100) { ?x; }                 | Single argument for loop. The loop will be sequentially executed for each value of x.                                 |\r\n| for(x=1; x\\<= 100; x=x+1) { ?x; }    | Three argument for loop. x=1 at the start of the loop. The loop continues while x \\<=100 and sets x=x+1 at each pass. |\r\n| x=1; for(0; x\\<10; 0) { ?x; x=x+1; } | This is equivalent to a while loop that will execute while x\\<10.                                                     |\r\n\r\n**Examples**\r\n\r\nThis example shows a simple for loop where x takes the values 1, 3, 5, 7, 9.\r\n\r\n```\r\na=1:2:10;\r\nfor(x=a) { \r\n ?x; \r\n} \r\n```\r\n\r\nNested loops: This example shows a nested for loop.\r\n\r\n```\r\nfor(i=1:100) { \r\n for(j=1:100) { \r\n  x = i^2+j; \r\n  ?x; \r\n } \r\n} \r\n```\r\n\r\nThe following code will get the electric field data from each monitors in this\r\nsimulation file, then save that data in a series of Lumerical data files. To test this\r\nexample, download the associated simulation file, run the simulation, then run the\r\nfollowing script.\r\n\r\n```\r\nrun;\r\nmNames = splitstring(getresult,endl);\r\n \r\nfor (i=1:length(mNames)) {\r\n if (haveresult(mNames{i},\"E\")) {\r\n  E=getresult(mNames{i},\"E\");   # get a result from that monitor\r\n } else {\r\n  E = mNames{i} + \" did not contain the specified data.\";\r\n }\r\n savedata(mNames{i},E);     # save data to file\r\n}\r\n```\r\n\r\nWhile loops: There is no \"while\" command in the scripting language, but the \"for\"\r\ncommand can be used to implement a \"while\" command. The command for(0;\r\nconditional_expression; 0) {} is the same as while(conditional_expression) {}. The “0”\r\nstatements in the “for” loop do nothing and are just placeholders because the scripting\r\nlanguage expects an argument there.\r\n\r\n```\r\n# implementation of a while loop in languages that support while loops\r\nx=1;\r\nwhile(x<10) {\r\n  ?x;\r\n  x=x+1;\r\n}\r\n# equivalent implementation of a while loop in Lumerical script language\r\nx=1;\r\nfor(0; x<10; 0) {\r\n  ?x;\r\n  x=x+1;\r\n}\r\n```",
    "summary": "Starts a for loop to allow some operations to be repeated a number of times",
    "syntax": [
      {
        "syntax": "for(x=1:100) { ?x; }",
        "description": "Single argument for loop. The loop will be sequentially executed for each value of x."
      },
      {
        "syntax": "for(x=1; x\\<= 100; x=x+1) { ?x; }",
        "description": "Three argument for loop. x=1 at the start of the loop. The loop continues while x \\<=100 and sets x=x+1 at each pass."
      },
      {
        "syntax": "x=1; for(0; x\\<10; 0) { ?x; x=x+1; }",
        "description": "This is equivalent to a while loop that will execute while x\\<10."
      }
    ],
    "example": ""
  },
  {
    "name": "framerate",
    "description": "Orbits the perspective view and returns the framerate. This can be useful for estimating your graphics performance. If comparing the performance of two computers, be sure to use exactly the same simulation file.",
    "usage": "framerate();",
    "category": "general",
    "markdown": "# framerate\r\n\r\nOrbits the perspective view and returns the framerate. This can be useful for estimating\r\nyour graphics performance. If comparing the performance of two computers, be sure to use\r\nexactly the same simulation file.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                 |\r\n| --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| fr = framerate(num_frames, zoom); | num_frames - Number of frames to draw zoom - Zoom factor used in perspective view fr - number of frames / wall time required to complete orbit. |\r\n\r\n**Example**\r\n\r\n```\r\nframerate(1000,2);\r\n```",
    "summary": "Orbits the perspective view and returns the framerate",
    "syntax": [
      {
        "syntax": "fr = framerate(num_frames, zoom);",
        "description": "num_frames - Number of frames to draw zoom - Zoom factor used in perspective view fr - number of frames / wall time required to complete orbit."
      }
    ],
    "example": "framerate(1000,2);"
  },
  {
    "name": "frequencysweep",
    "description": "Performs a frequency sweep using the current settings within the frequency analysis tab. Produces a D-CARD called \"frequencysweep\" that contains dispersion, effective index, and other data for as a function of frequency.",
    "usage": "frequencysweep();",
    "category": "general",
    "markdown": "# frequencysweep\r\n\r\nPerforms a frequency sweep using the current settings within the frequency analysis tab.\r\nProduces a D-CARD called \"frequencysweep\" that contains dispersion, effective index, and\r\nother data for as a function of frequency.\r\n\r\nThe\r\n[selectmode](https://optics.ansys.com/hc/en-us/articles/360034405234-selectmode-Script-command)\r\ncommand can be used to select one or more modes to be used for the frequency sweep.\r\n\r\n| **Syntax**      | **Description**                                                                              |\r\n| --------------- | -------------------------------------------------------------------------------------------- |\r\n| frequencysweep; | Perform a frequency sweep with the current settings. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nTo perform a frequency sweep on the first mode and plot the dispersion:\r\n\r\n```\r\nswitchtolayout;  \r\n\r\nfindmodes;  \r\nselectmode(1);  \r\nsetanalysis(\"track selected mode\",1);  \r\nsetanalysis(\"detailed dispersion calculation\",1);  \r\n\r\nfrequencysweep;  \r\nD=getdata(\"frequencysweep\",\"D\");  \r\nf=getdata(\"frequencysweep\",\"f_D\");  \r\n\r\nplot(c/f*1e6,D*1e6,\"Wavelength (um)\", \"Dispersion (ps/nm/km)\");\r\n```\r\n\r\nTo perform a frequency sweep on the first three mode and plot the effective index\r\n\r\n```\r\nswitchtolayout;  \r\nfindmodes;  \r\nselectmode([1,2,3]);  \r\n  \r\nfrequencysweep;  \r\nneff_sweep = getdata(“FDE::data::frequencysweep”, “neff”);  \r\nfreq_sweep = getdata(“FDE::data::frequencysweep”, “f”);  \r\nlambda_sweep = c/freq_sweep;  \r\nplot(lambda_sweep*1e6,real(neff_sweep), “Wavelength(um)”, “Real Effective Index”);  \r\nlegend(“Mode 1”, “Mode 2”, “Mode 3”);\r\n```",
    "summary": "Performs a frequency sweep using the current settings within the frequency analysis tab",
    "syntax": [
      {
        "syntax": "frequencysweep;",
        "description": "Perform a frequency sweep with the current settings. This function does not return any data."
      }
    ],
    "example": "switchtolayout;  \r\n\r\nfindmodes;  \r\nselectmode(1);  \r\nsetanalysis(\"track selected mode\",1);  \r\nsetanalysis(\"detailed dispersion calculation\",1);  \r\n\r\nfrequencysweep;  \r\nD=getdata(\"frequencysweep\",\"D\");  \r\nf=getdata(\"frequencysweep\",\"f_D\");  \r\n\r\nplot(c/f*1e6,D*1e6,\"Wavelength (um)\", \"Dispersion (ps/nm/km)\");"
  },
  {
    "name": "gdsaddcircle",
    "description": "This function adds an approximation of a circle to a GDSII file stream. GDSII files do not support circles, so this is just a convenient function to create a polygon representation of a circle. Polygons can only be added in a GDSII cell, so this command can be called only if a cell has been created.",
    "usage": "gdsaddcircle();",
    "category": "general",
    "markdown": "# gdsaddcircle\r\n\r\nThis function adds an approximation of a circle to a GDSII file stream. GDSII files do\r\nnot support circles, so this is just a convenient function to create a polygon\r\nrepresentation of a circle. Polygons can only be added in a GDSII cell, so this command\r\ncan be called only if a cell has been created.\r\n\r\n| **Syntax**                         | **Description**                                                                                          |\r\n| ---------------------------------- | -------------------------------------------------------------------------------------------------------- |\r\n| gdsaddcircle(f, layer, x, y, r, n) | Adds an approximation of a circle on a layer with x-, y-coordinates, radius and number of polygon sides. |\r\n\r\n| **Parameter** | **Type**         | **Description**                                                                                                                                                                                                                                                             |\r\n| ------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f             | string           | a file handle that was previously opened with gdsopen.                                                                                                                                                                                                                      |\r\n| layer         | string or number | string: a string of the form \"layer:datatype\" (for example \"6:2\") can be used to define the layer number and datatype for this structure from the GDSII file to import. Layer and datatype are integers. number: defines the layer number and sets the datatype to be zero. |\r\n| x             | number           | x-coordinate of the center position in meters.                                                                                                                                                                                                                              |\r\n| y             | number           | y-coordinate of the center position in meters.                                                                                                                                                                                                                              |\r\n| r             | number           | radius of the circle in meters.                                                                                                                                                                                                                                             |\r\n| n             | number           | number of sides to use in the polygon approximation. It is 64 by default.                                                                                                                                                                                                   |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsopen](./gdsopen.md) page.",
    "summary": "This function adds an approximation of a circle to a GDSII file stream",
    "syntax": [
      {
        "syntax": "gdsaddcircle(f, layer, x, y, r, n)",
        "description": "Adds an approximation of a circle on a layer with x-, y-coordinates, radius and number of polygon sides."
      }
    ],
    "example": ""
  },
  {
    "name": "gdsaddpath",
    "description": "This function adds adds a segmented line path with a fixed width. It supports the options with the square corner style.",
    "usage": "gdsaddpath();",
    "category": "general",
    "markdown": "# gdsaddpath\r\n\r\nThis function adds adds a segmented line path with a fixed width. It supports the\r\noptions with the square corner style.\r\n\r\n| **Syntax**                                               | **Description**                                |\r\n| -------------------------------------------------------- | ---------------------------------------------- |\r\n| gdsaddpath(fileHandle, layer_datatype, width, vertices); | Adds a segmented line path with a fixed width. |\r\n\r\n| **Parameter**  | **Type** | **Description**                                                                                                                                    |\r\n| -------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| fileHandle     | string   | a file handle that was previously opened with gdsopen.                                                                                             |\r\n| layer_datatype | integer  | layer_datatype is the same as other gdsadd commands, either an integer layer, or an integer layer colon integer data type encoded as string 'x:y'. |\r\n| width          | number   | width is a floating number.                                                                                                                        |\r\n| vertices       | matrix   | 2 column matrix of floating point coordinates.                                                                                                     |\r\n\r\n## Example\r\n\r\nThis shows an example to export a path and text to GDSII format via script code\r\n\r\n```\r\nf=gdsopen(\"path_text.gds\", 1e-3, 1e-9);\r\ngdsbegincell(f, 'example');\r\ngdsaddpath(f, 1, 0.5e-6, [-1, 0; 1, 0]*1e-6);\r\ngdsaddpath(f, '1:10', 0.5e-6, [-0.9, 0; -1.1, 0]*1e-6);\r\ngdsaddpath(f, '1:10', 0.5e-6, [0.9, 0; 1.1, 0]*1e-6);\r\ngdsaddtext(f, 10, -1e-6, 0, 'this is a pin');\r\ngdsendcell(f);\r\ngdsclose(f);\r\n```",
    "summary": "This function adds adds a segmented line path with a fixed width",
    "syntax": [
      {
        "syntax": "gdsaddpath(fileHandle, layer_datatype, width, vertices);",
        "description": "Adds a segmented line path with a fixed width."
      }
    ],
    "example": ""
  },
  {
    "name": "gdsaddpoly",
    "description": "This function adds a polygon element to a GDSII file stream. Polygons are also known as boundary elements in GDS terminology. This command can be called only if a cell has been created.The maximum number of vertices that can be added in a single polygon is 8190 due to [limitations](https://www.artwork.com/gdsii/max_vertex.htm) in the maximum number of vertices in a gdsii boundary. You can only use this command if a gds cell has already been created, for example, using [gdsbegincell](https://optics.ansys.com/hc/en-us/articles/360034927133-gdsbegincell-Script-command).",
    "usage": "gdsaddpoly();",
    "category": "general",
    "markdown": "# gdsaddpoly\r\n\r\nThis function adds a polygon element to a GDSII file stream. Polygons are also known as\r\nboundary elements in GDS terminology. This command can be called only if a cell has been\r\ncreated.The maximum number of vertices that can be added in a single polygon is 8190 due\r\nto [limitations](https://www.artwork.com/gdsii/max_vertex.htm) in the maximum number of\r\nvertices in a gdsii boundary. You can only use this command if a gds cell has already\r\nbeen created, for example, using\r\n[gdsbegincell](https://optics.ansys.com/hc/en-us/articles/360034927133-gdsbegincell-Script-command).\r\n\r\nFor complex geometries requiring more vertices, use\r\n[gdsaddstencil](https://optics.ansys.com/hc/en-us/articles/43594268925459-gdsaddstencil-Script-command).\r\n\r\n| **Syntax**                       | **Description**                                  |\r\n| -------------------------------- | ------------------------------------------------ |\r\n| gdsaddpoly(f, layer, [vertices]) | Adds a polygon element on a layer with vertices. |\r\n\r\n| **Parameter** | **Type**         | **Description**                                                                                                                                                                                                                                                             |\r\n| ------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f             | string           | A file handle that was previously opened with [gdsopen](https://optics.ansys.com/hc/en-us/articles/360034927093-gdsopen-Script-command).                                                                                                                                    |\r\n| layer         | string or number | String: a string of the form \"layer:datatype\" (for example \"6:2\") can be used to define the layer number and datatype for this structure from the GDSII file to import. Layer and datatype are integers. Number: defines the layer number and sets the datatype to be zero. |\r\n| vertices      | matrix           | Vertices of the polygon, in a Nx2 matrix where the first column represents x and the second column represents y, e.g., [x1,y1; x2,y2;...xn,yn]. The values are in meters. The first and last values should not be the same, the polygon will be automatically closed.       |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsopen](./gdsopen.md) page.",
    "summary": "This function adds a polygon element to a GDSII file stream",
    "syntax": [
      {
        "syntax": "gdsaddpoly(f, layer, [vertices])",
        "description": "Adds a polygon element on a layer with vertices."
      }
    ],
    "example": ""
  },
  {
    "name": "gdsaddrect",
    "description": "This function adds a rectangle element to a GDSII file stream. This is just a convenient function to create a polygon for the case of a rectangle. Other element type for rectangle (such as, box) is not supported at this moment. Polygons can only be added in a GDSII cell, so this command can be called only if a cell has been created.",
    "usage": "gdsaddrect();",
    "category": "general",
    "markdown": "# gdsaddrect\r\n\r\nThis function adds a rectangle element to a GDSII file stream. This is just a convenient\r\nfunction to create a polygon for the case of a rectangle. Other element type for\r\nrectangle (such as, box) is not supported at this moment. Polygons can only be added in\r\na GDSII cell, so this command can be called only if a cell has been created.\r\n\r\n| **Syntax**                                | **Description**                                                               |\r\n| ----------------------------------------- | ----------------------------------------------------------------------------- |\r\n| gdsaddrect(f, layer, x, y, width, height) | Adds a rectangle element on a layer with x-, y-coordinates, width and height. |\r\n\r\n| **Parameter** | **Type**         | **Description**                                                                                                                                                                                                                                                             |\r\n| ------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f             | string           | a file handle that was previously opened with gdsopen.                                                                                                                                                                                                                      |\r\n| layer         | string or number | string: a string of the form \"layer:datatype\" (for example \"6:2\") can be used to define the layer number and datatype for this structure from the GDSII file to import. Layer and datatype are integers. number: defines the layer number and sets the datatype to be zero. |\r\n| x             | number           | x-coordinate of the center position in meters.                                                                                                                                                                                                                              |\r\n| y             | number           | y-coordinate of the center position in meters.                                                                                                                                                                                                                              |\r\n| width         | number           | width of the rectangle in meters.                                                                                                                                                                                                                                           |\r\n| height        | number           | height of the rectangle in meters.                                                                                                                                                                                                                                          |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsopen](./gdsopen.md) page.",
    "summary": "This function adds a rectangle element to a GDSII file stream",
    "syntax": [
      {
        "syntax": "gdsaddrect(f, layer, x, y, width, height)",
        "description": "Adds a rectangle element on a layer with x-, y-coordinates, width and height."
      }
    ],
    "example": ""
  },
  {
    "name": "gdsaddref",
    "description": "This function adds a reference to another cell to the current cell in the GDSII file stream. This function replicates the referenced cell (has to be previously opened and finished) to the current cell and creates a nested hierarchy. The layer numbers of the replicated structures follow the referenced cell. References can only be added in a GDSII cell, so this command can be called only if a current cell has been created, for example, using [gdsbegincell](https://optics.ansys.com/hc/en-us/articles/360034927133-gdsbegincell-Script-command). In addition, the cell to be replicated has to exist before it is referenced.",
    "usage": "gdsaddref();",
    "category": "general",
    "markdown": "# gdsaddref\r\n\r\nThis function adds a reference to another cell to the current cell in the GDSII file\r\nstream. This function replicates the referenced cell (has to be previously opened and\r\nfinished) to the current cell and creates a nested hierarchy. The layer numbers of the\r\nreplicated structures follow the referenced cell. References can only be added in a\r\nGDSII cell, so this command can be called only if a current cell has been created, for\r\nexample, using\r\n[gdsbegincell](https://optics.ansys.com/hc/en-us/articles/360034927133-gdsbegincell-Script-command).\r\nIn addition, the cell to be replicated has to exist before it is referenced.\r\n\r\n| **Syntax**                                     | **Description**                                                                                        |\r\n| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| gdsaddref(f, \"cellname\", dx, dy, angle_in_deg) | Adds a reference to another cell (\"cellname\") to the current cell, with a specified move of dx and dy. |\r\n\r\n| **Parameter** | **Type** | **Description**                                                                                                                                                                                                                             |\r\n| ------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f             | string   | A file handle that was previously opened with gdsopen.                                                                                                                                                                                      |\r\n| cellname      | string   | Name of the referenced cell.                                                                                                                                                                                                                |\r\n| dx            | number   | X-movement of the replicated cell in the current cell.                                                                                                                                                                                      |\r\n| dy            | number   | Y-movement of the replicated cell in the current cell.                                                                                                                                                                                      |\r\n| angle_in_deg  | number   | Optional, angle of rotation in degrees of the replicated cell. For this operation, the **replicated** cell is rotated with respect to **its** **own** origin, and that cell is placed at the coordinates specified by parameters dx and dy. |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsopen](./gdsopen.md) page.",
    "summary": "This function adds a reference to another cell to the current cell in the GDSII file stream",
    "syntax": [
      {
        "syntax": "gdsaddref(f, \"cellname\", dx, dy, angle_in_deg)",
        "description": "Adds a reference to another cell (\"cellname\") to the current cell, with a specified move of dx and dy."
      }
    ],
    "example": ""
  },
  {
    "name": "gdsaddstencil",
    "description": "Adds one or more polygon elements to the current gds cell based on a slice formed by the intersection of a given z-plane and structures with a specific material and a partial name. Multiple polygons are created when there are more than 8190 vertices. You can only use this command if a gds cell has already been created, for example, using [gdsbegincell](https://optics.ansys.com/hc/en-us/articles/360034927133-gdsbegincell-Script-command).",
    "usage": "gdsaddstencil();",
    "category": "general",
    "markdown": "# gdsaddstencil\r\n\r\nAdds one or more polygon elements to the current gds cell based on a slice formed by the\r\nintersection of a given z-plane and structures with a specific material and a partial\r\nname. Multiple polygons are created when there are more than 8190 vertices. You can only\r\nuse this command if a gds cell has already been created, for example, using\r\n[gdsbegincell](https://optics.ansys.com/hc/en-us/articles/360034927133-gdsbegincell-Script-command).\r\n\r\nIf the material is “<Object defined dielectric>\", the index value must be provided.\r\n\r\nThis command will always ignore disabled geometry.\r\n\r\n| **Syntax**                                                                      | **Description**                                                                                                              |\r\n| ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| gdsaddstencil(f, layer, {\"material\": mat_name,                                  |                                                                                                                              |\r\n| \"partialname\": partial_name, \"z\": z, \"curve_chord_tol\": tol, \"dx\": dx, \"dy\": dy |                                                                                                                              |\r\n| });                                                                             | Adds one or more polygon elements based on the intersection of a z-plane and structures. The parameters are explained below. |\r\n\r\n| **Parameter**   | **Type**         | **Description**                                                                                                                                                                                                                                                             |\r\n| --------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f               | string           | A file handle that was previously opened with [gdsopen](https://optics.ansys.com/hc/en-us/articles/360034927093-gdsopen-Script-command).                                                                                                                                    |\r\n| layer           | string or number | String: a string of the form \"layer:datatype\" (for example \"6:2\") can be used to define the layer number and datatype for this structure from the GDSII file to import. Layer and datatype are integers. Number: defines the layer number and sets the datatype to be zero. |\r\n| mat_name        | string           | Material name for intersection. The command creates polygon(s) only for materials with this name.                                                                                                                                                                           |\r\n| partialname     | string           | Partial name of object for intersection. The command creates polygon(s) only for objects in the object tree that has this string as a part of its name.                                                                                                                     |\r\n| z               | number           | The z-plane to create the intersection on. Only a scalar value is accepted.                                                                                                                                                                                                 |\r\n| curve_chord_tol | number           | Optional with a default of 0. The maximum chordal distance between a facet edge and its original edge entity.                                                                                                                                                               |\r\n| dx              | number           | Optional with a default of 0. Position within the slice to be used as the origin of the gds coordinates.                                                                                                                                                                    |\r\n| dy              | number           | Optional with a default of 0. Position within the slice to be used as the origin of the gds coordinates.                                                                                                                                                                    |",
    "summary": "Adds one or more polygon elements to the current gds cell based on a slice formed by the intersectio...",
    "syntax": [
      {
        "syntax": "});",
        "description": "Adds one or more polygon elements based on the intersection of a z-plane and structures. The parameters are explained below."
      }
    ],
    "example": ""
  },
  {
    "name": "gdsaddtext",
    "description": "This function adds a text notation to a gds file at a specified position. This is usually just done on a notes layer for annotations. It supports text at a vertex position.",
    "usage": "gdsaddtext();",
    "category": "general",
    "markdown": "# gdsaddtext\r\n\r\nThis function adds a text notation to a gds file at a specified position. This is\r\nusually just done on a notes layer for annotations. It supports text at a vertex\r\nposition.\r\n\r\n| **Syntax**                                 | **Description**                                             |\r\n| ------------------------------------------ | ----------------------------------------------------------- |\r\n| gdsaddtext(fileHandle, layer, x, y, text); | Adds a text notation to a gds file at a specified position. |\r\n\r\n| **Parameter** | **Type** | **Description**                                                                          |\r\n| ------------- | -------- | ---------------------------------------------------------------------------------------- |\r\n| fileHandle    | string   | a file handle that was previously opened with gdsopen                                    |\r\n| layer         | integer  | layer must be an integer                                                                 |\r\n| x,y           | number   | x, y are floating point coordinates where text is placed (lower left corner of text box) |\r\n| text          | string   | text is an ascii string that forms the note body                                         |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsaddpath](./gdsaddpath.md) page.",
    "summary": "This function adds a text notation to a gds file at a specified position",
    "syntax": [
      {
        "syntax": "gdsaddtext(fileHandle, layer, x, y, text);",
        "description": "Adds a text notation to a gds file at a specified position."
      }
    ],
    "example": ""
  },
  {
    "name": "gdsbegincell",
    "description": "This function creates a cell in a GDSII file. All GDS elements (polygons, boxes, references, array references, etc) must be placed inside a cell, so this function must be called before adding any elements. When finished adding elements, gdsendcell can be called to finish the cell. Cells cannot be nested, so after calling gdsbegincell, a new cell cannot be called again until the first called cell has been closed. Although the GDSII file is a flat list of cells, cells can reference other cells, thus creating a nested hierarchy. See [gdsaddref](./gdsaddref.md) for more details. A GDS \"cell\" exists as a \"structure group\" when imported to FDTD, see [gdsimport](./gdsimport.md) for more details.",
    "usage": "gdsbegincell();",
    "category": "general",
    "markdown": "# gdsbegincell\r\n\r\nThis function creates a cell in a GDSII file. All GDS elements (polygons, boxes,\r\nreferences, array references, etc) must be placed inside a cell, so this function must\r\nbe called before adding any elements. When finished adding elements, gdsendcell can be\r\ncalled to finish the cell. Cells cannot be nested, so after calling gdsbegincell, a new\r\ncell cannot be called again until the first called cell has been closed. Although the\r\nGDSII file is a flat list of cells, cells can reference other cells, thus creating a\r\nnested hierarchy. See [gdsaddref](./gdsaddref.md) for more details. A GDS \"cell\" exists\r\nas a \"structure group\" when imported to FDTD, see [gdsimport](./gdsimport.md) for more\r\ndetails.\r\n\r\n| **Syntax**                  | **Description**                     |\r\n| --------------------------- | ----------------------------------- |\r\n| gdsbegincell(f, \"cellname\") | Creates a new cell in a GDSII file. |\r\n| **Parameter**               | **Type**                            |\r\n| ---                         | ---                                 |\r\n| f                           | string                              |\r\n| cellname                    | string                              |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsopen](./gdsopen.md) page.\r\n\r\nNote: Just to clarify, a GDS cell is different from a [Cell Array](./cell.md) in FDTD.",
    "summary": "This function creates a cell in a GDSII file",
    "syntax": [
      {
        "syntax": "gdsbegincell(f, \"cellname\")",
        "description": "Creates a new cell in a GDSII file."
      },
      {
        "syntax": "Parameter",
        "description": "Type"
      },
      {
        "syntax": "---",
        "description": "---"
      },
      {
        "syntax": "f",
        "description": "string"
      },
      {
        "syntax": "cellname",
        "description": "string"
      }
    ],
    "example": ""
  },
  {
    "name": "gdsclose",
    "description": "This function closes a GDSII file for writing. Before calling this command, a .gds file has to be previously opened, see [gdsopen](./gdsopen.md).",
    "usage": "gdsclose();",
    "category": "general",
    "markdown": "# gdsclose\r\n\r\nThis function closes a GDSII file for writing. Before calling this command, a .gds file\r\nhas to be previously opened, see [gdsopen](./gdsopen.md).\r\n\r\n| **Syntax**           | **Description**                                      |\r\n| -------------------- | ---------------------------------------------------- |\r\n| gdsclose(\"filename\") | closes a .gds file in the current working directory. |\r\n| **Parameter**        | **Type**                                             |\r\n| ---                  | ---                                                  |\r\n| filename             | string                                               |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsopen](./gdsopen.md) page.",
    "summary": "This function closes a GDSII file for writing",
    "syntax": [
      {
        "syntax": "gdsclose(\"filename\")",
        "description": "closes a .gds file in the current working directory."
      },
      {
        "syntax": "Parameter",
        "description": "Type"
      },
      {
        "syntax": "---",
        "description": "---"
      },
      {
        "syntax": "filename",
        "description": "string"
      }
    ],
    "example": ""
  },
  {
    "name": "gdsendcell",
    "description": "This function finishes a cell in a GDSII file. This function ends the current cell in the GDSII file stream. The command gdsbegincell has to be called before closing a cell.",
    "usage": "gdsendcell();",
    "category": "general",
    "markdown": "# gdsendcell\r\n\r\nThis function finishes a cell in a GDSII file. This function ends the current cell in\r\nthe GDSII file stream. The command gdsbegincell has to be called before closing a cell.\r\n\r\n| **Syntax**    | **Description**                                       |\r\n| ------------- | ----------------------------------------------------- |\r\n| gdsendcell(f) | Finishes the previously created cell in a GDSII file. |\r\n| **Parameter** | **Type**                                              |\r\n| ---           | ---                                                   |\r\n| f             | string                                                |\r\n\r\n## Example\r\n\r\nAn example of script code is available on the [gdsopen](./gdsopen.md) page.",
    "summary": "This function finishes a cell in a GDSII file",
    "syntax": [
      {
        "syntax": "gdsendcell(f)",
        "description": "Finishes the previously created cell in a GDSII file."
      },
      {
        "syntax": "Parameter",
        "description": "Type"
      },
      {
        "syntax": "---",
        "description": "---"
      },
      {
        "syntax": "f",
        "description": "string"
      }
    ],
    "example": ""
  },
  {
    "name": "gdsimport",
    "description": "This command imports a cell from a .gds file into the layout environment. This is equivalent to performing a GDSII import through the FILE->IMPORT menu. See the Layout editor reference guide on [ GDSII import ](https://optics.ansys.com/hc/en-us/articles/360034901933-Import-and-export-GDSII) for more information.",
    "usage": "gdsimport();",
    "category": "general",
    "markdown": "# gdsimport\r\n\r\nThis command imports a cell from a .gds file into the layout environment. This is\r\nequivalent to performing a GDSII import through the FILE->IMPORT menu. See the Layout\r\neditor reference guide on\r\n[ GDSII import ](https://optics.ansys.com/hc/en-us/articles/360034901933-Import-and-export-GDSII)\r\nfor more information.\r\n\r\n| **Syntax**                                                            | **Description**                                                                                                                                                                                                                                                                                                                                                                         |\r\n| --------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| n = gdsimport(\"filename\", \"cellname\", layer);                         | Imports the specified layer from the specified cell in the specified file into the current simulation environment. The objects created will have their material set to an object defined dielectric. In 3D, the 2D geometric data will be extruded to default values in the Z dimension. The optional returned value, n, is the number of objects that were imported from the gds file. |\r\n| n = gdsimport(\"filename\", \"cellname\", layer, \"material\");             | Same as the above command, but the material of the imported object will be set to the value specified.                                                                                                                                                                                                                                                                                  |\r\n| n = gdsimport(\"filename\", \"cellname\", layer, \"material\", zmin, zmax); | This form of the command is only allowed in 3D layouts. The behavior is the same as the above command, but the structures will be extruded in the Z dimension to the specified z min and z max values                                                                                                                                                                                   |\r\n\r\n| **Parameter** | **Type**         | **Description**                                                                                                                                                                                                                    |\r\n| ------------- | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| filename      | string           | name of the GDSII file to import. It can contain a complete path to file, or path relative to the current working directory.                                                                                                       |\r\n| cellname      | string           | name of the cell to import from the GDSII file.                                                                                                                                                                                    |\r\n| layer         | number or string | the layer number from the GDSII file to import. If only elements matching a certain data type are desired, this can be specified by using a string of the form: \"6:2\" where the desired layer is 6 and the desired data type is 2. |\r\n| material      | string           | a valid name of a material in your current layout environment. Partial names of materials can be matched starting at the beginning of the string. For example, \"Al (3\" would match \"Al (300nm)\".                                   |\r\n| zmin          | number           | the minimum z value for extruding 2D GDSII data into 3D objects                                                                                                                                                                    |\r\n| zmax          | number           | the maximum z value for extruding 2D GDSII data into 3D objects                                                                                                                                                                    |\r\n\r\n## Example:\r\n\r\nThis command imports \"cell_1\", on the first layer in the GDS_export.gds file, with a\r\nspecified material, z min and z max assigned. For more examples, please visit the Layout\r\neditor reference guide on\r\n[ GDSII import ](https://optics.ansys.com/hc/en-us/articles/360034901933-Import-and-export-GDSII)\r\n.\r\n\r\n```\r\ngdsimport(\"GDS_export.gds\", \"cell_1\", 1, \"Ag (Silver) - CRC\", 0, 1e-6);\r\n```",
    "summary": "This command imports a cell from a ",
    "syntax": [
      {
        "syntax": "n = gdsimport(\"filename\", \"cellname\", layer);",
        "description": "Imports the specified layer from the specified cell in the specified file into the current simulation environment. The objects created will have their material set to an object defined dielectric. In 3D, the 2D geometric data will be extruded to default values in the Z dimension. The optional returned value, n, is the number of objects that were imported from the gds file."
      },
      {
        "syntax": "n = gdsimport(\"filename\", \"cellname\", layer, \"material\");",
        "description": "Same as the above command, but the material of the imported object will be set to the value specified."
      },
      {
        "syntax": "n = gdsimport(\"filename\", \"cellname\", layer, \"material\", zmin, zmax);",
        "description": "This form of the command is only allowed in 3D layouts. The behavior is the same as the above command, but the structures will be extruded in the Z dimension to the specified z min and z max values"
      }
    ],
    "example": ""
  },
  {
    "name": "gdsopen",
    "description": "This function creates a new .gds file and returns a file handle that can be used with the other GdsWriter functions to write the file. The default database units are in 0.1nm and the user units are microns. The GDSII export function works as a group of commands, shown below as an example. For more information, please see [GDSII - Import and export ](https://optics.ansys.com/hc/en-us/articles/360034901933-Import-and-export-GDSII) . All gds commands will check that the ratio coordinates/dataBaseUnit does not have a magnitude larger than \\\\( 2^{31} \\\\).",
    "usage": "gdsopen();",
    "category": "general",
    "markdown": "# gdsopen\r\n\r\nThis function creates a new .gds file and returns a file handle that can be used with\r\nthe other GdsWriter functions to write the file. The default database units are in 0.1nm\r\nand the user units are microns. The GDSII export function works as a group of commands,\r\nshown below as an example. For more information, please see\r\n[GDSII - Import and export ](https://optics.ansys.com/hc/en-us/articles/360034901933-Import-and-export-GDSII)\r\n. All gds commands will check that the ratio coordinates/dataBaseUnit does not have a\r\nmagnitude larger than \\\\( 2^{31} \\\\).\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                           |\r\n| --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f = gdsopen(\"filename\", \"userUnit\", \"dataBaseUnit\") | Opens a .gds file in the current directory, specifies the size of user units and size of the GDSII file units. f is a file handle to open the GDSII file. |\r\n\r\n| **Parameter** | **Type** | **Description**                                                 |\r\n| ------------- | -------- | --------------------------------------------------------------- |\r\n| filename      | string   | Name of the GDSII file to export, may also contain a file path. |\r\n| userUnit      | number   | Size of user units in GDSII file units.                         |\r\n| databaseUnit  | number   | Size of the GDSII file units in meters.                         |\r\n\r\n## Example\r\n\r\nThis shows an example to export some simple structures to GDSII format via script code\r\n\r\n```\r\nf=gdsopen('GDS_export.gds'); \r\n# create a .gds file to write code. If the file exits, it will be overwritten.\r\ngdsbegincell(f,'cell_1');# create a cell named \"cell_1\"\r\ngdsaddcircle(f, 5, 0, 0, 1.5e-6);# add a circle\r\ngdsendcell(f);# finish \"cell_1\"\r\ngdsbegincell(f,'cell_2');# create another cell\r\ngdsaddpoly(f, 5, [0,0; 1.5,0; 1.2,1.3]*1e-6);# add a polygon \r\ngdsaddcircle(f, 5, -3e-6, -3e-6, 1.5e-6);# add a circle \r\ngdsaddrect(f, 5, -3e-6, 3e-6, 1e-6, 2e-6);# add a rectangle \r\ngdsaddref(f, 'cell_1', 3e-6, -3e-6);\r\n# reference a structure from \"cell_1\"\r\ngdsendcell(f);# finish the current cell\r\ngdsclose(f);# close the current .gds file\r\ngdsimport('GDS_export.gds','cell_1', 5);\r\n# show the exported design in a layout environment\r\n```\r\n\r\nAn example of script code is available on the webpage.",
    "summary": "This function creates a new ",
    "syntax": [
      {
        "syntax": "f = gdsopen(\"filename\", \"userUnit\", \"dataBaseUnit\")",
        "description": "Opens a .gds file in the current directory, specifies the size of user units and size of the GDSII file units. f is a file handle to open the GDSII file."
      }
    ],
    "example": ""
  },
  {
    "name": "get",
    "description": "Gets a property from selected objects. The property names for the get command are the same as the property names in the Edit dialogue box. For example, if you see a property called \"mesh accuracy\", then you can use the command get(\"mesh accuracy\"); to get that property. It is possible to get numeric, string, drop down and checkbox properties.",
    "usage": "get();",
    "category": "general",
    "markdown": "# get\r\n\r\nGets a property from selected objects. The property names for the get command are the\r\nsame as the property names in the Edit dialogue box. For example, if you see a property\r\ncalled \"mesh accuracy\", then you can use the command get(\"mesh accuracy\"); to get that\r\nproperty. It is possible to get numeric, string, drop down and checkbox properties.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| ?get;                         | Returns a list of the properties of the selected object(s).                                                                                                                                                                                                                                                                                                                                                                                                                    |\r\n| out = get(\"property\");        | Gets the requested property value from the currently selected object. It cannot be used to get the property value of a selected object in a group. If multiple objects are selected get(\"property\") is the same as get(\"property\",i), where i is the number of the first selected objects with the requested property. Out can be a matrix or a string, depending on the property requested. \"Property\" accepts struct format which allows user to obtain multiple attributes. |\r\n| get(\"property\",i);            | Gets the property of the ith selected object. Use this to act on a series of objects. It cannot be used to get the value of a selected object in a group. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree.                                                                                                                                            |\r\n| get(cell_array_of_properties) | Get the specific properties of the selected object as a struct (key-value pairs). The input is a cell array.                                                                                                                                                                                                                                                                                                                                                                   |\r\n\r\n**Examples**\r\n\r\nSee the list of the properties of a rectangle.\r\n\r\n```\r\naddrect;\r\n?get;\r\nalpha\r\ncolor opacity\r\ndetail\r\nenabled\r\n  ⋮\r\nz\r\nz max\r\nz min\r\nz span\r\n```\r\n\r\nGet the x span of an object named substrate.\r\n\r\n```\r\nselect(\"substrate\");\r\nx_span = get(\"x span\"); \r\n```\r\n\r\nAdd 2 microns to the radius of all selected objects that have a radius property.\r\n\r\n```\r\nselect(\"circle\");\r\nfor (i=1:getnumber) {\r\n rad=get(\"radius\",i);\r\n set(\"radius\",rad+2e-6,i);\r\n}\r\n```\r\n\r\nSet and get the vertices of a pentagon with a circumradius of 1um.\r\n\r\n```\r\naddpoly;\r\ntheta=linspace(0,2*pi*4/5,5);\r\nx=cos(theta)*1e-6;\r\ny=sin(theta)*1e-6;\r\nV=[x,y];\r\nset(\"vertices\",V);\r\n?get(\"vertices\");\r\nresult: \r\n1e-06 0   \r\n3.09017e-07 9.51057e-07   \r\n-8.09017e-07 5.87785e-07   \r\n-8.09017e-07 -5.87785e-07   \r\n3.09017e-07 -9.51057e-07 \r\n```\r\n\r\nGet the properties of a circle as a struct\r\n\r\n```\r\naddcircle;  \r\n  \r\n# Get specific properties of the selected object as a struct  \r\nPropStruct = get({\"x\",\"y\",\"z\",\"radius\"});  \r\n?PropStruct;  \r\nStruct with fields:  \r\nradius  \r\nx  \r\ny  \r\nz  \r\n  \r\n?PropStruct.radius;  \r\nresult:   \r\n1.8e-07   \r\n  \r\n# Get all the properties of the selected object as a struct  \r\nAllProps = get; # saved as a string  \r\nAllProps = splitstring(AllProps, endl); # convert to a cell array  \r\nPropStruct = get(AllProps);  \r\n  \r\n# Here's a single-line equivalent of the above three-line code   \r\nPropStruct = get(splitstring(get,endl));\r\n```",
    "summary": "Gets a property from selected objects",
    "syntax": [
      {
        "syntax": "?get;",
        "description": "Returns a list of the properties of the selected object(s)."
      },
      {
        "syntax": "out = get(\"property\");",
        "description": "Gets the requested property value from the currently selected object. It cannot be used to get the property value of a selected object in a group. If multiple objects are selected get(\"property\") is the same as get(\"property\",i), where i is the number of the first selected objects with the requested property. Out can be a matrix or a string, depending on the property requested. \"Property\" accepts struct format which allows user to obtain multiple attributes."
      },
      {
        "syntax": "get(\"property\",i);",
        "description": "Gets the property of the ith selected object. Use this to act on a series of objects. It cannot be used to get the value of a selected object in a group. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree."
      },
      {
        "syntax": "get(cell_array_of_properties)",
        "description": "Get the specific properties of the selected object as a struct (key-value pairs). The input is a cell array."
      }
    ],
    "example": ""
  },
  {
    "name": "getactivesolver",
    "description": "Gets the active solver. This could be the FDE, varFDTD, or EME solvers in MODE.",
    "usage": "getactivesolver();",
    "category": "general",
    "markdown": "# getactivesolver\r\n\r\nGets the active solver. This could be the FDE, varFDTD, or EME solvers in MODE.\r\n\r\n| **Syntax**        | **Description**         |\r\n| ----------------- | ----------------------- |\r\n| ?getactivesolver; | List the active solver. |\r\n\r\n**Example**\r\n\r\nWhen \"EME\" solver is already added, the following script will give the result:\r\n\r\n```\r\nsetactivesolver(\"EME\");\r\n?getactivesolver;\r\nEME\r\n```",
    "summary": "Gets the active solver",
    "syntax": [
      {
        "syntax": "?getactivesolver;",
        "description": "List the active solver."
      }
    ],
    "example": "setactivesolver(\"EME\");\r\n?getactivesolver;\r\nEME"
  },
  {
    "name": "getanalysis",
    "description": "Lists the parameters used in MODE' FDE and Finite Element IDE analysis window.",
    "usage": "getanalysis();",
    "category": "general",
    "markdown": "# getanalysis\r\n\r\nLists the parameters used in MODE' FDE and Finite Element IDE analysis window.\r\n\r\n| **Syntax**               | **Description**                                                              |\r\n| ------------------------ | ---------------------------------------------------------------------------- |\r\n| ?getanalysis;            | Lists all the parameters in the analysis window.                             |\r\n| getanalysis(\"property\"); | Returns the current value for the particular property on the analysis window |",
    "summary": "Lists the parameters used in MODE' FDE and Finite Element IDE analysis window",
    "syntax": [
      {
        "syntax": "?getanalysis;",
        "description": "Lists all the parameters in the analysis window."
      },
      {
        "syntax": "getanalysis(\"property\");",
        "description": "Returns the current value for the particular property on the analysis window"
      }
    ],
    "example": ""
  },
  {
    "name": "getattribute",
    "description": "Gets an attribute from an existing dataset.",
    "usage": "getattribute();",
    "category": "general",
    "markdown": "# getattribute\r\n\r\nGets an attribute from an existing dataset.\r\n\r\n| **Syntax**                       | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?getattribute(R);                | Returns the names of all the attributes in the dataset R.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| Attribute = R.getattribute(\"a\"); | Retrieves the attribute a from the existing dataset R. The result \"Attribute\" is a matrix in one of the forms below depending on the type of atrribute: vertex_scalar_attribute[npts; npar_1; npar_2; ...1] vertex_vector_attribute[npts; npar_1; npar_2; ...3] cell_scalar_attribute[ncells; 1] cell_vector_attribute[ncells; 3] \"npts\" is the number of vertices which is equal tothe length of geometric parameters 'x', 'y', 'z' \"ncells\" is the number of elements equal to number of rows of geometry parameter 'elements' |\r\n| Attribute = getparameter(R,\"a\"); | Retrieves the attribute a from the existing dataset R. The result \"Attribute\" is a matrix in one of the forms below depending on the type of atrribute: vertex_scalar_attribute[npts; npar_1; npar_2; ...1] vertex_vector_attribute[npts; npar_1; npar_2; ...3] cell_scalar_attribute[ncells; 1] cell_vector_attribute[ncells; 3] \"npts\" is the number of vertices which is equal tothe length of geometric parameters 'x', 'y', 'z' \"ncells\" is the number of elements equal to number of rows of geometry parameter 'elements' |\r\n\r\n**Examples**\r\n\r\nThis example retrieves the dataset results \"E\" from a profile monitor, and then uses the\r\n[ getparameter ](./getparameter.md) command to get the \"f\" parameter, and the\r\ngetattribute command to get the \"Ex\" and \"E2\" attributes from the dataset. Note that f,\r\nEx and E2 are all scalar matrices, like the results one would get with the\r\n[ getdata ](./getdata.md) command.\r\n\r\n```\r\nE = getresult(\"profile\",\"E\");\r\nf = E.getparameter(\"f\");  # the parameter f\r\nEx = E.getattribute(\"Ex\"); # the x component of the electric field\r\nE2 = E.getattribute(\"E2\"); # the electric field intensity, note that this only works if E is a vector\r\n```\r\n\r\nNote that one can also use the [ \".\" operator ](./dot_cmd.md) to retrieve the parameters\r\nand attributes directly. For example:\r\n\r\n```\r\nE = getresult(\"profile\",\"E\");\r\nf = E.f;  # the parameter f\r\nEx = E.Ex; # the x component of the electric field\r\nE2 = E.E2; # the electric field intensity, note that this only works if E is a vector\r\n```",
    "summary": "Gets an attribute from an existing dataset",
    "syntax": [
      {
        "syntax": "?getattribute(R);",
        "description": "Returns the names of all the attributes in the dataset R."
      },
      {
        "syntax": "Attribute = R.getattribute(\"a\");",
        "description": "Retrieves the attribute a from the existing dataset R. The result \"Attribute\" is a matrix in one of the forms below depending on the type of atrribute: vertex_scalar_attribute[npts; npar_1; npar_2; ...1] vertex_vector_attribute[npts; npar_1; npar_2; ...3] cell_scalar_attribute[ncells; 1] cell_vector_attribute[ncells; 3] \"npts\" is the number of vertices which is equal tothe length of geometric parameters 'x', 'y', 'z' \"ncells\" is the number of elements equal to number of rows of geometry parameter 'elements'"
      },
      {
        "syntax": "Attribute = getparameter(R,\"a\");",
        "description": "Retrieves the attribute a from the existing dataset R. The result \"Attribute\" is a matrix in one of the forms below depending on the type of atrribute: vertex_scalar_attribute[npts; npar_1; npar_2; ...1] vertex_vector_attribute[npts; npar_1; npar_2; ...3] cell_scalar_attribute[ncells; 1] cell_vector_attribute[ncells; 3] \"npts\" is the number of vertices which is equal tothe length of geometric parameters 'x', 'y', 'z' \"ncells\" is the number of elements equal to number of rows of geometry parameter 'elements'"
      }
    ],
    "example": ""
  },
  {
    "name": "getcelllist",
    "description": "Returns the list of cells associated with the gds file that has been loaded into a layer builder object. There needs to be a layer builder object selected, with a gds file loaded.",
    "usage": "getcelllist();",
    "category": "general",
    "markdown": "# getcelllist\r\n\r\nReturns the list of cells associated with the gds file that has been loaded into a layer\r\nbuilder object. There needs to be a layer builder object selected, with a gds file\r\nloaded.\r\n\r\n| **Syntax**   | **Description**                                                |\r\n| ------------ | -------------------------------------------------------------- |\r\n| getcelllist; | Returns the list of cells associated with the loaded gds file. |\r\n\r\n**Example**\r\n\r\nPlease\r\nrefer[ this example](https://optics.ansys.com/hc/en-us/articles/360034382394-Layer-builder).\r\nrun the script, and then type in\r\n\r\n```\r\n?getcelllist;\r\n\r\n\r\nCell array with 1 elements\r\n```",
    "summary": "Returns the list of cells associated with the gds file that has been loaded into a layer builder obj...",
    "syntax": [
      {
        "syntax": "getcelllist;",
        "description": "Returns the list of cells associated with the loaded gds file."
      }
    ],
    "example": "?getcelllist;\r\n\r\n\r\nCell array with 1 elements"
  },
  {
    "name": "getcommands",
    "description": "Returns the list of available script commands in the current script workspace.",
    "usage": "getcommands();",
    "category": "general",
    "markdown": "# getcommands\r\n\r\nReturns the list of available script commands in the current script workspace.\r\n\r\n| **Syntax**    | **Description**                             |\r\n| ------------- | ------------------------------------------- |\r\n| ?getcommands; | Returns a list of available script commands |\r\n\r\n**Examples**\r\n\r\nReturns the list of available script commands in the current script workspace.\r\n\r\n```\r\n?getcommands;\r\n+\r\n-\r\n*\r\n/\r\n^\r\n==\r\n!=\r\n=\r\n```",
    "summary": "Returns the list of available script commands in the current script workspace",
    "syntax": [
      {
        "syntax": "?getcommands;",
        "description": "Returns a list of available script commands"
      }
    ],
    "example": ""
  },
  {
    "name": "getdata",
    "description": "Get raw data from a simulation object. In most cases, it is more convenient to get a complete dataset with [ getresult](./getresult.md), rather than getting individual data elements with getdata.",
    "usage": "getdata();",
    "category": "general",
    "markdown": "# getdata\r\n\r\nGet raw data from a simulation object. In most cases, it is more convenient to get a\r\ncomplete dataset with [ getresult](./getresult.md), rather than getting individual data\r\nelements with getdata.\r\n\r\nRemember to run the simulation before using getdata.\r\n\r\nFor FDTD and MODE:\r\n\r\n| **Syntax**                             | **Description**                                       |\r\n| -------------------------------------- | ----------------------------------------------------- |\r\n| ?getdata;                              | Returns names of all objects with data.               |\r\n| ?getdata(\"monitor\")                    | Returns list of of data within the simulation object. |\r\n| out = getdata( \"monitor\", \"dataname\"); | Gets data from a monitor. For example, you can use    |\r\n\r\n- Ex = getdata(\"monitor1\",\"Ex\");\r\n\r\nto get the Ex field data from monitor1.\\\r\nout = getdata( \"monitor\", \"dataname\", option); | The optional argument, option, can have\r\na value of 1 or 2. If it is 2, the data is unfolded where possible according to the\r\nsymmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a\r\nboundary at x min, y min or z min. The default value of option is 2. For Propagator\r\nsimulations in MODE, this options also allow users to choose whether to expand the data\r\nto the correct size for dimensions where the field component is zero. Option 1 will\r\nreturn a singleton value of 0 for the field component in that dimension, and option 2\r\nwill return a matrix (composed of zeros) that matches the size of the other field\r\ncomponents.\r\n\r\nFor CHARGE, HEAT, DGTD, FEEM:\r\n\r\n| **Syntax**                                       | **Description**                                              |\r\n| ------------------------------------------------ | ------------------------------------------------------------ |\r\n| ?getdata;                                        | Returns names of all objects with data.                      |\r\n| ?getdata(\"monitor\")                              | Returns list of of results within the simulation object.     |\r\n| ?getdata( \"monitor\", \"result\");                  | Returns list of of data within the simulation object result. |\r\n| out = getdata( \"monitor\", \"result\", \"dataname\"); | Gets the simulation data.                                    |\r\n\r\nFor INTERCONNECT: The getdata command is available in INTERCONNECT for compatibility\r\nwith other Lumerical products, but it's best to use the getresult script function to\r\naccess INTERCONNECT simulation data.\r\n\r\n**Examples**\r\n\r\nThis example shows how to use getdata to check which data is available.\r\n\r\n```\r\n?getdata;\r\n?getdata(\"monitor\");\r\n> monitor\r\n> source\r\n> \r\n> x y z surface_normal dimension f Ex Ey Ez\r\n> Hx Hy Hz power \r\n```\r\n\r\nNext, we use getdata to create a image plot of Ex(x,y). We also show how getresult can\r\nbe used to create the same figure.\r\n\r\n```\r\n# get raw data with getdata\r\nx=getdata(\"monitor\",\"x\");\r\ny=getdata(\"monitor\",\"y\");\r\nz=getdata(\"monitor\",\"z\");\r\nf=getdata(\"monitor\",\"f\");\r\nEx=getdata(\"monitor\",\"Ex\");\r\n# select first frequency point of Ex data, then create plot\r\n?size(Ex);\r\nEx = pinch(Ex,4,1); \r\nimage(x*1e6,y*1e6,Ex,\"x (um)\",\"y (um)\",\"Ex\");\r\n# use getresult to get all of the E field data in a single command\r\nE=getresult(\"monitor\",\"E\");\r\n# select first frequency point of Ex data, then create plot\r\n?size(E.Ex);\r\nEx = pinch(E.Ex,4,1); # select first frequency point to plot\r\nimage(E.x*1e6,E.y*1e6,Ex,\"x (um)\",\"y (um)\",\"Ex\"); \r\n```\r\n\r\nGet a list of data in the 'Device region' object, then get the 'n' carrier concentration\r\ndata.\r\n\r\n```\r\n?getdata(\"Device region\");\r\n?getdata(\"Device region\",\"active\");\r\nn=getdata(\"Device region\",\"active\",\"n\");\r\n?size(n);\r\n> active drain source\r\n> n p Ei Ec Ev Efn Efp log10(N) mun mup \r\n> result: \r\n>  2826 1 9 1 \r\n```",
    "summary": "Get raw data from a simulation object",
    "syntax": [
      {
        "syntax": "?getdata;",
        "description": "Returns names of all objects with data."
      },
      {
        "syntax": "?getdata(\"monitor\")",
        "description": "Returns list of of data within the simulation object."
      },
      {
        "syntax": "out = getdata( \"monitor\", \"dataname\");",
        "description": "Gets data from a monitor. For example, you can use"
      }
    ],
    "example": ""
  },
  {
    "name": "getdevice",
    "description": "Returns the type of device used to run the simulation in the [FDTD Resource Selection Group](https://optics.ansys.com/hc/en-us/articles/36952912384403-Ansys-Lumerical-FDTD-Modern-User-Interface#run_simulation_group). This command can only be used if there is an FDTD simulation region present.",
    "usage": "getdevice();",
    "category": "general",
    "markdown": "# getdevice\r\n\r\nReturns the type of device used to run the simulation in the\r\n[FDTD Resource Selection Group](https://optics.ansys.com/hc/en-us/articles/36952912384403-Ansys-Lumerical-FDTD-Modern-User-Interface#run_simulation_group).\r\nThis command can only be used if there is an FDTD simulation region present.\r\n\r\n| **Syntax**     | **Description**                                                                                                        |\r\n| -------------- | ---------------------------------------------------------------------------------------------------------------------- |\r\n| out=getdevice; | Returns the currently selected type of device used to run the simulation. The returned value is either “CPU” or “GPU”. |",
    "summary": "Returns the type of device used to run the simulation in the [FDTD Resource Selection Group](https:/...",
    "syntax": [
      {
        "syntax": "out=getdevice;",
        "description": "Returns the currently selected type of device used to run the simulation. The returned value is either “CPU” or “GPU”."
      }
    ],
    "example": ""
  },
  {
    "name": "getdgtdindex",
    "description": "Returns the complex refractive index of a material in the Materials Group with material fit that will be used in a DGTD simulation.",
    "usage": "getdgtdindex();",
    "category": "general",
    "markdown": "# getdgtdindex\r\n\r\nReturns the complex refractive index of a material in the Materials Group with material\r\nfit that will be used in a DGTD simulation.\r\n\r\nMany materials (such as sampled materials) have properties that depend on frequency.\r\nUsing getdgtdindex, you can specify frequency range, and the fitting routine will find a\r\nbest fit of the material data over that range. The refractive index evaluated at the\r\nspecified frequencies is then returned.\r\n\r\nNote that the fit result depends on the fit parameters, Max coefficients and Tolerance\r\nset for the material, thus getdgtdindex result depends on those parameters as well. Tips\r\nfor setting these parameters can be found at\r\n[ Modifying the material fits ](https://optics.ansys.com/hc/en-us/articles/360034915053-Modifying-the-Material-Fits)\r\n.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                                                                                           |\r\n| --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getdgtdindex( \"materialname\", f, fmin, fmax); | Returns the complex index of the material with the given name. The index is returned for the specified frequency f. Similar to getindex, but you also specify fmin and fmax, the span of frequency of the DGTD simulation. All frequency units are in Hz. |\r\n\r\n**Examples**\r\n\r\nThis example shows how to get material (n,k) data with the getindex and getdgtdindex\r\nfunctions. In this case, we compare the experimental data to the DGTD fit of the that\r\ndata that will be used in the simulation.\r\n\r\nNote that the material \"Au (Gold) - CRC\" with optical material properties must already\r\nexist in the Materials Group before running the script.\r\n\r\n```\r\nmaterial=\"Au (Gold) - CRC\";   # material \r\nsource_min_f=c/700e-9;      # source min frequency\r\nsource_max_f=c/400e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\n# get experimental data\r\nn_exp=getindex(material,f_vector);\r\n# get DGTD fit of experimental data\r\nn_dgtd=getdgtdindex(material,f_vector,source_min_f,source_max_f);\r\n# plot results\r\nplot(c/f_vector*1e9,real(n_exp),real(n_dgtd),\"wavelenth (nm)\",\"n\",material);\r\nlegend(\"experimental data\",\"DGTD fit\");\r\nplot(c/f_vector*1e9,imag(n_exp),imag(n_dgtd),\"wavelenth (nm)\",\"k\",material);\r\nlegend(\"experimental data\",\"DGTD fit\");\r\n# output index data to text file\r\ndata=matrix(100,5);\r\ndata(1:100,1)=c/f_vector*1e9;\r\ndata(1:100,2)=real(n_exp);\r\ndata(1:100,3)=imag(n_exp);\r\ndata(1:100,4)=real(n_dgtd);\r\ndata(1:100,5)=imag(n_dgtd);\r\nwrite(material+\".txt\",\"wavelength_nm exp_n exp_k dgtd_n dgtd_k\");\r\nwrite(material+\".txt\",num2str(data));\r\n```",
    "summary": "Returns the complex refractive index of a material in the Materials Group with material fit that wil...",
    "syntax": [
      {
        "syntax": "out = getdgtdindex( \"materialname\", f, fmin, fmax);",
        "description": "Returns the complex index of the material with the given name. The index is returned for the specified frequency f. Similar to getindex, but you also specify fmin and fmax, the span of frequency of the DGTD simulation. All frequency units are in Hz."
      }
    ],
    "example": ""
  },
  {
    "name": "geteigensolver",
    "description": "Mode sources, mode expansion monitors, and ports in FDTD and MODE, and each individual cell in EME have embedded eigensolvers. This script command makes it possible to get the properties of that eigensolver without using the GUI.",
    "usage": "geteigensolver();",
    "category": "general",
    "markdown": "# geteigensolver\r\n\r\nMode sources, mode expansion monitors, and ports in FDTD and MODE, and each individual\r\ncell in EME have embedded eigensolvers. This script command makes it possible to get the\r\nproperties of that eigensolver without using the GUI.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                        |\r\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| ?geteigensolver;            | Returns a list of the properties of the embedded eigensolver                                                                                           |\r\n| geteigensolver(\"property\"); | This will get the eigensolver properties of the currently selected objects. The returned value may be a number or a string, depending on the property. |\r\n\r\n**Example**\r\n\r\nPlease open ring_resonator2.lms from the\r\n[ ring resonator example ](**%20to%20be%20defined%20**) and type in this command\r\n\r\n```\r\nselect(\"expansion\");\r\n?geteigensolver;\r\n```\r\n\r\nIt will give a list of the parameters of the eigensolver. Any parameters can be\r\nobtained, for example, type in\r\n\r\n```\r\n?geteigensolver(\"bend radius\");\r\nresult: \r\n1e-005  \r\n```\r\n\r\nWill give the bend radius of 10e-6 meter.\r\n\r\nAlso see the examples in the [ seteigensolver ](./seteigensolver.md) and\r\n[ addmodeexpansion ](./addmodeexpansion.md) script functions.",
    "summary": "Mode sources, mode expansion monitors, and ports in FDTD and MODE, and each individual cell in EME h...",
    "syntax": [
      {
        "syntax": "?geteigensolver;",
        "description": "Returns a list of the properties of the embedded eigensolver"
      },
      {
        "syntax": "geteigensolver(\"property\");",
        "description": "This will get the eigensolver properties of the currently selected objects. The returned value may be a number or a string, depending on the property."
      }
    ],
    "example": "select(\"expansion\");\r\n?geteigensolver;"
  },
  {
    "name": "getelectric",
    "description": "Returns the sum of the amplitude squares for all electric field components, i.e. it returns |Ex| 2 +|Ey| 2 +|Ez| 2 .",
    "usage": "getelectric();",
    "category": "general",
    "markdown": "# getelectric\r\n\r\nReturns the sum of the amplitude squares for all electric field components, i.e. it\r\nreturns |Ex| 2 +|Ey| 2 +|Ez| 2 .\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                                                                         |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getelectric( \"monitorname\");   | Returns                                                                                                                                                                                                                                                                                 |\r\n| getelectric( \"monitorname\", option); | The optional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n\r\n**Examples**\r\n\r\nThis example creates an image plot of |E|^2 for a z-normal frequency monitor in the x-y\r\nplane.\r\n\r\n```\r\nE2=getelectric(\"output\");\r\nx=getdata(\"output\",\"x\");\r\ny=getdata(\"output\",\"y\");\r\nimage(x,y,E2);\r\n```",
    "summary": "Returns the sum of the amplitude squares for all electric field components, i",
    "syntax": [
      {
        "syntax": "out = getelectric( \"monitorname\");",
        "description": "Returns"
      },
      {
        "syntax": "getelectric( \"monitorname\", option);",
        "description": "The optional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      }
    ],
    "example": ""
  },
  {
    "name": "getemeanalysis",
    "description": "Gets calculation parameters in MODE' EME analysis window.",
    "usage": "getemeanalysis();",
    "category": "general",
    "markdown": "# getemeanalysis\r\n\r\nGets calculation parameters in MODE' EME analysis window.\r\n\r\n| **Syntax**                  | **Description**                                                                             |\r\n| --------------------------- | ------------------------------------------------------------------------------------------- |\r\n| ?getemeanalysis;            | Lists all the parameters in the analysis window.                                            |\r\n| getemeanalysis(\"property\"); | Gets the value of the calculation parameter named \"property\" in EME solver analysis window. |\r\n\r\n**Examples**\r\n\r\nThis code will display the values of the \"group spans\" parameters from the EME setup\r\nsection of the EME analysis window.\r\n\r\n```\r\n# display the values of the group spans  \r\n?getemeanalysis(\"group spans\");\r\n```",
    "summary": "Gets calculation parameters in MODE' EME analysis window",
    "syntax": [
      {
        "syntax": "?getemeanalysis;",
        "description": "Lists all the parameters in the analysis window."
      },
      {
        "syntax": "getemeanalysis(\"property\");",
        "description": "Gets the value of the calculation parameter named \"property\" in EME solver analysis window."
      }
    ],
    "example": ""
  },
  {
    "name": "getemesweep",
    "description": "Gets the user s-matrix result from a propagation sweep, mode convergence sweep, or perturbative wavelength sweep.",
    "usage": "getemesweep();",
    "category": "general",
    "markdown": "# getemesweep\r\n\r\nGets the user s-matrix result from a propagation sweep, mode convergence sweep, or\r\nperturbative wavelength sweep.\r\n\r\n| **Syntax**                               | **Description**                                                                                    |\r\n| ---------------------------------------- | -------------------------------------------------------------------------------------------------- |\r\n| getemesweep(\"S\");                        | Gets the user s-matrix result from an EME propagation sweep named \"S\".                             |\r\n| getemesweep(\"S_mode_convergence_sweep\"); | Gets the user s-matrix result from an EME mode convergence sweep named \"S_mode_convergence_sweep\". |\r\n| getemesweep(\"S_wavelength_sweep\");       | Gets the user s-matrix result from an EME wavelength convergence sweep named \"S_wavelength_sweep\". |\r\n\r\n**Examples**\r\n\r\nThis code will set up, run and collect the user s-matrix result from the propagation\r\nsweep tool in Analysis mode. The result from the propagation sweep is packaged in a\r\ndataset called \"S\".\r\n\r\n```\r\n# set propagation sweep settings  \r\nsetemeanalysis(\"propagation sweep\",1);  \r\nsetemeanalysis(\"parameter\",\"group span 2\");  \r\nsetemeanalysis(\"start\",10e-6);  \r\nsetemeanalysis(\"stop\",200e-6);  \r\nsetemeanalysis(\"number of points\",10);  \r\n\r\n# run propagation sweep tool  \r\nemesweep;  \r\n\r\n# get propagation sweep result  \r\nS = getemesweep('S');  \r\n\r\n# plot S21 vs group span  \r\ns21 = S.s21;  \r\ngroup_span = S.group_span_2;  \r\nplot(group_span,abs(s21)^2);\r\n```\r\n\r\nThis code will set up, run and collect the user s-matrix result from the mode\r\nconvergence sweep tool in Analysis mode. The result from the mode convergence sweep is\r\npackaged in a dataset called \"S_mode_convergence_sweep\".\r\n\r\n```\r\n# set mode convergence sweep settings  \r\nstart_mode = 4; #set smaller number of modes for convergence test  \r\nmode_interval = 1; #set mode interval for convergence test  \r\nsetnamed(\"EME\",\"number of modes for all cell groups\",25);   \r\nsetemeanalysis(\"mode convergence sweep\", 1);  \r\nsetemeanalysis(\"start mode\", start_mode);  \r\nsetemeanalysis(\"mode interval\", mode_interval);  \r\n\r\n# run mode convergence sweep tool  \r\nemesweep(\"mode convergence sweep\");  \r\n\r\n# get mode convergence sweep result  \r\nS_mode = getemesweep(\"S_mode_convergence_sweep\");  \r\n\r\n# plot S21 vs number of modes  \r\ns21 = S_mode.s21;  \r\nmodes = S_mode.modes;  \r\nplot(modes, abs(s21)^2);\r\n```\r\n\r\nThis code will set up, run and collect the user s-matrix result from the perturbative\r\nwavelength convergence sweep tool in Analysis mode. The result from the wavelength\r\nconvergence sweep is packaged in a dataset called \"S_wavelength_sweep\".\r\n\r\n```\r\n# set wavelength convergence sweep settings  \r\nstart_lam = 1.5e-6; #set start wavelength [m]  \r\nend_lam = = 1.6e-6; #set end wavelength [m]  \r\nlam_res = 100; #set wavelength for convergence test  \r\nsetnamed(\"EME\",\"number of modes for all cell groups\",25);   \r\nsetemeanalysis(\"wavelength sweep\",1);  \r\nsetemeanalysis(\"start wavelength\",start_lam);   \r\nsetemeanalysis(\"stop wavelength\",end_lam);\r\nsetemeanalysis(\"number of wavelength points\",lam_res);\r\n  \r\n # run wavelength convergence sweep tool  \r\nemesweep(\"wavelength sweep\");  \r\n  \r\n # get mode convergence sweep result  \r\nS_lambda = getemesweep(\"S_wavelength_sweep\");  \r\n  \r\n# plot S21 vs number of wavelength  \r\ns21 = S_lambda.s21;  \r\nlambda = S_lambda.wavelength;  \r\nplot(lambda, abs(s21)^2);\r\n```",
    "summary": "Gets the user s-matrix result from a propagation sweep, mode convergence sweep, or perturbative wave...",
    "syntax": [
      {
        "syntax": "getemesweep(\"S\");",
        "description": "Gets the user s-matrix result from an EME propagation sweep named \"S\"."
      },
      {
        "syntax": "getemesweep(\"S_mode_convergence_sweep\");",
        "description": "Gets the user s-matrix result from an EME mode convergence sweep named \"S_mode_convergence_sweep\"."
      },
      {
        "syntax": "getemesweep(\"S_wavelength_sweep\");",
        "description": "Gets the user s-matrix result from an EME wavelength convergence sweep named \"S_wavelength_sweep\"."
      }
    ],
    "example": ""
  },
  {
    "name": "getfdtdindex",
    "description": "Returns the complex refractive index of a material in the database with material fit that will be used in a simulation in FDTD.",
    "usage": "getfdtdindex();",
    "category": "general",
    "markdown": "# getfdtdindex\r\n\r\nReturns the complex refractive index of a material in the database with material fit\r\nthat will be used in a simulation in FDTD.\r\n\r\nMany materials (such as Sampled materials) have properties that depend on frequency.\r\nUsing getfdtdindex, you can specify frequency range, and the fitting routine will find a\r\nbest fit of the material data over that range. The refractive index evaluated at the\r\nspecified frequencies is then returned.\r\n\r\nNote that the fit result depends on the fit parameters, Max coefficients and Tolerance\r\nset for the material, thus getfdtdindex result depends on those parameters as well. Tips\r\nfor setting these parameters can be found at\r\n[ Modifying the material fits ](https://optics.ansys.com/hc/en-us/articles/360034915053-Modifying-the-Material-Fits)\r\n.\r\n\r\n| **Syntax**                                             | **Description**                                                                                                                                                                                                                                           |\r\n| ------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getfdtdindex( \"materialname\", f, fmin, fmax);    | Returns the complex index of the material with the given name. The index is returned for the specified frequency f. Similar to getindex, but you also specify fmin and fmax, the span of frequency of the FDTD simulation. All frequency units are in Hz. |\r\n| getfdtdindex(\"materialname\", f,fmin, fmax, component); | Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1.                                                                                                                              |\r\n\r\n**Examples**\r\n\r\nThis example shows how to get material (n,k) data with the getindex and getfdtdindex\r\nfunctions. In this case, we compare the experimental data to the FDTD fit of the that\r\ndata that will be used in the simulation.\r\n\r\n```\r\nmaterial=\"Au (Gold) - CRC\";   # material \r\nsource_min_f=c/700e-9;      # source min frequency\r\nsource_max_f=c/400e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\n# get experimental data\r\nn_exp=getindex(material,f_vector);\r\n# get FDTD fit of experimental data\r\nn_fdtd=getfdtdindex(material,f_vector,source_min_f,source_max_f);\r\n# plot results\r\nplot(c/f_vector*1e9,real(n_exp),real(n_fdtd),\"wavelenth (nm)\",\"n\",material);\r\nlegend(\"experimental data\",\"FDTD fit\");\r\nplot(c/f_vector*1e9,imag(n_exp),imag(n_fdtd),\"wavelenth (nm)\",\"k\",material);\r\nlegend(\"experimental data\",\"FDTD fit\");\r\n# output index data to text file\r\ndata=matrix(100,5);\r\ndata(1:100,1)=c/f_vector*1e9;\r\ndata(1:100,2)=real(n_exp);\r\ndata(1:100,3)=imag(n_exp);\r\ndata(1:100,4)=real(n_fdtd);\r\ndata(1:100,5)=imag(n_fdtd);\r\nwrite(material+\".txt\",\"wavelength_nm exp_n exp_k fdtd_n fdtd_k\");\r\nwrite(material+\".txt\",num2str(data));\r\n```\r\n\r\nThis example shows how to get the permittivity of a material. The getfdtdindex and\r\ngetindex functions always return the material index, so we must apply eps = n^2 to get\r\nthe permittivity.\r\n\r\n```\r\nmaterial=\"Au (Gold) - CRC\";   # material \r\nsource_min_f=c/700e-9;      # source min frequency\r\nsource_max_f=c/400e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\n# get (n,k) data\r\nn_fdtd=getfdtdindex(material,f_vector,source_min_f,source_max_f);\r\n# get permittivity data\r\neps_fdtd=n_fdtd^2;    \r\n```",
    "summary": "Returns the complex refractive index of a material in the database with material fit that will be us...",
    "syntax": [
      {
        "syntax": "out = getfdtdindex( \"materialname\", f, fmin, fmax);",
        "description": "Returns the complex index of the material with the given name. The index is returned for the specified frequency f. Similar to getindex, but you also specify fmin and fmax, the span of frequency of the FDTD simulation. All frequency units are in Hz."
      },
      {
        "syntax": "getfdtdindex(\"materialname\", f,fmin, fmax, component);",
        "description": "Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1."
      }
    ],
    "example": ""
  },
  {
    "name": "getfdtdsurfaceconductivity",
    "description": "For materials which use a surface conductivity material model (such as Graphene), this function returns the surface conductivity of the material in the database as it will be used in an actual simulation. For a list of materials which use the surface conductivity model, see [ Material conductivity models ](https://optics.ansys.com/hc/en-us/articles/360034915113-Material-Conductivity-Models) .",
    "usage": "getfdtdsurfaceconductivity();",
    "category": "general",
    "markdown": "# getfdtdsurfaceconductivity\r\n\r\nFor materials which use a surface conductivity material model (such as Graphene), this\r\nfunction returns the surface conductivity of the material in the database as it will be\r\nused in an actual simulation. For a list of materials which use the surface conductivity\r\nmodel, see\r\n[ Material conductivity models ](https://optics.ansys.com/hc/en-us/articles/360034915113-Material-Conductivity-Models)\r\n.\r\n\r\nThe conductivity evaluated at the specified frequencies is returned. Note that the fit\r\nresult depends on the fit parameters, Max coefficients and Tolerance set for the\r\nmaterial, thus getfdtdsurfaceconductivity result depends on those parameters as well.\r\n\r\n| **Syntax**                                                           | **Description**                                                                                                                                                                                                                                                                                                |\r\n| -------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getfdtdsurfaceconductivity( \"materialname\", f, fmin, fmax);    | Returns the surface conductivity (in units of S) of the material with the given name. The surface conductivity is returned for the specified frequency f. Similar to getsurfaceconductivity, but you also specify fmin and fmax, the span of frequency range of the simulation. All frequency units are in Hz. |\r\n| getfdtdsurfaceconductivity(\"materialname\", f,fmin, fmax, component); | Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1.                                                                                                                                                                                   |",
    "summary": "For materials which use a surface conductivity material model (such as Graphene), this function retu...",
    "syntax": [
      {
        "syntax": "out = getfdtdsurfaceconductivity( \"materialname\", f, fmin, fmax);",
        "description": "Returns the surface conductivity (in units of S) of the material with the given name. The surface conductivity is returned for the specified frequency f. Similar to getsurfaceconductivity, but you also specify fmin and fmax, the span of frequency range of the simulation. All frequency units are in Hz."
      },
      {
        "syntax": "getfdtdsurfaceconductivity(\"materialname\", f,fmin, fmax, component);",
        "description": "Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1."
      }
    ],
    "example": ""
  },
  {
    "name": "getfield",
    "description": "The script command returns the value of a field from structure input.",
    "usage": "getfield();",
    "category": "general",
    "markdown": "# getfield\r\n\r\nThe script command returns the value of a field from structure input.\r\n\r\n| **Syntax**                     | **Description**                                        |\r\n| ------------------------------ | ------------------------------------------------------ |\r\n| value= getfield(input, field); | Returns the value of a ‘field’ from structure ‘input’. |\r\n\r\n### Example\r\n\r\n```\r\n>x=struct;\r\n>x.t=10;\r\n>?getfield(x,'t');\r\nresult: \r\n10 \r\n```",
    "summary": "The script command returns the value of a field from structure input",
    "syntax": [
      {
        "syntax": "value= getfield(input, field);",
        "description": "Returns the value of a ‘field’ from structure ‘input’."
      }
    ],
    "example": ""
  },
  {
    "name": "getglobalmonitor",
    "description": "Sets global monitor properties. This command will return an error in analysis mode.",
    "usage": "getglobalmonitor();",
    "category": "general",
    "markdown": "# getglobalmonitor\r\n\r\nSets global monitor properties. This command will return an error in analysis mode.\r\n\r\n| **Syntax**                     | **Description**                                 |\r\n| ------------------------------ | ----------------------------------------------- |\r\n| ?getglobalmonitor;             | Returns a list of the global monitor properties |\r\n| ?getglobalmonitor(\"property\"); | Returns the value of the requested property.    |\r\n\r\n**Example**\r\n\r\nSet the global number of monitored frequency points to 11, then confirm value was set\r\nproperly.\r\n\r\n```\r\nsetglobalmonitor(\"frequency points\",11);\r\n?getglobalmonitor(\"frequency points\");\r\nresult: \r\n11  \r\n```",
    "summary": "Sets global monitor properties",
    "syntax": [
      {
        "syntax": "?getglobalmonitor;",
        "description": "Returns a list of the global monitor properties"
      },
      {
        "syntax": "?getglobalmonitor(\"property\");",
        "description": "Returns the value of the requested property."
      }
    ],
    "example": "setglobalmonitor(\"frequency points\",11);\r\n?getglobalmonitor(\"frequency points\");\r\nresult: \r\n11"
  },
  {
    "name": "getglobalsource",
    "description": "Sets global monitor properties. This command will return an error in analysis mode.",
    "usage": "getglobalsource();",
    "category": "general",
    "markdown": "# getglobalsource\r\n\r\nSets global monitor properties. This command will return an error in analysis mode.\r\n\r\n| **Syntax**                   | **Description**                                |\r\n| ---------------------------- | ---------------------------------------------- |\r\n| getglobalsource;             | Returns a list of the global source properties |\r\n| getglobalsource(\"property\"); | Returns the value of the requested property.   |\r\n\r\n**Example**\r\n\r\nSet the global start wavelength to 400nm, then confirm value was set properly.\r\n\r\n```\r\nsetglobalsource(\"wavelength start\",400e-9);\r\n?getglobalsource(\"wavelength start\");\r\nresult: \r\n4e-007 \r\n```",
    "summary": "Sets global monitor properties",
    "syntax": [
      {
        "syntax": "getglobalsource;",
        "description": "Returns a list of the global source properties"
      },
      {
        "syntax": "getglobalsource(\"property\");",
        "description": "Returns the value of the requested property."
      }
    ],
    "example": "setglobalsource(\"wavelength start\",400e-9);\r\n?getglobalsource(\"wavelength start\");\r\nresult: \r\n4e-007"
  },
  {
    "name": "getindex",
    "description": "Returns the complex refractive index of a material in the material database. The refractive index at the specified frequency is linearly interpolated from the neighboring frequencies where the data is available.",
    "usage": "getindex();",
    "category": "general",
    "markdown": "# getindex\r\n\r\nReturns the complex refractive index of a material in the material database. The\r\nrefractive index at the specified frequency is linearly interpolated from the\r\nneighboring frequencies where the data is available.\r\n\r\n| **Syntax**                              | **Description**                                                                                                                           |\r\n| --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getindex(\"materialname\", f);      | Returns the complex index of the material with the given name. The index is returned for the specified frequency f. Frequency f is in Hz. |\r\n| getindex(\"materialname\", f, component); | Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1.              |\r\n\r\n**Example**\r\n\r\nThis example shows how to get material (n,k) data with the getindex and getfdtdindex\r\nfunctions. In this case, we compare the experimental data to the fit of the that data\r\nthat will be used in the simulation.\r\n\r\n```\r\nmaterial=\"Au (Gold) - CRC\";   # material \r\nsource_min_f=c/700e-9;      # source min frequency\r\nsource_max_f=c/400e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\n# get experimental data\r\nn_exp=getindex(material,f_vector);\r\n# get FDTD fit of experimental data\r\nn_fdtd=getfdtdindex(material,f_vector,source_min_f,source_max_f);\r\n# plot results\r\nplot(c/f_vector*1e9,real(n_exp),real(n_fdtd),\"wavelenth (nm)\",\"n\",material);\r\nlegend(\"experimental data\",\"FDTD fit\");\r\nplot(c/f_vector*1e9,imag(n_exp),imag(n_fdtd),\"wavelenth (nm)\",\"k\",material);\r\nlegend(\"experimental data\",\"FDTD fit\");\r\n# output index data to text file\r\ndata=matrix(100,5);\r\ndata(1:100,1)=c/f_vector*1e9;\r\ndata(1:100,2)=real(n_exp);\r\ndata(1:100,3)=imag(n_exp);\r\ndata(1:100,4)=real(n_fdtd);\r\ndata(1:100,5)=imag(n_fdtd);\r\nwrite(material+\".txt\",\"wavelength_nm exp_n exp_k fdtd_n fdtd_k\");\r\nwrite(material+\".txt\",num2str(data));\r\n```",
    "summary": "Returns the complex refractive index of a material in the material database",
    "syntax": [
      {
        "syntax": "out = getindex(\"materialname\", f);",
        "description": "Returns the complex index of the material with the given name. The index is returned for the specified frequency f. Frequency f is in Hz."
      },
      {
        "syntax": "getindex(\"materialname\", f, component);",
        "description": "Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1."
      }
    ],
    "example": "material=\"Au (Gold) - CRC\";   # material \r\nsource_min_f=c/700e-9;      # source min frequency\r\nsource_max_f=c/400e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\n# get experimental data\r\nn_exp=getindex(material,f_vector);\r\n# get FDTD fit of experimental data\r\nn_fdtd=getfdtdindex(material,f_vector,source_min_f,source_max_f);\r\n# plot results\r\nplot(c/f_vector*1e9,real(n_exp),real(n_fdtd),\"wavelenth (nm)\",\"n\",material);\r\nlegend(\"experimental data\",\"FDTD fit\");\r\nplot(c/f_vector*1e9,imag(n_exp),imag(n_fdtd),\"wavelenth (nm)\",\"k\",material);\r\nlegend(\"experimental data\",\"FDTD fit\");\r\n# output index data to text file\r\ndata=matrix(100,5);\r\ndata(1:100,1)=c/f_vector*1e9;\r\ndata(1:100,2)=real(n_exp);\r\ndata(1:100,3)=imag(n_exp);\r\ndata(1:100,4)=real(n_fdtd);\r\ndata(1:100,5)=imag(n_fdtd);\r\nwrite(material+\".txt\",\"wavelength_nm exp_n exp_k fdtd_n fdtd_k\");\r\nwrite(material+\".txt\",num2str(data));"
  },
  {
    "name": "getlayerlist",
    "description": "Returns the list of layers associated with the loaded gds file. There needs to be a layer builder object selected, with a gds file loaded.",
    "usage": "getlayerlist();",
    "category": "general",
    "markdown": "# getlayerlist\r\n\r\nReturns the list of layers associated with the loaded gds file. There needs to be a\r\nlayer builder object selected, with a gds file loaded.\r\n\r\n| **Syntax**    | **Description**                                                 |\r\n| ------------- | --------------------------------------------------------------- |\r\n| getlayerlist; | Returns the list of layers associated with the loaded gds file. |\r\n\r\n**Example**\r\n\r\nPlease\r\nrefer[ this example](https://optics.ansys.com/hc/en-us/articles/360034382394-Layer-builder).\r\nrun the script, and then type in\r\n\r\n```\r\n?getlayerlist;\r\n\r\n\r\nCell array with 4 elements\r\n```",
    "summary": "Returns the list of layers associated with the loaded gds file",
    "syntax": [
      {
        "syntax": "getlayerlist;",
        "description": "Returns the list of layers associated with the loaded gds file."
      }
    ],
    "example": "?getlayerlist;\r\n\r\n\r\nCell array with 4 elements"
  },
  {
    "name": "getlicenseestimate",
    "description": "Checks how many licenses is required to run a given resource and returns the result.",
    "usage": "getlicenseestimate();",
    "category": "general",
    "markdown": "# getlicenseestimate\r\n\r\nChecks how many licenses is required to run a given resource and returns the result.\r\n\r\n| **Syntax**                                      | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                 |\r\n| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getlicenseestimate(“solver”, “resource”); | Returns a structure outlining the feature license and amount of license required dictated by a given solver specified and the resource. The resource parameter should either be a string indicating the row number in the Resource Configuration window (starting at 1), or a string indicating the name of the resource. If duplicate names are present, the first one is returned. The output structures are specified below. |\r\n\r\nThe returned structure is specified below.\r\n\r\n| Field         | **Description**                                                                                                                                                                                                                                                                                                             |\r\n| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| feature       | The name of the license feature required as specified by the [List of licensed features by product.](https://optics.ansys.com/hc/en-us/articles/360052724713-List-of-licensed-features-by-product)                                                                                                                          |\r\n| sharedlicense | Only returned for standard licenses. Indicates whether the selected resource can use standard license sharing. The result is 0 if standard license sharing cannot be used, and 1 if it can be.                                                                                                                              |\r\n| single        | Indicates the required licenses for a single simulation ran on the selected resource as a string. For standard license, a number is returned indicating the number of the license feature required. For enterprise license, a string is returned indicating the number of Ansys HPC workgroup increments or packs required. |\r\n| sweep         | Indicates the required licenses for a parameter sweep ran on the selected resource as a string. For standard license, a number is returned indicating the number of the license feature required. For enterprise license, a string is returned indicating the number of Ansys HPC workgroup increments or packs required.   |\r\n| smcount       | Only returned for GPU resources. This field indicates number of streaming microprocessors **you have entered** for this resource. The number of SMs for your GPU can be obtained using [gpuspecs](https://optics.ansys.com/hc/en-us/articles/34669049884947-gpuspecs-Script-command).                                       |\r\n\r\n**Example**\r\n\r\nA FDTD resource named “Local Host” is setup as the first row in the resource\r\nconfiguration window, with standard license, and with processes = 16, threads =1, and\r\ncapacity =4.\r\n\r\n```\r\n#Obtain output structure  \r\nlic_struct=getlicenseestimate(\"FDTD\",\"1\");   \r\n?lic_struct.feature; #This returns lum_fdtd_solve, the FDTD license feature needed  \r\n?lic_struct.sharedlicense; #This returns 0, because there are more than 32 cores, and standard license sharing is only supported up to 32 cores.  \r\n?lic_struct.single; #This returns 1, because only 1 license is needed to run a single simulation of 16 cores.  \r\n?lic_struct.sweep; #This returns 4, because 4 concurrent simulations of 16 cores each requires 4 lum_fdtd_solve licenses.\r\n```\r\n\r\nA FDTD resource named “Local Host” is setup as the first row in the resource\r\nconfiguration window, with enterprise license, and with processes = 16, threads =1, and\r\ncapacity =4.\r\n\r\n```\r\nlic_struct=getlicenseestimate(\"FDTD\",\"Local Host\");   \r\n?lic_struct.feature; #This returns ‘1 lumerical_solve’, meaning that 1 lumerical_solve license feature is needed in addition to all other requirements.  \r\n?lic_struct.single; #This returns ‘12 anshpc OR 2 anshpc_pack’, matching the results on the Ansys HPC Licensing Calculator  \r\n?lic_struct.sweep; #This returns ‘72 anshpc OR 6 anshpc_pack’, matching the results on the Ansys HPC Licensing Calculator\r\n```",
    "summary": "Checks how many licenses is required to run a given resource and returns the result",
    "syntax": [
      {
        "syntax": "out = getlicenseestimate(“solver”, “resource”);",
        "description": "Returns a structure outlining the feature license and amount of license required dictated by a given solver specified and the resource. The resource parameter should either be a string indicating the row number in the Resource Configuration window (starting at 1), or a string indicating the name of the resource. If duplicate names are present, the first one is returned. The output structures are specified below."
      }
    ],
    "example": "#Obtain output structure  \r\nlic_struct=getlicenseestimate(\"FDTD\",\"1\");   \r\n?lic_struct.feature; #This returns lum_fdtd_solve, the FDTD license feature needed  \r\n?lic_struct.sharedlicense; #This returns 0, because there are more than 32 cores, and standard license sharing is only supported up to 32 cores.  \r\n?lic_struct.single; #This returns 1, because only 1 license is needed to run a single simulation of 16 cores.  \r\n?lic_struct.sweep; #This returns 4, because 4 concurrent simulations of 16 cores each requires 4 lum_fdtd_solve licenses."
  },
  {
    "name": "getlicenseestimateallactiveresources",
    "description": "Obtain the number of licenses needed to run a parameter sweep on all active resources.",
    "usage": "getlicenseestimateallactiveresources();",
    "category": "general",
    "markdown": "# getlicenseestimateallactiveresources\r\n\r\nObtain the number of licenses needed to run a parameter sweep on all active resources.\r\n\r\n| Syntax                                                                 | Description                                                                                                                                                                                   |\r\n| ---------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getlicenseestimateallactiveresources(“solver”, “resource_type”); | Returns a string indicating the number of licenses required to run parameter sweep on all active resources specified by the resource_type parameter. If none is specified, defaults to “CPU”: |\r\n\r\n- For FDTD, the parameter can either be “CPU” or “GPU”.\r\n- For all other solvers, the parameter can only be “CPU”.\r\n\r\n**Example**\r\n\r\nTwo FDTD CPU resources are set up with enterprise license. The first resource has\r\nprocess = 16, threads =1, and capacity =4. The second resource has process = 8, threads\r\n=1, and capacity = 3.\r\n\r\n```\r\n?getlicenseestimateallactiveresources(\"FDTD\",\"CPU\");   \r\n#Returns ‘1 lumerical_solve AND (104 anshpc OR 9 anshpc_pack),’ indicating the number of HPC packs needed to run parameter sweep on both resources.\r\n```",
    "summary": "Obtain the number of licenses needed to run a parameter sweep on all active resources",
    "syntax": [
      {
        "syntax": "out = getlicenseestimateallactiveresources(“solver”, “resource_type”);",
        "description": "Returns a string indicating the number of licenses required to run parameter sweep on all active resources specified by the resource_type parameter. If none is specified, defaults to “CPU”:"
      }
    ],
    "example": "?getlicenseestimateallactiveresources(\"FDTD\",\"CPU\");   \r\n#Returns ‘1 lumerical_solve AND (104 anshpc OR 9 anshpc_pack),’ indicating the number of HPC packs needed to run parameter sweep on both resources."
  },
  {
    "name": "getmagnetic",
    "description": "Returns the sum of the amplitude squares for all magnetic field components, i.e. it returns |Hx| 2 +|Hy| 2 +|Hz| 2 .",
    "usage": "getmagnetic();",
    "category": "general",
    "markdown": "# getmagnetic\r\n\r\nReturns the sum of the amplitude squares for all magnetic field components, i.e. it\r\nreturns |Hx| 2 +|Hy| 2 +|Hz| 2 .\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                                                                         |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getmagnetic( \"monitorname\");   | Returns                                                                                                                                                                                                                                                                                 |\r\n| getmagnetic( \"monitorname\", option); | The optional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n\r\n**Examples**\r\n\r\nThis example creates an image plot of |H|^2 for a z-normal frequency monitor in the x-y\r\nplane.\r\n\r\n```\r\nH2=getmagnetic(\"output\");\r\nx=getdata(\"output\",\"x\");\r\ny=getdata(\"output\",\"y\");\r\nimage(x,y,H2);\r\n```",
    "summary": "Returns the sum of the amplitude squares for all magnetic field components, i",
    "syntax": [
      {
        "syntax": "out = getmagnetic( \"monitorname\");",
        "description": "Returns"
      },
      {
        "syntax": "getmagnetic( \"monitorname\", option);",
        "description": "The optional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      }
    ],
    "example": ""
  },
  {
    "name": "getmaterial",
    "description": "Returns properties of a material in the material database.",
    "usage": "getmaterial();",
    "category": "general",
    "markdown": "# getmaterial\r\n\r\nReturns properties of a material in the material database.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                                                                                       |\r\n| --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?getmaterial( \"materialname\");                      | Displays the property names of the specified material that can be modified.                                                                                                                                                                           |\r\n| out = getmaterial( \"materialname\", \"propertyname\"); | Returns the property named \"propertyname\" of the material with the name \"materialname\". The returned variable is either a matrix or a string, depending on the property in the query.                                                                 |\r\n| out = getmaterial( \"materialname\", _**cell**_);     | Return multiple properties, by passing a [cell](https://support.lumerical.com/hc/en-us/articles/360034929913-cell) with entries equal to \"propertyname\". In this case out will be a struct with keys equal to the \"propertyname\" entries in the cell. |\r\n\r\n**Examples**\r\n\r\nThese commands add a new Conductive material, set the name to \"aluminum\", anisotropy to\r\n\"Diagonal\", and set the permittivity as well as conductivity properties for the\r\nmaterial. The command getmaterial() is then used to find the permittivity of the\r\nmaterial.\r\n\r\n```\r\nA=[4;5;6];\r\nB=[1;2;3];\r\nmymaterial = addmaterial(\"Conductive\");\r\nsetmaterial(mymaterial,\"name\",\"Aluminium\");\r\nsetmaterial(\"Aluminum\", \"Anisotropy\", 1); # enable diagonal anisotropy\r\nsetmaterial(\"Aluminum\",\"Permittivity\", A);\r\nsetmaterial(\"Aluminum\",\"Conductivity\", B);\r\n?getmaterial(\"Aluminum\",\"Permittivity\");\r\nresult: \r\n4 5 6   \r\n  \r\n#Using cell array  \r\nprops = cell(2);  \r\nprops{1} = \"Permittivity\"; props{2} = \"Conductivity\";  \r\nAl_vals = getmaterial(\"Aluminum\",props);  \r\n?Al_vals.Conductivity;  \r\nresult:   \r\n1 2 3 \r\n```\r\n\r\nThis example shows how to access raw data from a Sampled data material.\r\n\r\n## Note: Sampled data matrix format The sampled data matrix has 2 or 4 columns, for isotropic or anisotropic materials - The first column is the frequency vector, in Hz. - The next column(s) are the complex valued permittivity. If you want refractive index data (rather than permittivity), remember that permittivity is simply the square of the refractive index.\r\n\r\n```\r\nmatName = \"Ag (Silver) - CRC\";\r\n?getmaterial(matName);\r\nmaxCoeff = getmaterial(matName,\"max coefficient\");\r\nsampledData = getmaterial(matName,\"sampled data\");\r\n# convert sampledData matrix to refractive index\r\nf1  = pinch(sampledData,2,1); # first column\r\neps = pinch(sampledData,2,2);  # second column\r\nnk1 = sqrt(eps);\r\n# use getindex command for comparison\r\nf2 = linspace(100e12,1000e12,100);\r\nnk2 = getindex(matName,f2);\r\nplotxy(c/f1*1e6,real(nk1),\r\n    c/f1*1e6,imag(nk1),\r\n    c/f2*1e6,real(nk2),\r\n    c/f2*1e6,imag(nk2),\r\n    \"wavelength (um)\",\"refractive index\");\r\nlegend(\"n - getmaterial\",\r\n    \"k - getmaterial\",\r\n    \"n - getindex\",\r\n    \"k - getindex\"); \r\n```",
    "summary": "Returns properties of a material in the material database",
    "syntax": [
      {
        "syntax": "?getmaterial( \"materialname\");",
        "description": "Displays the property names of the specified material that can be modified."
      },
      {
        "syntax": "out = getmaterial( \"materialname\", \"propertyname\");",
        "description": "Returns the property named \"propertyname\" of the material with the name \"materialname\". The returned variable is either a matrix or a string, depending on the property in the query."
      },
      {
        "syntax": "out = getmaterial( \"materialname\", _cell_);",
        "description": "Return multiple properties, by passing a [cell](https://support.lumerical.com/hc/en-us/articles/360034929913-cell) with entries equal to \"propertyname\". In this case out will be a struct with keys equal to the \"propertyname\" entries in the cell."
      }
    ],
    "example": ""
  },
  {
    "name": "getmeshcontours",
    "description": "Gets information about the contours between different domains in an unstructured (finite-element) dataset. The dataset must contain the \"ID\" attribute (a unique identified for each domain in the finite-element mesh generated in Finite Element IDE based products).",
    "usage": "getmeshcontours();",
    "category": "general",
    "markdown": "# getmeshcontours\r\n\r\nGets information about the contours between different domains in an unstructured\r\n(finite-element) dataset. The dataset must contain the \"ID\" attribute (a unique\r\nidentified for each domain in the finite-element mesh generated in Finite Element IDE\r\nbased products).\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\r\n| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| A = getmeshcontours(dataset); | Returns information about the contours between different domains of the unstructured dataset named \"dataset\". The output is provided as a cell array. Each entry is a struct with three fields: **ID:** An integer ID that is unique for that contour. **adjacent:** Two integers representing the IDs of the adjacent domains. **elements:** For 2D, Nx2 array and for 3D, Nx3 array of integers that are the indexes to the vertices for each face on the boundary. |\r\n\r\n**Examples**\r\n\r\nThe script commands below will get the contour information for the \"grid\" dataset\r\n(available after calculating the finite-element mesh).\r\n\r\n```\r\nmesh(\"CHARGE\");  # calculate the mesh in Finite Element IDE using the CHARGE solver\r\ngrid = getresult(\"CHARGE\",\"grid\");  # get the mesh information (\"grid\" dataset)\r\ncontours = getmeshcontours(grid);\r\n# get the ID of the first contour\r\nID_1 = contours{1}.ID;\r\n# get the ID of the two adjacent domains (ID = 0 means external boundary) \r\ndomains_1 = contours{1}.adjacent;\r\n# get the index of vertices forming the first contour\r\nvertices_1 = contours{1}.elements;\r\n```",
    "summary": "Gets information about the contours between different domains in an unstructured (finite-element) da...",
    "syntax": [
      {
        "syntax": "A = getmeshcontours(dataset);",
        "description": "Returns information about the contours between different domains of the unstructured dataset named \"dataset\". The output is provided as a cell array. Each entry is a struct with three fields: ID: An integer ID that is unique for that contour. adjacent: Two integers representing the IDs of the adjacent domains. elements: For 2D, Nx2 array and for 3D, Nx3 array of integers that are the indexes to the vertices for each face on the boundary."
      }
    ],
    "example": ""
  },
  {
    "name": "getmodeindex",
    "description": "This function returns the material index of a material in the database as it will be used in an actual MODE simulation.",
    "usage": "getmodeindex();",
    "category": "general",
    "markdown": "# getmodeindex\r\n\r\nThis function returns the material index of a material in the database as it will be\r\nused in an actual MODE simulation.\r\n\r\nMany materials (such as Sampled Materials) have properties that depend on frequency.\r\nUsing getmodeindex, you can obtain the refractive index as a function of the specified\r\nfrequency, f, as it will be used in MODE calculations.\r\n\r\nNote that the fit result depends on the fit parameters, Max coefficients and Tolerance\r\nset for the material, thus getfdtdindex result depends on those parameters as well. Tips\r\nfor setting these parameters can be found at\r\n[ Modifying the material fits ](https://optics.ansys.com/hc/en-us/articles/360034915053-Modifying-the-Material-Fits)\r\n.\r\n\r\n| **Syntax**                                                                      | **Description**                                                                                                                                                                                                                                                                                                                               |\r\n| ------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getmodeindex( \"materialname\", f);                                         | Returns the complex index of the material with the given name. The index is returned for the specified frequency f. This result is identical to getindex unless the optional arguments fitsampled and fitanalytic are used. All frequency units are in Hz.                                                                                    |\r\n| getmodeindex(\"materialname\", f,component);                                      | Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1.                                                                                                                                                                                                                  |\r\n| getmodeindex(\"materialname\", f,component, fitsampled, fitanalytic, fmin, fmax); | Optional arguments to specify if Sampled Materials or Analytic Materials should be fitted using Lumerical's multi-coefficient model (MCM), which is commonly used in FDTD simulations. If either of these options are set to 1 (true) then you must supply a minimum and maximum frequency for fitting. The MCM is typically used in MODE for |\r\n\r\n- Sampled Materials when calculating waveguide dispersion, and for\r\n- Analytic Materials only for the purpose of using precisely the same materials in both\r\n  FDTD and MODE simulations.\r\n\r\nThe default values are 0 (false) for fitsampled and fitanalytic.\r\n\r\n**Example**\r\n\r\nThis example shows how to get material (n,k) data with the getindex and getmodeindex\r\nfunctions. In this case, we compare the experimental data to the MODE multi-coefficient\r\nfit of the that data that would be used in the simulation.\r\n\r\n```\r\nmaterial=\"Si (Silicon) - Palik\";   # material \r\nsource_min_f=c/700e-9;      # source min frequency\r\nsource_max_f=c/400e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\n# get experimental data\r\nn_exp=getindex(material,f_vector);\r\n# get MODE multi-coefficient fit of experimental data\r\nn_mode=getmodeindex(material,f_vector,1,1,0,source_min_f,source_max_f);\r\n# plot results\r\nplot(c/f_vector*1e9,real(n_exp),real(n_mode),\"wavelenth (nm)\",\"n\",material);\r\nlegend(\"experimental data\",\"MODE fit\");\r\nplot(c/f_vector*1e9,imag(n_exp),imag(n_mode),\"wavelenth (nm)\",\"k\",material);\r\nlegend(\"experimental data\",\"MODE fit\");\r\n```",
    "summary": "This function returns the material index of a material in the database as it will be used in an actu...",
    "syntax": [
      {
        "syntax": "out = getmodeindex( \"materialname\", f);",
        "description": "Returns the complex index of the material with the given name. The index is returned for the specified frequency f. This result is identical to getindex unless the optional arguments fitsampled and fitanalytic are used. All frequency units are in Hz."
      },
      {
        "syntax": "getmodeindex(\"materialname\", f,component);",
        "description": "Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1."
      },
      {
        "syntax": "getmodeindex(\"materialname\", f,component, fitsampled, fitanalytic, fmin, fmax);",
        "description": "Optional arguments to specify if Sampled Materials or Analytic Materials should be fitted using Lumerical's multi-coefficient model (MCM), which is commonly used in FDTD simulations. If either of these options are set to 1 (true) then you must supply a minimum and maximum frequency for fitting. The MCM is typically used in MODE for"
      }
    ],
    "example": "material=\"Si (Silicon) - Palik\";   # material \r\nsource_min_f=c/700e-9;      # source min frequency\r\nsource_max_f=c/400e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\n# get experimental data\r\nn_exp=getindex(material,f_vector);\r\n# get MODE multi-coefficient fit of experimental data\r\nn_mode=getmodeindex(material,f_vector,1,1,0,source_min_f,source_max_f);\r\n# plot results\r\nplot(c/f_vector*1e9,real(n_exp),real(n_mode),\"wavelenth (nm)\",\"n\",material);\r\nlegend(\"experimental data\",\"MODE fit\");\r\nplot(c/f_vector*1e9,imag(n_exp),imag(n_mode),\"wavelenth (nm)\",\"k\",material);\r\nlegend(\"experimental data\",\"MODE fit\");"
  },
  {
    "name": "getname",
    "description": "The script command getname is used to get the name of a datset.",
    "usage": "getname();",
    "category": "general",
    "markdown": "# getname\r\n\r\nThe script command getname is used to get the name of a datset.\r\n\r\n| **Syntax**   | **Description**                                    |\r\n| ------------ | -------------------------------------------------- |\r\n| ?getname(a); | Returns the name of the dataset of the variable a. |\r\n| ?a.getname;  | Returns the name of the dataset of the variable a. |\r\n\r\n**Example**\r\n\r\nThe following is a short example in which we create a matrix dataset named tt and assign\r\nit to variable named T. Using the getname script command the name of the dataset can be\r\nobtained.\r\n\r\n```\r\nT = matrixdataset(\"tt\"); \r\nT.setname(\"test\");\r\n?getname(T);\r\ntest\r\n?T.getname;\r\ntest\r\n```",
    "summary": "The script command getname is used to get the name of a datset",
    "syntax": [
      {
        "syntax": "?getname(a);",
        "description": "Returns the name of the dataset of the variable a."
      },
      {
        "syntax": "?a.getname;",
        "description": "Returns the name of the dataset of the variable a."
      }
    ],
    "example": "T = matrixdataset(\"tt\"); \r\nT.setname(\"test\");\r\n?getname(T);\r\ntest\r\n?T.getname;\r\ntest"
  },
  {
    "name": "getnamed",
    "description": "Gets a property from objects with a given name.",
    "usage": "getnamed();",
    "category": "general",
    "markdown": "# getnamed\r\n\r\nGets a property from objects with a given name.\r\n\r\nIf multiple objects are selected, and the values are different, the smallest value is\r\nreturned. To be certain of the results, be sure that only one object is selected, or use\r\nthe form of getnamed that allows a specific object to be selected.\r\n\r\n| **Syntax**                                        | **Description**                                                                                                                                                                                                                                                                                      |\r\n| ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?getnamed(\"name\");                                | Returns a list of the properties of the objects called name.                                                                                                                                                                                                                                         |\r\n| out = getnamed(\"name\", \"property\");               | Returns the value of the specific property of the named object.                                                                                                                                                                                                                                      |\r\n| out = getnamed(\"name\", \"properties_array\");       | Return the values of the properties of the named object as struct. The \"properties_array\" is a cell array of strings.                                                                                                                                                                                |\r\n| out=getnamed(\"name\", \"property\", i);              | Gets the property of the ith named object. Use this to act on a series of objects. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree.                                         |\r\n| out = getnamed(\"groupname::name\", \"property\");    | The same as get, but acts on objects named \"name\" located in the group \"groupname\", instead of selected objects.                                                                                                                                                                                     |\r\n| out = getnamed(\"groupname::name\", \"property\", i); | Gets the property of the ith object named \"name\" located in the group \"groupname\". Use this to act on a series of objects. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. |\r\n\r\n**Examples**\r\n\r\nThis example uses the get command to get the x span of an object named substrate.\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"substrate\");\r\nsetnamed(\"substrate\",\"x span\",2e-6); \r\nx_span = getnamed(\"substrate\",\"x span\"); \r\n?x_span;\r\nresult: \r\n2e-006  \r\n```\r\n\r\nAdd 2 microns to the radius of all selected objects named circle.\r\n\r\n```\r\nfor (i=1:getnamednumber(\"circle\")) {\r\n rad=getnamed(\"circle\",\"radius\",i);\r\n setnamed(\"circle\",\"radius\",rad+2e-6,i);\r\n}\r\n```\r\n\r\nGet the x, y, z positions of the named object as struct.\r\n\r\n```\r\naddrect({\"name\":\"substrate\"});  \r\nA = getnamed(\"substrate\",{\"x\",\"y\",\"z\"});  \r\n?A.x;  \r\nresult:   \r\n0 \r\n```",
    "summary": "Gets a property from objects with a given name",
    "syntax": [
      {
        "syntax": "?getnamed(\"name\");",
        "description": "Returns a list of the properties of the objects called name."
      },
      {
        "syntax": "out = getnamed(\"name\", \"property\");",
        "description": "Returns the value of the specific property of the named object."
      },
      {
        "syntax": "out = getnamed(\"name\", \"properties_array\");",
        "description": "Return the values of the properties of the named object as struct. The \"properties_array\" is a cell array of strings."
      },
      {
        "syntax": "out=getnamed(\"name\", \"property\", i);",
        "description": "Gets the property of the ith named object. Use this to act on a series of objects. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree."
      },
      {
        "syntax": "out = getnamed(\"groupname::name\", \"property\");",
        "description": "The same as get, but acts on objects named \"name\" located in the group \"groupname\", instead of selected objects."
      },
      {
        "syntax": "out = getnamed(\"groupname::name\", \"property\", i);",
        "description": "Gets the property of the ith object named \"name\" located in the group \"groupname\". Use this to act on a series of objects. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree."
      }
    ],
    "example": ""
  },
  {
    "name": "getnamednumber",
    "description": "Gets the number of objects with a given name.",
    "usage": "getnamednumber();",
    "category": "general",
    "markdown": "# getnamednumber\r\n\r\nGets the number of objects with a given name.\r\n\r\n| **Syntax**                                | **Description**                                                                                                    |\r\n| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\r\n| out = getnamednumber( \"name\");            | The same as getnumber, but acts on objects with a specific name, instead of selected objects.                      |\r\n| out = getnamednumber( \"groupname::name\"); | The same as getnumber, but acts on all objects named \"name\" in the group \"groupname\", instead of selected objects. |\r\n\r\n**Example**\r\n\r\nAdd 2 microns to the radius of all selected objects named circle.\r\n\r\n```\r\nfor (i=1:getnamednumber(\"circle\")) {\r\n rad=getnamed(\"circle\",\"radius\",i);\r\n setnamed(\"circle\",\"radius\",rad+2e-6,i);\r\n}\r\n```",
    "summary": "Gets the number of objects with a given name",
    "syntax": [
      {
        "syntax": "out = getnamednumber( \"name\");",
        "description": "The same as getnumber, but acts on objects with a specific name, instead of selected objects."
      },
      {
        "syntax": "out = getnamednumber( \"groupname::name\");",
        "description": "The same as getnumber, but acts on all objects named \"name\" in the group \"groupname\", instead of selected objects."
      }
    ],
    "example": "for (i=1:getnamednumber(\"circle\")) {\r\n rad=getnamed(\"circle\",\"radius\",i);\r\n setnamed(\"circle\",\"radius\",rad+2e-6,i);\r\n}"
  },
  {
    "name": "getnumber",
    "description": "Gets the number of objects that are selected.",
    "usage": "getnumber();",
    "category": "general",
    "markdown": "# getnumber\r\n\r\nGets the number of objects that are selected.\r\n\r\n| **Syntax**       | **Description**                                  |\r\n| ---------------- | ------------------------------------------------ |\r\n| out = getnumber; | Returns the number of objects that are selected; |\r\n\r\n**Example**\r\n\r\nAdd 2 microns to the radius of all objects named \"circle\".\r\n\r\n```\r\nselect(\"circle\");\r\nfor (i=1:getnumber) {\r\n rad=get(\"radius\",i);\r\n set(\"radius\",rad+2e-6,i);\r\n}\r\n```",
    "summary": "Gets the number of objects that are selected",
    "syntax": [
      {
        "syntax": "out = getnumber;",
        "description": "Returns the number of objects that are selected;"
      }
    ],
    "example": "select(\"circle\");\r\nfor (i=1:getnumber) {\r\n rad=get(\"radius\",i);\r\n set(\"radius\",rad+2e-6,i);\r\n}"
  },
  {
    "name": "getnumericalpermittivity",
    "description": "This advanced function returns the permittivity of a material in the database as it will be used in an actual FDTD simulation, including the effects of a finite time step, dt. In FDTD, the relationship between the displacement field, D, and the electric field, E, is given by",
    "usage": "getnumericalpermittivity();",
    "category": "general",
    "markdown": "# getnumericalpermittivity\r\n\r\nThis advanced function returns the permittivity of a material in the database as it will\r\nbe used in an actual FDTD simulation, including the effects of a finite time step, dt.\r\nIn FDTD, the relationship between the displacement field, D, and the electric field, E,\r\nis given by\r\n\r\n$$ \\\\vec{D}(\\\\omega)=\\\\varepsilon\\_{0} \\\\varepsilon\\_{\\\\gamma}(\\\\omega, d t)\r\n\\\\vec{E}(\\\\omega) $$\r\n\r\nIn the limit where dt tends to zero, we have\r\n\r\n$$ \\\\lim _{d t \\\\rightarrow 0} \\\\varepsilon_{r}(\\\\omega, d t)=n^{2}(\\\\omega) $$\r\n\r\nwhere n( ω ) is the refractive index returned by the script function getfdtdindex, or\r\nshown in the Materials Explorer. If you set dt to zero when calling this function, it\r\nwill return exactly the same result as the square of getfdtdindex.\r\n\r\nThe name of the function is a reminder that it returns the numerical permittivity, i.e.,\r\nthe ratio of D and E, which is different from the refractive index, i.e. the ratio of\r\nthe speed of light in a vacuum to the phase velocity of light in the medium. To\r\nunderstand the relationship between them, we must consider the full, numerical\r\ndispersion relation between ω and k, which is given by\r\n\r\n$$ \\\\varepsilon\\_{r}(\\\\omega, d t)\\\\left\\[\\\\frac{1}{c d t} \\\\sin \\\\left(\\\\frac{\\\\omega d\r\nt}{2}\\\\right)\\\\right\\]^{2}=\\\\left\\[\\\\frac{1}{d x} \\\\sin \\\\left(\\\\frac{k\\_{x} d\r\nx}{2}\\\\right)\\\\right\\]^{2}+\\\\left\\[\\\\frac{1}{d y} \\\\sin \\\\left(\\\\frac{k\\_{y} d\r\ny}{2}\\\\right)\\\\right\\]^{2}+\\\\left\\[\\\\frac{1}{d z} \\\\sin \\\\left(\\\\frac{k\\_{z} d\r\nz}{2}\\\\right)\\\\right\\]^{2} $$\r\n\r\nIn the limit where dt, dx, dy and dz tend to zero, it is easy to show that we have the\r\nexpected result\r\n\r\n$$ \\\\omega=\\\\frac{c k}{\\\\sqrt{\\\\varepsilon\\_{r}(\\\\omega, d t=0)}}=\\\\frac{c\r\nk}{n(\\\\omega)} $$\r\n\r\nThe spatial FDTD mesh and time step are generally chosen to obtain a desired level of\r\nsimulation accuracy, essentially by ensuring that the arguments of the sine functions\r\nare sufficiently small that sin(x)~x and that the simulation is stable. For some\r\nmaterials, it may be desired to further reduce the value of the time step, dt, without\r\nmodifying the spatial FDTD mesh, in order to obtain a higher level of accuracy for ε r (\r\nω ,dt). This script function makes it possible to calculate, in advance, the value of dt\r\nrequired to obtain the desired accuracy for the permittivity.\r\n\r\nThe results from getnumericalpermittivity will be different if the Broadband Fixed Angle\r\nSource Technique (BFAST) is used. Since the script function does not require a\r\ncalculation being performed beforehand, the user needs to specify if the computation\r\nuses BFAST or not. See the\r\n[ BFAST page ](https://optics.ansys.com/hc/en-us/articles/360034902273-Source-BFAST) for\r\nmore details about this technique.\r\n\r\n| **Syntax**                                                                        | **Description**                                                                                                                                                                                                                          |\r\n| --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getnumericalpermittivity ( \"materialname\", f, fmin, fmax, dt);              | Returns the complex permittivity of the material with the given name. The permittivity is returned for the specified frequency f. This is similar to getfdtdindex except for the additional parameter dt. All frequency units are in Hz. |\r\n| getnumericalpermittivity(\"materialname\", f,fmin, fmax, dt, component);            | Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1.                                                                                                             |\r\n| getnumericalpermittivity(\"materialname\", f,fmin, fmax, dt, component, use_bfast); | Optional argument use_bfast can be 0 or 1. It indicates whether the simulation is performed using the Broadband Fixed Angle Source Technique (BFAST) or not. The default is 0.                                                           |\r\n\r\n**Examples**\r\n\r\nThis example shows how to get the material permittivity with the getindex, getfdtdindex\r\nand getnumerical permittivity functions. In this case, we compare the experimental\r\npermittivity data to the theoretical FDTD fit of the that data as well as to the\r\nnumerical permittivity that will result using a finite value of dt.\r\n\r\n```\r\nmaterial=\"Si (Silicon) - Palik\";   # material \r\nsource_min_f=c/800e-9;      # source min frequency\r\nsource_max_f=c/200e-9;      # source max frequency\r\nf_vector=linspace(source_max_f,source_min_f,100);\r\ncomponent = 1; # desired permittivity component x (1), y (2) or z (3). Relevant for anisotropic materials, default 1\r\nuse_bfast = 0; # Change to 1 if using BFAST, default 0 \r\n# get experimental data\r\neps_exp=(getindex(material,f_vector))^2;\r\n# get FDTD fit of experimental data\r\neps_fit=(getfdtdindex(material,f_vector,source_min_f,source_max_f))^2;\r\n# get the numerical FDTD result for 3 different values of dt\r\nTmin = 1/max(f_vector);\r\ndt = Tmin * [ 0.1; 0.05; 0.01 ];\r\n# alternate way to get dt values: 100%, 10%, 1% of current dt value\r\n# dt = getnamed(\"FDTD\",\"dt\");\r\n# dt = [dt; dt*0.1; dt*0.01];\r\n \r\neps_numerical1=getnumericalpermittivity(material,f_vector,source_min_f,source_max_f,dt(1),component,use_bfast);\r\neps_numerical2=getnumericalpermittivity(material,f_vector,source_min_f,source_max_f,dt(2),component,use_bfast);\r\neps_numerical3=getnumericalpermittivity(material,f_vector,source_min_f,source_max_f,dt(3),component,use_bfast);\r\n# plot results\r\nif (use_bfast==1){fdtd_method = \"FDTD - BFAST\";}\r\nelse{fdtd_method = \"FDTD\";}\r\nplot(c/f_vector*1e9,real(eps_exp),real(eps_fit),\r\n          real(eps_numerical1),\r\n          real(eps_numerical2),\r\n          real(eps_numerical3),\r\n          \"wavelenth (nm)\",\"Re(eps)\",material);\r\nlegend(\"experimental data\",\"FDTD fit\",\r\n    fdtd_method+\", dt=\"+num2str(dt(1)*1e15)+\"fs\",\r\n    fdtd_method+\", dt=\"+num2str(dt(2)*1e15)+\"fs\",\r\n    fdtd_method+\", dt=\"+num2str(dt(3)*1e15)+\"fs\");\r\nplot(c/f_vector*1e9,imag(eps_exp),imag(eps_fit),\r\n          imag(eps_numerical1),\r\n          imag(eps_numerical2),\r\n          imag(eps_numerical3),\"wavelenth (nm)\",\"Im(eps)\",material);\r\nlegend(\"experimental data\",\"FDTD fit\",\r\n    fdtd_method+\", dt=\"+num2str(dt(1)*1e15)+\"fs\",\r\n    fdtd_method+\", dt=\"+num2str(dt(2)*1e15)+\"fs\",\r\n    fdtd_method+\", dt=\"+num2str(dt(3)*1e15)+\"fs\");\r\n```",
    "summary": "This advanced function returns the permittivity of a material in the database as it will be used in ...",
    "syntax": [
      {
        "syntax": "out = getnumericalpermittivity ( \"materialname\", f, fmin, fmax, dt);",
        "description": "Returns the complex permittivity of the material with the given name. The permittivity is returned for the specified frequency f. This is similar to getfdtdindex except for the additional parameter dt. All frequency units are in Hz."
      },
      {
        "syntax": "getnumericalpermittivity(\"materialname\", f,fmin, fmax, dt, component);",
        "description": "Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1."
      },
      {
        "syntax": "getnumericalpermittivity(\"materialname\", f,fmin, fmax, dt, component, use_bfast);",
        "description": "Optional argument use_bfast can be 0 or 1. It indicates whether the simulation is performed using the Broadband Fixed Angle Source Technique (BFAST) or not. The default is 0."
      }
    ],
    "example": ""
  },
  {
    "name": "getparameter",
    "description": "Gets a parameter from an existing dataset.",
    "usage": "getparameter();",
    "category": "general",
    "markdown": "# getparameter\r\n\r\nGets a parameter from an existing dataset.\r\n\r\n| **Syntax**                       | **Description**                                                                                                                                                                                                                                  |\r\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| ?getparameter(R);                | Returns the names of all the parameters in the dataset R.                                                                                                                                                                                        |\r\n| Parameter = R.getparameter(\"p\"); | Retrieves the parameter p from the existing dataset R. The result \"Parameter\" is a scalar matrix. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about dimensions of attribute data. |\r\n| Parameter = getparameter(R,\"p\"); | Retrieves the parameter p from the existing dataset R. The result \"Parameter\" is a scalar matrix. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about dimensions of attribute data. |\r\n\r\n**Examples**\r\n\r\nThis example retrieves the dataset results \"E\" from a profile monitor, and then uses the\r\ngetparameter command to get the \"f\" parameter, and the\r\n[ getattribute ](./getattribute.md) command to get the \"Ex\" and \"E2\" attributes from the\r\ndataset. Note that f, Ex and E2 are all scalar matrices, like the results one would get\r\nwith the [ getdata ](./getdata.md) command.\r\n\r\n```\r\nE = getresult(\"profile\",\"E\");\r\nf = E.getparameter(\"f\");  # the parameter f\r\nEx = E.getattribute(\"Ex\"); # the x component of the electric field\r\nE2 = E.getattribute(\"E2\"); # the electric field intensity, note that this only works if E is a vector\r\n```\r\n\r\nNote that one can also use the [ \".\" operator ](./dot_cmd.md) to retrieve the parameters\r\nand attributes directly. For example:\r\n\r\n```\r\nE = getresult(\"profile\",\"E\");\r\nf = E.f;  # the parameter f\r\nEx = E.Ex; # the x component of the electric field\r\nE2 = E.E2; # the electric field intensity, note that this only works if E is a vector\r\n```",
    "summary": "Gets a parameter from an existing dataset",
    "syntax": [
      {
        "syntax": "?getparameter(R);",
        "description": "Returns the names of all the parameters in the dataset R."
      },
      {
        "syntax": "Parameter = R.getparameter(\"p\");",
        "description": "Retrieves the parameter p from the existing dataset R. The result \"Parameter\" is a scalar matrix. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about dimensions of attribute data."
      },
      {
        "syntax": "Parameter = getparameter(R,\"p\");",
        "description": "Retrieves the parameter p from the existing dataset R. The result \"Parameter\" is a scalar matrix. See [ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets) for details about dimensions of attribute data."
      }
    ],
    "example": ""
  },
  {
    "name": "getpath",
    "description": "Gets the current path. By default, the current working directory and the script sub-directory of the installation directory are in the path. Typically the path is important for setting the location of your script files.",
    "usage": "getpath();",
    "category": "general",
    "markdown": "# getpath\r\n\r\nGets the current path. By default, the current working directory and the script\r\nsub-directory of the installation directory are in the path. Typically the path is\r\nimportant for setting the location of your script files.\r\n\r\n| **Syntax**     | **Description**                                                                |\r\n| -------------- | ------------------------------------------------------------------------------ |\r\n| out = getpath; | Returns the current path as a string. Use ?getpath; to print it to the screen. |\r\n\r\n**Examples**\r\n\r\nGets the current path.\r\n\r\n```\r\n?getpath;\r\n./  \r\nC:/Program Files/Lumerical/2020a/scripts\r\n```",
    "summary": "Gets the current path",
    "syntax": [
      {
        "syntax": "out = getpath;",
        "description": "Returns the current path as a string. Use ?getpath; to print it to the screen."
      }
    ],
    "example": ""
  },
  {
    "name": "getperiodicity",
    "description": "Returns the periodicity vector(s) associated with the active periodic boundary conditions in the specified solver.",
    "usage": "getperiodicity();",
    "category": "general",
    "markdown": "# getperiodicity\r\n\r\nReturns the periodicity vector(s) associated with the active periodic boundary\r\nconditions in the specified solver.\r\n\r\n| **Syntax**                          | **Description**                                                                                                                                                                                                                                              |\r\n| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = getperiodicity(\"solvername\"); | Returns the periodicity vector(s) of the system based on the active periodic boundary conditions in the named solver. The output is a [3XN] matrix where N is the number of dimensions that have active periodic boundary conditions (typically one or two). |\r\n\r\n| **Parameter** |          | **Default value** | **Type** | **Description**                                                     |\r\n| ------------- | -------- | ----------------- | -------- | ------------------------------------------------------------------- |\r\n| solvername    | required |                   | string   | Name of the solver from which to extract the periodicity vector(s). |\r\n\r\n**Example**\r\n\r\nThis example retrieves the periodicity vectors from a DGTD simulation with periodic\r\nboundary conditions.\r\n\r\n```\r\nperiod = getperiodicity(\"DGTD\"); \r\n```",
    "summary": "Returns the periodicity vector(s) associated with the active periodic boundary conditions in the spe...",
    "syntax": [
      {
        "syntax": "out = getperiodicity(\"solvername\");",
        "description": "Returns the periodicity vector(s) of the system based on the active periodic boundary conditions in the named solver. The output is a [3XN] matrix where N is the number of dimensions that have active periodic boundary conditions (typically one or two)."
      }
    ],
    "example": "period = getperiodicity(\"DGTD\");"
  },
  {
    "name": "getports",
    "description": "Returns a list of ports available in an element.",
    "usage": "getports();",
    "category": "general",
    "markdown": "# getports\r\n\r\nReturns a list of ports available in an element.\r\n\r\n| **Syntax**                     | **Description**                                      |\r\n| ------------------------------ | ---------------------------------------------------- |\r\n| out = getports(\"name\")         | Gets a list of available ports.                      |\r\n| out = getports(\"name\", \"type\") | Gets a list of available ports with the type \"type\". |\r\n\r\n| **Parameter** | **Type** | **Description**                                                     |\r\n| ------------- | -------- | ------------------------------------------------------------------- |\r\n| name          | string   | name of the element.                                                |\r\n| type          | string   | type of the port. Available types: \"electrical\" \"optical\" \"digital\" |\r\n\r\n**Example**\r\n\r\n```\r\naddelement(\"Optical Amplifier\");\r\n?getports(\"AMP_1\", \"optical\");\r\n>input\r\noutput\r\n```",
    "summary": "Returns a list of ports available in an element",
    "syntax": [
      {
        "syntax": "out = getports(\"name\")",
        "description": "Gets a list of available ports."
      },
      {
        "syntax": "out = getports(\"name\", \"type\")",
        "description": "Gets a list of available ports with the type \"type\"."
      }
    ],
    "example": "addelement(\"Optical Amplifier\");\r\n?getports(\"AMP_1\", \"optical\");\r\n>input\r\noutput"
  },
  {
    "name": "getposition",
    "description": "Gets the current horizontal or vertical position of an element.",
    "usage": "getposition();",
    "category": "general",
    "markdown": "# getposition\r\n\r\nGets the current horizontal or vertical position of an element.\r\n\r\n| **Syntax**                      | **Description**                                        |\r\n| ------------------------------- | ------------------------------------------------------ |\r\n| out=getposition(\"element\",”x”); | Returns the current horizontal position of an element. |\r\n| out=getposition(\"element\",”y”); | Returns the current vertical position of an element.   |\r\n\r\n**Example**\r\n\r\nThis example is to get the x position of an element named \"Waveguide Coupler_1\"\r\n\r\n```\r\n?getposition(\"Waveguide Coupler_1\",\"x\");\r\nresult: \r\n1e-006  \r\n```",
    "summary": "Gets the current horizontal or vertical position of an element",
    "syntax": [
      {
        "syntax": "out=getposition(\"element\",”x”);",
        "description": "Returns the current horizontal position of an element."
      },
      {
        "syntax": "out=getposition(\"element\",”y”);",
        "description": "Returns the current vertical position of an element."
      }
    ],
    "example": "?getposition(\"Waveguide Coupler_1\",\"x\");\r\nresult: \r\n1e-006"
  },
  {
    "name": "getrectangle",
    "description": "Gets the width or height of an element rectangle.",
    "usage": "getrectangle();",
    "category": "general",
    "markdown": "# getrectangle\r\n\r\nGets the width or height of an element rectangle.\r\n\r\n| **Syntax**                        | **Description**                             |\r\n| --------------------------------- | ------------------------------------------- |\r\n| out=getrectangle (\"element\",”w”); | Returns the width of an element rectangle.  |\r\n| out=getrectangle (\"element\",”h”); | Returns the height of an element rectangle. |\r\n\r\n**Example**\r\n\r\nTo get the x position of a waveguide element named \"Straight Waveguide_1\" use the\r\nfollowing script\r\n\r\n```\r\n?getrectangle(\"Straight Waveguide_1\",\"w\") ;\r\nresult: \r\n1e-006 \r\n```",
    "summary": "Gets the width or height of an element rectangle",
    "syntax": [
      {
        "syntax": "out=getrectangle (\"element\",”w”);",
        "description": "Returns the width of an element rectangle."
      },
      {
        "syntax": "out=getrectangle (\"element\",”h”);",
        "description": "Returns the height of an element rectangle."
      }
    ],
    "example": "?getrectangle(\"Straight Waveguide_1\",\"w\") ;\r\nresult: \r\n1e-006"
  },
  {
    "name": "getremotedata",
    "description": "An interoperability command that will get a variable from the server workspace into the client workspace via an active session. This works for matrices and strings (and not for structs and cell arrays).",
    "usage": "getremotedata();",
    "category": "general",
    "markdown": "# getremotedata\r\n\r\nAn interoperability command that will get a variable from the server workspace into the\r\nclient workspace via an active session. This works for matrices and strings (and not for\r\nstructs and cell arrays).\r\n\r\n| **Syntax**              | **Description**                                                                                                       |\r\n| ----------------------- | --------------------------------------------------------------------------------------------------------------------- |\r\n| y=getremotedata(s,'x'); | Creates variable y in the local client workspace that has value of x in the server workspace via an active session s. |\r\n\r\n### Example\r\n\r\nThe following code example opens Device as a server, sends local variable 'x' to Device\r\nworkspace followed by a command to manipulate the variable and the retrieves the result\r\nbefore closing the session:\r\n\r\n```\r\n#Opend Device session\r\ns2=opensession('device');\r\n#Declare local variable x\r\nx=2;\r\n#Send the local variable to Device workspace via API\r\nputremotedata(s2,'x_device',x);\r\n#Send script command to Device via API andsquare the variable\r\nevalremote(s2,\"y_device=x_device^2;\");\r\n#Get the variable from Device worksapace via API \r\n?y=getremotedata(s2,'y_device');\r\n#Close the session\r\nclosesession(s2);\r\n```",
    "summary": "An interoperability command that will get a variable from the server workspace into the client works...",
    "syntax": [
      {
        "syntax": "y=getremotedata(s,'x');",
        "description": "Creates variable y in the local client workspace that has value of x in the server workspace via an active session s."
      }
    ],
    "example": ""
  },
  {
    "name": "getresource",
    "description": "Returns the current setting for properties of the available resources in resource manager for the specified solver. This command is also used to obtain submittable fields for [Ansys Cloud Burst Compute™ for Lumerical](https://optics.ansys.com/hc/en-us/articles/39824576734867-Ansys-Cloud-Burst-Compute-for-Lumerical).",
    "usage": "getresource();",
    "category": "general",
    "markdown": "# getresource\r\n\r\nReturns the current setting for properties of the available resources in resource\r\nmanager for the specified solver. This command is also used to obtain submittable fields\r\nfor\r\n[Ansys Cloud Burst Compute™ for Lumerical](https://optics.ansys.com/hc/en-us/articles/39824576734867-Ansys-Cloud-Burst-Compute-for-Lumerical).\r\n\r\nFor all resources except Ansys Cloud Burst Compute™ for Lumerical:\r\n\r\n| **Syntax**                                           | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| ---------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=getresource(\"solver\", resource_num, \"property\"); | Returns the current setting for properties of the available resources in resource manager for the specified solver. The \"solver\" argument is used to select the solver from which the resource is being selected. The \"solver\" argument is not supported by INTERCONNECT. resource_num is the number of the desired resource (row number in resource manager) and is optional. If not specified, the command will return the number of resources currently available for the specified solver. \"property\" is the desired property of the resource and is optional. If not specified, the command will return a list of all properties available for the resource. |\r\n\r\nWhen using\r\n[Ansys Cloud Burst Compute™ for Lumerical](https://optics.ansys.com/hc/en-us/articles/39824576734867-Ansys-Cloud-Burst-Compute-for-Lumerical):\r\n\r\n| **Syntax**                                                                                                                                            | **Description**                                                                                        |\r\n| ----------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| out=getresource(\"burst\");                                                                                                                             | Returns a structure containing burst settings. The fields of the output structure are described below. |\r\n| out = getresource(“burst”,”accounts”);                                                                                                                | Returns a list of available burst accounts to choose from.                                             |\r\n| out = getresource(“burst”, “name”, “resource_type”);                                                                                                  | Returns a list of available queues for the account specified by the parameter name.                    |\r\n| The queue type, as specified by the resource_type parameter, can either be “GPU” for a list of all GPU queues, or “CPU” for a list of all CPU queues. |                                                                                                        |\r\n\r\nThe structure returned by `getresource(\"burst\")` is described below. These are the\r\nfields that can be modified during job submission.\r\n\r\nThe settings for Ansys Cloud Burst Compute for Lumerical will be reverted to default\r\nafter every job submission. As such, the values of each field will be their default\r\nvalues. To modify settings during job submission, see\r\n[run](https://optics.ansys.com/hc/en-us/articles/360034931333-run-Script-command) and\r\n[runsweep](https://optics.ansys.com/hc/en-us/articles/360034931413-runsweep-Script-command).\r\n\r\n| **Field**                                                                                              | **Description**                                                                                                                                                                                                                                                                   |\r\n| ------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| account                                                                                                | Current account name.                                                                                                                                                                                                                                                             |\r\n| download                                                                                               | Whether or not to download the results after simulation completion. This is 0 if the results are not downloaded, and 1 if the results are downloaded. The results can be downloaded from [Ansys Engineering Portal](https://portal.ansys.com/) if automatic download is disabled. |\r\n| jobMonitoring                                                                                          | Whether or not job monitoring from the GUI is enabled. This result 0 if you are not monitoring the job in the GUI. An Ansys Engineering Portal link to the job is provided in the script prompt when you submit a job without monitoring.                                         |\r\n| name                                                                                                   | Name of the current Ansys Cloud Burst Compute job.                                                                                                                                                                                                                                |\r\n| queue                                                                                                  | Name of the queue to be used for the job. By default, this will be empty to indicate that a queue will be automatically selected.                                                                                                                                                 |\r\n| You can find a list of queues using the `getresource(\"burst\",\"name\",\"type\")` command documented above. |                                                                                                                                                                                                                                                                                   |\r\n\r\n**Example**\r\n\r\nThis example will return the number of processes currently set for the second resource\r\nof the DGTD solver in Finite Element IDE\r\n\r\n```\r\nout=getresource(\"DGTD\",2,\"processes\");\r\n```",
    "summary": "Returns the current setting for properties of the available resources in resource manager for the sp...",
    "syntax": [
      {
        "syntax": "out=getresource(\"solver\", resource_num, \"property\");",
        "description": "Returns the current setting for properties of the available resources in resource manager for the specified solver. The \"solver\" argument is used to select the solver from which the resource is being selected. The \"solver\" argument is not supported by INTERCONNECT. resource_num is the number of the desired resource (row number in resource manager) and is optional. If not specified, the command will return the number of resources currently available for the specified solver. \"property\" is the desired property of the resource and is optional. If not specified, the command will return a list of all properties available for the resource."
      }
    ],
    "example": "out=getresource(\"DGTD\",2,\"processes\");"
  },
  {
    "name": "getresult",
    "description": "Get results from simulation objects. Results will be returned as datasets.",
    "usage": "getresult();",
    "category": "general",
    "markdown": "# getresult\r\n\r\nGet results from simulation objects. Results will be returned as datasets.\r\n\r\n| **Syntax**                         | **Description**                                                                                                                |\r\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| ?getresult(\"monitor_name\");        | Returns the names of all the results for the monitor. All the dataset and scalar matrix results will be returned in this case. |\r\n| R = getresult(\"monitor_name\",\"T\"); | Returns the result T from the monitor. T is a dataset.                                                                         |\r\n\r\n**Examples**\r\n\r\nThis example shows how to get the electric field dataset from a monitor. We then apply a\r\nnumber of operations to the dataset, such as finding the maximum |E|^2 value, viewing\r\nthe dataset with the visualizer, and creating a plot of Ex at the first frequency point.\r\n\r\nNote that E is a dataset, rather than a simple matrix based variable. Data within the\r\ndataset can be accessed with the '.' operator, as shown below.\r\n\r\n```\r\n# get Electric field dataset\r\nE=getresult(\"monitor\",\"E\");\r\n# output dataset value to prompt\r\n?E;\r\n# check size of position vectors and data matrices\r\n?size(E.f);\r\n?size(E.Ex);\r\n# find maximum |E|^2 value \r\n?max(E.E2);\r\n# view dataset with visualizer\r\nvisualize(E);\r\n# select first frequency point of Ex data, then create plot\r\nEx = pinch(E.Ex,4,1); \r\nimage(E.x*1e6,E.y*1e6,Ex,\"x (um)\",\"y (um)\",\"Ex\");\r\n E vs x, y, z, lambda/f\r\n result: \r\n 5 1 \r\n result: \r\n 343 255 1 5 \r\n result: \r\n 3.223651 \r\n```",
    "summary": "Get results from simulation objects",
    "syntax": [
      {
        "syntax": "?getresult(\"monitor_name\");",
        "description": "Returns the names of all the results for the monitor. All the dataset and scalar matrix results will be returned in this case."
      },
      {
        "syntax": "R = getresult(\"monitor_name\",\"T\");",
        "description": "Returns the result T from the monitor. T is a dataset."
      }
    ],
    "example": ""
  },
  {
    "name": "getresultdata",
    "description": "Gets results from an analyzer. This differs from the \"getresult\" function in that the results are returned as matrices, not [Datasets](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets).",
    "usage": "getresultdata();",
    "category": "general",
    "markdown": "# getresultdata\r\n\r\nGets results from an analyzer. This differs from the \"getresult\" function in that the\r\nresults are returned as matrices, not\r\n[Datasets](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets).\r\n\r\n| **Syntax**                                 | **Description**                                                                   |\r\n| ------------------------------------------ | --------------------------------------------------------------------------------- |\r\n| ?getresultdata;                            | Returns the names of all elements in the current simulation that contain results. |\r\n| ?getresultdata(\"analyzer\");                | Returns all available results for \"analyzer\".                                     |\r\n| out = getresultdata(\"analyzer\", \"result\"); | Returns the result \"result\" for \"analyzer\".                                       |",
    "summary": "Gets results from an analyzer",
    "syntax": [
      {
        "syntax": "?getresultdata;",
        "description": "Returns the names of all elements in the current simulation that contain results."
      },
      {
        "syntax": "?getresultdata(\"analyzer\");",
        "description": "Returns all available results for \"analyzer\"."
      },
      {
        "syntax": "out = getresultdata(\"analyzer\", \"result\");",
        "description": "Returns the result \"result\" for \"analyzer\"."
      }
    ],
    "example": ""
  },
  {
    "name": "getsetting",
    "description": "Returns the value of a user defined setting. This command can be used with [ setsetting ](./setsetting.md) .",
    "usage": "getsetting();",
    "category": "general",
    "markdown": "# getsetting\r\n\r\nReturns the value of a user defined setting. This command can be used with\r\n[ setsetting ](./setsetting.md) .\r\n\r\n| **Syntax**          | **Description**                           |\r\n| ------------------- | ----------------------------------------- |\r\n| getsetting(\"name\"); | Gets the value of a user defined setting. |\r\n\r\n| **Parameter** | **Type** | **Description**      |\r\n| ------------- | -------- | -------------------- |\r\n| name          | string   | name of the setting. |\r\n\r\n**Example**\r\n\r\nPlease visit the page [ setsetting ](./setsetting.md) .",
    "summary": "Returns the value of a user defined setting",
    "syntax": [
      {
        "syntax": "getsetting(\"name\");",
        "description": "Gets the value of a user defined setting."
      }
    ],
    "example": ""
  },
  {
    "name": "getsolver",
    "description": "Returns the solver that is currently active.",
    "usage": "getsolver();",
    "category": "general",
    "markdown": "# getsolver\r\n\r\nReturns the solver that is currently active.\r\n\r\n## Note : 'getsolver' is deprecated, use 'getactivesolver' instead\r\n\r\n| **Syntax**  | **Description**                              |\r\n| ----------- | -------------------------------------------- |\r\n| ?getsolver; | Returns the solver that is currently active. |\r\n\r\n**Example**\r\n\r\nIf EME is active, then getsolver will show it:\r\n\r\n```\r\n?getsolver;\r\nWarning: prompt line 1: 'getsolver' is deprecated, use 'getactivesolver' instead\r\nEME\r\n```",
    "summary": "Returns the solver that is currently active",
    "syntax": [
      {
        "syntax": "?getsolver;",
        "description": "Returns the solver that is currently active."
      }
    ],
    "example": "?getsolver;\r\nWarning: prompt line 1: 'getsolver' is deprecated, use 'getactivesolver' instead\r\nEME"
  },
  {
    "name": "getsourceangle",
    "description": "Returns the source angle theta as a function of frequency. Broadband sources inject fields that have a constant in-plane wavevector at all frequencies. This implies injection angle must change as a function of frequency. The in-plane wavevector is chosen such that the incidence angle at the center frequency of the simulation (\\\\(f\\_{sim}\\\\)) will match the source angle theta (\\\\(\\\\theta\\_{sim}\\\\)) specified in the source properties. Higher frequencies will be injected at smaller angles, while lower frequencies will be injected at larger angles. This 'theta vs wavelength' plot in the beam source edit window shows the same function.",
    "usage": "getsourceangle();",
    "category": "general",
    "markdown": "# getsourceangle\r\n\r\nReturns the source angle theta as a function of frequency. Broadband sources inject\r\nfields that have a constant in-plane wavevector at all frequencies. This implies\r\ninjection angle must change as a function of frequency. The in-plane wavevector is\r\nchosen such that the incidence angle at the center frequency of the simulation\r\n(\\\\(f\\_{sim}\\\\)) will match the source angle theta (\\\\(\\\\theta\\_{sim}\\\\)) specified in\r\nthe source properties. Higher frequencies will be injected at smaller angles, while\r\nlower frequencies will be injected at larger angles. This 'theta vs wavelength' plot in\r\nthe beam source edit window shows the same function.\r\n\r\n$$ \\\\theta(f) = \\\\arcsin\\\\bigg[\\\\frac{sin(\\\\theta\\_{sim})f\\_{sim}}{f}\\\\bigg]$$\r\n\r\n| **Syntax**                                | **Description**                                                                                         |\r\n| ----------------------------------------- | ------------------------------------------------------------------------------------------------------- |\r\n| theta = getsourceangle( \"sourcename\", f); | Returns the source angle theta (degrees) as a function of frequency. f is a vector of frequencies (Hz). |\r\n\r\n**Example**\r\n\r\nThis example shows how to get the source injection angle as a function of frequency. The\r\nsource frequency range is 300-600THz, and the nominal source angle theta is 10 degrees.\r\n\r\n```\r\nf_max=600e12;  \r\nf_min=300e12;  \r\nf=linspace(f_min,f_max,5);  \r\n\r\n?theta_f=getsourceangle(\"source1\",f);  \r\nresult:   \r\n15.0981   \r\n12.0273   \r\n10   \r\n8.55978   \r\n7.48324  \r\n```",
    "summary": "Returns the source angle theta as a function of frequency",
    "syntax": [
      {
        "syntax": "theta = getsourceangle( \"sourcename\", f);",
        "description": "Returns the source angle theta (degrees) as a function of frequency. f is a vector of frequencies (Hz)."
      }
    ],
    "example": "f_max=600e12;  \r\nf_min=300e12;  \r\nf=linspace(f_min,f_max,5);  \r\n\r\n?theta_f=getsourceangle(\"source1\",f);  \r\nresult:   \r\n15.0981   \r\n12.0273   \r\n10   \r\n8.55978   \r\n7.48324"
  },
  {
    "name": "getsourcedirection",
    "description": "Returns a unit vector in the direction of the wave vector (or k-vector) of the specified source. The unit vector has three elements corresponding to the X,Y and Z directions.",
    "usage": "getsourcedirection();",
    "category": "general",
    "markdown": "# getsourcedirection\r\n\r\nReturns a unit vector in the direction of the wave vector (or k-vector) of the specified\r\nsource. The unit vector has three elements corresponding to the X,Y and Z directions.\r\n\r\n| **Syntax**                              | **Description**                                                                                 |\r\n| --------------------------------------- | ----------------------------------------------------------------------------------------------- |\r\n| out = getsourcedirection(\"sourcename\"); | Returns a [3x1] matrix with a unit vector in the direction of the specified source wave vector. |\r\n\r\n| **Parameter** |          | **Default value** | **Type** | **Description**     |\r\n| ------------- | -------- | ----------------- | -------- | ------------------- |\r\n| sourcename    | required |                   | string   | Name of the source. |\r\n\r\n**Example**\r\n\r\nThis example computes a unit vector in direction of the k-vector of the plane wave\r\nsource named \"source\".\r\n\r\n```\r\nsource_k = getsourcedirection(\"DGTD::source\"); \r\n```",
    "summary": "Returns a unit vector in the direction of the wave vector (or k-vector) of the specified source",
    "syntax": [
      {
        "syntax": "out = getsourcedirection(\"sourcename\");",
        "description": "Returns a [3x1] matrix with a unit vector in the direction of the specified source wave vector."
      }
    ],
    "example": "source_k = getsourcedirection(\"DGTD::source\");"
  },
  {
    "name": "getsurfaceconductivity",
    "description": "For materials which use a surface conductivity material model (such as Graphene), this function returns the complex index of any material that is in the material database. The surface conductivity at the specified frequency is interpolated from the neighboring frequencies where the conductivity data is available. For a list of materials which use the surface conductivity model, see [ Material conductivity models ](https://optics.ansys.com/hc/en-us/articles/360034915113-Material-Conductivity-Models) .",
    "usage": "getsurfaceconductivity();",
    "category": "general",
    "markdown": "# getsurfaceconductivity\r\n\r\nFor materials which use a surface conductivity material model (such as Graphene), this\r\nfunction returns the complex index of any material that is in the material database. The\r\nsurface conductivity at the specified frequency is interpolated from the neighboring\r\nfrequencies where the conductivity data is available. For a list of materials which use\r\nthe surface conductivity model, see\r\n[ Material conductivity models ](https://optics.ansys.com/hc/en-us/articles/360034915113-Material-Conductivity-Models)\r\n.\r\n\r\n| **Syntax**                                             | **Description**                                                                                                                                                                     |\r\n| ------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = getsurfaceconductivity( \"materialname\", f);      | Returns the surface conductivity (in units of S) of the material with the given name. The surface conductivity is returned for the specified frequency f where f is in units of Hz. |\r\n| getsurfaceconductivity( \"materialname\", f, component); | Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1.                                                        |",
    "summary": "For materials which use a surface conductivity material model (such as Graphene), this function retu...",
    "syntax": [
      {
        "syntax": "out = getsurfaceconductivity( \"materialname\", f);",
        "description": "Returns the surface conductivity (in units of S) of the material with the given name. The surface conductivity is returned for the specified frequency f where f is in units of Hz."
      },
      {
        "syntax": "getsurfaceconductivity( \"materialname\", f, component);",
        "description": "Optional argument component can be 1, 2 or 3 to specify the x, y or z component for anisotropic materials. The default is 1."
      }
    ],
    "example": ""
  },
  {
    "name": "getsweep",
    "description": "Gets a property from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item.",
    "usage": "getsweep();",
    "category": "general",
    "markdown": "# getsweep\r\n\r\nGets a property from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item.\r\n\r\n| **Syntax**                         | **Description**                                                                                                                                                                                                                        |\r\n| ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| getsweep(\"name\", \"property_name\"); | Gets a property from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item. \"name\" is the absolute name of an analysis item. \"property_name\" is the property showed in the edit window. Returns the value of the property. |\r\n| ?getsweep(\"name\");                 | Lists the properties that are available from the analysis item.                                                                                                                                                                        |\r\n\r\n**Example**\r\n\r\nThis example shows how to get a property from a parameter sweep. Please download the\r\nexample file from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\n?getsweep(\"thickness_sweep\", \"thickness\");\r\n> Struct with fields:\r\n> name\r\n> parameter\r\n> start\r\n> stop\r\n> type\r\n```",
    "summary": "Gets a property from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item",
    "syntax": [
      {
        "syntax": "getsweep(\"name\", \"property_name\");",
        "description": "Gets a property from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item. \"name\" is the absolute name of an analysis item. \"property_name\" is the property showed in the edit window. Returns the value of the property."
      },
      {
        "syntax": "?getsweep(\"name\");",
        "description": "Lists the properties that are available from the analysis item."
      }
    ],
    "example": "?getsweep(\"thickness_sweep\", \"thickness\");\r\n> Struct with fields:\r\n> name\r\n> parameter\r\n> start\r\n> stop\r\n> type"
  },
  {
    "name": "getsweepdata",
    "description": "Gets raw data from a parameter sweep/optimization/Monte Carlo analysis. In most cases, it is more convenient to get a complete dataset with getsweepresult , rather than getting individual data elements with getsweepdata .",
    "usage": "getsweepdata();",
    "category": "general",
    "markdown": "# getsweepdata\r\n\r\nGets raw data from a parameter sweep/optimization/Monte Carlo analysis. In most cases,\r\nit is more convenient to get a complete dataset with getsweepresult , rather than\r\ngetting individual data elements with getsweepdata .\r\n\r\n| **Syntax**                                | **Description**                                                                                                               |\r\n| ----------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |\r\n| ?getsweepdata;                            | Returns names of all sweep, optimization, and Monte Carlo analysis objects.                                                   |\r\n| ?getsweepdata(\"sweep_name\");              | Returns all the names of the available data which is stored in the sweep, optimization, or Monte Carlo analysis object.       |\r\n| out = getsweepdata(\"sweep_name\", \"data\"); | Returns parameter sweep, optimization, or Monte Carlo analysis data. The following data can be obtained from an optimization: |\r\n\r\n- fomTrend - Figure of merit as a function of generation\r\n- fomHistory - Figure of merit history (for each generation there will be generation\r\n  size number)\r\n- bestFom - Best figure of merit obtained during sweep\r\n- bestParameter - Parameter which corresponds to bestFom\r\n- paramHistory - Parameter history\r\n\r\nFor a parameter sweep and Monte Carlo analysis, this command returns both parameters and\r\nresults.\r\n\r\n**Examples**\r\n\r\nThis example shows how to get data from a parameter sweep. Please download the example\r\nfile from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\nm=\"thickness_sweep\";\r\n?getsweepdata(m);\r\nth = getsweepdata(m,\"thickness\"); # get parameter from sweep\r\nR = getsweepdata(m,\"R\");# get result from sweep\r\nplot(th*1e6,R,\"thickness (microns)\",\"Reflection\");\r\n> R\r\n> T\r\n> thickness \r\n```\r\n\r\nThis example shows how to access data from an optimization.\r\n\r\n```\r\nm=\"thickness_optimization\";\r\n?getsweepdata(m);\r\ngenVec = getsweepdata(m,\"genVec\");       # Generation vector (1D vector, Ng)\r\nmemberVec = getsweepdata(m,\"memberVec\");    # Generation member vector (1D vector, Nm)\r\nfomTrend = getsweepdata(m,\"fomTrend\");     # Best of each generation, same as shown in Opt. GUI window (1D vector, Ng)\r\nparamsTrend = getsweepdata(m,\"paramsTrend\");  # Parameters corresponding to FOM trend (3D matrix, 1 x Np x Ng)\r\nbestFom = getsweepdata(m,\"bestFom\");      # Global best FOM\r\nbestParams = getsweepdata(m,\"bestParams\");   # Parameters corresponding to global best FOM (1D vector, Np)\r\nfomHistory = getsweepdata(m,\"fomHistory\");   # Every FOM calculated in optimization (2D maxtrix, Nm x Ng)\r\nparamHistory = getsweepdata(m,\"paramHistory\"); # Every parameter set used in optimization (3D maxtrix, Np x Nm x Ng)\r\nplot(genVec,fomTrend,\"generation number\",\"fom Trend\",\"best FOM of each generation\"); \r\n?\"Best FOM: \"+num2str(bestFom);\r\n?\"Best Params: \"+num2str(bestParams);\r\n?\"Total number of simulations run: \"+num2str(length(genVec)*length(memberVec));\r\nimage(memberVec,genVec,fomHistory,\"member\",\"generation\",\"All FOM's obtained\");\r\n> genVec\r\n> memberVec\r\n> paramsTrend\r\n> fomTrend\r\n> paramHistory\r\n> fomHistory\r\n> bestParams\r\n> bestFom\r\n> Best FOM: 0.00187328\r\n> Best Params: 5.96041e-008\r\n> Total number of simulations run: 50\r\n```",
    "summary": "Gets raw data from a parameter sweep/optimization/Monte Carlo analysis",
    "syntax": [
      {
        "syntax": "?getsweepdata;",
        "description": "Returns names of all sweep, optimization, and Monte Carlo analysis objects."
      },
      {
        "syntax": "?getsweepdata(\"sweep_name\");",
        "description": "Returns all the names of the available data which is stored in the sweep, optimization, or Monte Carlo analysis object."
      },
      {
        "syntax": "out = getsweepdata(\"sweep_name\", \"data\");",
        "description": "Returns parameter sweep, optimization, or Monte Carlo analysis data. The following data can be obtained from an optimization:"
      }
    ],
    "example": ""
  },
  {
    "name": "getsweepresult",
    "description": "Gets the parameter sweep/optimization/Monte Carlo/S-parameter sweep results in the form of a dataset.",
    "usage": "getsweepresult();",
    "category": "general",
    "markdown": "# getsweepresult\r\n\r\nGets the parameter sweep/optimization/Monte Carlo/S-parameter sweep results in the form\r\nof a dataset.\r\n\r\n| **Syntax**                                    | **Description**                                                                                                                |\r\n| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| ?getsweepresult;                              | Returns names of all sweep, optimization, Monte Carlo, and S-parameter sweep objects with available results.                   |\r\n| ?getsweepresult(\"sweep_name\");                | Returns names of the available results from the specified sweep, optimization,Monte Carlo, or S-parameter sweep task.          |\r\n| out = getsweepresult(\"sweep_name\", \"result\"); | Returns the specified result dataset from the specified parameter sweep, optimization, Monte Carlo, or S-parameter sweep task. |\r\n\r\n**Examples**\r\n\r\nThis example shows how to get data from a parameter sweep. Please download the example\r\nfile from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\n?getsweepresult(\"thickness_sweep\");\r\n?R = getsweepresult(\"thickness_sweep\",\"R\");\r\nimage(R.lambda*1e6,R.thickness*1e6,R.T,\"wavelength (um)\",\"thickness (um)\",\"reflection\");\r\n> R\r\n> T\r\n> thickness\r\n> T vs lambda/f, thickness\r\n```\r\n\r\nThis following commands show how to access optimization results:\r\n\r\nFirst, see the available data.\r\n\r\n```\r\nm=\"thickness_optimization\";\r\n?getsweepresult(m);\r\n> fom trend\r\n> best fom\r\n> parameter trend\r\n> best parameters\r\n> fom history\r\n> parameter history\r\n> genVec\r\n> memberVec\r\n> paramsTrend\r\n> fomTrend\r\n> paramHistory\r\n> fomHistory\r\n> bestParams\r\n> bestFom\r\n```\r\n\r\nFollowing is the description of each available result:\r\n\r\n```\r\nAvailable datasets\r\nfom trend :     Best result per generation. This is the quantity shown in the Optimization GUI window (1D vector, Ng)  \r\nbest fom :      Global best FOM. (Single value, not dataset) \r\nparameter trend :  Parameters corresponding to FOM trend (3D matrix, 1 x Np x Ng)\r\nbest parameters :  Parameters corresponding to global best FOM (1D vector, Np)\r\nfom history :    Every FOM calculated in optimization (2D maxtrix, Nm x Ng)\r\nparameter history : Every parameter set used in optimization (3D maxtrix, Np x Nm x Ng)\r\nAvailable raw data. The following quantities are simply the simple matrix versions of the above results\r\ngenVec :       Generation vector (1D vector, Ng)\r\nmemberVec :     Generation member vector (1D vector, Nm)\r\nparamsTrend :    Parameters corresponding to FOM trend (3D matrix, 1 x Np x Ng)\r\nfomTrend :      Best result per generation. This is the quantity shown in the Optimization GUI window\r\nparamHistory :    Every parameter set used in optimization (3D maxtrix, Np x Nm x Ng)\r\nfomHistory :     Every FOM calculated in optimization (2D maxtrix, Nm x Ng)\r\nbestParams :     Parameters corresponding to global best FOM (1D vector, Np)\r\nbestFom :      Global best FOM (Single value)\r\n```\r\n\r\nGet the global best Figure of merit\r\n\r\n```\r\n# get the best FOM\r\n?getsweepresult(\"thickness_optimization\",\"best fom\");\r\n> result: \r\n0.00187328\r\n```\r\n\r\nPlot the Figure of merit trend\r\n\r\n```\r\nFOMtrend = getsweepresult(\"thickness_optimization\",\"fom trend\");\r\nplot(FOMtrend.generation,FOMtrend.fom);\r\n```\r\n\r\nThe following script is an excerpt from the example script from\r\n[ S-parameter matrix sweep ](https://optics.ansys.com/hc/en-us/articles/360034403214-S-parameter-matrix-sweep)\r\nshowing how to collect the results from an S-parameter sweep.\r\n\r\n```\r\n# collect results\r\nS_matrix = getsweepresult(\"s-parameter sweep\",\"S matrix\");\r\nS_parameters = getsweepresult(\"s-parameter sweep\",\"S parameters\");\r\nS_diagnostic = getsweepresult(\"s-parameter sweep\",\"S diagnostic\");\r\n```",
    "summary": "Gets the parameter sweep/optimization/Monte Carlo/S-parameter sweep results in the form of a dataset",
    "syntax": [
      {
        "syntax": "?getsweepresult;",
        "description": "Returns names of all sweep, optimization, Monte Carlo, and S-parameter sweep objects with available results."
      },
      {
        "syntax": "?getsweepresult(\"sweep_name\");",
        "description": "Returns names of the available results from the specified sweep, optimization,Monte Carlo, or S-parameter sweep task."
      },
      {
        "syntax": "out = getsweepresult(\"sweep_name\", \"result\");",
        "description": "Returns the specified result dataset from the specified parameter sweep, optimization, Monte Carlo, or S-parameter sweep task."
      }
    ],
    "example": ""
  },
  {
    "name": "getvalue",
    "description": "Gets an internal value for an element's internal ‘s parameters’.",
    "usage": "getvalue();",
    "category": "general",
    "markdown": "# getvalue\r\n\r\nGets an internal value for an element's internal ‘s parameters’.\r\n\r\n| **Syntax**                                                                              | **Description**                                                                                                                                                                                                           |\r\n| --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| value=getvalue(\"element\", \"parameter\"); value=getvalue(\"element\", \"parameter\", \"type\"); | Gets an internal value for an element's internal ‘parameter’. Different from ‘set’ or ‘getnamed’, ‘getvalue’ can have direct access to internal element parameters. ‘type’ allows for variations for a given ‘parameter’. |\r\n\r\n**Example**\r\n\r\nThe following example gets the \"s parameter\" from the element \"SPAR_1\".\r\n\r\n```\r\n?getvalue(\"SPAR_1\", \"s parameters\");\r\nCell array with 3 elements\r\n```",
    "summary": "Gets an internal value for an element's internal ‘s parameters’",
    "syntax": [
      {
        "syntax": "value=getvalue(\"element\", \"parameter\"); value=getvalue(\"element\", \"parameter\", \"type\");",
        "description": "Gets an internal value for an element's internal ‘parameter’. Different from ‘set’ or ‘getnamed’, ‘getvalue’ can have direct access to internal element parameters. ‘type’ allows for variations for a given ‘parameter’."
      }
    ],
    "example": "?getvalue(\"SPAR_1\", \"s parameters\");\r\nCell array with 3 elements"
  },
  {
    "name": "getvariable",
    "description": "Returns the value of a workspace variable, if the value is not found it returns a ‘default’ value.",
    "usage": "getvariable();",
    "category": "general",
    "markdown": "# getvariable\r\n\r\nReturns the value of a workspace variable, if the value is not found it returns a\r\n‘default’ value.\r\n\r\n| **Syntax**                           | **Description**                                                                                    |\r\n| ------------------------------------ | -------------------------------------------------------------------------------------------------- |\r\n| out= getvariable (property,default); | Returns the value of a workspace variable, if the value is not found it returns a ‘default’ value. |\r\n\r\n**Examples**\r\n\r\n```\r\n?getvariable(\"variable\");\r\n```",
    "summary": "Returns the value of a workspace variable, if the value is not found it returns a ‘default’ value",
    "syntax": [
      {
        "syntax": "out= getvariable (property,default);",
        "description": "Returns the value of a workspace variable, if the value is not found it returns a ‘default’ value."
      }
    ],
    "example": ""
  },
  {
    "name": "getview",
    "description": "This command allows the viewing properties of the Layout Editor to be retrieved.",
    "usage": "getview();",
    "category": "general",
    "markdown": "# getview\r\n\r\nThis command allows the viewing properties of the Layout Editor to be retrieved.\r\n\r\n| **Syntax**           | **Description**                                                    |\r\n| -------------------- | ------------------------------------------------------------------ |\r\n| outstring = getview; | Returns a list of the view properties that can be set. The command |\r\n\r\n```\r\n?getview;\r\n```\r\n\r\nwill return\r\n\r\n```\r\nextent, zoom, theta, phi  \r\n```\r\n\r\nout = getview(\"property\"); | Returns the current value of any of the view properties.\r\nFor example,\r\n\r\n```\r\nzoom_level = getview(\"zoom\");\r\n```\r\n\r\nwill return the current zoom setting of the perspective view relative to the default\r\nlevel.\r\n\r\n## Note: The \"extent\" and \"zoom\" options for this command are not available in Finite Element IDE.\r\n\r\n**Example**\r\n\r\nThe properties that can be obtained with getview are described in\r\n[ setview ](./setview.md) .\r\n\r\n```\r\n?getview;\r\nextent, zoom, theta, phi\r\n```",
    "summary": "This command allows the viewing properties of the Layout Editor to be retrieved",
    "syntax": [
      {
        "syntax": "outstring = getview;",
        "description": "Returns a list of the view properties that can be set. The command"
      }
    ],
    "example": "?getview;\r\nextent, zoom, theta, phi"
  },
  {
    "name": "gpuspecs",
    "description": "Obtains specifications of all GPUs in the system and return as a cell array. Each element of the cell array represents a physical GPU installed in the system, and contains a structure with fields showing its specifications.",
    "usage": "gpuspecs();",
    "category": "general",
    "markdown": "# gpuspecs\r\n\r\nObtains specifications of all GPUs in the system and return as a cell array. Each\r\nelement of the cell array represents a physical GPU installed in the system, and\r\ncontains a structure with fields showing its specifications.\r\n\r\n| **Syntax** | **Description**                                                                                                                                                                    |\r\n| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| gpuspecs;  | Returns a cell array representing all installed GPUs in the system, elements to each cell are structs that show individual specifications. Details of each struct are shown below. |\r\n\r\nEach structure in the cell array will have the following fields\r\n\r\n| **Field**               | **Description**                                                       |\r\n| ----------------------- | --------------------------------------------------------------------- |\r\n| availableDeviceMemoryKb | Available Video RAM (VRAM) of the GPU in Kilobytes (KB).              |\r\n| bus                     | Index for the bus of the device                                       |\r\n| deviceSMCount           | Number of streaming microprocessors in the GPU.                       |\r\n| deviceTotalMemoryKb     | Total VRAM of the GPU in KB.                                          |\r\n| deviceUUID              | Unique Identifier for the GPU.                                        |\r\n| domain                  | The Peripheral Component Interconnect (PCI) domain of the device.     |\r\n| maxLinkSpeedMBPS        | Maximum link speed of the GPU’s PCI express (PCIe) interface in MPBS. |\r\n| maxlinkWidth            | Maximum link width of the GPU and its PCIe interface.                 |\r\n| memoryBusWidth          | Memory bus width of the GPU in Megabytes-per-second (MBPS).           |\r\n| nvmlDeviceIndex         | Index of GPU for Resource Configuration.                              |\r\n| userReadableDeviceName  | Human-readable name for the GPU.                                      |\r\n\r\n**Example**\r\n\r\nObtain the device index of the first detected GPU in the system\r\n\r\n```\r\ngpus_cell = gpuspecs; #save cell array of all GPU specs in gpus_cell  \r\n  \r\n?gpus_cell{1}.deviceIndex;  \r\n  \r\nresult:  \r\n  \r\n0\r\n```\r\n\r\nObtain streaming processor count for the first detected GPU in the system.\r\n\r\n```\r\n?gpus_cell{1}.deviceSMCount;  \r\n  \r\nresult:  \r\n  \r\n16\r\n```",
    "summary": "Obtains specifications of all GPUs in the system and return as a cell array",
    "syntax": [
      {
        "syntax": "gpuspecs;",
        "description": "Returns a cell array representing all installed GPUs in the system, elements to each cell are structs that show individual specifications. Details of each struct are shown below."
      }
    ],
    "example": "gpus_cell = gpuspecs; #save cell array of all GPU specs in gpus_cell  \r\n  \r\n?gpus_cell{1}.deviceIndex;  \r\n  \r\nresult:  \r\n  \r\n0"
  },
  {
    "name": "grating",
    "description": "Returns the fraction of transmitted power to each physical grating orders for a given simulation. Results are normalized such that the sum of all the orders is equal to 1. To convert these values into fractions of the source power, multiply by the the transmission script function.",
    "usage": "grating();",
    "category": "general",
    "markdown": "# grating\r\n\r\nReturns the fraction of transmitted power to each physical grating orders for a given\r\nsimulation. Results are normalized such that the sum of all the orders is equal to 1. To\r\nconvert these values into fractions of the source power, multiply by the the\r\ntransmission script function.\r\n\r\n3D simulations: Data is returned in a NxMxP matrix where N,M are the number of grating\r\norders, and P is the number of frequency points.\r\n\r\n2D simulations: Data is returned in a NxP matrix where N is the number of grating\r\norders, and P is the number of frequency points.\r\n\r\n| **Syntax**                                         | **Description**                                                       |\r\n| -------------------------------------------------- | --------------------------------------------------------------------- |\r\n| out = grating(\"monitorname\",f, index, direction ); | Returns the strength of all physical grating orders from monitorname. |\r\n\r\n| **Parameter** |          | **Default value**           | **Type** | **Description**                                                                                                                                                                                      |\r\n| ------------- | -------- | --------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| monitorname   | required |                             | string   | name of the monitor from which far field is calculated                                                                                                                                               |\r\n| f             | optional | 1                           | vector   | Index of the desired frequency point. This can be a single number or a vector. Multithreaded projection to allow multiple frequency points to be calculated simultaneously was introduced in R2016b. |\r\n| index         | optional | value at monitor center     | number   | The index of the material to use for the projection.                                                                                                                                                 |\r\n| direction     | optional | direction of max power flow | number   | Direction: this can be +1 or -1.                                                                                                                                                                     |\r\n\r\nThe following table summarizes how to interpret the coordinate vector properties for\r\nvarious monitor orientations.\r\n\r\n| **Monitor orientation** | **Monitor surface normal** | **'N', 'ux', 'gratingn', 'gratingperiod1', 'gratingu1', 'gratingbloch1', correspond to** | **'M', 'uy', 'gratingm', 'gratingperiod2', 'gratingu2', 'gratingbloch2' correspond to** |\r\n| ----------------------- | -------------------------- | ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |\r\n| XY plane                | Z                          | x axis                                                                                   | y axis                                                                                  |\r\n| XZ plane                | Y                          | x axis                                                                                   | z axis                                                                                  |\r\n| YZ plane                | X                          | y axis                                                                                   | z axis                                                                                  |\r\n\r\n**Example**\r\n\r\nThis 2D example plots the relative strength of the grating orders.\r\n\r\n```\r\nmname=\"T\";          # monitor name\r\ntheta=gratingangle(mname);  # angle of each grating order\r\nG=grating(mname);      # power to each order (fraction of transmitted power)\r\nplot(theta,G,\"theta (deg)\",\"relative power\",\"grating orders\",\"plot points\");\r\n```\r\n\r\nThis 3D example calculates various grating quantities.\r\n\r\n```\r\nmname=\"T\";       # monitor name\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\nT=transmission(mname); # total power transmitted through monitor (fraction of source power)\r\n# Print all grating orders to prompt. Results will sum to 1.\r\n# Then normalize grating results to the injected source power.\r\n?G;  # grating results\r\n?G*T; # normalized to source power\r\n# find strength and direction of 0,0 grating order\r\nnx=find(N,0); # find 0th grating order\r\nny=find(M,0); # find 0th grating order\r\n?\"Grating order 0,0 strength: \" + num2str( G(nx,ny) );\r\n?\"Grating order 0,0 direction: Ux=\" +num2str(u1(nx)) + \" Uy=\" +num2str(u2(ny));\r\n# image all grating orders, using log scale\r\nimage(u1,u2,G,\"ux\",\"uy\",\"Grating order strength\",\"logplot\");\r\n```\r\n\r\nCalculate the zeroth grating order transmission from a monitor that recorded multiple\r\nfrequency points. The grating function operates on one frequency point at a time, so a\r\nfor loop is required.\r\n\r\n```\r\nmname=\"T\";       # monitor name\r\nf=getdata(mname,\"f\");  # get frequency vector\r\nT=transmission(mname); # get total transmission\r\nG00 = matrix(length(f)); # initialize matrix\r\n# get 0,0 grating order for each frequency\r\nfor (i=1:length(T)) {\r\n N=gratingn(mname,i);  # grating order numbers\r\n M=gratingm(mname,i); \r\n temp=grating(\"T2\",i);\r\n G00(i) = temp(find(N,0),find(M,0)); # select 0,0 grating order\r\n}\r\nplot(c/f*1e6,T,G00*T,\"wavelength (um)\",\"power\");\r\nlegend(\"total transmission\",\"0,0 grating transmission\"); \r\n```",
    "summary": "Returns the fraction of transmitted power to each physical grating orders for a given simulation",
    "syntax": [
      {
        "syntax": "out = grating(\"monitorname\",f, index, direction );",
        "description": "Returns the strength of all physical grating orders from monitorname."
      }
    ],
    "example": "mname=\"T\";          # monitor name\r\ntheta=gratingangle(mname);  # angle of each grating order\r\nG=grating(mname);      # power to each order (fraction of transmitted power)\r\nplot(theta,G,\"theta (deg)\",\"relative power\",\"grating orders\",\"plot points\");"
  },
  {
    "name": "gratingangle",
    "description": "Returns the angle vector corresponding to the values returned by grating, in degrees, for 2D simulations. For 3D simulations, use gratingu1 and gratingu2.",
    "usage": "gratingangle();",
    "category": "general",
    "markdown": "# gratingangle\r\n\r\nReturns the angle vector corresponding to the values returned by grating, in degrees,\r\nfor 2D simulations. For 3D simulations, use gratingu1 and gratingu2.\r\n\r\nIf Bloch boundary conditions are used, the Bloch vector must be properly set for this\r\ncommand to return the correct results. To make sure the Bloch vector is properly set,\r\nturn on the \"set based on source angle\" option in the \"Boundary conditions\" tab of the\r\nFDTD solver settings.\r\n\r\n| **Syntax**                               | **Description**                     |\r\n| ---------------------------------------- | ----------------------------------- |\r\n| out = gratingangle( \"monitorname\", ...); | Same arguments as grating function. |\r\n\r\n**Example**\r\n\r\nThis example plots the relative strength of the grating orders.\r\n\r\n```\r\nmname=\"T\";          # monitor name\r\ntheta=gratingangle(mname);  # angle of each grating order\r\nG=grating(mname);      # power to each order (fraction of transmitted power)\r\nplot(theta,G,\"theta (deg)\",\"relative power\",\"grating orders\",\"plot points\");\r\n```",
    "summary": "Returns the angle vector corresponding to the values returned by grating, in degrees, for 2D simulat...",
    "syntax": [
      {
        "syntax": "out = gratingangle( \"monitorname\", ...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": "mname=\"T\";          # monitor name\r\ntheta=gratingangle(mname);  # angle of each grating order\r\nG=grating(mname);      # power to each order (fraction of transmitted power)\r\nplot(theta,G,\"theta (deg)\",\"relative power\",\"grating orders\",\"plot points\");"
  },
  {
    "name": "gratingbloch1",
    "description": "Returns the bloch vector (k in_1 and k in_2 ) used in the grating calculation. This corresponds to the bloch vector setting in the simulation region. gratingbloch1 gives the bloch vector for the first dimension (2D and 3D). gratingbloch2 gives the bloch vector for the 2nd dimension (3D only). See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingbloch1();",
    "category": "general",
    "markdown": "# gratingbloch1\r\n\r\nReturns the bloch vector (k in_1 and k in_2 ) used in the grating calculation. This\r\ncorresponds to the bloch vector setting in the simulation region. gratingbloch1 gives\r\nthe bloch vector for the first dimension (2D and 3D). gratingbloch2 gives the bloch\r\nvector for the 2nd dimension (3D only). See the grating function documentation for\r\ninformation on interpreting N, M, ux, uy for various monitor orientations.\r\n\r\n| **Syntax**                                | **Description**                     |\r\n| ----------------------------------------- | ----------------------------------- |\r\n| out = gratingbloch1( \"monitorname\", ...); | Same arguments as grating function. |",
    "summary": "Returns the bloch vector (k in_1 and k in_2 ) used in the grating calculation",
    "syntax": [
      {
        "syntax": "out = gratingbloch1( \"monitorname\", ...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": ""
  },
  {
    "name": "gratingbloch2",
    "description": "Returns the bloch vector (k in_1 and k in_2 ) used in the grating calculation. This corresponds to the bloch vector setting in the simulation region. gratingbloch1 gives the bloch vector for the first dimension (2D and 3D). gratingbloch2 gives the bloch vector for the 2nd dimension (3D only). See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingbloch2();",
    "category": "general",
    "markdown": "# gratingbloch2\r\n\r\nReturns the bloch vector (k in_1 and k in_2 ) used in the grating calculation. This\r\ncorresponds to the bloch vector setting in the simulation region. gratingbloch1 gives\r\nthe bloch vector for the first dimension (2D and 3D). gratingbloch2 gives the bloch\r\nvector for the 2nd dimension (3D only). See the grating function documentation for\r\ninformation on interpreting N, M, ux, uy for various monitor orientations.\r\n\r\n| **Syntax**                                | **Description**                     |\r\n| ----------------------------------------- | ----------------------------------- |\r\n| out = gratingbloch2( \"monitorname\", ...); | Same arguments as grating function. |",
    "summary": "Returns the bloch vector (k in_1 and k in_2 ) used in the grating calculation",
    "syntax": [
      {
        "syntax": "out = gratingbloch2( \"monitorname\", ...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": ""
  },
  {
    "name": "gratingm",
    "description": "Returns a vector of the grating order numbers (i.e. zeroeth order, first order) corresponding to the data from the grating function. gratingn gives the order numbers for the first dimension of the data (2D and 3D). gratingm gives the order numbers for the 2nd dimension (3D only). See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingm();",
    "category": "general",
    "markdown": "# gratingm\r\n\r\nReturns a vector of the grating order numbers (i.e. zeroeth order, first order)\r\ncorresponding to the data from the grating function. gratingn gives the order numbers\r\nfor the first dimension of the data (2D and 3D). gratingm gives the order numbers for\r\nthe 2nd dimension (3D only). See the grating function documentation for information on\r\ninterpreting N, M, ux, uy for various monitor orientations.\r\n\r\n| **Syntax**                          | **Description**                     |\r\n| ----------------------------------- | ----------------------------------- |\r\n| out = gratingm( \"monitorname\",...); | Same arguments as grating function. |\r\n\r\n**Example**\r\n\r\nThis example calculates various grating quantities.\r\n\r\n```\r\nmname=\"T\";       # monitor name\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\nT=transmission(mname); # total power transmitted through monitor (fraction of source power)\r\n# Print all grating orders to prompt. Results will sum to 1.\r\n# Then normalize grating results to the injected source power.\r\n?G;  # grating results\r\n?G*T; # normalized to source power\r\n# find strength and direction of 0,0 grating order\r\nnx=find(N,0); # find 0th grating order\r\nny=find(M,0); # find 0th grating order\r\n?\"Grating order 0,0 strength: \" + num2str( G(nx,ny) );\r\n?\"Grating order 0,0 direction: Ux=\" +num2str(u1(nx)) + \" Uy=\" +num2str(u2(ny));\r\n# image all grating orders, using log scale\r\nimage(u1,u2,G,\"ux\",\"uy\",\"Grating order strength\",\"logplot\");\r\n```",
    "summary": "Returns a vector of the grating order numbers (i",
    "syntax": [
      {
        "syntax": "out = gratingm( \"monitorname\",...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": "mname=\"T\";       # monitor name\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\nT=transmission(mname); # total power transmitted through monitor (fraction of source power)\r\n# Print all grating orders to prompt. Results will sum to 1.\r\n# Then normalize grating results to the injected source power.\r\n?G;  # grating results\r\n?G*T; # normalized to source power\r\n# find strength and direction of 0,0 grating order\r\nnx=find(N,0); # find 0th grating order\r\nny=find(M,0); # find 0th grating order\r\n?\"Grating order 0,0 strength: \" + num2str( G(nx,ny) );\r\n?\"Grating order 0,0 direction: Ux=\" +num2str(u1(nx)) + \" Uy=\" +num2str(u2(ny));\r\n# image all grating orders, using log scale\r\nimage(u1,u2,G,\"ux\",\"uy\",\"Grating order strength\",\"logplot\");"
  },
  {
    "name": "gratingn",
    "description": "Returns a vector of the grating order numbers (i.e. zeroeth order, first order) corresponding to the data from the grating function. gratingn gives the order numbers for the first dimension of the data (2D and 3D). gratingm gives the order numbers for the 2nd dimension (3D only). See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingn();",
    "category": "general",
    "markdown": "# gratingn\r\n\r\nReturns a vector of the grating order numbers (i.e. zeroeth order, first order)\r\ncorresponding to the data from the grating function. gratingn gives the order numbers\r\nfor the first dimension of the data (2D and 3D). gratingm gives the order numbers for\r\nthe 2nd dimension (3D only). See the grating function documentation for information on\r\ninterpreting N, M, ux, uy for various monitor orientations.\r\n\r\n| **Syntax**                          | **Description**                     |\r\n| ----------------------------------- | ----------------------------------- |\r\n| out = gratingn( \"monitorname\",...); | Same arguments as grating function. |\r\n\r\n**Example**\r\n\r\nThis example calculates various grating quantities.\r\n\r\n```\r\nmname=\"T\";       # monitor name\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\nT=transmission(mname); # total power transmitted through monitor (fraction of source power)\r\n# Print all grating orders to prompt. Results will sum to 1.\r\n# Then normalize grating results to the injected source power.\r\n?G;  # grating results\r\n?G*T; # normalized to source power\r\n# find strength and direction of 0,0 grating order\r\nnx=find(N,0); # find 0th grating order\r\nny=find(M,0); # find 0th grating order\r\n?\"Grating order 0,0 strength: \" + num2str( G(nx,ny) );\r\n?\"Grating order 0,0 direction: Ux=\" +num2str(u1(nx)) + \" Uy=\" +num2str(u2(ny));\r\n# image all grating orders, using log scale\r\nimage(u1,u2,G,\"ux\",\"uy\",\"Grating order strength\",\"logplot\");\r\n```",
    "summary": "Returns a vector of the grating order numbers (i",
    "syntax": [
      {
        "syntax": "out = gratingn( \"monitorname\",...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": "mname=\"T\";       # monitor name\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\nT=transmission(mname); # total power transmitted through monitor (fraction of source power)\r\n# Print all grating orders to prompt. Results will sum to 1.\r\n# Then normalize grating results to the injected source power.\r\n?G;  # grating results\r\n?G*T; # normalized to source power\r\n# find strength and direction of 0,0 grating order\r\nnx=find(N,0); # find 0th grating order\r\nny=find(M,0); # find 0th grating order\r\n?\"Grating order 0,0 strength: \" + num2str( G(nx,ny) );\r\n?\"Grating order 0,0 direction: Ux=\" +num2str(u1(nx)) + \" Uy=\" +num2str(u2(ny));\r\n# image all grating orders, using log scale\r\nimage(u1,u2,G,\"ux\",\"uy\",\"Grating order strength\",\"logplot\");"
  },
  {
    "name": "gratingordercount",
    "description": "Returns the total number of supported grating numbers.",
    "usage": "gratingordercount();",
    "category": "general",
    "markdown": "# gratingordercount\r\n\r\nReturns the total number of supported grating numbers.\r\n\r\n| **Syntax**                                                    | **Description**                                                                                 |\r\n| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |\r\n| out = gratingordercount( \"monitorname\", f, index, direction); | Returns the total number of supported grating orders. Same arguments as grating script command. |\r\n\r\n**Example**\r\n\r\nThis example calculates power to each order only if grating orders are supported.\r\n\r\n```\r\nmname=\"T\";       # monitor name\r\nif(gratingordercount(mname) > 0){\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\n}\r\n```",
    "summary": "Returns the total number of supported grating numbers",
    "syntax": [
      {
        "syntax": "out = gratingordercount( \"monitorname\", f, index, direction);",
        "description": "Returns the total number of supported grating orders. Same arguments as grating script command."
      }
    ],
    "example": "mname=\"T\";       # monitor name\r\nif(gratingordercount(mname) > 0){\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\n}"
  },
  {
    "name": "gratingorders",
    "description": "Returns a matrix data set with the propagating grating orders, a unit vector in the direction of the wave vector (or k-vector) of each order, and the grating angles. The grating orders are the same as those used by the gratingprojection command to perform a projection.",
    "usage": "gratingorders();",
    "category": "general",
    "markdown": "# gratingorders\r\n\r\nReturns a matrix data set with the propagating grating orders, a unit vector in the\r\ndirection of the wave vector (or k-vector) of each order, and the grating angles. The\r\ngrating orders are the same as those used by the gratingprojection command to perform a\r\nprojection.\r\n\r\n| **Syntax**                                             | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = gratingorders(period, source, frequency, index); | Returns a matrix data set with the propagating grating orders (integers n and m), a unit vector in the direction of the k-vector of each order (call them **u** (n,m)) and their corresponding angles (theta and phi). The parameters of the data set are n,m and frequency. Indexes n and m correspond to the first and second periodicity directions specified by the input periodicity vectors. The attributes of the data set are the unit vectors **u** (n,m) and their corresponding angles (theta and phi). The grating angles are defined with respect to the normal incidence direction of the source (call it the **n** -axis). The first angle (theta) is an elevation from the **n** -axis and the and the second angle (phi) is a rotation around the **n** -axis starting from the first periodicity vector. Angle phi is only returned when two periodicity vectors are specified. |\r\n\r\n| **Parameter** |          | **Default value** | **Type**         | **Description**                                                                                                                                              |\r\n| ------------- | -------- | ----------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| period        | required |                   | vector           | [3x1] or [3x2] matrix with the periodicity vectors. These are typically retrieved using the getperiodicity command.                                          |\r\n| source        | required |                   | vector           | [3x1] vector with the normalized source k-vector. This is typically retrieved using the getsourcedirection command.                                          |\r\n| frequency     | required |                   | vector           | Vector of frequencies (in Hz).                                                                                                                               |\r\n| index         | optional | 1.0               | number or vector | Refractive index of the background medium (typically the substrate or superstrate). It can be a scalar or a vector of the same size as the frequency vector. |\r\n\r\n**Example**\r\n\r\nThis example shows how to find the propagating grating orders from a DGTD simulation\r\nwith periodic boundary conditions. The source k-vector and frequency are obtained from\r\nand plane wave source object named \"source\" and a frequency domain monitor named\r\n\"monitor\", respectively.\r\n\r\n```\r\n# frequency vector of the near fields\r\nfields = getresult(\"DGTD::monitor\",\"fields\");\r\nfrequency = fields.f; \r\n# periodicity vectors\r\nperiod = getperiodicity(\"DGTD\");\r\n# source k-vector\r\nsource_k = getsourcedirection(\"DGTD::source\");\r\n# propagating grating orders\r\ngo = gratingorders(period,source_k,frequency,1.0);\r\nvisualize(go); \r\n```",
    "summary": "Returns a matrix data set with the propagating grating orders, a unit vector in the direction of the...",
    "syntax": [
      {
        "syntax": "out = gratingorders(period, source, frequency, index);",
        "description": "Returns a matrix data set with the propagating grating orders (integers n and m), a unit vector in the direction of the k-vector of each order (call them u (n,m)) and their corresponding angles (theta and phi). The parameters of the data set are n,m and frequency. Indexes n and m correspond to the first and second periodicity directions specified by the input periodicity vectors. The attributes of the data set are the unit vectors u (n,m) and their corresponding angles (theta and phi). The grating angles are defined with respect to the normal incidence direction of the source (call it the n -axis). The first angle (theta) is an elevation from the n -axis and the and the second angle (phi) is a rotation around the n -axis starting from the first periodicity vector. Angle phi is only returned when two periodicity vectors are specified."
      }
    ],
    "example": "# frequency vector of the near fields\r\nfields = getresult(\"DGTD::monitor\",\"fields\");\r\nfrequency = fields.f; \r\n# periodicity vectors\r\nperiod = getperiodicity(\"DGTD\");\r\n# source k-vector\r\nsource_k = getsourcedirection(\"DGTD::source\");\r\n# propagating grating orders\r\ngo = gratingorders(period,source_k,frequency,1.0);\r\nvisualize(go);"
  },
  {
    "name": "gratingperiod1",
    "description": "Returns the grating period (i.e. the simulation span) used in the grating calculations. gratingperiod1 gives the grating period for the first dimension (2D and 3D). gratingperiod2 gives the period of the 2nd dimension (3D only). See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingperiod1();",
    "category": "general",
    "markdown": "# gratingperiod1\r\n\r\nReturns the grating period (i.e. the simulation span) used in the grating calculations.\r\ngratingperiod1 gives the grating period for the first dimension (2D and 3D).\r\ngratingperiod2 gives the period of the 2nd dimension (3D only). See the grating function\r\ndocumentation for information on interpreting N, M, ux, uy for various monitor\r\norientations.\r\n\r\n| **Syntax**                                 | **Description**                     |\r\n| ------------------------------------------ | ----------------------------------- |\r\n| out = gratingperiod1( \"monitorname\", ...); | Same arguments as grating function. |",
    "summary": "Returns the grating period (i",
    "syntax": [
      {
        "syntax": "out = gratingperiod1( \"monitorname\", ...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": ""
  },
  {
    "name": "gratingperiod2",
    "description": "Returns the grating period (i.e. the simulation span) used in the grating calculations. gratingperiod1 gives the grating period for the first dimension (2D and 3D). gratingperiod2 gives the period of the 2nd dimension (3D only). See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingperiod2();",
    "category": "general",
    "markdown": "# gratingperiod2\r\n\r\nReturns the grating period (i.e. the simulation span) used in the grating calculations.\r\ngratingperiod1 gives the grating period for the first dimension (2D and 3D).\r\ngratingperiod2 gives the period of the 2nd dimension (3D only). See the grating function\r\ndocumentation for information on interpreting N, M, ux, uy for various monitor\r\norientations.\r\n\r\n| **Syntax**                                 | **Description**                     |\r\n| ------------------------------------------ | ----------------------------------- |\r\n| out = gratingperiod2( \"monitorname\", ...); | Same arguments as grating function. |",
    "summary": "Returns the grating period (i",
    "syntax": [
      {
        "syntax": "out = gratingperiod2( \"monitorname\", ...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": ""
  },
  {
    "name": "gratingpolar",
    "description": "Returns the relative strength of all physical grating orders where vector field information is returned in spherical coordinates. This is useful when studying the polarization effects. The data is normalized such that the sum of |Er|^2+|Etheta|^2+",
    "usage": "gratingpolar();",
    "category": "general",
    "markdown": "# gratingpolar\r\n\r\nReturns the relative strength of all physical grating orders where vector field\r\ninformation is returned in spherical coordinates. This is useful when studying the\r\npolarization effects. The data is normalized such that the sum of |Er|^2+|Etheta|^2+\r\n|Ephi|^2 over all grating orders equals 1. See the\r\n[grating](https://optics.ansys.com/hc/en-us/articles/360034927213) function\r\ndocumentation for information on interpreting N, M, ux, uy for various monitor\r\norientations.\r\n\r\n3D simulations: Data is returned in a NxMxPx3 matrix where N,M are the number of grating\r\norders. P is the number of frequency points. The third dimension is Er, Etheta, Ephi.\r\n\r\n2D simulations: Data is returned in a NxPx3 matrix where N is the number of grating\r\norders. P is the number of frequency points. The second dimension is Er, Etheta, Ephi.\r\n\r\nThe results are returned on hemisphere 1m away. For more information on the basis used\r\nplease refer to\r\n[Understanding field polarization in far field projections](https://optics.ansys.com/hc/en-us/articles/360034914753)\r\n\r\n| **Syntax**                                         | **Description**                                                                                           |\r\n| -------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\r\n| out = gratingpolar( \"mname\", f, index, direction); | Returns the strength of all physical grating orders from the monitor. Output is in spherical coordinates. |\r\n\r\n| **Parameter** |          | **Default value**           | **Type** | **Description**                                                                |\r\n| ------------- | -------- | --------------------------- | -------- | ------------------------------------------------------------------------------ |\r\n| mname         | required |                             | string   | name of the monitor from which far field is calculated                         |\r\n| f             | optional | 1                           | vector   | Index of the desired frequency point. This can be a single number of a vector. |\r\n| index         | optional | value at monitor center     | number   | The index of the material to use for the projection.                           |\r\n| direction     | optional | direction of max power flow | number   | Direction: this can be +1 or -1.                                               |\r\n\r\n**Examples**\r\n\r\nThis 2D result shows that gratingpolar gives the same result as the grating function\r\nwhen we calculate |Er|^2+|Etheta|^2+ |Ephi|^2.\r\n\r\n```\r\n?Gp=gratingpolar(\"monitor1\");\r\nresult: \r\n-3.06956e-017+0i -0.069704-0.32201i 0+0i \r\n-3.66784e-018-1.46714e-017i -0.0813186-0.381864i 0+0i \r\n2.97089e-017+1.48545e-017i -0.670119-0.442682i 0+0i \r\n-4.78864e-018-3.83091e-017i -0.0585844-0.30093i 0+0i \r\n?sum(abs(Gp)^2,2);\r\nresult: \r\n0.108549 \r\n0.152433 \r\n0.645027 \r\n0.093991 \r\n?G=grating(\"monitor1\");\r\nresult: \r\n0.108549 \r\n0.152433 \r\n0.645027 \r\n0.093991 \r\n```",
    "summary": "Returns the relative strength of all physical grating orders where vector field information is retur...",
    "syntax": [],
    "example": ""
  },
  {
    "name": "gratingprojection",
    "description": "Takes the near fields from a frequency domain monitor together with the periodicity vectors of the system, the source wave vector and the background refractive index and performs a far field projection to determine the relative power in each propagating grating order.",
    "usage": "gratingprojection();",
    "category": "general",
    "markdown": "# gratingprojection\r\n\r\nTakes the near fields from a frequency domain monitor together with the periodicity\r\nvectors of the system, the source wave vector and the background refractive index and\r\nperforms a far field projection to determine the relative power in each propagating\r\ngrating order.\r\n\r\n| **Syntax**                                                 | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = gratingprojection(nearfield, period, source, index); | Returns a matrix data set with all the projection results. The parameters of the data set are the grating orders (integers n and m) and frequency. Indexes n and m correspond to the first and second periodicity directions specified by the input periodicity vectors. The attributes of the data set are the same as those returned by the gratingorders command with the addition of the relative power into each propagating grating order (called projection). The projection result is normalized so that its sum over all grating orders is always equal to one. The frequency parameter is the same as that of the input field data. |\r\n\r\n| **Parameter** |          | **Default value** | **Type**              | **Description**                                                                                                                                              |\r\n| ------------- | -------- | ----------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| nearfield     | required |                   | unstructured data set | Field data from a frequency domain monitor.                                                                                                                  |\r\n| period        | required |                   | vector                | Periodicity vector(s) as returned by the getperiodicity command.                                                                                             |\r\n| source        | required |                   | vector                | Source unit wave vector as returned by the getsourcedirection command.                                                                                       |\r\n| index         | optional | 1.0               | number or vector      | Refractive index of the background medium (typically the substrate or superstrate). It can be a scalar or a vector of the same size as the frequency vector. |\r\n\r\n**Example**\r\n\r\nThis example demonstrates how to calculate the relative power into each propagating\r\ngrating order for a DGTD simulation with periodic boundary conditions. The near fields\r\nare collected from a frequency domain monitor named \"monitor\". The source wave vector is\r\ncollected from a plane wave source named \"source\". The periodicity vectors are collected\r\nfrom the DGTD simulation object.\r\n\r\n```\r\n# unstructured data set with the near field\r\nfields = getresult(\"DGTD::monitor\",\"fields\");\r\n# periodicity vector\r\nperiod = getperiodicity(\"DGTD\");\r\n# normalized source k-vector\r\nsource_k = getsourcedirection(\"DGTD::source\");\r\n# grating projection\r\ngp = gratingprojection(fields,period,source_k);\r\nvisualize(gp); \r\n```",
    "summary": "Takes the near fields from a frequency domain monitor together with the periodicity vectors of the s...",
    "syntax": [
      {
        "syntax": "out = gratingprojection(nearfield, period, source, index);",
        "description": "Returns a matrix data set with all the projection results. The parameters of the data set are the grating orders (integers n and m) and frequency. Indexes n and m correspond to the first and second periodicity directions specified by the input periodicity vectors. The attributes of the data set are the same as those returned by the gratingorders command with the addition of the relative power into each propagating grating order (called projection). The projection result is normalized so that its sum over all grating orders is always equal to one. The frequency parameter is the same as that of the input field data."
      }
    ],
    "example": "# unstructured data set with the near field\r\nfields = getresult(\"DGTD::monitor\",\"fields\");\r\n# periodicity vector\r\nperiod = getperiodicity(\"DGTD\");\r\n# normalized source k-vector\r\nsource_k = getsourcedirection(\"DGTD::source\");\r\n# grating projection\r\ngp = gratingprojection(fields,period,source_k);\r\nvisualize(gp);"
  },
  {
    "name": "gratingu1",
    "description": "Returns the grating order direction unit vectors (u 1 and u 2 ) corresponding to the data from the grating function from 3D simulation. For 2D simulations, use the gratingangle function. See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingu1();",
    "category": "general",
    "markdown": "# gratingu1\r\n\r\nReturns the grating order direction unit vectors (u 1 and u 2 ) corresponding to the\r\ndata from the grating function from 3D simulation. For 2D simulations, use the\r\ngratingangle function. See the grating function documentation for information on\r\ninterpreting N, M, ux, uy for various monitor orientations.\r\n\r\n| **Syntax**                            | **Description**                     |\r\n| ------------------------------------- | ----------------------------------- |\r\n| out = gratingu1( \"monitorname\", ...); | Same arguments as grating function. |\r\n\r\n**Examples**\r\n\r\nThis example calculates various grating quantities.\r\n\r\n```\r\nmname=\"T\";       # monitor name\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\nT=transmission(mname); # total power transmitted through monitor (fraction of source power)\r\n# Print all grating orders to prompt. Results will sum to 1.\r\n# Then normalize grating results to the injected source power.\r\n?G;  # grating results\r\n?G*T; # normalized to source power\r\n# find strength and direction of 0,0 grating order\r\nnx=find(N,0); # find 0th grating order\r\nny=find(M,0); # find 0th grating order\r\n?\"Grating order 0,0 strength: \" + num2str( G(nx,ny) );\r\n?\"Grating order 0,0 direction: Ux=\" +num2str(u1(nx)) + \" Uy=\" +num2str(u2(ny));\r\n# image all grating orders, using log scale\r\nimage(u1,u2,G,\"ux\",\"uy\",\"Grating order strength\",\"logplot\");\r\n```",
    "summary": "Returns the grating order direction unit vectors (u 1 and u 2 ) corresponding to the data from the g...",
    "syntax": [
      {
        "syntax": "out = gratingu1( \"monitorname\", ...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": ""
  },
  {
    "name": "gratingu2",
    "description": "Returns the grating order direction unit vectors (u 1 and u 2 ) corresponding to the data from the grating function from 3D simulation. For 2D simulations, use the gratingangle function. See the grating function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingu2();",
    "category": "general",
    "markdown": "# gratingu2\r\n\r\nReturns the grating order direction unit vectors (u 1 and u 2 ) corresponding to the\r\ndata from the grating function from 3D simulation. For 2D simulations, use the\r\ngratingangle function. See the grating function documentation for information on\r\ninterpreting N, M, ux, uy for various monitor orientations.\r\n\r\n| **Syntax**                            | **Description**                     |\r\n| ------------------------------------- | ----------------------------------- |\r\n| out = gratingu2( \"monitorname\", ...); | Same arguments as grating function. |\r\n\r\n**Examples**\r\n\r\nThis example calculates various grating quantities.\r\n\r\n```\r\nmname=\"T\";       # monitor name\r\nN=gratingn(mname);   # grating order numbers\r\nM=gratingm(mname);\r\nu1=gratingu1(mname);  # grating unit vectors (can be converted to theta,phi)\r\nu2=gratingu2(mname);\r\nG=grating(mname);   # power to each order (fraction of transmitted power)\r\nT=transmission(mname); # total power transmitted through monitor (fraction of source power)\r\n# Print all grating orders to prompt. Results will sum to 1.\r\n# Then normalize grating results to the injected source power.\r\n?G;  # grating results\r\n?G*T; # normalized to source power\r\n# find strength and direction of 0,0 grating order\r\nnx=find(N,0); # find 0th grating order\r\nny=find(M,0); # find 0th grating order\r\n?\"Grating order 0,0 strength: \" + num2str( G(nx,ny) );\r\n?\"Grating order 0,0 direction: Ux=\" +num2str(u1(nx)) + \" Uy=\" +num2str(u2(ny));\r\n# image all grating orders, using log scale\r\nimage(u1,u2,G,\"ux\",\"uy\",\"Grating order strength\",\"logplot\");\r\n```",
    "summary": "Returns the grating order direction unit vectors (u 1 and u 2 ) corresponding to the data from the g...",
    "syntax": [
      {
        "syntax": "out = gratingu2( \"monitorname\", ...);",
        "description": "Same arguments as grating function."
      }
    ],
    "example": ""
  },
  {
    "name": "gratingvector",
    "description": "Returns the relative strength of all physical grating orders where vector field information is returned in Cartesian coordinates. This is useful when studying the polarization effects. The data is normalized such that the sum of |Ex|^2+|Ey|^2+ |Ez|^2 over all grating orders equals 1. See the [grating](https://optics.ansys.com/hc/en-us/articles/360034927213) function documentation for information on interpreting N, M, ux, uy for various monitor orientations.",
    "usage": "gratingvector();",
    "category": "general",
    "markdown": "# gratingvector\r\n\r\nReturns the relative strength of all physical grating orders where vector field\r\ninformation is returned in Cartesian coordinates. This is useful when studying the\r\npolarization effects. The data is normalized such that the sum of |Ex|^2+|Ey|^2+ |Ez|^2\r\nover all grating orders equals 1. See the\r\n[grating](https://optics.ansys.com/hc/en-us/articles/360034927213) function\r\ndocumentation for information on interpreting N, M, ux, uy for various monitor\r\norientations.\r\n\r\n3D simulations: Data is returned in a NxMxPx3 matrix where N,M are the number of grating\r\norders. P is the number of frequency points. The third dimension is Ex, Ey, Ez.\r\n\r\n2D simulations: Data is returned in a NxPx3 matrix where N is the number of grating\r\norders. P is the number of frequency points. The second dimension is Ex, Ey, Ez.\r\n\r\nThe results are returned on hemisphere 1m away. For more information on the basis used\r\nplease refer to\r\n[Understanding field polarization in far field projections](https://optics.ansys.com/hc/en-us/articles/360034914753)\r\n\r\n| **Syntax**                                          | **Description**                                                                                           |\r\n| --------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\r\n| out = gratingvector( \"mname\", f, index, direction); | Returns the strength of all physical grating orders from monitorname. Output is in Cartesian coordinates. |\r\n\r\n| **Parameter** |          | **Default value**           | **Type** | **Description**                                                                |\r\n| ------------- | -------- | --------------------------- | -------- | ------------------------------------------------------------------------------ |\r\n| mname         | required |                             | string   | name of the monitor from which far field is calculated                         |\r\n| f             | optional | 1                           | vector   | Index of the desired frequency point. This can be a single number or a vector. |\r\n| index         | optional | value at monitor center     | number   | The index of the material to use for the projection.                           |\r\n| direction     | optional | direction of max power flow | number   | Direction: this can be +1 or -1.                                               |\r\n\r\n**Examples**\r\n\r\nThis 2D result shows that gratingvector gives the same result as the grating function\r\nwhen we calculate |Ex|^2+|Ey|^2+ |Ez|^2.\r\n\r\n```\r\n?Gv=gratingvector(\"monitor1\");\r\nresult: \r\n0.0476203+0.219991i 0.0509014+0.235148i 0+0i \r\n0.0794422+0.373053i 0.0173684+0.0815601i 0+0i \r\n0.638599+0.42186i -0.203101-0.134169i 0+0i \r\n0.0335526+0.172349i -0.0480246-0.246687i 0+0i \r\n?sum(abs(Gv)^2,2);\r\nresult: \r\n0.108549 \r\n0.152433 \r\n0.645027 \r\n0.093991 \r\n?G=grating(\"monitor1\");\r\nresult: \r\n0.108549 \r\n0.152433 \r\n0.645027 \r\n0.093991 \r\n```",
    "summary": "Returns the relative strength of all physical grating orders where vector field information is retur...",
    "syntax": [
      {
        "syntax": "out = gratingvector( \"mname\", f, index, direction);",
        "description": "Returns the strength of all physical grating orders from monitorname. Output is in Cartesian coordinates."
      }
    ],
    "example": ""
  },
  {
    "name": "groupscope",
    "description": "Changes the group scope. Script commands that add or modify simulation object use the groupscope property to know where to act within the object tree. For example, if you want to delete everything within a particular group, set the groupscope to that group (i.e. ::model::my_group). If you want to delete all objects in the simulation, set the group scope the root level (i.e. ::model).",
    "usage": "groupscope();",
    "category": "general",
    "markdown": "# groupscope\r\n\r\nChanges the group scope. Script commands that add or modify simulation object use the\r\ngroupscope property to know where to act within the object tree. For example, if you\r\nwant to delete everything within a particular group, set the groupscope to that group\r\n(i.e. ::model::my_group). If you want to delete all objects in the simulation, set the\r\ngroup scope the root level (i.e. ::model).\r\n\r\n| **Syntax**                | **Description**                 |\r\n| ------------------------- | ------------------------------- |\r\n| ?groupscope;              | returns the current group scope |\r\n| groupscope(\"group_name\"); | changes the group scope         |\r\n\r\n**Example**\r\n\r\nCreate an analysis group with a Field and Index monitor.\r\n\r\n```\r\n#create a new FDTD simulation\r\nnewproject;\r\naddanalysisgroup;\r\nset(\"name\",\"Field_Index\");\r\n#change the group scope and add monitors to the group\r\ngroupscope(\"Field_Index\"); # same as groupscope(\"::model::Field_Index\");\r\naddpower; set(\"name\",\"field\");\r\naddindex; set(\"name\",\"index\");\r\nselectall;\r\nset(\"monitor type\",\"3D\");\r\nset(\"spatial interpolation\",\"nearest mesh cell\");\r\nset(\"x\",0); set(\"y\",0); set(\"z\",0);\r\nset(\"x span\",1e-6); set(\"y span\",1e-6); set(\"z span\",1e-6);\r\n# change the group scope back the the model\r\ngroupscope(\"::model\");\r\n# make a copy of the box\r\nselect(\"Field_Index\");\r\ncopy(2e-6,0,0);\r\n```",
    "summary": "Changes the group scope",
    "syntax": [
      {
        "syntax": "?groupscope;",
        "description": "returns the current group scope"
      },
      {
        "syntax": "groupscope(\"group_name\");",
        "description": "changes the group scope"
      }
    ],
    "example": "#create a new FDTD simulation\r\nnewproject;\r\naddanalysisgroup;\r\nset(\"name\",\"Field_Index\");\r\n#change the group scope and add monitors to the group\r\ngroupscope(\"Field_Index\"); # same as groupscope(\"::model::Field_Index\");\r\naddpower; set(\"name\",\"field\");\r\naddindex; set(\"name\",\"index\");\r\nselectall;\r\nset(\"monitor type\",\"3D\");\r\nset(\"spatial interpolation\",\"nearest mesh cell\");\r\nset(\"x\",0); set(\"y\",0); set(\"z\",0);\r\nset(\"x span\",1e-6); set(\"y span\",1e-6); set(\"z span\",1e-6);\r\n# change the group scope back the the model\r\ngroupscope(\"::model\");\r\n# make a copy of the box\r\nselect(\"Field_Index\");\r\ncopy(2e-6,0,0);"
  },
  {
    "name": "h5info",
    "description": "Returns information about the structure of an HDF5 file.",
    "usage": "h5info();",
    "category": "general",
    "markdown": "# h5info\r\n\r\nReturns information about the structure of an HDF5 file.\r\n\r\n| **Syntax**                 | **Description**                                                                                          |\r\n| -------------------------- | -------------------------------------------------------------------------------------------------------- |\r\n| info = h5info(\"filename\"); | Returns a struct \"info\" that contains information about the structure of the HDF5 file named \"filename.\" |\r\n\r\n| **Parameter** | **Type** | **Description**        |\r\n| ------------- | -------- | ---------------------- |\r\n| filename      | string   | name of the HDF5 file. |\r\n\r\n**Examples**\r\n\r\n```\r\nfilename = \"samplefile.h5\";\r\ninfo = h5info(filename);\r\n?info;\r\n> Struct with fields:\r\n> Attributes\r\n> Datasets\r\n> Datatypes\r\n> FileName\r\n> Groups\r\n> Name\r\n```\r\n\r\nThe struct containing the information about the HDF5 file has the following fields:\r\n\r\n| **Belongs to** | **Field**                                                                               | **Description**                                               |\r\n| -------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------------------- |\r\n| File           | Attributes                                                                              | structure containing a list of the attributes of the file.    |\r\n| Datasets       | structure containing a list of the datasets in the file.                                |                                                               |\r\n| Datatypes      | structure containing a list of the datatypes in the file.                               |                                                               |\r\n| Filename       | string containing the name of the file.                                                 |                                                               |\r\n| Groups         | structure containing a list of the top-level groups.                                    |                                                               |\r\n| Name           | string containing the path to the root. The value is always \"/\".                        |                                                               |\r\n| Groups         | Attributes                                                                              | structure containing a list of the attributes of the group.   |\r\n| Datasets       | structure containing a list of the datasets in the group.                               |                                                               |\r\n| Datatypes      | structure containing a list of the datatypes in the group.                              |                                                               |\r\n| Groups         | structure containing a list of the sub-groups within the group.                         |                                                               |\r\n| Name           | string containing the name (path) of the group.                                         |                                                               |\r\n| Datasets       | Attributes                                                                              | structure containing a list of the attributes of the dataset. |\r\n| Dataspace      | structure containing information about the size of the dataset.                         |                                                               |\r\n| Datatype       | structure containing information about the dataset type.                                |                                                               |\r\n| Name           | string containing the name (path) of the dataset.                                       |                                                               |\r\n| Propertylist   | structure containing various properties of the dataset such as fill value, filter, etc. |                                                               |\r\n| Datatypes      | Class                                                                                   | string containing the HDF5 class of the datatype.             |\r\n| Name           | string containing the name of the datatype.                                             |                                                               |\r\n| Size           | size of the datatype in bytes.                                                          |                                                               |\r\n| Type           | string describing the type of the datatype.                                             |                                                               |",
    "summary": "Returns information about the structure of an HDF5 file",
    "syntax": [
      {
        "syntax": "info = h5info(\"filename\");",
        "description": "Returns a struct \"info\" that contains information about the structure of the HDF5 file named \"filename.\""
      }
    ],
    "example": ""
  },
  {
    "name": "h5read",
    "description": "Reads data from an HDF5 file. The command supports a large number of dataset types such as integer, float, double, string, compound, etc.",
    "usage": "h5read();",
    "category": "general",
    "markdown": "# h5read\r\n\r\nReads data from an HDF5 file. The command supports a large number of dataset types such\r\nas integer, float, double, string, compound, etc.\r\n\r\n| **Syntax**                                 | **Description**                                                                       |\r\n| ------------------------------------------ | ------------------------------------------------------------------------------------- |\r\n| data = h5read(\"filename\", \"dataset_name\"); | Reads data in the dataset named \"dataset_name\" within the HDF5 file named \"filename.\" |\r\n\r\n| **Parameter** | **Type** | **Description**                        |\r\n| ------------- | -------- | -------------------------------------- |\r\n| filename      | string   | name of the HDF5 file.                 |\r\n| datasetname   | string   | name (path) of the dataset to be read. |\r\n\r\n**Examples**\r\n\r\n```\r\nfilename = \"samplefile.h5\";\r\ninfo = h5info(filename);\r\ndataset_name = info.Group{1}.Datasets{1}.Name;  # returns the name (path) of the first dataset in the first group\r\ndata = h5read(filename,dataset_name);\r\n```",
    "summary": "Reads data from an HDF5 file",
    "syntax": [
      {
        "syntax": "data = h5read(\"filename\", \"dataset_name\");",
        "description": "Reads data in the dataset named \"dataset_name\" within the HDF5 file named \"filename.\""
      }
    ],
    "example": ""
  },
  {
    "name": "h5readattr",
    "description": "Reads attributes from an HDF5 file.",
    "usage": "h5readattr();",
    "category": "general",
    "markdown": "# h5readattr\r\n\r\nReads attributes from an HDF5 file.\r\n\r\n| **Syntax**                                               | **Description**                                                                                          |\r\n| -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\r\n| attr = h5readattr(\"filename\", \"attr_path\", \"attr_name\"); | Reads the attribute named \"attr_name\" at the location \"attr_path\" within the HDF5 file named \"filename.\" |\r\n\r\n| **Parameter** | **Type** | **Description**                                                        |\r\n| ------------- | -------- | ---------------------------------------------------------------------- |\r\n| filename      | string   | name of the HDF5 file.                                                 |\r\n| attr_path     | string   | name (path) of the dataset or group to which the attribute belongs to. |\r\n| attr_name     | string   | name of the attribute to be read.                                      |\r\n\r\n**Examples**\r\n\r\n```\r\nfilename = \"samplefile.h5\";\r\nA = h5info(filename);\r\nattr_path = A.Groups{1}.Name;\r\nattr_name = A.Groups{1}.Attributes{1}.Name;\r\nattr = h5readattr(filename, attr_path, attr_name);\r\n```",
    "summary": "Reads attributes from an HDF5 file",
    "syntax": [
      {
        "syntax": "attr = h5readattr(\"filename\", \"attr_path\", \"attr_name\");",
        "description": "Reads the attribute named \"attr_name\" at the location \"attr_path\" within the HDF5 file named \"filename.\""
      }
    ],
    "example": ""
  },
  {
    "name": "h5writeattr",
    "description": "Write a matrix or string as an attribute of a group or a dataset to an HDF5 file.",
    "usage": "h5writeattr();",
    "category": "general",
    "markdown": "# h5writeattr\r\n\r\nWrite a matrix or string as an attribute of a group or a dataset to an HDF5 file.\r\n\r\n| **Syntax**                                                                                         | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| h5writeattr(\"filename\", \"location_name\", \"attribute_name\", data);                                  | Create an attribute named \"attribute_name\" to a group or dataset named \" location_name\" within an HDF5 file named \"filename\" from the given data. Will create the HDF5 file named \"filename\" if it does not exist. If there is no group or dataset called “location_name”, a new group called “location_name” will be created. If the attribute named \"attribute_name\" already exists in the given group/dataset within the HDF5 file, the attribute will be overwritten. Otherwise, the attribute is simply added to the existing group/dataset within the HDF5 file.                                                                                                                                         |\r\n| h5writeattr(\"filename\", \"location_name\", \"attribute_name\", data, [\"access_mode\"]);                 | Optional argument: \"append\" or \"overwrite\" \"append\": The attribute named \"attribute_name\" is added to a group or dataset named \"location_name\" in the HDF5 file \"filename\" if the attribute does not exist yet. Otherwise, it is overwritten. This command creates a HDF5 file named “filename” if it does not exist. If there is no group or dataset named “location_name”, a new group called “location_name” will be created. The \"append\" option is set by default. \"overwrite\": If the HDF5 file named \"filename\" already exists, the file is overwritten completely. Otherwise, it will be created. The file will only contain the group named \"location_name\" and the attribute named \"attribute_name\". |\r\n| h5writeattr(\"filename\", \"location_name\", \"attribute_name\", data, [{\"datatype\": \"datatype_name\"}]); | Optional argument. This struct indicates the data type in which the data is stored in the HDF5 file. Possible options: {“datatype”: “short”}: data is stored as short integers {“datatype”: “int”}: data is stored as integers {“datatype”: “long long”}: data is stored as long long integers {“datatype”: “double”}: data is stored as doubles The data struct is not applicable to string values. In that case, the command will throw an error.                                                                                                                                                                                                                                                            |\r\n\r\n| **Parameter**                 | **Type**      | **Description**                                                                                                                                                                                                                                                     |\r\n| ----------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| filename                      | string        | Name of the HDF5 file.                                                                                                                                                                                                                                              |\r\n| location_name                 | string        | Name of a group or dataset.                                                                                                                                                                                                                                         |\r\n| attribute_name                | string        | Name of the attribute.                                                                                                                                                                                                                                              |\r\n| data                          | matrix/string | Real/ complex matrix or string.                                                                                                                                                                                                                                     |\r\n| access_mode                   | string        | Optional argument. Only the strings \"append\" and \"overwrite\" are valid options.                                                                                                                                                                                     |\r\n| {\"datatype\": \"datatype_name\"} | struct        | Optional argument. Not available for string values. If given, the string “datatype” is a mandatory field in the struct. The field can only have the string values “short”, “int”, “long long”, and “double”. The latter is the default data type for matrix values. |\r\n\r\n**Example**\r\n\r\nWrite a real matrix as an attribute to a group within an HDF5 file by firstly using the\r\ndefault data type and secondly the integer data type.\r\n\r\n```\r\na = [1, 2, pi; 4, 5, 2*pi];\r\nh5writeattr(\"testfile.h5\", \"test_group\", \"double_matrix\", a);\r\nh5writeattr(\"testfile.h5\", \"test_group\", \"int_matrix\", a, {\"datatype\":\"int\"});\r\n```\r\n\r\nReading the data using [ h5readattr ](./h5readattr.md) gives the following results.\r\n\r\n```\r\n?h5readattr(\"testfile.h5\", \"/test_group\", \"double_matrix\");\r\nresult:\r\n1  2  3.14159\r\n4  5  6.28319\r\n\r\n?h5readattr(\"testfile.h5\", \"/test_group\", \"int_matrix\");\r\nresult:\r\n1  2  3\r\n4  5  6\r\n```\r\n\r\nOverwrite the existing HDF5 file by replacing the existing data with a group \"new_group\"\r\ncontaining the attribute \"vector\".\r\n\r\n```\r\nb = [2, 3, 5, 7, 11, 13];\r\nh5writeattr(\"testfile.h5\", \"new_group\", \"vector\", b, \"overwrite\");\r\n```\r\n\r\nApplying\r\n[ h5info ](https://optics.ansys.com/hc/en-us/articles/360034927413-h5info-Script-command)\r\nand [ h5readattr ](./h5readattr.md) to the HDF5 file shows a single group with a single\r\nattributes. The attribute contains the given 1D real matrix.\r\n\r\n```\r\ninfo = h5info(\"testfile.h5\");\r\n?info.Groups;\r\nCell array with 1 elements\r\n\r\ninfo.Groups{1}.Attributes;\r\nCell array with 1 elements\r\n?h5readattr(\"testfile.h5\", \"/new_group\", \"vector\");\r\nresult: \r\n2  3  5  7  11  13\r\n```",
    "summary": "Write a matrix or string as an attribute of a group or a dataset to an HDF5 file",
    "syntax": [
      {
        "syntax": "h5writeattr(\"filename\", \"location_name\", \"attribute_name\", data);",
        "description": "Create an attribute named \"attribute_name\" to a group or dataset named \" location_name\" within an HDF5 file named \"filename\" from the given data. Will create the HDF5 file named \"filename\" if it does not exist. If there is no group or dataset called “location_name”, a new group called “location_name” will be created. If the attribute named \"attribute_name\" already exists in the given group/dataset within the HDF5 file, the attribute will be overwritten. Otherwise, the attribute is simply added to the existing group/dataset within the HDF5 file."
      },
      {
        "syntax": "h5writeattr(\"filename\", \"location_name\", \"attribute_name\", data, [\"access_mode\"]);",
        "description": "Optional argument: \"append\" or \"overwrite\" \"append\": The attribute named \"attribute_name\" is added to a group or dataset named \"location_name\" in the HDF5 file \"filename\" if the attribute does not exist yet. Otherwise, it is overwritten. This command creates a HDF5 file named “filename” if it does not exist. If there is no group or dataset named “location_name”, a new group called “location_name” will be created. The \"append\" option is set by default. \"overwrite\": If the HDF5 file named \"filename\" already exists, the file is overwritten completely. Otherwise, it will be created. The file will only contain the group named \"location_name\" and the attribute named \"attribute_name\"."
      },
      {
        "syntax": "h5writeattr(\"filename\", \"location_name\", \"attribute_name\", data, [{\"datatype\": \"datatype_name\"}]);",
        "description": "Optional argument. This struct indicates the data type in which the data is stored in the HDF5 file. Possible options: {“datatype”: “short”}: data is stored as short integers {“datatype”: “int”}: data is stored as integers {“datatype”: “long long”}: data is stored as long long integers {“datatype”: “double”}: data is stored as doubles The data struct is not applicable to string values. In that case, the command will throw an error."
      }
    ],
    "example": "a = [1, 2, pi; 4, 5, 2*pi];\r\nh5writeattr(\"testfile.h5\", \"test_group\", \"double_matrix\", a);\r\nh5writeattr(\"testfile.h5\", \"test_group\", \"int_matrix\", a, {\"datatype\":\"int\"});"
  },
  {
    "name": "havedata",
    "description": "Used to see a simulation object (such as a monitor) has any data. This command is very similar to haveresult, but is intended to be used with the getdata command, rather than getresult.",
    "usage": "havedata();",
    "category": "general",
    "markdown": "# havedata\r\n\r\nUsed to see a simulation object (such as a monitor) has any data. This command is very\r\nsimilar to haveresult, but is intended to be used with the getdata command, rather than\r\ngetresult.\r\n\r\n| **Syntax**               | **Description**                                                                         |\r\n| ------------------------ | --------------------------------------------------------------------------------------- |\r\n| havedata;                | Returns 1 if any simulation objects have raw data, and 0 if none have any raw data.     |\r\n| havedata(\"name\");        | Returns 1 if \"name\" has raw data, and 0 if it does not have any raw data.               |\r\n| havedata(\"name\",\"data\"); | Returns 1 if \"name\" has the raw data named \"data\", and 0 if it does not have that data. |\r\n\r\n**Examples**\r\n\r\nThe following example shows the output of ?getdata, when it is called after a simulation\r\nhas been run. There is a monitor group in the simulation that has an analysis script\r\nfile and at least one result parameter. Before the analysis script is run, the monitor\r\ngroup does not have data, after it is run the monitor group has data that is stored in\r\nthe result parameter.\r\n\r\n```\r\n?getdata;\r\nlocal sources:\r\n source2 \r\nlocal monitors:\r\n monitor group \r\n?havedata(\"monitor group\");\r\nresult: \r\n0 \r\nrunanalysis(\"monitor group\");\r\n?havedata(\"monitor group\");\r\nresult: \r\n1  \r\n```",
    "summary": "Used to see a simulation object (such as a monitor) has any data",
    "syntax": [
      {
        "syntax": "havedata;",
        "description": "Returns 1 if any simulation objects have raw data, and 0 if none have any raw data."
      },
      {
        "syntax": "havedata(\"name\");",
        "description": "Returns 1 if \"name\" has raw data, and 0 if it does not have any raw data."
      },
      {
        "syntax": "havedata(\"name\",\"data\");",
        "description": "Returns 1 if \"name\" has the raw data named \"data\", and 0 if it does not have that data."
      }
    ],
    "example": ""
  },
  {
    "name": "haveproperty",
    "description": "Returns the number of selected objects with a particular property.",
    "usage": "haveproperty();",
    "category": "general",
    "markdown": "# haveproperty\r\n\r\nReturns the number of selected objects with a particular property.\r\n\r\n| **Syntax**                      | **Description**                                                     |\r\n| ------------------------------- | ------------------------------------------------------------------- |\r\n| out = haveproperty(\"property\"); | Returns the number of selected objects with the specified property. |\r\n\r\n**Example**\r\n\r\nAdd a circle and a rectangle. Use haveproperty to show that both objects have the\r\nproperty 'x', but only one has the property 'radius'.\r\n\r\n```\r\naddcircle;\r\naddrect;\r\nselectall;\r\n?haveproperty(\"x\");\r\n?haveproperty(\"radius\");\r\nresult:2\r\nresult:\r\n1 \r\n```",
    "summary": "Returns the number of selected objects with a particular property",
    "syntax": [
      {
        "syntax": "out = haveproperty(\"property\");",
        "description": "Returns the number of selected objects with the specified property."
      }
    ],
    "example": "addcircle;\r\naddrect;\r\nselectall;\r\n?haveproperty(\"x\");\r\n?haveproperty(\"radius\");\r\nresult:2\r\nresult:\r\n1"
  },
  {
    "name": "haveresult",
    "description": "Used to see a simulation object (such as a monitor) has any results.",
    "usage": "haveresult();",
    "category": "general",
    "markdown": "# haveresult\r\n\r\nUsed to see a simulation object (such as a monitor) has any results.\r\n\r\nNote: This command is very similar to havedata, but is intended to be used with the\r\ngetresult command, rather than getdata.\r\n\r\n| **Syntax**                 | **Description**                                                          |\r\n| -------------------------- | ------------------------------------------------------------------------ |\r\n| haveresult;                | Returns 1 if any simulation objects currently have any results.          |\r\n| haveresult(\"name\");        | Returns 1 if \"name\" has any results, and 0 if it does not.               |\r\n| haveresult(\"name\",\"data\"); | Returns 1 if the \"name\" has a result named \"data\", and 0 if it does not. |\r\n\r\n**Examples**\r\n\r\nThe following example shows the output of ?getresult, when it is called after a\r\nsimulation has been run. There are several monitors and a source with available results.\r\n\r\n```\r\n?getresult;\r\ntime\r\nT\r\nR\r\nModeSource\r\n?haveresult;  # check if results are available\r\nresult: \r\n1 \r\n?haveresult(\"T\"); # check if 'T' has any results\r\nresult: \r\n1 \r\n?haveresult(\"TT\"); # check if 'TT' has any results \r\nresult: \r\n0 \r\n?haveresult(\"T\",\"E\"); # check if 'T' has a result named 'E'\r\nresult: \r\n1  \r\n```",
    "summary": "Used to see a simulation object (such as a monitor) has any results",
    "syntax": [
      {
        "syntax": "haveresult;",
        "description": "Returns 1 if any simulation objects currently have any results."
      },
      {
        "syntax": "haveresult(\"name\");",
        "description": "Returns 1 if \"name\" has any results, and 0 if it does not."
      },
      {
        "syntax": "haveresult(\"name\",\"data\");",
        "description": "Returns 1 if the \"name\" has a result named \"data\", and 0 if it does not."
      }
    ],
    "example": ""
  },
  {
    "name": "havesweepdata",
    "description": "Checks whether a parameter sweep/optimization/Monte Carlo analysis has data. Similar to the script command havedata .",
    "usage": "havesweepdata();",
    "category": "general",
    "markdown": "# havesweepdata\r\n\r\nChecks whether a parameter sweep/optimization/Monte Carlo analysis has data. Similar to\r\nthe script command havedata .\r\n\r\n| **Syntax**                     | **Description**                                                                                                    |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |\r\n| ?havesweepdata;                | Returns 1 if any sweeps, optimizations or Monte Carlo analysis have data. Returns 0 if data is not available.      |\r\n| ?havesweepdata(\"name\");        | Returns 1 if the specified sweep, optimization or Monte Carlo analysis has data.                                   |\r\n| ?havesweepdata(\"name\",\"data\"); | Returns 1 if the specified sweep, optimization or Monte Carlo analysis named \"name\" has the specified data \"data\". |\r\n\r\n**Examples**\r\n\r\nThe following example shows the output of getsweepresult and havesweepdata . Please\r\ndownload the example file from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\n?getsweepresult;\r\n?havesweepdata(\"thickness_optimization\",\"fom trend\");\r\n> thickness_sweep\r\n> thickness_optimization\r\n> result: \r\n0    \r\n```",
    "summary": "Checks whether a parameter sweep/optimization/Monte Carlo analysis has data",
    "syntax": [
      {
        "syntax": "?havesweepdata;",
        "description": "Returns 1 if any sweeps, optimizations or Monte Carlo analysis have data. Returns 0 if data is not available."
      },
      {
        "syntax": "?havesweepdata(\"name\");",
        "description": "Returns 1 if the specified sweep, optimization or Monte Carlo analysis has data."
      },
      {
        "syntax": "?havesweepdata(\"name\",\"data\");",
        "description": "Returns 1 if the specified sweep, optimization or Monte Carlo analysis named \"name\" has the specified data \"data\"."
      }
    ],
    "example": ""
  },
  {
    "name": "havesweepresult",
    "description": "Checks whether a parameter parameter sweep/optimization/Monte Carlo/S-parameter sweep has results. Similar to haveresult .",
    "usage": "havesweepresult();",
    "category": "general",
    "markdown": "# havesweepresult\r\n\r\nChecks whether a parameter parameter sweep/optimization/Monte Carlo/S-parameter sweep\r\nhas results. Similar to haveresult .\r\n\r\n| **Syntax**                       | **Description**                                                                                                                         |\r\n| -------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?havesweepresult;                | Returns 1 if any sweeps or optimizations, Monte Carlo analysis, or S-parameter sweeps have results. Returns 0 if data is not available. |\r\n| ?havesweepresult(\"name\");        | Returns 1 if the specified sweep, optimization, Monte Carlo, or S-parameter sweep has results.                                          |\r\n| ?havesweepresult(\"name\",\"data\"); | Returns 1 if the sweep, optimization, Monte Carlo, or S-parameter sweep named \"name\" has the specified result \"data\".                   |\r\n\r\n**Examples**\r\n\r\nThe following example shows the output of getsweepresult and havesweepdata . Please\r\ndownload the example file from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\n?getsweepresult;\r\n?havesweepresult(\"thickness_optimization\",\"fom trend\");\r\n> thickness_sweep\r\n> thickness_optimization\r\n> result: \r\n1   \r\n```",
    "summary": "Checks whether a parameter parameter sweep/optimization/Monte Carlo/S-parameter sweep has results",
    "syntax": [
      {
        "syntax": "?havesweepresult;",
        "description": "Returns 1 if any sweeps or optimizations, Monte Carlo analysis, or S-parameter sweeps have results. Returns 0 if data is not available."
      },
      {
        "syntax": "?havesweepresult(\"name\");",
        "description": "Returns 1 if the specified sweep, optimization, Monte Carlo, or S-parameter sweep has results."
      },
      {
        "syntax": "?havesweepresult(\"name\",\"data\");",
        "description": "Returns 1 if the sweep, optimization, Monte Carlo, or S-parameter sweep named \"name\" has the specified result \"data\"."
      }
    ],
    "example": ""
  },
  {
    "name": "help",
    "description": "Opens the Lumerical Knowledge Base using the default web browser.",
    "usage": "help();",
    "category": "general",
    "markdown": "# help\r\n\r\nOpens the Lumerical Knowledge Base using the default web browser.\r\n\r\n| **Syntax**         | **Description**                                                                                                                                                                                                                                                                                                            |\r\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| help(argument=””); | Opens the Lumerical knowledge base using the default web browser. If no arguments are provided the web browser will open the page with the alphabetical list of all script commands, otherwise it will run a search using the ‘argument’ parameter and open the page with the search results for the ‘argument’ parameter. |\r\n\r\n**Example**\r\n\r\n```\r\n>help;\r\n>help(\"setsparameter\");\r\n```",
    "summary": "Opens the Lumerical Knowledge Base using the default web browser",
    "syntax": [
      {
        "syntax": "help(argument=””);",
        "description": "Opens the Lumerical knowledge base using the default web browser. If no arguments are provided the web browser will open the page with the alphabetical list of all script commands, otherwise it will run a search using the ‘argument’ parameter and open the page with the search results for the ‘argument’ parameter."
      }
    ],
    "example": ">help;\r\n>help(\"setsparameter\");"
  },
  {
    "name": "hide",
    "description": "Hides the graphical user interface, can be used with the [ show ](./hide.md) command.",
    "usage": "hide();",
    "category": "general",
    "markdown": "# hide\r\n\r\nHides the graphical user interface, can be used with the [ show ](./hide.md) command.\r\n\r\n| **Syntax** | **Description** |\r\n| ---------- | --------------- |\r\n| hide;      | hides the GUI.  |",
    "summary": "Hides the graphical user interface, can be used with the [ show ](",
    "syntax": [
      {
        "syntax": "hide;",
        "description": "hides the GUI."
      }
    ],
    "example": ""
  },
  {
    "name": "hidecategory",
    "description": "Hides all properties of a given ‘category' of a given ‘element’.",
    "usage": "hidecategory();",
    "category": "general",
    "markdown": "# hidecategory\r\n\r\nHides all properties of a given ‘category' of a given ‘element’.\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                        |\r\n| ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| hidecategory(element,category,hide); | Hides all properties of a given ‘category' of a given ‘element’. The argument 'hide' is a boolean value. If ‘hide’ is true the category is invisible, if 'hide' is false the category is visible. The default value of ‘hide’ is true. |\r\n\r\n**Example**\r\n\r\n```\r\naddelement(\"CW Laser\");\r\nhidecategory(\"CWL_1\",\"Polarization\", true);\r\n```",
    "summary": "Hides all properties of a given ‘category' of a given ‘element’",
    "syntax": [
      {
        "syntax": "hidecategory(element,category,hide);",
        "description": "Hides all properties of a given ‘category' of a given ‘element’. The argument 'hide' is a boolean value. If ‘hide’ is true the category is invisible, if 'hide' is false the category is visible. The default value of ‘hide’ is true."
      }
    ],
    "example": "addelement(\"CW Laser\");\r\nhidecategory(\"CWL_1\",\"Polarization\", true);"
  },
  {
    "name": "hideproperty",
    "description": "Hides the ‘property’ of a given ‘element’.",
    "usage": "hideproperty();",
    "category": "general",
    "markdown": "# hideproperty\r\n\r\nHides the ‘property’ of a given ‘element’.\r\n\r\n| **Syntax**                            | **Description**                                                                                                                                                                                                  |\r\n| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| hideproperty (element,property,hide); | Hides the ‘property’ of a given ‘element’. The argument 'hide' is a boolean value. If ‘hide’ is true the property is invisible, if 'hide' is false the property is visible. The default value of ‘hide' is true. |\r\n\r\n**Example**\r\n\r\n```\r\naddelement(\"CW Laser\");\r\nhideproperty(\"CWL_1\",\"linewidth\", true);\r\n```",
    "summary": "Hides the ‘property’ of a given ‘element’",
    "syntax": [
      {
        "syntax": "hideproperty (element,property,hide);",
        "description": "Hides the ‘property’ of a given ‘element’. The argument 'hide' is a boolean value. If ‘hide’ is true the property is invisible, if 'hide' is false the property is visible. The default value of ‘hide' is true."
      }
    ],
    "example": "addelement(\"CW Laser\");\r\nhideproperty(\"CWL_1\",\"linewidth\", true);"
  },
  {
    "name": "histc",
    "description": "Creates a histogram plot.",
    "usage": "histc();",
    "category": "general",
    "markdown": "# histc\r\n\r\nCreates a histogram plot.\r\n\r\n| **Syntax**                                  | **Description**                                                                                       |\r\n| ------------------------------------------- | ----------------------------------------------------------------------------------------------------- |\r\n| out = histc(y);                             | Creates a histogram plot of y. Returns the figure number.                                             |\r\n| histc(y,n);                                 | Creates a histogram plot of y, using n bins. Returns the figure number.                               |\r\n| histc (y,n, \"x label\", \"y label\", \"title\"); | Creates a histogram plot of y, using n bins, with axis labels and a title. Returns the figure number. |\r\n\r\n**Example**\r\n\r\nThese are scripts for creating simple histograms.\r\n\r\n```\r\n#Creates a histogram plot of y.\r\ny = randmatrix(1,10);\r\ny = y*10;\r\nout = histc(y);\r\n#Creates a histogram plot of y, using n bins.\r\n#Returns the figure number.\r\ny = randmatrix(1,10);\r\ny = y*10;\r\nn = 5;\r\nout = histc(y,n);\r\n#Creates a histogram plot of y, using n bins, with axis labels and a title.\r\nhistc (y,n, \"x label\", \"y label\", \"title\");\r\n```",
    "summary": "Creates a histogram plot",
    "syntax": [
      {
        "syntax": "out = histc(y);",
        "description": "Creates a histogram plot of y. Returns the figure number."
      },
      {
        "syntax": "histc(y,n);",
        "description": "Creates a histogram plot of y, using n bins. Returns the figure number."
      },
      {
        "syntax": "histc (y,n, \"x label\", \"y label\", \"title\");",
        "description": "Creates a histogram plot of y, using n bins, with axis labels and a title. Returns the figure number."
      }
    ],
    "example": "#Creates a histogram plot of y.\r\ny = randmatrix(1,10);\r\ny = y*10;\r\nout = histc(y);\r\n#Creates a histogram plot of y, using n bins.\r\n#Returns the figure number.\r\ny = randmatrix(1,10);\r\ny = y*10;\r\nn = 5;\r\nout = histc(y,n);\r\n#Creates a histogram plot of y, using n bins, with axis labels and a title.\r\nhistc (y,n, \"x label\", \"y label\", \"title\");"
  },
  {
    "name": "histogram",
    "description": "Create a matrix containing the histogram count of a yield analysis result.",
    "usage": "histogram();",
    "category": "general",
    "markdown": "# histogram\r\n\r\nCreate a matrix containing the histogram count of a yield analysis result.\r\n\r\n| **Syntax**            | **Description**                                                     |\r\n| --------------------- | ------------------------------------------------------------------- |\r\n| out = histogram(y);   | Returns a matrix containing the histogram count of y.               |\r\n| out = histogram(y,n); | Returns a matrix containing the histogram count of y, using n bins. |",
    "summary": "Create a matrix containing the histogram count of a yield analysis result",
    "syntax": [
      {
        "syntax": "out = histogram(y);",
        "description": "Returns a matrix containing the histogram count of y."
      },
      {
        "syntax": "out = histogram(y,n);",
        "description": "Returns a matrix containing the histogram count of y, using n bins."
      }
    ],
    "example": ""
  },
  {
    "name": "historyoff",
    "description": "Disables taking snapshots (history) of the current object tree (non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality.",
    "usage": "historyoff();",
    "category": "general",
    "markdown": "# historyoff\r\n\r\nDisables taking snapshots (history) of the current object tree\r\n(non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality.\r\n\r\nWhen running co-simulations in INTERCONNECT or multiple simulations each with lots of\r\noperations (for example, when using\r\n[lumopt](https://optics.ansys.com/hc/en-us/articles/360050995394-Getting-Started-with-lumopt-Python-API)),\r\nthis option will improve simulation performance.\r\n\r\n| **Syntax**  | **Description**                                                                                                                         |\r\n| ----------- | --------------------------------------------------------------------------------------------------------------------------------------- |\r\n| historyoff; | Disables taking snapshots (history) of the current object tree (non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality. |\r\n\r\n**Example**\r\n\r\n```\r\nhistoryoff;\r\n```",
    "summary": "Disables taking snapshots (history) of the current object tree (non-INTERCONNECT)/schematic (INTERCO...",
    "syntax": [
      {
        "syntax": "historyoff;",
        "description": "Disables taking snapshots (history) of the current object tree (non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality."
      }
    ],
    "example": "historyoff;"
  },
  {
    "name": "historyon",
    "description": "Enables taking snapshots (history) for the current object tree (non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality.",
    "usage": "historyon();",
    "category": "general",
    "markdown": "# historyon\r\n\r\nEnables taking snapshots (history) for the current object tree\r\n(non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality.\r\n\r\nWhen running co-simulations in INTERCONNECT or multiple simulations each with lots of\r\noperations (for example, when using\r\n[lumopt](https://optics.ansys.com/hc/en-us/articles/360050995394-Getting-Started-with-lumopt-Python-API)),\r\nthis option could will hinder performance.\r\n\r\n| **Syntax** | **Description**                                                                                                                         |\r\n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------- |\r\n| historyon; | Enables taking snapshots (history) for the current object tree (non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality. |\r\n\r\n**Example**\r\n\r\n```\r\nhistoryon;\r\n```",
    "summary": "Enables taking snapshots (history) for the current object tree (non-INTERCONNECT)/schematic (INTERCO...",
    "syntax": [
      {
        "syntax": "historyon;",
        "description": "Enables taking snapshots (history) for the current object tree (non-INTERCONNECT)/schematic (INTERCONNECT) for undo redo functionality."
      }
    ],
    "example": "historyon;"
  },
  {
    "name": "holdoff",
    "description": "Switches off the holdon mode.",
    "usage": "holdoff();",
    "category": "general",
    "markdown": "# holdoff\r\n\r\nSwitches off the holdon mode.\r\n\r\n| **Syntax** | **Description**                                                                   |\r\n| ---------- | --------------------------------------------------------------------------------- |\r\n| holdoff;   | Switches off the mode to hold multiple mathematical functions on the same figure. |\r\n\r\n**Example**\r\n\r\nAn example is available on the holdon page.",
    "summary": "Switches off the holdon mode",
    "syntax": [
      {
        "syntax": "holdoff;",
        "description": "Switches off the mode to hold multiple mathematical functions on the same figure."
      }
    ],
    "example": ""
  },
  {
    "name": "holdon",
    "description": "Holds multiple functions on a single plot. Note that, only the labeling and plot options of the first plot are taken into account; a warning is reported in this case. The command setplot can be used instead.",
    "usage": "holdon();",
    "category": "general",
    "markdown": "# holdon\r\n\r\nHolds multiple functions on a single plot. Note that, only the labeling and plot options\r\nof the first plot are taken into account; a warning is reported in this case. The\r\ncommand setplot can be used instead.\r\n\r\n| **Syntax** | **Description**                                                                  |\r\n| ---------- | -------------------------------------------------------------------------------- |\r\n| holdon;    | Switches on the mode to hold multiple mathematical functions on the same figure. |\r\n\r\n**Example**\r\n\r\nThis example will generate a figure with three lines based on the sin(x) function.\r\n\r\n```\r\n# setup data\r\n# for logarithm, avoid non-positive values\r\nx1=linspace(1,10,100);\r\nx2=linspace(2,11,100);\r\ny1=sin(x1)+1.1;\r\ny2=y1^2+1.1;\r\n# plot y1, y2, y3\r\nplot(x1,y1,\"x\",\"y\",\"holdon/off\",\"log10x\");\r\nholdon;\r\nplot(x2,y2,\"xx\",\"yy\",\"title1\",\"log10y, plot points\");\r\nplot(x2,2*y2, \"xxx\",\"yyy\", \"title2\", \"greyscale\");\r\n# plot labeling and options cannot work in hold on\r\n# use setplot command instead!\r\nlegend(\"y1\",\"y2\",\"y3\");\r\nholdoff;\r\n```\r\n\r\nThe following figure shows the output of the the example code.",
    "summary": "Holds multiple functions on a single plot",
    "syntax": [
      {
        "syntax": "holdon;",
        "description": "Switches on the mode to hold multiple mathematical functions on the same figure."
      }
    ],
    "example": "# setup data\r\n# for logarithm, avoid non-positive values\r\nx1=linspace(1,10,100);\r\nx2=linspace(2,11,100);\r\ny1=sin(x1)+1.1;\r\ny2=y1^2+1.1;\r\n# plot y1, y2, y3\r\nplot(x1,y1,\"x\",\"y\",\"holdon/off\",\"log10x\");\r\nholdon;\r\nplot(x2,y2,\"xx\",\"yy\",\"title1\",\"log10y, plot points\");\r\nplot(x2,2*y2, \"xxx\",\"yyy\", \"title2\", \"greyscale\");\r\n# plot labeling and options cannot work in hold on\r\n# use setplot command instead!\r\nlegend(\"y1\",\"y2\",\"y3\");\r\nholdoff;"
  },
  {
    "name": "icht",
    "description": "Takes the Chebyshev interpolation coefficients and returns the corresponding function samples.",
    "usage": "icht();",
    "category": "general",
    "markdown": "# icht\r\n\r\nTakes the Chebyshev interpolation coefficients and returns the corresponding function\r\nsamples.\r\n\r\n| **Syntax**              | **Description**                                                                                                                                                                                                         |\r\n| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=icht(coeff,option); | Returns function samples from Chebyshev interpolation coefficients coeff. Option: If option=1 is selected, the vector x will not include the endpoints If option=2 is selected, the vector x will include the endpoints |\r\n\r\n**Example**\r\n\r\nThis example shows how to obtain interpolation coefficients from a sampled function and\r\nthen calculate back the function samples from the coefficients.\r\n\r\n```\r\nNc = 15;         # Number of sample points\r\nxmin = 0;\r\nxmax = 1;\r\nx = chpts(xmin,xmax,Nc,1); # Returns Chebyshev roots grid on interval between xmin and xmax\r\nf = exp(1i*2*pi*x);    # Function sampling using Chebyshev grid\r\ncoeff = dcht(f,1);     # Get interpolation coefficients\r\n# Calculate the function samples from the coefficients and compare them to the original function samples\r\n?icht(coeff,1);\r\n?f;     \r\n```",
    "summary": "Takes the Chebyshev interpolation coefficients and returns the corresponding function samples",
    "syntax": [
      {
        "syntax": "out=icht(coeff,option);",
        "description": "Returns function samples from Chebyshev interpolation coefficients coeff. Option: If option=1 is selected, the vector x will not include the endpoints If option=2 is selected, the vector x will include the endpoints"
      }
    ],
    "example": "Nc = 15;         # Number of sample points\r\nxmin = 0;\r\nxmax = 1;\r\nx = chpts(xmin,xmax,Nc,1); # Returns Chebyshev roots grid on interval between xmin and xmax\r\nf = exp(1i*2*pi*x);    # Function sampling using Chebyshev grid\r\ncoeff = dcht(f,1);     # Get interpolation coefficients\r\n# Calculate the function samples from the coefficients and compare them to the original function samples\r\n?icht(coeff,1);\r\n?f;"
  },
  {
    "name": "if",
    "description": "Starts an if statement. The scripting language supports if statements in the following forms:",
    "usage": "if();",
    "category": "general",
    "markdown": "# if\r\n\r\nStarts an if statement. The scripting language supports if statements in the following\r\nforms:\r\n\r\n| **Syntax**                                              | **Description**                  |\r\n| ------------------------------------------------------- | -------------------------------- |\r\n| if(x < 5) { y = x^2; }                                  | Simple if statement on one line. |\r\n| if(x < 5) { y = x^2; }                                  | Multi-line if statement          |\r\n| if(x < 5) { y = x^2; } else { y = x^3; }                | If else statement.               |\r\n| if(x < 5) { if(x > 0) {y = x^2;} } else { y = x^3; }    | Nested if statement with else.   |\r\n| if(x < 5) { y = x^2; } else if ( x > 10 ) { y = 2\\*x; } | Chained if else if statement.    |\r\n\r\n**Examples**\r\n\r\nThis example shows a simple if, OR, AND logical statement\r\n\r\n```\r\nclear;\r\na=1;\r\nb=2;\r\nd=3;\r\nif((a==1)|(b==2)&(d==3)){\r\n?\"correct\";}\r\nelse{\r\n?\"not correct\";}\r\n```",
    "summary": "Starts an if statement",
    "syntax": [
      {
        "syntax": "if(x < 5) { y = x^2; }",
        "description": "Simple if statement on one line."
      },
      {
        "syntax": "if(x < 5) { y = x^2; }",
        "description": "Multi-line if statement"
      },
      {
        "syntax": "if(x < 5) { y = x^2; } else { y = x^3; }",
        "description": "If else statement."
      },
      {
        "syntax": "if(x < 5) { if(x > 0) {y = x^2;} } else { y = x^3; }",
        "description": "Nested if statement with else."
      },
      {
        "syntax": "if(x < 5) { y = x^2; } else if ( x > 10 ) { y = 2\\*x; }",
        "description": "Chained if else if statement."
      }
    ],
    "example": ""
  },
  {
    "name": "imag",
    "description": "Returns the imaginary part of a number or matrix.",
    "usage": "imag();",
    "category": "general",
    "markdown": "# imag\r\n\r\nReturns the imaginary part of a number or matrix.\r\n\r\n| **Syntax**     | **Description**                  |\r\n| -------------- | -------------------------------- |\r\n| out = imag(x); | Returns the imaginary part of x. |\r\n\r\n**Example**\r\n\r\nCalculate the imaginary part of numbers in an array.\r\n\r\n```\r\n?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?imag(x);\r\nresult: \r\n0 \r\n1\r\n```",
    "summary": "Returns the imaginary part of a number or matrix",
    "syntax": [
      {
        "syntax": "out = imag(x);",
        "description": "Returns the imaginary part of x."
      }
    ],
    "example": "?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?imag(x);\r\nresult: \r\n0 \r\n1"
  },
  {
    "name": "image",
    "description": "Creates 2D image plots.",
    "usage": "image();",
    "category": "general",
    "markdown": "# image\r\n\r\nCreates 2D image plots.\r\n\r\n| **Syntax**                                              | **Description**                                                                                                                                                     |\r\n| ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = image(x,y,z);                                     | Creates a 2D image plot of the data in z. If x is of dimension N x 1 and y is of dimension M x 1, then z must be of dimension N x M. The figure number is returned. |\r\n| image(x,y,z, \"x label\", \"y label\", \"title\");            | Creates a 2D image plot with axis labels and a title. The figure number is returned.                                                                                |\r\n| image(x,y,z, \"x label\", \"y label\", \"title\", \"options\"); | Creates a 2D image plot with axis labels and options, options can be                                                                                                |\r\n\r\n- logplot\r\n- polar\r\n- red2blue\r\n- any comma separated list of the above\r\n\r\n**Example**\r\n\r\nThis example generates a figure of the 2D function pic(x,y)=sin(x)+sin(y).\r\n\r\n```\r\nx=linspace(0,10,100);\r\ny=linspace(0,10,100);\r\nx2=sin(x);\r\ny2=sin(y);\r\npic=meshgridx(x2,y2)+meshgridy(x2,y2);\r\nimage(x,y,pic,\"\",\"\",\"\",\"logplot\");\r\nimage(x,y,pic,\"\",\"\",\"\",\"logplot,red2blue\");\r\n```\r\n\r\nThe following figures show the output of the example code.",
    "summary": "Creates 2D image plots",
    "syntax": [
      {
        "syntax": "out = image(x,y,z);",
        "description": "Creates a 2D image plot of the data in z. If x is of dimension N x 1 and y is of dimension M x 1, then z must be of dimension N x M. The figure number is returned."
      },
      {
        "syntax": "image(x,y,z, \"x label\", \"y label\", \"title\");",
        "description": "Creates a 2D image plot with axis labels and a title. The figure number is returned."
      },
      {
        "syntax": "image(x,y,z, \"x label\", \"y label\", \"title\", \"options\");",
        "description": "Creates a 2D image plot with axis labels and options, options can be"
      }
    ],
    "example": "x=linspace(0,10,100);\r\ny=linspace(0,10,100);\r\nx2=sin(x);\r\ny2=sin(y);\r\npic=meshgridx(x2,y2)+meshgridy(x2,y2);\r\nimage(x,y,pic,\"\",\"\",\"\",\"logplot\");\r\nimage(x,y,pic,\"\",\"\",\"\",\"logplot,red2blue\");"
  },
  {
    "name": "implantkurtosis",
    "description": "Calculates the 'kurtosis' of the 1D doping profile from ion implant. The script command takes the semiconductor material name, dopant type, and ion energy as input arguments.",
    "usage": "implantkurtosis();",
    "category": "general",
    "markdown": "# implantkurtosis\r\n\r\nCalculates the 'kurtosis' of the 1D doping profile from ion implant. The script command\r\ntakes the semiconductor material name, dopant type, and ion energy as input arguments.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = implantkurtosis(\"dopant\", \"semiconductor\", E) | Provides the 'kurtosis' of the 1D doping profile from ion implant. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV. |\r\n\r\n**Example**\r\n\r\nThe following script calculates the range, straggle, skewness, kurtosis, and lateral\r\nscatter for an ion implant in 'silicon' with 'boron' for an ion implant energy of 1 keV.\r\nThe script then calculates the peak concentration for the 1D doping profile for an ion\r\ndose of 2e13 /cm 2 and sets up an implant doping object in the CHARGE solver to model\r\nthe corresponding doping profile.\r\n\r\n```\r\nE = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);\r\n```",
    "summary": "Calculates the 'kurtosis' of the 1D doping profile from ion implant",
    "syntax": [
      {
        "syntax": "out = implantkurtosis(\"dopant\", \"semiconductor\", E)",
        "description": "Provides the 'kurtosis' of the 1D doping profile from ion implant. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV."
      }
    ],
    "example": "E = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);"
  },
  {
    "name": "implantlateralscatter",
    "description": "Calculates the 'lateral scatter' of the doping profile from an ion implant. The script command takes the semiconductor material name, dopant type, and ion energy as input arguments.",
    "usage": "implantlateralscatter();",
    "category": "general",
    "markdown": "# implantlateralscatter\r\n\r\nCalculates the 'lateral scatter' of the doping profile from an ion implant. The script\r\ncommand takes the semiconductor material name, dopant type, and ion energy as input\r\narguments.\r\n\r\n| **Syntax**                                               | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = implanlateralscatter(\"dopant\", \"semiconductor\", E) | Provides the 'lateral scatter' of the doping profile from an ion implant in units of m. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV. |\r\n\r\n**Example**\r\n\r\nThe following script calculates the range, straggle, skewness, kurtosis, and lateral\r\nscatter for an ion implant in 'silicon' with 'boron' for an ion implant energy of 1 keV.\r\nThe script then calculates the peak concentration for the 1D doping profile (without\r\nlateral scatter) for an ion dose of 2e13 /cm 2 and sets up an implant doping object in\r\nthe CHARGE solver to model the corresponding doping profile.\r\n\r\n```\r\nE = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);\r\n```",
    "summary": "Calculates the 'lateral scatter' of the doping profile from an ion implant",
    "syntax": [
      {
        "syntax": "out = implanlateralscatter(\"dopant\", \"semiconductor\", E)",
        "description": "Provides the 'lateral scatter' of the doping profile from an ion implant in units of m. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV."
      }
    ],
    "example": "E = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);"
  },
  {
    "name": "implantrange",
    "description": "Calculates the 'range' of the 1D doping profile from ion implant. The script command takes the semiconductor material name, dopant type, and ion energy as input arguments.",
    "usage": "implantrange();",
    "category": "general",
    "markdown": "# implantrange\r\n\r\nCalculates the 'range' of the 1D doping profile from ion implant. The script command\r\ntakes the semiconductor material name, dopant type, and ion energy as input arguments.\r\n\r\n| **Syntax**                                       | **Description**                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = implantrange(\"dopant\", \"semiconductor\", E) | Provides the 'range' of the 1D doping profile from ion implant in units of m. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV. |\r\n\r\n**Example**\r\n\r\nThe following script calculates the range, straggle, skewness, kurtosis, and lateral\r\nscatter for an ion implant in 'silicon' with 'boron' for an ion implant energy of 1 keV.\r\nThe script then calculates the peak concentration for the 1D doping profile for an ion\r\ndose of 2e13 /cm 2 and sets up an implant doping object in the CHARGE solver to model\r\nthe corresponding doping profile.\r\n\r\n```\r\nE = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);\r\n```",
    "summary": "Calculates the 'range' of the 1D doping profile from ion implant",
    "syntax": [
      {
        "syntax": "out = implantrange(\"dopant\", \"semiconductor\", E)",
        "description": "Provides the 'range' of the 1D doping profile from ion implant in units of m. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV."
      }
    ],
    "example": "E = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);"
  },
  {
    "name": "implantskewness",
    "description": "Calculates the 'skewness' of the 1D doping profile from ion implant. The script command takes the semiconductor material name, dopant type, and ion energy as input arguments.",
    "usage": "implantskewness();",
    "category": "general",
    "markdown": "# implantskewness\r\n\r\nCalculates the 'skewness' of the 1D doping profile from ion implant. The script command\r\ntakes the semiconductor material name, dopant type, and ion energy as input arguments.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = implantskewness(\"dopant\", \"semiconductor\", E) | Provides the 'skewness' of the 1D doping profile from ion implant. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV. |\r\n\r\n**Example**\r\n\r\nThe following script calculates the range, straggle, skewness, kurtosis, and lateral\r\nscatter for an ion implant in 'silicon' with 'boron' for an ion implant energy of 1 keV.\r\nThe script then calculates the peak concentration for the 1D doping profile for an ion\r\ndose of 2e13 /cm 2 and sets up an implant doping object in the CHARGE solver to model\r\nthe corresponding doping profile.\r\n\r\n```\r\nE = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);\r\n```",
    "summary": "Calculates the 'skewness' of the 1D doping profile from ion implant",
    "syntax": [
      {
        "syntax": "out = implantskewness(\"dopant\", \"semiconductor\", E)",
        "description": "Provides the 'skewness' of the 1D doping profile from ion implant. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV."
      }
    ],
    "example": "E = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);"
  },
  {
    "name": "implantstraggle",
    "description": "Calculates the 'straggle' of the 1D doping profile from ion implant. The script command takes the semiconductor material name, dopant type, and ion energy as input arguments.",
    "usage": "implantstraggle();",
    "category": "general",
    "markdown": "# implantstraggle\r\n\r\nCalculates the 'straggle' of the 1D doping profile from ion implant. The script command\r\ntakes the semiconductor material name, dopant type, and ion energy as input arguments.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = implantstraggle(\"dopant\", \"semiconductor\", E) | Provides the 'sraggle' of the 1D doping profile from ion implant in units of m. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV. |\r\n\r\n**Example**\r\n\r\nThe following script calculates the range, straggle, skewness, kurtosis, and lateral\r\nscatter for an ion implant in 'silicon' with 'boron' for an ion implant energy of 1 keV.\r\nThe script then calculates the peak concentration for the 1D doping profile for an ion\r\ndose of 2e13 /cm 2 and sets up an implant doping object in the CHARGE solver to model\r\nthe corresponding doping profile.\r\n\r\n```\r\nE = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);\r\n```",
    "summary": "Calculates the 'straggle' of the 1D doping profile from ion implant",
    "syntax": [
      {
        "syntax": "out = implantstraggle(\"dopant\", \"semiconductor\", E)",
        "description": "Provides the 'sraggle' of the 1D doping profile from ion implant in units of m. The \"dopant\" argument is a string providing the dopant type. The options are (i) \"boron\", (ii) \"phosphorous\", (iii) \"antimony\", and (iv) \"arsenic\". The \"semiconductor\" argument is a string providing the semiconductor type. The only available option is \"silicon\". The last argument (E) is the ion energy for the implant in units of eV."
      }
    ],
    "example": "E = 1000;  # eV\r\ndose = 2e13 * 1e4;  # /m^2\r\nmu = implantrange(\"boron\",\"silicon\",E);  # range in m\r\nsi = implantstraggle(\"boron\",\"silicon\",E);  # straggle in m\r\ngal = implantskewness(\"boron\",\"silicon\",E); # skewness\r\nbe2 = implantkurtosis(\"boron\",\"silicon\",E); # kurtosis\r\nsi_lat = implantlateralscatter(\"boron\",\"silicon\",E);  # lateral scatter in m\r\n# calculate peak doping concentration\r\nx = linspace(0,mu+10*si,1001);\r\ny = pearson4pdf(x,mu,si,gal,be2); \r\nion_absorbed = integrate(y,[1],x);  \r\npeak = max(y)*dose/ion_absorbed;  # peak doping density in /m^3\r\n# set up implant doping object (assume doping object is already present in the objects tree)\r\nselect(\"CHARGE::implant\");\r\nset(\"dopant type\",\"p\");\r\nset(\"peak concentration\",peak);\r\nset(\"distribution function\",\"pearson4\");\r\nset(\"range\",mu);\r\nset(\"straggle\",si);\r\nset(\"skewness\",gal);\r\nset(\"kurtosis\",be2);\r\nset(\"lateral scatter\",si_lat);"
  },
  {
    "name": "importbinary",
    "description": "Import binary data (1s and 0s) over an entire volume from a file. The object will be present wherever the binary data is 1 and not when it is 0. This command only applies to import primitives. The function returns 1 if the data is successfully imported. Example script files showing how to use these functions can be found in the Online Help. See the User Guide, Structures section.",
    "usage": "importbinary();",
    "category": "general",
    "markdown": "# importbinary\r\n\r\nImport binary data (1s and 0s) over an entire volume from a file. The object will be\r\npresent wherever the binary data is 1 and not when it is 0. This command only applies to\r\nimport primitives. The function returns 1 if the data is successfully imported. Example\r\nscript files showing how to use these functions can be found in the Online Help. See the\r\nUser Guide, Structures section.\r\n\r\n| **Syntax**                                                            | **Description**                                                                                                   |\r\n| --------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| out = importbinary(filename,file_units,x0,y0,z0,reverse_index_order); | Import binary data from filename in three dimensional simulations. All arguments after the filename are optional. |\r\n\r\n| **Parameter**       | **Default value** | **Type** | **Description**                                                                                                                                                                                                                                                                 |\r\n| ------------------- | ----------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| filename            | required          | string   | name of the file with binary data to import. May contain complete path to file, or path relative to current working directory                                                                                                                                                   |\r\n| file_units          | \"m\"               | string   | The optional string argument file_units can be \"m\", \"cm, \"mm\", \"microns\" or \"nm\" to specify the units in the file.                                                                                                                                                              |\r\n| x0                  | 0                 | number   | The optional arguments x0, y0 and z0 specify the data origin in the global coordinates of the Graphical Layout Editor. For example, if you defined your volume with respect to a particular point in space, for example (0,0,-5) microns, then you should set z0 to -5 microns. |\r\n| y0                  | 0                 | number   |                                                                                                                                                                                                                                                                                 |\r\n| z0                  | 0                 | number   |                                                                                                                                                                                                                                                                                 |\r\n| reverse_index_order | 0                 | number   | The optional argument reverse_index_order can be set to 1 to reverse how the indices are interpreted in the file. It is best to verify the correct setting with a graphical import before using the script command.                                                             |\r\n\r\n## Note: Imported binary object boundaries The boundary of the import binary object is positioned between the vertices where the material is present and the vertices where the material is not present. The shape of this implied boundary can be complex, and the viewport does not show the full detail. The boundary can be moved closer to vertices where the material is present by increasing the \"binary threshold\" property of the import object. To confirm the boundary that will be used in the simulation by the solver, use an index monitor.\r\n\r\n**Example**\r\n\r\nPlease refer to the\r\n[importing spatial binary example](https://optics.ansys.com/hc/en-us/articles/360034382754-Import-object-Binary-spatial-data)\r\nfor details.",
    "summary": "Import binary data (1s and 0s) over an entire volume from a file",
    "syntax": [
      {
        "syntax": "out = importbinary(filename,file_units,x0,y0,z0,reverse_index_order);",
        "description": "Import binary data from filename in three dimensional simulations. All arguments after the filename are optional."
      }
    ],
    "example": ""
  },
  {
    "name": "importbinary2",
    "description": "Import binary data (1s and 0s) over an entire volume from script variables. The object will be present wherever the binary data is 1 and not when it is 0. This command only applies to import primitives. The function returns 1 if the data is successfully imported. Example script files showing how to use these functions can be found in the Online Help. See the User Guide, Structures section.",
    "usage": "importbinary2();",
    "category": "general",
    "markdown": "# importbinary2\r\n\r\nImport binary data (1s and 0s) over an entire volume from script variables. The object\r\nwill be present wherever the binary data is 1 and not when it is 0. This command only\r\napplies to import primitives. The function returns 1 if the data is successfully\r\nimported. Example script files showing how to use these functions can be found in the\r\nOnline Help. See the User Guide, Structures section.\r\n\r\n| **Syntax**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | **Description**                                                                                        |\r\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| out = importbinary2(binary,x,y,z);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Import binary data from script variables in three dimensional simulations. All arguments are required. |\r\n| **Parameter**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | **Default value**                                                                                      |\r\n| ---                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | ---                                                                                                    |\r\n| binary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | required                                                                                               |\r\n| x                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | required                                                                                               |\r\n| y                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | required                                                                                               |\r\n| z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | 1                                                                                                      |\r\n| Note: Imported binary object boundaries The boundary of the import binary object is positioned between the vertices where the material is present and the vertices where the material is not present. The shape of this implied boundary can be complex, and the viewport does not show the full detail. The boundary can be moved closer to vertices where the material is present by increasing the \"binary threshold\" property of the import object. To confirm the boundary that will be used in the simulation by the solver, use an index monitor. |                                                                                                        |\r\n\r\n______________________________________________________________________\r\n\r\n**Example**\r\n\r\nPlease refer to the\r\n[importing spatial binary example](https://optics.ansys.com/hc/en-us/articles/360034382754-Import-object-Binary-spatial-data)\r\nfor details.",
    "summary": "Import binary data (1s and 0s) over an entire volume from script variables",
    "syntax": [
      {
        "syntax": "out = importbinary2(binary,x,y,z);",
        "description": "Import binary data from script variables in three dimensional simulations. All arguments are required."
      },
      {
        "syntax": "Parameter",
        "description": "Default value"
      },
      {
        "syntax": "---",
        "description": "---"
      },
      {
        "syntax": "binary",
        "description": "required"
      },
      {
        "syntax": "x",
        "description": "required"
      },
      {
        "syntax": "y",
        "description": "required"
      },
      {
        "syntax": "z",
        "description": "1"
      }
    ],
    "example": ""
  },
  {
    "name": "importbinaryobfuscated",
    "description": "This command is identical to importbinary but makes it possible to import data from a file that has been obfuscated. For details on how to obfuscate the data files, please see the Online Help in the User Guide, Structures section.",
    "usage": "importbinaryobfuscated();",
    "category": "general",
    "markdown": "# importbinaryobfuscated\r\n\r\nThis command is identical to importbinary but makes it possible to import data from a\r\nfile that has been obfuscated. For details on how to obfuscate the data files, please\r\nsee the Online Help in the User Guide, Structures section.\r\n\r\n| **Syntax**                                                                          | **Description**                                                                                                   |\r\n| ----------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| out = importbinaryobfuscated(key,filename,file_units,x0,y0,z0,reverse_index_order); | Import binary data from filename in three dimensional simulations. All arguments after the filename are optional. |\r\n| **Parameter**                                                                       | **Default value**                                                                                                 |\r\n| ---                                                                                 | ---                                                                                                               |\r\n| key                                                                                 | required                                                                                                          |\r\n| filename                                                                            | required                                                                                                          |\r\n| file_units                                                                          | \"m\"                                                                                                               |\r\n| x0                                                                                  | 0                                                                                                                 |\r\n| y0                                                                                  | 0                                                                                                                 |\r\n| z0                                                                                  | 0                                                                                                                 |\r\n| reverse_index_order                                                                 | 0                                                                                                                 |\r\n\r\n**Example**\r\n\r\nPlease refer this example [Obfuscating import data](**%20to%20be%20defined%20**).",
    "summary": "This command is identical to importbinary but makes it possible to import data from a file that has ...",
    "syntax": [
      {
        "syntax": "out = importbinaryobfuscated(key,filename,file_units,x0,y0,z0,reverse_index_order);",
        "description": "Import binary data from filename in three dimensional simulations. All arguments after the filename are optional."
      },
      {
        "syntax": "Parameter",
        "description": "Default value"
      },
      {
        "syntax": "---",
        "description": "---"
      },
      {
        "syntax": "key",
        "description": "required"
      },
      {
        "syntax": "filename",
        "description": "required"
      },
      {
        "syntax": "file_units",
        "description": "\"m\""
      },
      {
        "syntax": "x0",
        "description": "0"
      },
      {
        "syntax": "y0",
        "description": "0"
      },
      {
        "syntax": "z0",
        "description": "0"
      },
      {
        "syntax": "reverse_index_order",
        "description": "0"
      }
    ],
    "example": ""
  },
  {
    "name": "importcsvlc",
    "description": "This command adds a LC grid attribute or analysis group containing a liquid crystal structure and LC grid attribute with data imported from a specified csv (comma separated value) file without using the GUI import wizard. The arguments allow you to make the same choices that are available in the GUI. For more information about the GUI import wizard, see [Import object - Liquid crystal from CSV](**%20to%20be%20defined%20**).",
    "usage": "importcsvlc();",
    "category": "general",
    "markdown": "# importcsvlc\r\n\r\nThis command adds a LC grid attribute or analysis group containing a liquid crystal\r\nstructure and LC grid attribute with data imported from a specified csv (comma separated\r\nvalue) file without using the GUI import wizard. The arguments allow you to make the\r\nsame choices that are available in the GUI. For more information about the GUI import\r\nwizard, see [Import object - Liquid crystal from CSV](**%20to%20be%20defined%20**).\r\n\r\n| **Syntax**                                                           | **Description**                                                                                                                                                                                                                              |\r\n| -------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| importcsvlc(filename);                                               | Import the csv file from the specified filename. All arguments after the filename are optional.                                                                                                                                              |\r\n| out = importcsvlc(filename,option);                                  | Import the csv file but specify if it should be imported as a single grid attribute or added to an analysis group LC structure.                                                                                                              |\r\n| out = importcsvlc(filename,option,exported_from_xz_plane);           | Import the csv file and specify if it was originally exported from the x-z plane. This option only applies to 2D datasets but is critical to get the orientation of the LC structure correct when it is imported into FDTD in the x-y plane. |\r\n| out = importcsvlc(filename,option,exported_from_xz_plane,rotations); | Import the csv file with additional axis rotations.                                                                                                                                                                                          |\r\n\r\n| **Parameter**          | **Default value** | **Type** | **Description**                                                                                                                                                                                                                                              |\r\n| ---------------------- | ----------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| filename               | required          | string   | The name of the csv file to import. May contain complete path to file, or path relative to current working directory                                                                                                                                         |\r\n| option                 | true              | boolean  | When set to 1 (true) the import will create an analysis group structure with the grid attribute and a rectangle, the same as when using the graphical import. When set to 0 (false) it will import only the grid attribute. This argument is optional        |\r\n| exported_from_xz_plane | true              | boolean  | Applies to 2D datasets only. This indicates that the data was originally exported from the x-z plane and this should be accounted for when it is imported into the x-y plane.                                                                                |\r\n| rotations              | [0,0,0]           | matrix   | The optional argument allows you to specify 3 rotations around the x, y and z axes respectively that are used exactly the same way as the graphical import wizard. The matrix must have 3 elements and each value will be rounded to the nearest 90 degrees. |\r\n\r\n**Example**\r\n\r\nThe following script command will import the grid attribute from file \"myfile.csv\" into\r\nan LC analysis group and rotate 90 degrees about the x axis.\r\n\r\n```\r\nimportcsvlc(\"myfile.csv\",true,true,[90,0,0]);\r\n```\r\n\r\nFor more examples on creating LC grid attribute from script visit this kB page:\r\n[LC rotation](https://optics.ansys.com/hc/en-us/articles/360034915153-LC-Rotation).",
    "summary": "This command adds a LC grid attribute or analysis group containing a liquid crystal structure and LC...",
    "syntax": [
      {
        "syntax": "importcsvlc(filename);",
        "description": "Import the csv file from the specified filename. All arguments after the filename are optional."
      },
      {
        "syntax": "out = importcsvlc(filename,option);",
        "description": "Import the csv file but specify if it should be imported as a single grid attribute or added to an analysis group LC structure."
      },
      {
        "syntax": "out = importcsvlc(filename,option,exported_from_xz_plane);",
        "description": "Import the csv file and specify if it was originally exported from the x-z plane. This option only applies to 2D datasets but is critical to get the orientation of the LC structure correct when it is imported into FDTD in the x-y plane."
      },
      {
        "syntax": "out = importcsvlc(filename,option,exported_from_xz_plane,rotations);",
        "description": "Import the csv file with additional axis rotations."
      }
    ],
    "example": "importcsvlc(\"myfile.csv\",true,true,[90,0,0]);"
  },
  {
    "name": "importdataset",
    "description": "This command can be used to import a rectilinear or unstructured dataset into a simulation object.",
    "usage": "importdataset();",
    "category": "general",
    "markdown": "# importdataset\r\n\r\nThis command can be used to import a rectilinear or unstructured dataset into a\r\nsimulation object.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                             |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| importdataset(\"filename\") | Imports the dataset from the specified Matlab file in the current working directory. The object to load data into must be selected.                                                                                                         |\r\n| importdataset(charge)     | Imports the data from the specified dataset in the script workspace. The dataset can be loaded from a Matlab file to the script workspace using the [ matlabload ](./matlabload.md) command. The object to load data into must be selected. |\r\n\r\nThere are several cases where this command can be used\r\n\r\n1\\. Import data into a grid attribute (data could be from charge monitor or temperature\r\nmonitor in Finite Element IDE).\r\n\r\n2\\. Import doping data into a selected 'import doping' object.\r\n\r\n3\\. Import optical generation data into a selected 'import generation' object.\r\n\r\n4\\. Import field data to an import source (FDTD).\r\n\r\n5\\. Import field data to a port object (FDTD and MODE).\r\n\r\nThe command can be used in two ways. The dataset can be saved inside a matlab (.mat)\r\nfile which can be called to load the data or, the command can directly call the dataset\r\nfrom the script workspace to load it into the simulation object. In both cases, the\r\ndataset need to have the following properties:\r\n\r\n| **Data**                                           | **Simulation object**                                                                   | **Dataset type**            | **Name for variables defining coordinate data**                                                                                                                  | **Name for variables defining actual data** |\r\n| -------------------------------------------------- | --------------------------------------------------------------------------------------- | --------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |\r\n| Liquid crystal orientation (3 element unit vector) | 'lc orientation' grid attribute                                                         | Rectilinear                 | x, y, z                                                                                                                                                          | u                                           |\r\n| Rotation angles in radians                         | 'permittivity rotation' grid attribute                                                  | Rectilinear                 | x, y, z                                                                                                                                                          | theta, phi, psi                             |\r\n| Unitary transform matrix (3x3 tensor)              | 'matrix transform' grid attribute                                                       | Rectilinear                 | x, y, z                                                                                                                                                          | U                                           |\r\n| Charge density                                     | 'np density' grid attribute                                                             | Unstructured                | x, y, z, C                                                                                                                                                       | n, p                                        |\r\n| Doping profile                                     | 'Import doping' object                                                                  | Unstructured or rectangular | x, y, z, C (unstructured); x, y, z (rectangular)                                                                                                                 | N                                           |\r\n| Optical generation rate                            | Import generation' object                                                               | Rectangular                 | x, y, z                                                                                                                                                          | G                                           |\r\n| Temperature in Kelvin                              | 'temperature' grid attribute                                                            | Unstructured                | x, y, z, elements (see [ Dataset builder ](https://optics.ansys.com/hc/en-us/articles/360034901713-Dataset-builder) for more information)                        | N                                           |\r\n| E and H field data                                 | Import source in FDTD                                                                   | Rectilinear                 | x, y, z, f (optional) (see [ Sources - Import ](https://optics.ansys.com/hc/en-us/articles/360034383014-Sources-Import) for more information)                    | E (required), H (optional)                  |\r\n| E and H field data                                 | Port in MODE EME solver (note that only 1 mode can be imported at a time for each port) | Rectilinear                 | x,y,z (see [ Impoting arbitrary source fields ](https://optics.ansys.com/hc/en-us/articles/360034396394-Importing-arbitrary-source-fields) for more information) | E, H                                        |\r\n\r\n**Examples**\r\n\r\nThis example shows how to import an unstructured dataset 'charge' to the 'np Density'\r\ngrid attribute.\r\n\r\n```\r\nselect(\"np density\");\r\nimportdataset(\"device_data.mat\");\r\n```\r\n\r\nIt is also equivalent to the method below.\r\n\r\n```\r\nselect(\"np Density\");\r\nmatlabload(\"device_data.mat\");\r\nimportdataset(charge);\r\n```",
    "summary": "This command can be used to import a rectilinear or unstructured dataset into a simulation object",
    "syntax": [
      {
        "syntax": "importdataset(\"filename\")",
        "description": "Imports the dataset from the specified Matlab file in the current working directory. The object to load data into must be selected."
      },
      {
        "syntax": "importdataset(charge)",
        "description": "Imports the data from the specified dataset in the script workspace. The dataset can be loaded from a Matlab file to the script workspace using the [ matlabload ](./matlabload.md) command. The object to load data into must be selected."
      }
    ],
    "example": ""
  },
  {
    "name": "importnetlist",
    "description": "This script command can import an optical SPICE netlist.",
    "usage": "importnetlist();",
    "category": "general",
    "markdown": "# importnetlist\r\n\r\nThis script command can import an optical SPICE netlist.\r\n\r\n| **Syntax**                                  | **Description**                                                                                                                                                                                                                |\r\n| ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| importnetlist(\"compound name\", \"filename\"); | imports an optical SPICE netlist. The \"compound name\" is optional, if not specified, the Root Element level circuit configuration will be imported; if specified, the sub-circuit will be imported to this specified compound. |\r\n\r\n| **Parameter** |          | **Type** | **Description**      |\r\n| ------------- | -------- | -------- | -------------------- |\r\n| compound name | optional | string   | name of the compound |\r\n| filename      | required | string   | name of the netlist. |",
    "summary": "This script command can import an optical SPICE netlist",
    "syntax": [
      {
        "syntax": "importnetlist(\"compound name\", \"filename\");",
        "description": "imports an optical SPICE netlist. The \"compound name\" is optional, if not specified, the Root Element level circuit configuration will be imported; if specified, the sub-circuit will be imported to this specified compound."
      }
    ],
    "example": ""
  },
  {
    "name": "importnk",
    "description": "Imports the refractive index (n and k) over an entire volume or surface from a file. This command only applies to import primitives. The function returns 1 if the data is successfully imported. It is possible to import anisotropic nk data.",
    "usage": "importnk();",
    "category": "general",
    "markdown": "# importnk\r\n\r\nImports the refractive index (n and k) over an entire volume or surface from a file.\r\nThis command only applies to import primitives. The function returns 1 if the data is\r\nsuccessfully imported. It is possible to import anisotropic nk data.\r\n\r\n| **Syntax**                                                         | **Description**                                                                                                                           |\r\n| ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = importnk(filename,file_units, x0,y0,z0,reverse_index_order); | Import n (and k) data from filename in three dimensional (or two dimensional) simulations. All arguments after the filename are optional. |\r\n\r\n| **Parameter**       | **Default value** | **Type** | **Description**                                                                                                                                                                                                                           |\r\n| ------------------- | ----------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| filename            | required          | string   | name of the file with n (and k) data to import. May contain complete path to file, or path relative to current working directory                                                                                                          |\r\n| file_units          | \"m\"               | string   | The optional string argument file_units can be \"m\", \"cm, \"mm\", \"microns\" or \"nm\" to specify the units in the file.                                                                                                                        |\r\n| x0                  | 0                 | number   | The optional arguments x0, y0 and z0 specify the data origin in the global coordinates of the Graphical Layout Editor. For example, you can define your volume with respect to a particular point in space, for example (0,0,-5) microns. |\r\n| y0                  | 0                 | number   |                                                                                                                                                                                                                                           |\r\n| z0                  | 0                 | number   |                                                                                                                                                                                                                                           |\r\n| reverse_index_order | 0                 | number   | The optional argument reverse_index_order can be set to 1 to reverse how the indices are interpreted in the file. It is best to verify the correct setting with a graphical import before using the script command.                       |\r\n\r\n**Example**\r\n\r\nSee the\r\n[Import object - Spatial (n,k) data](https://optics.ansys.com/hc/en-us/articles/360034901993-Import-object-Spatial-n-k-data)\r\nexample for file format.",
    "summary": "Imports the refractive index (n and k) over an entire volume or surface from a file",
    "syntax": [
      {
        "syntax": "out = importnk(filename,file_units, x0,y0,z0,reverse_index_order);",
        "description": "Import n (and k) data from filename in three dimensional (or two dimensional) simulations. All arguments after the filename are optional."
      }
    ],
    "example": ""
  },
  {
    "name": "importnk2",
    "description": "Imports the refractive index (n and k) over an entire volume or surface from script variables. This command only applies to import primitives. The function returns 1 if the data is successfully imported. It is possible to import anisotropic nk data.",
    "usage": "importnk2();",
    "category": "general",
    "markdown": "# importnk2\r\n\r\nImports the refractive index (n and k) over an entire volume or surface from script\r\nvariables. This command only applies to import primitives. The function returns 1 if the\r\ndata is successfully imported. It is possible to import anisotropic nk data.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                     |\r\n| ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = importnk2(n,x,y,z); | Import n (and k) data from script variables in three dimensional simulations, n can be complex. All arguments are required. n must be of dimension NxMxP or NxMxPx3 with N >= 2, M >= 2 and P >= 2. |\r\n\r\n| **Parameter** | **Default value** | **Type** | **Description**                                                                                                                                                                                                                                                                                                                       |\r\n| ------------- | ----------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| n             | required          | matrix   | The refractive index. If it is complex-valued, then the imaginary part is interpreted as k. For isotropic material, this should be an NxMxP matrix in three dimensions and an NxMx2 matrix in two dimensions. For anisotropic material, this should be an NxMxPx3 matrix in three dimensions and an NxMx2x3 matrix in two dimensions. |\r\n| x             | required          | matrix   | If n is an NxMxP matrix, then x should have dimension Nx1. For two dimensional simulation, if n is an NxMx2 matrix then x should have dimension Nx1. Values of x must be uniformly spaced.                                                                                                                                            |\r\n| y             | required          | matrix   | If n is an NxMxP matrix, then y should have dimension Mx1. For two dimensional simulation, if n is an NxMx2 matrix then y should have dimension Mx1. Values of y must be uniformly spaced.                                                                                                                                            |\r\n| z             | required          | matrix   | If n is an NxMxP matrix, then z should have dimension Px1. For two dimensional simulation, if n is an NxMx2 matrix then z should have dimension 2x1. Values of z must be uniformly spaced.                                                                                                                                            |\r\n\r\n**Example**\r\n\r\n[Import object - Spatial (n,k) data](https://optics.ansys.com/hc/en-us/articles/360034901993-Import-object-Spatial-n-k-data)",
    "summary": "Imports the refractive index (n and k) over an entire volume or surface from script variables",
    "syntax": [
      {
        "syntax": "out = importnk2(n,x,y,z);",
        "description": "Import n (and k) data from script variables in three dimensional simulations, n can be complex. All arguments are required. n must be of dimension NxMxP or NxMxPx3 with N >= 2, M >= 2 and P >= 2."
      }
    ],
    "example": ""
  },
  {
    "name": "importnkobfuscated",
    "description": "This command is identical to importnk but makes it possible to import data from a file that has been obfuscated. For details on how to obfuscate the data files, please see the Online Help in the User Guide, Structures section.",
    "usage": "importnkobfuscated();",
    "category": "general",
    "markdown": "# importnkobfuscated\r\n\r\nThis command is identical to importnk but makes it possible to import data from a file\r\nthat has been obfuscated. For details on how to obfuscate the data files, please see the\r\nOnline Help in the User Guide, Structures section.\r\n\r\n| **Syntax**                                                                      | **Description**                                                                                                      |\r\n| ------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |\r\n| out = importnkobfuscated(key,filename,file_units,x0,y0,z0,reverse_index_order); | Import n (and k) data from filename in three dimensional simulations. All arguments after the filename are optional. |\r\n| **Parameter**                                                                   | **Default value**                                                                                                    |\r\n| ---                                                                             | ---                                                                                                                  |\r\n| key                                                                             | required                                                                                                             |\r\n| filename                                                                        | required                                                                                                             |\r\n| file_units                                                                      | \"m\"                                                                                                                  |\r\n| x0                                                                              | 0                                                                                                                    |\r\n| y0                                                                              | 0                                                                                                                    |\r\n| z0                                                                              | 0                                                                                                                    |\r\n| reverse_index_order                                                             | 0                                                                                                                    |\r\n\r\n**Example**\r\n\r\nPlease refer this example [Obfuscating import data](**%20to%20be%20defined%20**).",
    "summary": "This command is identical to importnk but makes it possible to import data from a file that has been...",
    "syntax": [
      {
        "syntax": "out = importnkobfuscated(key,filename,file_units,x0,y0,z0,reverse_index_order);",
        "description": "Import n (and k) data from filename in three dimensional simulations. All arguments after the filename are optional."
      },
      {
        "syntax": "Parameter",
        "description": "Default value"
      },
      {
        "syntax": "---",
        "description": "---"
      },
      {
        "syntax": "key",
        "description": "required"
      },
      {
        "syntax": "filename",
        "description": "required"
      },
      {
        "syntax": "file_units",
        "description": "\"m\""
      },
      {
        "syntax": "x0",
        "description": "0"
      },
      {
        "syntax": "y0",
        "description": "0"
      },
      {
        "syntax": "z0",
        "description": "0"
      },
      {
        "syntax": "reverse_index_order",
        "description": "0"
      }
    ],
    "example": ""
  },
  {
    "name": "importsurface",
    "description": "Imports surface data. This command only applies to import primitives. The function returns 1 if the data is successfully imported. Example script files showing how to use these functions can be found in the Online Help. See the User Guide, Structures section.",
    "usage": "importsurface();",
    "category": "general",
    "markdown": "# importsurface\r\n\r\nImports surface data. This command only applies to import primitives. The function\r\nreturns 1 if the data is successfully imported. Example script files showing how to use\r\nthese functions can be found in the Online Help. See the User Guide, Structures section.\r\n\r\n| **Syntax**                                                                | **Description**                                                                                                                     |\r\n| ------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = importsurface(filename,upper_surface,file_units,x0,y0,z0,invertXY); | Import a surface from the file in the string filename in a three dimensional simulation. All arguments after filename are optional. |\r\n| out = importsurface(filename,upper_surface,file_units,x0,y0,invertXY);    | Import a surface from the file in the string filename in a two dimensional simulation. All arguments after filename are optional.   |\r\n\r\n| **Parameter** | **Default value** | **Type** | **Description**                                                                                                                                                                                                                                                               |\r\n| ------------- | ----------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| filename      | required          | string   | name of the file with surface data to import. May contain complete path to file, or path relative to current working directory                                                                                                                                                |\r\n| upper_surface | 1                 | number   | This optional argument should be 1 to import the upper surface and 0 to import the lower surface.                                                                                                                                                                             |\r\n| file_units    | \"m\"               | string   | The optional string argument file_units can be \"m\", \"cm, \"mm\", \"microns\" or \"nm\" to specify the units in the file.                                                                                                                                                            |\r\n| x0            | 0                 | number   | The optional arguments x0, y0 and z0 specify the data origin in the global coordinates of the Graphical Layout Editor. For example, if you are importing a surface defined by an AFM that is on a slab of Si that ranges from 0 to 2 microns, you should set z0 to 2 microns. |\r\n| y0            | 0                 | number   |                                                                                                                                                                                                                                                                               |\r\n| z0            | 0                 | number   |                                                                                                                                                                                                                                                                               |\r\n| invertXY      | 0                 | number   | The optional argument invertXY can be used to reverse how the x and y axes are read from the file.                                                                                                                                                                            |\r\n\r\n**Example**\r\n\r\nplease refer a complete example:\r\n[Import object - Surfaces](https://optics.ansys.com/hc/en-us/articles/360034901973)",
    "summary": "Imports surface data",
    "syntax": [
      {
        "syntax": "out = importsurface(filename,upper_surface,file_units,x0,y0,z0,invertXY);",
        "description": "Import a surface from the file in the string filename in a three dimensional simulation. All arguments after filename are optional."
      },
      {
        "syntax": "out = importsurface(filename,upper_surface,file_units,x0,y0,invertXY);",
        "description": "Import a surface from the file in the string filename in a two dimensional simulation. All arguments after filename are optional."
      }
    ],
    "example": ""
  },
  {
    "name": "importsurface2",
    "description": "Imports surface data from script variables. This command only applies to import primitives. The function returns 1 if the data is successfully imported. Example script files showing how to use these functions can be found in the Online Help. See the User Guide, Structures section.",
    "usage": "importsurface2();",
    "category": "general",
    "markdown": "# importsurface2\r\n\r\nImports surface data from script variables. This command only applies to import\r\nprimitives. The function returns 1 if the data is successfully imported. Example script\r\nfiles showing how to use these functions can be found in the Online Help. See the User\r\nGuide, Structures section.\r\n\r\n| **Syntax**                                 | **Description**                                                                                                          |\r\n| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |\r\n| out = importsurface2(Z,x,y,upper_surface); | Import a surface from the variables Z, x and y in three dimensional simulations. The upper_surface argument is optional. |\r\n\r\n| **Parameter** | **Default value** | **Type** | **Description**                                                                                                                                  |\r\n| ------------- | ----------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Z             | required          | matrix   | The two dimensional matrix that defines the surface.                                                                                             |\r\n| x             | required          | matrix   | If Z is an NxM matrix, then x should have dimension Nx1. For two dimensional simulation, if Y is an Nx1 matrix then x should have dimension Nx1. |\r\n| y             | required          | matrix   | If Z is an NxM matrix, then y should have dimension Mx1.                                                                                         |\r\n| upper_surface | 1                 | number   | This optional argument should be 1 to import the upper surface and 0 to import the lower surface.                                                |\r\n\r\n**Example**\r\n\r\nplease refer a complete example:\r\n[Import object - Surfaces](https://optics.ansys.com/hc/en-us/articles/360034901973)",
    "summary": "Imports surface data from script variables",
    "syntax": [
      {
        "syntax": "out = importsurface2(Z,x,y,upper_surface);",
        "description": "Import a surface from the variables Z, x and y in three dimensional simulations. The upper_surface argument is optional."
      }
    ],
    "example": ""
  },
  {
    "name": "inpoly",
    "description": "Determines if a point is inside or outside a polygon. The function is vectorized so it can be used to create a mesh of a polygon.",
    "usage": "inpoly();",
    "category": "general",
    "markdown": "# inpoly\r\n\r\nDetermines if a point is inside or outside a polygon. The function is vectorized so it\r\ncan be used to create a mesh of a polygon.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                                         |\r\n| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = inpoly(V,x,y); | Returns a matrix of the same dimension of x with 1 if the corresponding point is inside the polygon and 0 otherwise. The matrices x and y must have the same length, or one of them can be a singleton. |\r\n\r\n**Examples**\r\n\r\nThe following example shows how to identify the points in a mesh that are inside a\r\npolygon.\r\n\r\n```\r\nV = [ 0,0; 1,0; 1,1; 0,1];\r\nx = linspace(-4,4,100);\r\ny = linspace(-4,4,100);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\nimage(x,y,inpoly(V,X,Y),\"x\",\"y\");\r\n```\r\n\r\nThe generated image is:",
    "summary": "Determines if a point is inside or outside a polygon",
    "syntax": [
      {
        "syntax": "out = inpoly(V,x,y);",
        "description": "Returns a matrix of the same dimension of x with 1 if the corresponding point is inside the polygon and 0 otherwise. The matrices x and y must have the same length, or one of them can be a singleton."
      }
    ],
    "example": ""
  },
  {
    "name": "insert",
    "description": "Inserts an object into an existing cell in a lookup table.",
    "usage": "insert();",
    "category": "general",
    "markdown": "# insert\r\n\r\nInserts an object into an existing cell in a lookup table.\r\n\r\n| **Syntax**                                                                   | **Description**                          |\r\n| ---------------------------------------------------------------------------- | ---------------------------------------- |\r\n| out{1}.association = insert( out{1}.association, association, cell number ); | Inserts an object into an existing cell. |\r\n\r\n**Example**\r\n\r\nLoads the lookup table \"coupler_map.ixml\" and prints the cell array that containing all\r\nthe contents of the .ixml file\r\n\r\n```\r\nclear;\r\ntabCoupler = lookupread( \"coupler_map.ixml\" );\r\n?toscript( tabCoupler );\r\n```\r\n\r\nwhere “coupler_map.ixml” is a lookup table containing a map between coupler parameters\r\nand different s-parameters:\r\n\r\n```\r\ntabCoupler=cell(1);\r\ntabCoupler{1}=struct;\r\ntabCoupler{1}.association=cell(1);\r\ntabCoupler{1}.association{1}=struct;\r\ntabCoupler{1}.association{1}.design=cell(1);\r\ntabCoupler{1}.association{1}.design{1}=struct;\r\ntabCoupler{1}.association{1}.design{1}.name='gap';\r\ntabCoupler{1}.association{1}.design{1}.value=3.5e-007;\r\ntabCoupler{1}.association{1}.extracted=cell(1);\r\ntabCoupler{1}.association{1}.extracted{1}=struct;\r\ntabCoupler{1}.association{1}.extracted{1}.name='coupling_length';\r\ntabCoupler{1}.association{1}.extracted{1}.value=7.18624e-006;\r\ntabCoupler{1}.name='coupler_extracted';\r\n```\r\n\r\nThe following commands insert an object into the existing lookup table\r\n\r\n```\r\nassociation=struct;\r\nassociation.design=cell(1);\r\nassociation.design{1}=struct;\r\nassociation.design{1}.name='gap';\r\nassociation.design{1}.value=5e-007;\r\nassociation.extracted=cell(1);\r\nassociation.extracted{1}=struct;\r\nassociation.extracted{1}.name='coupling_length';\r\nassociation.extracted{1}.value=9e-006;\r\n# insert association at last position\r\ntabCoupler{1}.association = insert( tabCoupler{1}.association, association, 2 );\r\n# print updated values\r\n?toscript(tabCoupler);\r\nlookupwrite( \"coupler_map.ixml\", tabCoupler );\r\n```\r\n\r\nnow the table prints as below:\r\n\r\n```\r\ntabCoupler=cell(1);\r\ntabCoupler{1}=struct;\r\ntabCoupler{1}.association=cell(2);\r\ntabCoupler{1}.association{1}=struct;\r\ntabCoupler{1}.association{1}.design=cell(1);\r\ntabCoupler{1}.association{1}.design{1}=struct;\r\ntabCoupler{1}.association{1}.design{1}.name='gap';\r\ntabCoupler{1}.association{1}.design{1}.value=3.5e-007;\r\ntabCoupler{1}.association{1}.extracted=cell(1);\r\ntabCoupler{1}.association{1}.extracted{1}=struct;\r\ntabCoupler{1}.association{1}.extracted{1}.name='coupling_length';\r\ntabCoupler{1}.association{1}.extracted{1}.value=7.18624e-006;\r\ntabCoupler{1}.association{2}=struct;\r\ntabCoupler{1}.association{2}.design=cell(1);\r\ntabCoupler{1}.association{2}.design{1}=struct;\r\ntabCoupler{1}.association{2}.design{1}.name='gap';\r\ntabCoupler{1}.association{2}.design{1}.value=5e-007;\r\ntabCoupler{1}.association{2}.extracted=cell(1);\r\ntabCoupler{1}.association{2}.extracted{1}=struct;\r\ntabCoupler{1}.association{2}.extracted{1}.name='coupling_length';\r\ntabCoupler{1}.association{2}.extracted{1}.value=9e-006;\r\ntabCoupler{1}.name='coupler_extracted';\r\n```\r\n\r\nThe following commands append a new association into the existing table:\r\n\r\n```\r\nclear;\r\ndesign=cell(1);\r\ndesign{1}=struct;\r\ndesign{1}.name='gap';\r\ndesign{1}.value=6e-007;\r\n# create extracted parameter\r\nextracted=cell(1);\r\nextracted{1}=struct;\r\nextracted{1}.name='coupling_length';\r\nextracted{1}.value=9.9e-006;\r\n# append to existing table\r\nlookupappend( \"coupler_map.ixml\", \"coupler_extracted\", design, extracted );\r\n# print contents\r\n?toscript( lookupread( \"coupler_map.ixml\" ) );\r\n```\r\n\r\nNow the lookup table prints as below:\r\n\r\n```\r\nvalue=cell(1);\r\nvalue{1}=struct;\r\nvalue{1}.association=cell(3);\r\nvalue{1}.association{1}=struct;\r\nvalue{1}.association{1}.design=cell(1);\r\nvalue{1}.association{1}.design{1}=struct;\r\nvalue{1}.association{1}.design{1}.name='gap';\r\nvalue{1}.association{1}.design{1}.value=3.5e-007;\r\nvalue{1}.association{1}.extracted=cell(1);\r\nvalue{1}.association{1}.extracted{1}=struct;\r\nvalue{1}.association{1}.extracted{1}.name='coupling_length';\r\nvalue{1}.association{1}.extracted{1}.value=7.18624e-006;\r\nvalue{1}.association{2}=struct;\r\nvalue{1}.association{2}.design=cell(1);\r\nvalue{1}.association{2}.design{1}=struct;\r\nvalue{1}.association{2}.design{1}.name='gap';\r\nvalue{1}.association{2}.design{1}.value=5e-007;\r\nvalue{1}.association{2}.extracted=cell(1);\r\nvalue{1}.association{2}.extracted{1}=struct;\r\nvalue{1}.association{2}.extracted{1}.name='coupling_length';\r\nvalue{1}.association{2}.extracted{1}.value=9e-006;\r\nvalue{1}.association{3}=struct;\r\nvalue{1}.association{3}.design=cell(1);\r\nvalue{1}.association{3}.design{1}=struct;\r\nvalue{1}.association{3}.design{1}.name='gap';\r\nvalue{1}.association{3}.design{1}.value=6e-007;\r\nvalue{1}.association{3}.extracted=cell(1);\r\nvalue{1}.association{3}.extracted{1}=struct;\r\nvalue{1}.association{3}.extracted{1}.name='coupling_length';\r\nvalue{1}.association{3}.extracted{1}.value=9.9e-006;\r\nvalue{1}.name='coupler_extracted';\r\n```",
    "summary": "Inserts an object into an existing cell in a lookup table",
    "syntax": [
      {
        "syntax": "out{1}.association = insert( out{1}.association, association, cell number );",
        "description": "Inserts an object into an existing cell."
      }
    ],
    "example": "clear;\r\ntabCoupler = lookupread( \"coupler_map.ixml\" );\r\n?toscript( tabCoupler );"
  },
  {
    "name": "insertsweep",
    "description": "Inserts a sweep/optimization/Monte Carlo item as a parent to an existing analysis item. The existing item becomes a child of the newly inserted sweep.",
    "usage": "insertsweep();",
    "category": "general",
    "markdown": "# insertsweep\r\n\r\nInserts a sweep/optimization/Monte Carlo item as a parent to an existing analysis item.\r\nThe existing item becomes a child of the newly inserted sweep.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                |\r\n| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| insertsweep(\"name\"); | Inserts a sweep/optimization/Monte Carlo item as a child to a parent analysis item. \"name\" is the absolute name of the existing analysis item. |\r\n\r\n**Example**\r\n\r\n```\r\naddsweep(0);\r\ninsertsweep(\"sweep\");\r\n```",
    "summary": "Inserts a sweep/optimization/Monte Carlo item as a parent to an existing analysis item",
    "syntax": [
      {
        "syntax": "insertsweep(\"name\");",
        "description": "Inserts a sweep/optimization/Monte Carlo item as a child to a parent analysis item. \"name\" is the absolute name of the existing analysis item."
      }
    ],
    "example": "addsweep(0);\r\ninsertsweep(\"sweep\");"
  },
  {
    "name": "installdesignkit",
    "description": "Installs a design kit file to the Design Kits folder.",
    "usage": "installdesignkit();",
    "category": "general",
    "markdown": "# installdesignkit\r\n\r\nInstalls a design kit file to the Design Kits folder.\r\n\r\n| **Syntax**                                   | **Description**                                                                                                                                                                                                                                                                                                                                          |\r\n| -------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| installdesignkit(filename, path, overwrite); | Installs a design kit file named ‘filename.cml’ and directs its contents to a user defined ‘path’. The design kit will be available in the element library ‘Design kits’ folder. If ‘overwrite’ is true, it will overwrite an existing design kit with the same name, if ‘overwrite’ is false, it will ask the user for confirmation before overwriting. |\r\n\r\n**Example**\r\n\r\n```\r\n#installs the \"dk.cml\" library to the Design Kits folder\r\ninstalldesignkit(\"dk.cml\", \"C:/Users/xxx\", true);\r\n```",
    "summary": "Installs a design kit file to the Design Kits folder",
    "syntax": [
      {
        "syntax": "installdesignkit(filename, path, overwrite);",
        "description": "Installs a design kit file named ‘filename.cml’ and directs its contents to a user defined ‘path’. The design kit will be available in the element library ‘Design kits’ folder. If ‘overwrite’ is true, it will overwrite an existing design kit with the same name, if ‘overwrite’ is false, it will ask the user for confirmation before overwriting."
      }
    ],
    "example": "#installs the \"dk.cml\" library to the Design Kits folder\r\ninstalldesignkit(\"dk.cml\", \"C:/Users/xxx\", true);"
  },
  {
    "name": "integrate",
    "description": "Returns the integral over the specified dimension of a matrix.",
    "usage": "integrate();",
    "category": "general",
    "markdown": "# integrate\r\n\r\nReturns the integral over the specified dimension of a matrix.\r\n\r\nIntegrals over singleton dimensions will return zero (i.e. the area under a single point\r\nis zero). See integrate2 for an alternate behavior.\r\n\r\n| **Syntax**                          | **Description**                                                                                                                                                                                                                                                |\r\n| ----------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = integrate(A, n, x1);          | Integrates A over the nth dimension in the matrix. x1 is the corresponding position vector for that dimension.                                                                                                                                                 |\r\n| out = integrate(A, d, x1, x2, ...); | Calculates the integral of A over the specified list of dimension(s) d. d is a vector containing the dimensions over which to integrate. xi are the position vectors corresponding to the dimensions of A over which the integration is occurring. For example |\r\n\r\n- power = integrate(A,1:2,x,y) will integrate A over an x-y surface.\r\n\r\n**Example**\r\n\r\nIn the following example, the integrate command is used to integrate y=x^2 from 0 to 3,\r\nwhere the function is sampled at the points x=0,1,2,3. The integrate function will\r\ndetermine dx from the position vector x. For reference, the value of this integral for\r\nthe continuous function y=x^2 (as opposed to the discrete samples in this example) is 9.\r\nReducing dx will make this discrete integral approach the continuous result.\r\n\r\nAdvanced note: The actual calculation in this very simple example will be 0.5*0 + 1*1 +\r\n1*4 + 0.5*9 = 9.5, as illustrated in the figure below. It is interesting to note that\r\nthe first and last points have a factor of 0.5\\*dx because they are at the edge of the\r\nintegration range. Without the factor of 0.5 applied to those points, the integral would\r\neffectively be calculated from x=-0.5 to x=3.5\r\n\r\n```\r\n?x=0:3;\r\ny=x^2;\r\n?integrate(y,1,x);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\nresult: \r\n9.5 \r\n```\r\n\r\nNext, we demonstrate that the integrate function correctly treats non-uniform sampling.\r\nThe portion of the function from 0 to 2 is evaluated with a dx=1, while a dx of 0.2 is\r\nused from 2 to 3. In this case, the integrate function will calculate 0.5*0 + 1*1 +\r\n0.6*4 + 0.2*4.84 + 0.2*5.76 + 0.2*6.76 + 0.2*7.84 + 0.1*9;\r\n\r\n```\r\n?x=[[0:1]; [2:0.2:3]];\r\ny=x^2;\r\n?integrate(y,1,x);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n2.2 \r\n2.4 \r\n2.6 \r\n2.8 \r\n3 \r\nresult: \r\n9.34 \r\n```\r\n\r\nLastly, this example shows how to calculate the power transmitted through a y-normal\r\nmonitor by integrating the Poynting vector. To get transmitted power, we want to\r\nintegrate the real part of the normal component of the poynting vector (Py). The Py data\r\nmatrix will have size N x x N y x N z x N f , where Nx, Ny, Nz are the number of mesh\r\npoint in each direction. If the monitor is Y-normal, Ny=1. Nf is the number of frequency\r\npoints collected by the monitor. After integrating over the X and Z direction, we are\r\nbasically left with a 1D function of the transmitted power vs frequency.\r\n\r\n```\r\nPy = getdata(\"Monitor1\",\"Py\");\r\nx = getdata(\"Monitor1\",\"x\");\r\ny = getdata(\"Monitor1\",\"y\");\r\nz = getdata(\"Monitor1\",\"z\");\r\nf = getdata(\"Monitor1\",\"f\");\r\npower = 0.5 * integrate( real(Py), [1,3], x,z );\r\n```",
    "summary": "Returns the integral over the specified dimension of a matrix",
    "syntax": [
      {
        "syntax": "out = integrate(A, n, x1);",
        "description": "Integrates A over the nth dimension in the matrix. x1 is the corresponding position vector for that dimension."
      },
      {
        "syntax": "out = integrate(A, d, x1, x2, ...);",
        "description": "Calculates the integral of A over the specified list of dimension(s) d. d is a vector containing the dimensions over which to integrate. xi are the position vectors corresponding to the dimensions of A over which the integration is occurring. For example"
      }
    ],
    "example": "?x=0:3;\r\ny=x^2;\r\n?integrate(y,1,x);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\nresult: \r\n9.5"
  },
  {
    "name": "integrate2",
    "description": "Very similar to the standard integrate function, except that singleton dimensions are ignored.",
    "usage": "integrate2();",
    "category": "general",
    "markdown": "# integrate2\r\n\r\nVery similar to the standard integrate function, except that singleton dimensions are\r\nignored.\r\n\r\nAs described in the integrate function description, integrating over dimensions with a\r\nsingle value (singleton dimensions) returns zero because the area under a single point\r\nis zero. In some cases, particularly when you are not sure which dimensions are\r\nsingleton, this behavior can cause difficulties. The integrate2 function automatically\r\nignores all dimensions with a size of one, which avoids the problem of a zero valued\r\nintegrals due to singleton dimensions.\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                                                                                                         |\r\n| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = integrate2(A, 1, x1);          | Integrates A over the first dimension in the matrix. x1 is the corresponding position vector.                                                                                                                                                                                                                           |\r\n| out = integrate2(A, d, x1, x2, ...); | Calculates the integral of A over the specified dimension(s) d. d is a vector containing the dimensions over which to integrate. xi is the position vector corresponding to the dimensions of A over which the integration is occurring. If any of the xi vectors only have 1 element, integrate returns 0. For example |\r\n\r\n- power = integrate2(A,1:2,x,y) will integrate A over an x-y surface.\r\n\r\n**Example**\r\n\r\nIn the following example, we compare the integrate and integrate2 commands when\r\nintegrating over matrices with singleton dimensions.\r\n\r\n```\r\n# create 3D matrix of results: data(x,y,z) where\r\n# there are 50 'x' sample points, 1 'y' sample points\r\n# and 40 'z' sample points. This is typical of data\r\n# from a 2D monitor oriented in the XZ plane.\r\nx=linspace(-5,5,50);\r\ny=0;\r\nz=linspace(-3,3,40);\r\nX=meshgrid3dx(x,y,z);\r\nZ=meshgrid3dz(x,y,z);\r\ndata = X^2 + Z^2;\r\nimage(x,z,data,\"x\",\"z\",\"data\");\r\n?integrate2(data, [1,2,3], x,y,z); # Integrate2 ignores singleton dimension, giving non-zero result.\r\n?integrate (data, [1,2,3], x,y,z); # Result is zero because of the singleton dimension\r\n?integrate (data, [1,3] , x,z ); # Get the same result as integrate2 by integrating over x and z, but not y.\r\n> result: \r\n> 680.653 \r\n> result: \r\n> 0 \r\n> result: \r\n> 680.653 \r\n```",
    "summary": "Very similar to the standard integrate function, except that singleton dimensions are ignored",
    "syntax": [
      {
        "syntax": "out = integrate2(A, 1, x1);",
        "description": "Integrates A over the first dimension in the matrix. x1 is the corresponding position vector."
      },
      {
        "syntax": "out = integrate2(A, d, x1, x2, ...);",
        "description": "Calculates the integral of A over the specified dimension(s) d. d is a vector containing the dimensions over which to integrate. xi is the position vector corresponding to the dimensions of A over which the integration is occurring. If any of the xi vectors only have 1 element, integrate returns 0. For example"
      }
    ],
    "example": "# create 3D matrix of results: data(x,y,z) where\r\n# there are 50 'x' sample points, 1 'y' sample points\r\n# and 40 'z' sample points. This is typical of data\r\n# from a 2D monitor oriented in the XZ plane.\r\nx=linspace(-5,5,50);\r\ny=0;\r\nz=linspace(-3,3,40);\r\nX=meshgrid3dx(x,y,z);\r\nZ=meshgrid3dz(x,y,z);\r\ndata = X^2 + Z^2;\r\nimage(x,z,data,\"x\",\"z\",\"data\");\r\n?integrate2(data, [1,2,3], x,y,z); # Integrate2 ignores singleton dimension, giving non-zero result.\r\n?integrate (data, [1,2,3], x,y,z); # Result is zero because of the singleton dimension\r\n?integrate (data, [1,3] , x,z ); # Get the same result as integrate2 by integrating over x and z, but not y.\r\n> result: \r\n> 680.653 \r\n> result: \r\n> 0 \r\n> result: \r\n> 680.653"
  },
  {
    "name": "interp",
    "description": "Calculates the linear interpolation of a given data set. The data can be complex.",
    "usage": "interp();",
    "category": "general",
    "markdown": "# interp\r\n\r\nCalculates the linear interpolation of a given data set. The data can be complex.\r\n\r\n| **Syntax**                    | **Description**                               |\r\n| ----------------------------- | --------------------------------------------- |\r\n| out = interp(Ex, xold, xnew); | Does a linear interpolation of a 1D data set. |\r\n\r\n- Ex is existing data\r\n- xold specifies the points where Ex is sampled\r\n- xnew specifies new point to interpolate the data.\r\n\r\nThe xnew does not have to be within the bounds of xold.\\\r\ninterp(Ex, xold, yold, xnew, ynew); | The 2D version of interp.\\\r\ninterp(Ex, xold, yold, zold, xnew, ynew, znew); | The 3D version of interp.\\\r\ninterp(Ex, xold, yold, zold, told, xnew, ynew, znew, tnew); | The 4D version of interp.\r\n\r\n**Example**\r\n\r\nResample Ex at xnew using linear interpolation. Note that xnew can be outside the bounds\r\nof xold.\r\n\r\n```\r\nxold=linspace(0,10,100);\r\nEx=sin(xold);\r\nxnew=linspace(-1,9,10); # defining a new x vector\r\nExnew=interp(Ex,xold,xnew); # interpolating the new data set\r\nplotxy(xold,Ex,xnew,Exnew,\"x\",\"y\",\"\");\r\nlegend(\"old data\", \"interp\");\r\n```\r\n\r\nThe example code will generate a plot for two vectors that were sampled at different\r\npositions. It shows the data sampled at the old and new positions. Note that the\r\n'interp' data only looks 'bad' because 'xnew' has only 10 points compared to 100 in the\r\noriginal data.",
    "summary": "Calculates the linear interpolation of a given data set",
    "syntax": [
      {
        "syntax": "out = interp(Ex, xold, xnew);",
        "description": "Does a linear interpolation of a 1D data set."
      }
    ],
    "example": "xold=linspace(0,10,100);\r\nEx=sin(xold);\r\nxnew=linspace(-1,9,10); # defining a new x vector\r\nExnew=interp(Ex,xold,xnew); # interpolating the new data set\r\nplotxy(xold,Ex,xnew,Exnew,\"x\",\"y\",\"\");\r\nlegend(\"old data\", \"interp\");"
  },
  {
    "name": "interptet",
    "description": "Interpolates a 3D dataset from a tetrahedral grid to another tetrahedral or a rectilinear grid. The data can be complex.",
    "usage": "interptet();",
    "category": "general",
    "markdown": "# interptet\r\n\r\nInterpolates a 3D dataset from a tetrahedral grid to another tetrahedral or a\r\nrectilinear grid. The data can be complex.\r\n\r\nThis function is typically used for resampling data evaluated originally in a finite\r\nelement mesh (monitor data from CHARGE, for example) to a new rectilinear grid.\r\n\r\n## \\[[Note:]\\] Since 2020a R7, \\[[interptet]\\] can interpolate a data set from a tetrahedral to a rectangular grid or to a list of points. The data can be vectorial.\r\n\r\n| **Syntax**                                                                                                                 | **Description**                                                                                                                  |\r\n| -------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = interptet(tet, vtx, u, xi, yi, zi, extrap_val); out = interptet(tet, vtx, u, xi, yi, zi, extrap_val, \"rectilinear\"); | Does a tetrahedral to rectilinear interpolation of a function and outputs a PxQxRxS array of interpolated values, f(xi,yi,zi,p). |\r\n\r\n- u is existing data of the finite element mesh (NxS)\r\n- xi, yi and zi are arrays with length P, Q and R, respectively. They specify the points\r\n  where u is to be sampled on the rectilinear mesh, in the x-direction, y-direction and\r\n  z-direction\r\n- tet is the connectivity array, Mx4, containing row entries that index the 4 vertices\r\n  of M tetrahedra. Taken from the simulation region\r\n- vtx is a matrix with the vertices of the tetrahedral mesh, Nx3, containing row entries\r\n  of (x,y,z) pairs. Taken from the simulation region\r\n- extrap_val(optional): if an interpolation point is outside of the finite element mesh,\r\n  the point will be assigned this value (default is Inf)\r\n\r\nout = interptet(tet, vtx, u, xi, yi, zi, extrap_val, \"unstructured\"); | Does a\r\ntetrahedral to point cloud interpolation of a function and outputs a PxS array of\r\ninterpolated values.\r\n\r\n- u is existing data of the finite element mesh (NxS)\r\n- xi, yi and zi are arrays with length P. They specify the P points where u is to be\r\n  sampled on\r\n- tet is the connectivity array, Mx4, containing row entries that index the 4 vertices\r\n  of M tetrahedra. Taken from the simulation region\r\n- vtx is a matrix with the vertices of the tetrahedral mesh, Nx3, containing row entries\r\n  of (x,y,z) pairs. Taken from the simulation region\r\n- extrap_val(optional): if an interpolation point is outside of the finite element mesh,\r\n  the point will be assigned this value (default is Inf)\r\n\r\n**Example**\r\n\r\nSee the example for the interptri script function.",
    "summary": "Interpolates a 3D dataset from a tetrahedral grid to another tetrahedral or a rectilinear grid",
    "syntax": [
      {
        "syntax": "out = interptet(tet, vtx, u, xi, yi, zi, extrap_val); out = interptet(tet, vtx, u, xi, yi, zi, extrap_val, \"rectilinear\");",
        "description": "Does a tetrahedral to rectilinear interpolation of a function and outputs a PxQxRxS array of interpolated values, f(xi,yi,zi,p)."
      }
    ],
    "example": ""
  },
  {
    "name": "interptri",
    "description": "Interpolates a 2D dataset from a triangular grid to another triangular or a rectilinear grid. The data can be complex.",
    "usage": "interptri();",
    "category": "general",
    "markdown": "# interptri\r\n\r\nInterpolates a 2D dataset from a triangular grid to another triangular or a rectilinear\r\ngrid. The data can be complex.\r\n\r\nThis function is typically used for resampling data evaluated originally in a finite\r\nelement mesh (monitor data from DGTD, for example) to a new rectilinear grid.\r\n\r\n## \\[[Note:]\\] A special case involves converting data from elements to vertices and vice-versa. This require additional processing, beyond interptri and is covered in the following article - [Interpolating Between Element and Vertex Datapoints in Finite-element Datasets](https://optics.ansys.com/hc/en-us/articles/14259382364563)\r\n\r\n## \\[[Note:]\\] Since 2020a R7, \\[[interptri]\\] can interpolate a data set from a triangular to a rectangular grid or to a list of points. The data can be vectorial.\r\n\r\n| **Syntax**                                                                                                         | **Description**                                                                                                                 |\r\n| ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = interptri(tri, vtx, u, xi, yi, extrap_val); out = interptri(tri, vtx, u, xi, yi, extrap_val, \"rectilinear\"); | Does a triangular to rectilinear grid interpolation of a function and outputs a PxQxS array of interpolated values, z(xi,yi,p). |\r\n\r\n- u is existing data of the finite element mesh (size NxS)\r\n- xi and yi are arrays with length P and Q, respectively. They specify the points where\r\n  u is to be sampled on the rectilinear mesh, in the x-direction and y-direction\r\n- tri is the connectivity array, Mx3, containing row entries that index the three\r\n  vertices of M triangles. Taken from the simulation region\r\n- vtx is a matrix with the vertices of the triangular mesh, Nx2, containing row entries\r\n  of (x,y) pairs. Taken from the simulation region\r\n- extrap_val(optional): if an interpolation point is outside of the finite element mesh,\r\n  the point will be assigned this value (default is Inf)\r\n\r\nout = interptri(tri, vtx, u, xi, yi, extrap_val, \"unstructured\"); | Does a triangular to\r\npoint cloud interpolation of a function and outputs a PxS array of interpolated values.\r\n\r\n- u is existing data of the finite element mesh (size NxS)\r\n- xi and yi are arrays with length P. They specify the points where u is to be sampled\r\n  on\r\n- tri is the connectivity array, Mx3, containing row entries that index the three\r\n  vertices of M triangles. Taken from the simulation region\r\n- vtx is a matrix with the vertices of the triangular mesh, Nx2, containing row entries\r\n  of (x,y) pairs. Taken from the simulation region\r\n- extrap_val(optional): if an interpolation point is outside of the finite element mesh,\r\n  the point will be assigned this value (default is Inf)\r\n\r\n**Example**\r\n\r\nThis is an example of a script for CHARGE that will resample charge \"n\" on a rectilinear\r\ngrid. The example assumes that a simulation has been run in CHARGE with multiple bias\r\nvoltages. The simulation domain is in the XZ plane. The script will select the charge\r\ndata for the first bias voltage and resample the charge information on the XZ plane to a\r\nnew rectilinear grid defined by xrect and zrect. This is just to show how the interptri\r\ncommand will get used. It will not actually plot the results unless you try a similar\r\nset of commands with a simulation that has already been run.\r\n\r\n```\r\n# Read the charge data\r\nN = getdata(\"CHARGE\",\"charge\",\"n\");# The dimension of N is [L, 1, bb, 1].\r\n  # \"L\" is the number of vertices, \"bb\" is the number of bias points.\r\ntemp = size(N);\r\nL = temp(1); # get the length of N (this is basically the number of vertices).\r\nvtx = getdata(\"CHARGE\",\"charge\",\"vertices\"); # dimension is [L, 3]. It stores the x, y, z coordinates of all the vertices.\r\ntri = getdata(\"CHARGE\",\"charge\",\"elements\");# dimension is [ee, 3]. It stores the index of the 3 vertices for all elements. \r\n# \"ee\" is the total number of triangular elements.\r\n# Set the array with the x coordinates of the new rectilinear grid:\r\nxmin = -.1e-6;\r\nxmax = .1e-6;\r\nxstep = .001e-6;\r\nxrect = xmin:xstep:xmax;\r\n# Set the array with the z coordinates of the new rectilinear grid:\r\nzmin = -0.8e-6;\r\nzmax = 0;\r\nzstep = .001e-6;\r\nzrect = zmin:zstep:zmax; \r\n# Prepare the N array to be used in the interptri command. N should have a dimension of L x 1.\r\nN = pinch(N); # Removing singleton dimensions.\r\nN = pinch(N(1:L,1)); # Getting data for just one bias voltage (the first one).\r\n# Prepare the vtx array to be used in the interptri command. vtx should have a dimension of L x 2.\r\nvtx = vtx(1:L,[1,3]); # getting only x and z axis information (removing the y data).\r\n# Creating the rectilinear data using interptri\r\nN_rect = interptri(tri,vtx,N,xrect,zrect); \r\n# Plot data\r\nimage(xrect,zrect,N_rect);\r\n```",
    "summary": "Interpolates a 2D dataset from a triangular grid to another triangular or a rectilinear grid",
    "syntax": [
      {
        "syntax": "out = interptri(tri, vtx, u, xi, yi, extrap_val); out = interptri(tri, vtx, u, xi, yi, extrap_val, \"rectilinear\");",
        "description": "Does a triangular to rectilinear grid interpolation of a function and outputs a PxQxS array of interpolated values, z(xi,yi,p)."
      }
    ],
    "example": "# Read the charge data\r\nN = getdata(\"CHARGE\",\"charge\",\"n\");# The dimension of N is [L, 1, bb, 1].\r\n  # \"L\" is the number of vertices, \"bb\" is the number of bias points.\r\ntemp = size(N);\r\nL = temp(1); # get the length of N (this is basically the number of vertices).\r\nvtx = getdata(\"CHARGE\",\"charge\",\"vertices\"); # dimension is [L, 3]. It stores the x, y, z coordinates of all the vertices.\r\ntri = getdata(\"CHARGE\",\"charge\",\"elements\");# dimension is [ee, 3]. It stores the index of the 3 vertices for all elements. \r\n# \"ee\" is the total number of triangular elements.\r\n# Set the array with the x coordinates of the new rectilinear grid:\r\nxmin = -.1e-6;\r\nxmax = .1e-6;\r\nxstep = .001e-6;\r\nxrect = xmin:xstep:xmax;\r\n# Set the array with the z coordinates of the new rectilinear grid:\r\nzmin = -0.8e-6;\r\nzmax = 0;\r\nzstep = .001e-6;\r\nzrect = zmin:zstep:zmax; \r\n# Prepare the N array to be used in the interptri command. N should have a dimension of L x 1.\r\nN = pinch(N); # Removing singleton dimensions.\r\nN = pinch(N(1:L,1)); # Getting data for just one bias voltage (the first one).\r\n# Prepare the vtx array to be used in the interptri command. vtx should have a dimension of L x 2.\r\nvtx = vtx(1:L,[1,3]); # getting only x and z axis information (removing the y data).\r\n# Creating the rectilinear data using interptri\r\nN_rect = interptri(tri,vtx,N,xrect,zrect); \r\n# Plot data\r\nimage(xrect,zrect,N_rect);"
  },
  {
    "name": "inv",
    "description": "Calculates the inverse of a matrix. The matrix has to be invertible.",
    "usage": "inv();",
    "category": "general",
    "markdown": "# inv\r\n\r\nCalculates the inverse of a matrix. The matrix has to be invertible.\r\n\r\n| **Syntax**         | **Description**                                                                 |\r\n| ------------------ | ------------------------------------------------------------------------------- |\r\n| out = inv(A)       | Returns the inverse of matrix A.                                                |\r\n| out = inv(A, tol); | Returns the Moore-Penrose pseudoinverse of matrix A, with a tolerance of \"tol\". |\r\n\r\n**Examples**\r\n\r\nInvert a matrix and multiply by original matrix to get the identity.\r\n\r\n```\r\nA= [ 1, 2; 3, 4];\r\nB= inv(A);\r\n?mult(B,A);  # This should return the identity matrix\r\nresult: \r\n1 0 \r\n0 1  \r\n```\r\n\r\nDerive the Moore-Penrose pseudoinverse of the same matrix, with a tolerance of 0.1.\r\n\r\n```\r\n?C = inv(A, 0.1);  \r\nresult:   \r\n0.0426428 0.0963963   \r\n0.0605104 0.136787 \r\n```",
    "summary": "Calculates the inverse of a matrix",
    "syntax": [
      {
        "syntax": "out = inv(A)",
        "description": "Returns the inverse of matrix A."
      },
      {
        "syntax": "out = inv(A, tol);",
        "description": "Returns the Moore-Penrose pseudoinverse of matrix A, with a tolerance of \"tol\"."
      }
    ],
    "example": ""
  },
  {
    "name": "invfft",
    "description": "Computes the 1D, 2D or 3D inverse Fast Fourier Transform (FFT) of a matrix. In the 1D case the transform is given by",
    "usage": "invfft();",
    "category": "general",
    "markdown": "# invfft\r\n\r\nComputes the 1D, 2D or 3D inverse Fast Fourier Transform (FFT) of a matrix. In the 1D\r\ncase the transform is given by\r\n\r\n$$E_x[m]=\\\\text{invfft}(E_w)=\\\\frac{1}{N}\\\\sum\\_{n-1}^NE_w[n]. e^{-(\\\\frac{2\\\\pi\r\ni}{N})(n-1)(m-1)} $$\r\n\r\nThe inverse FFT, FFT and all related functions have an option (option 1 below) that\r\ncontrols the format used to store the frequency domain data. When working with spectral\r\ndata it is not possible to switch between formats; there are no functions to convert\r\nbetween formats. This implies that if you use option1=n to produce a spectrum with fft,\r\nthen you must also use option1=n if you want to pass that same spectral data to invfft.\r\nSimilarly, if you use option1=n for fft, then you also need to use option1=n with fftw\r\nto get the proper frequency vector corresponding to your spectrum. invfft and fftk work\r\nin the same way.\r\n\r\n| **Syntax**                        | **Description**                                                                                   |\r\n| --------------------------------- | ------------------------------------------------------------------------------------------------- |\r\n| out = invfft(Ew);                 | Returns the inverse fast Fourier transform of Ew. Ew can 1D,2D or 3D.                             |\r\n| out = invfft(Ew,option1,option2); | option1 This option controls the format used to store the frequency domain data. The options are: |\r\n\r\n- 1 : the standard FFT (zero frequency is at the first element of the matrix). This is\r\n  the default option.\r\n- 2 : zero frequency is the first element, but only data up to and including the Nyquist\r\n  frequency is stored. This option is only useful for real valued, 1D time/spatial\r\n  signals.\r\n- 3 : the FFT is shifted so zero frequency is the central element of the spectrum (more\r\n  precisely, this means the zero frequency point is at element floor(N/2 + 1), where N\r\n  is the number of samples).\r\n\r\noption2 This option is either a 1, 2 or 3 element vector depending on whether Ex is 1D,\r\n2D or 3D. For each dimension, specify a value of either 0, 1 or N to obtain the desired\r\n0 padding options.\r\n\r\n- 0: no zero padding\r\n- 1: zero padding up to the next power of 2 longer than the length of Ex (default)\r\n- N: zero pad up to length N if N > length(Ex), where length of Ex is the length in a\r\n  specific dimension. If N \\<= length(Ex), it will zero pad up to the next power of 2\r\n  longer than the length of Ex. For the fastest results, N should be a power of 2 and\r\n  can be entered, for example, as 2^12.\r\n\r\n**Example**\r\n\r\nThis example shows that x2=invfft(fft(x)) returns x. x2 will only be equal to x if the\r\nstandard fft without zero padding is used. In the plot command, 1 is added to x2 so that\r\nboth lines are visible in the plot.\r\n\r\n```\r\nt=linspace(0,100,1000);\r\nx=sin(t)+sin(t/10);\r\nk=fft(x,1,0);\r\nx2=invfft(k,1,0);\r\nplot(t,x,x2+1,\"t\");\r\n```",
    "summary": "Computes the 1D, 2D or 3D inverse Fast Fourier Transform (FFT) of a matrix",
    "syntax": [
      {
        "syntax": "out = invfft(Ew);",
        "description": "Returns the inverse fast Fourier transform of Ew. Ew can 1D,2D or 3D."
      },
      {
        "syntax": "out = invfft(Ew,option1,option2);",
        "description": "option1 This option controls the format used to store the frequency domain data. The options are:"
      }
    ],
    "example": "t=linspace(0,100,1000);\r\nx=sin(t)+sin(t/10);\r\nk=fft(x,1,0);\r\nx2=invfft(k,1,0);\r\nplot(t,x,x2+1,\"t\");"
  },
  {
    "name": "iscell",
    "description": "The script command checks whether input is a cell.",
    "usage": "iscell();",
    "category": "general",
    "markdown": "# iscell\r\n\r\nThe script command checks whether input is a cell.\r\n\r\n| **Syntax**            | **Description**                                                                                                       |\r\n| --------------------- | --------------------------------------------------------------------------------------------------------------------- |\r\n| value= iscell(input); | Determine whether ‘input is a cell. It returns logical 1 (true) if ‘input’ is a cell and logical 0 (false) otherwise. |\r\n\r\n### Example\r\n\r\n```\r\n>x=cell(3);\r\n>?iscell(x);\r\nresult: \r\n1 \r\n```",
    "summary": "The script command checks whether input is a cell",
    "syntax": [
      {
        "syntax": "value= iscell(input);",
        "description": "Determine whether ‘input is a cell. It returns logical 1 (true) if ‘input’ is a cell and logical 0 (false) otherwise."
      }
    ],
    "example": ""
  },
  {
    "name": "isfield",
    "description": "The script command checks whether input is a field.",
    "usage": "isfield();",
    "category": "general",
    "markdown": "# isfield\r\n\r\nThe script command checks whether input is a field.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                |\r\n| ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| value= isfield(input, field); | Determine whether ‘input contains filed name ‘field’. It returns logical 1 (true) if ‘input contains ‘field’, and logical 0 (false) otherwise. |\r\n\r\n### Example\r\n\r\n```\r\n>x=struct;\r\n>x.t=10;\r\n>?isfield(x,'t');\r\nresult: \r\n1\r\n```",
    "summary": "The script command checks whether input is a field",
    "syntax": [
      {
        "syntax": "value= isfield(input, field);",
        "description": "Determine whether ‘input contains filed name ‘field’. It returns logical 1 (true) if ‘input contains ‘field’, and logical 0 (false) otherwise."
      }
    ],
    "example": ""
  },
  {
    "name": "islicensestandard",
    "description": "Checks if the license is a standard license.",
    "usage": "islicensestandard();",
    "category": "general",
    "markdown": "# islicensestandard\r\n\r\nChecks if the license is a standard license.\r\n\r\n| **Syntax**         | **Description**                                                                                                                      |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------ |\r\n| islicensestandard; | Checks if the current license for Lumerical is a standard license. It returns true if it is a standard license, and false otherwise. |\r\n\r\n**Example**\r\n\r\n```\r\n#Ran on an enterprise license environment  \r\n?islicensestandard;  \r\n  \r\nResult:  \r\nFalse\r\n```",
    "summary": "Checks if the license is a standard license",
    "syntax": [
      {
        "syntax": "islicensestandard;",
        "description": "Checks if the current license for Lumerical is a standard license. It returns true if it is a standard license, and false otherwise."
      }
    ],
    "example": "#Ran on an enterprise license environment  \r\n?islicensestandard;  \r\n  \r\nResult:  \r\nFalse"
  },
  {
    "name": "ispropertyactive",
    "description": "Returns true if the property ‘property’ from element ‘element’ is active.",
    "usage": "ispropertyactive();",
    "category": "general",
    "markdown": "# ispropertyactive\r\n\r\nReturns true if the property ‘property’ from element ‘element’ is active.\r\n\r\n| **Syntax**                               | **Description**                                                           |\r\n| ---------------------------------------- | ------------------------------------------------------------------------- |\r\n| out=ispropertyactive (element,property); | Returns true if the property ‘property’ from element ‘element’ is active. |\r\n\r\n**Example**\r\n\r\n```\r\naddelement(\"CW Laser\");\r\n?ispropertyactive(\"CWL_1\", \"frequency\");\r\nresult: \r\n1  \r\n```",
    "summary": "Returns true if the property ‘property’ from element ‘element’ is active",
    "syntax": [
      {
        "syntax": "out=ispropertyactive (element,property);",
        "description": "Returns true if the property ‘property’ from element ‘element’ is active."
      }
    ],
    "example": "addelement(\"CW Laser\");\r\n?ispropertyactive(\"CWL_1\", \"frequency\");\r\nresult: \r\n1"
  },
  {
    "name": "isstruct",
    "description": "The script command checks whether input is a structure.",
    "usage": "isstruct();",
    "category": "general",
    "markdown": "# isstruct\r\n\r\nThe script command checks whether input is a structure.\r\n\r\n| **Syntax**              | **Description**                                                                                                                  |\r\n| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------- |\r\n| value= isstruct(input); | Determine whether ‘input’ is a structure. It returns logical 1 (true) if ‘input’ is a structure and logical 0 (false) otherwise. |\r\n\r\n### Example\r\n\r\n```\r\n>x=struct;\r\n>?isstruct(x);\r\nresult: \r\n1 \r\n```",
    "summary": "The script command checks whether input is a structure",
    "syntax": [
      {
        "syntax": "value= isstruct(input);",
        "description": "Determine whether ‘input’ is a structure. It returns logical 1 (true) if ‘input’ is a structure and logical 0 (false) otherwise."
      }
    ],
    "example": ""
  },
  {
    "name": "issweep",
    "description": "The script command checks if the simulation is in sweep mode.",
    "usage": "issweep();",
    "category": "general",
    "markdown": "# issweep\r\n\r\nThe script command checks if the simulation is in sweep mode.\r\n\r\n| **Syntax**     | **Description**                                                     |\r\n| -------------- | ------------------------------------------------------------------- |\r\n| out = issweep; | Returns true (1 or 0) if the simulation is currently in sweep mode. |",
    "summary": "The script command checks if the simulation is in sweep mode",
    "syntax": [
      {
        "syntax": "out = issweep;",
        "description": "Returns true (1 or 0) if the simulation is currently in sweep mode."
      }
    ],
    "example": ""
  },
  {
    "name": "jsonload",
    "description": "Returns the value of a JSON file.",
    "usage": "jsonload();",
    "category": "general",
    "markdown": "# jsonload\r\n\r\nReturns the value of a JSON file.\r\n\r\n| **Syntax**            | **Description**                                                     |\r\n| --------------------- | ------------------------------------------------------------------- |\r\n| jsonload(\"filename\"); | Returns the values of the json file (struct, cell, string, number). |\r\n\r\n### Example\r\n\r\nThe following code example shows how to load the data of the JSON file \"test_json.json\".\r\n\r\n```\r\njsonload(\"test_json.json\");\r\n?a;\r\n?b;\r\n```\r\n\r\nThe output result looks like:\r\n\r\n```\r\n?a;\r\nresult: \r\n1  \r\n?b;\r\nresult: \r\n1+2i  3+4i  \r\n```",
    "summary": "Returns the value of a JSON file",
    "syntax": [
      {
        "syntax": "jsonload(\"filename\");",
        "description": "Returns the values of the json file (struct, cell, string, number)."
      }
    ],
    "example": ""
  },
  {
    "name": "jsonsave",
    "description": "Saves data to a JSON file.",
    "usage": "jsonsave();",
    "category": "general",
    "markdown": "# jsonsave\r\n\r\nSaves data to a JSON file.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                                                                                                                                                       |\r\n| -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| jsonsave(\"filename\");                  | Saves all data in workspace to a JSON file using the explicit Lumerical Cell and Matrix Option 1 notation. For detailed information on the notations, please see the page [ JSON files ](https://optics.ansys.com/hc/en-us/articles/360034936933-JSON-files) .        |\r\n| jsonsave(\"filename\", var1, var2, ...); | Saves the specified data variables to a JSON file using the explicit Lumerical Cell and Matrix Option 1 notation. For detailed information on the notations, please see the page [ JSON files ](https://optics.ansys.com/hc/en-us/articles/360034936933-JSON-files) . |\r\n\r\n### Example\r\n\r\nThe following code example shows how to save the data in Lumerical workspace to a JSON\r\nfile.\r\n\r\n```\r\n# Create variables a and b\r\na = 1;\r\nb = [1+2i, 3+4i];\r\njsonsave(\"test_json.json\");\r\n```\r\n\r\nData in the \"test_json.json\" file:\r\n\r\n{ \"a\" : 1, \"b\" : { \"\\_complex\" : true, \"\\_data\" : [ 1, 2, 3, 4 ], \"\\_size\" : [ 1, 2 ],\r\n\"\\_type\" : \"matrix\" } }\r\n\r\nSpecify the variables you would like to save in your workspace.\r\n\r\n```\r\na = 1;  \r\nb = [1+2i, 3+4i];  \r\nstring = \"string\";  \r\njsonsave(\"test_json.json\",a,string);\r\n```\r\n\r\nCreates the following json file.\r\n\r\n```\r\n{  \r\n \"a\" : 1,  \r\n \"string\" : \"string\"  \r\n}\r\n```",
    "summary": "Saves data to a JSON file",
    "syntax": [
      {
        "syntax": "jsonsave(\"filename\");",
        "description": "Saves all data in workspace to a JSON file using the explicit Lumerical Cell and Matrix Option 1 notation. For detailed information on the notations, please see the page [ JSON files ](https://optics.ansys.com/hc/en-us/articles/360034936933-JSON-files) ."
      },
      {
        "syntax": "jsonsave(\"filename\", var1, var2, ...);",
        "description": "Saves the specified data variables to a JSON file using the explicit Lumerical Cell and Matrix Option 1 notation. For detailed information on the notations, please see the page [ JSON files ](https://optics.ansys.com/hc/en-us/articles/360034936933-JSON-files) ."
      }
    ],
    "example": ""
  },
  {
    "name": "killwizard",
    "description": "This closes the wizard window. It should only be called after a wizard window has been created with the newwizard command.",
    "usage": "killwizard();",
    "category": "general",
    "markdown": "# killwizard\r\n\r\nThis closes the wizard window. It should only be called after a wizard window has been\r\ncreated with the newwizard command.\r\n\r\n| **Syntax**  | **Description**                |\r\n| ----------- | ------------------------------ |\r\n| killwizard; | This closes the wizard window. |\r\n\r\n**Examples**\r\n\r\nSee the newwizard page for an example.",
    "summary": "This closes the wizard window",
    "syntax": [
      {
        "syntax": "killwizard;",
        "description": "This closes the wizard window."
      }
    ],
    "example": ""
  },
  {
    "name": "layoutmode",
    "description": "This script command can be used to determine whether the simulation file is currently in LAYOUT mode or in ANALYSIS mode. It is important to use this command to check the status of the project file once it is opened to avoid running into an error during the subsequent operations if the file is not in the desired mode.",
    "usage": "layoutmode();",
    "category": "general",
    "markdown": "# layoutmode\r\n\r\nThis script command can be used to determine whether the simulation file is currently in\r\nLAYOUT mode or in ANALYSIS mode. It is important to use this command to check the status\r\nof the project file once it is opened to avoid running into an error during the\r\nsubsequent operations if the file is not in the desired mode.\r\n\r\n| **Syntax**   | **Description**                                                                        |\r\n| ------------ | -------------------------------------------------------------------------------------- |\r\n| ?layoutmode; | Returns 1 if in LAYOUT mode (DESIGN mode for INTERCONNECT), and 0 if in ANALYSIS mode. |\r\n\r\n**Example**\r\n\r\nThe following script commands will first load a project file named \"test.fsp\". The aim\r\nof the script is to add a new rectangle to the existing geometry. However, if the file\r\nis in ANALYSIS mode then the \"addrect\" command will create an error. To avoid this, the\r\nscript command \"layoutmode\" is first used to determine the status of the file. Then an\r\n\"if/else\" statement is used to add the rectangle directly if the file is already in\r\nLAYOUT mode or to add the rectangle after switching to LAYOUT mode first if the file is\r\nin ANALYSIS mode.\r\n\r\n```\r\nload(\"test.fsp\");  \r\nstatus = layoutmode;  \r\n\r\nif (status == 1) {  \r\n    addrect;  \r\n}  \r\nelse {  \r\n    switchtolayout;  \r\n    addrect;  \r\n}\r\n```",
    "summary": "This script command can be used to determine whether the simulation file is currently in LAYOUT mode...",
    "syntax": [
      {
        "syntax": "?layoutmode;",
        "description": "Returns 1 if in LAYOUT mode (DESIGN mode for INTERCONNECT), and 0 if in ANALYSIS mode."
      }
    ],
    "example": "load(\"test.fsp\");  \r\nstatus = layoutmode;  \r\n\r\nif (status == 1) {  \r\n    addrect;  \r\n}  \r\nelse {  \r\n    switchtolayout;  \r\n    addrect;  \r\n}"
  },
  {
    "name": "legend",
    "description": "Adds a legend to a line plot.",
    "usage": "legend();",
    "category": "general",
    "markdown": "# legend\r\n\r\nAdds a legend to a line plot.\r\n\r\n| **Syntax**                                  | **Description**                                                                                                                        |\r\n| ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\r\n| legend(\"legend1\",\"legend2\",..., \"legendn\"); | Adds a legend to the selected figure. Parameters can be strings, or an array (cell) of strings This function does not return any data. |\r\n\r\n**Example**\r\n\r\nAdd a legend using an array of strings.\r\n\r\n```\r\nx=linspace(0,10,100);\r\ny1=sin(x);\r\ny2=y1^2;\r\nplot(x,y1,y2,\"x\",\"y\",\"title\");\r\n  \r\n# create an array of strings\r\nleg=cell(2);\r\nleg{1}=\"y1\";\r\nleg{2}=\"y2\";\r\n  \r\n# add legend\r\nlegend(leg);\r\n```\r\n\r\nUsing a for loop to add a number to the legend.\r\n\r\n```\r\nn=5; # number of legend\r\nleg=cell(n); # define the array of strings\r\ny=linspace(10,50,n);\r\nfor (i=1:n){\r\nleg{i}=num2str(y(i));\r\n}\r\n  \r\n# add legend\r\nlegend(leg);\r\n```",
    "summary": "Adds a legend to a line plot",
    "syntax": [
      {
        "syntax": "legend(\"legend1\",\"legend2\",..., \"legendn\");",
        "description": "Adds a legend to the selected figure. Parameters can be strings, or an array (cell) of strings This function does not return any data."
      }
    ],
    "example": "x=linspace(0,10,100);\r\ny1=sin(x);\r\ny2=y1^2;\r\nplot(x,y1,y2,\"x\",\"y\",\"title\");\r\n  \r\n# create an array of strings\r\nleg=cell(2);\r\nleg{1}=\"y1\";\r\nleg{2}=\"y2\";\r\n  \r\n# add legend\r\nlegend(leg);"
  },
  {
    "name": "length",
    "description": "Returns the number of elements in a matrix. If the argument is a string, it will return the length of the string.",
    "usage": "length();",
    "category": "general",
    "markdown": "# length\r\n\r\nReturns the number of elements in a matrix. If the argument is a string, it will return\r\nthe length of the string.\r\n\r\n| **Syntax**     | **Description**                                                                                       |\r\n| -------------- | ----------------------------------------------------------------------------------------------------- |\r\n| y = length(x); | y the number of elements in a matrix. For example, if x is an n by m matrix, y = length( x ) = n * m. |\r\n\r\n**Example**\r\n\r\nFind the length of a matrix and of a string.\r\n\r\n```\r\nx=matrix(2,3,3);\r\n?y=length(x);\r\nresult: \r\n18  \r\n\r\n?length(\"hello\");\r\nresult:\r\n5  \r\n```",
    "summary": "Returns the number of elements in a matrix",
    "syntax": [
      {
        "syntax": "y = length(x);",
        "description": "y the number of elements in a matrix. For example, if x is an n by m matrix, y = length( x ) = n * m."
      }
    ],
    "example": "x=matrix(2,3,3);\r\n?y=length(x);\r\nresult: \r\n18  \r\n\r\n?length(\"hello\");\r\nresult:\r\n5"
  },
  {
    "name": "library",
    "description": "Returns a list of elements available in the currently installed element library, including custom elements.",
    "usage": "library();",
    "category": "general",
    "markdown": "# library\r\n\r\nReturns a list of elements available in the currently installed element library,\r\nincluding custom elements.\r\n\r\n| **Syntax**     | **Description**                                                                                               |\r\n| -------------- | ------------------------------------------------------------------------------------------------------------- |\r\n| out = library; | Returns a list of elements available in the currently installed element libraries, including custom elements. |\r\n\r\n**Example**\r\n\r\nListing currently available elements\r\n\r\n```\r\n?library\r\nresult: \r\n::analyzers::digital::logic analyzer\r\n::analyzers::electrical::oscilloscope\r\n...\r\n```",
    "summary": "Returns a list of elements available in the currently installed element library, including custom el...",
    "syntax": [
      {
        "syntax": "out = library;",
        "description": "Returns a list of elements available in the currently installed element libraries, including custom elements."
      }
    ],
    "example": "?library\r\nresult: \r\n::analyzers::digital::logic analyzer\r\n::analyzers::electrical::oscilloscope\r\n..."
  },
  {
    "name": "linecross",
    "description": "Determines if two line segments in the x-y plane cross each other.",
    "usage": "linecross();",
    "category": "general",
    "markdown": "# linecross\r\n\r\nDetermines if two line segments in the x-y plane cross each other.\r\n\r\nLine segments are contained in a single matrix of dimension 2\\*Nx2, where there are N\r\nline segments. For example, the matrix L = [ 0,0; 1,1; 0,0; 0,1]; represents two lines\r\nsegments, one from (0,0) to (1,1) and another from (0,0) to (0,1).\r\n\r\n| **Syntax**              | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = linecross(L1,L2); | Returns an array of dimension N which determines if the N line segments in L1 and the N line segments in L2 cross; the comparison is done pairwise as in the lineintersect command. L1 and L2 must have the same size (2\\*Nx2 for N line segments). The elements in the output array are 0 if the segments do not cross, 1 if they cross and 0.5 if the endpoint of one segment touches the other. Line segments that are coincident and touch also return a value of 0.5 |\r\n\r\n**Example**\r\n\r\nThe following examples illustrate the different outcomes of the linecross function:\r\n\r\n```\r\nL1 = [ 0,0; 1,1; 0,0; 1,1 ];\r\nL2 = [ 0,1; 1,0; 2,2; 3,3 ];\r\n?linecross(L1,L2);\r\nresult: \r\n1  \r\n0\r\nL1 = [ 0,0; 1,1 ];\r\nL2 = [ 0.5,0.5; 0,1 ]; # The start point of L2 touches L1\r\n?linecross(L1,L2);\r\nresult: \r\n0.5 \r\nL1 = [ 0,0; 1,1 ];\r\nL2 = [ 1,1; 2,2 ]; # The end point of L1 is the same as the start point of L2\r\n?linecross(L1,L2);\r\nresult: \r\n0.5 \r\nL1 = [ 0,0; 1,1 ];\r\n?linecross(L1,L1);\r\nresult: \r\n0.5\r\n```",
    "summary": "Determines if two line segments in the x-y plane cross each other",
    "syntax": [
      {
        "syntax": "out = linecross(L1,L2);",
        "description": "Returns an array of dimension N which determines if the N line segments in L1 and the N line segments in L2 cross; the comparison is done pairwise as in the lineintersect command. L1 and L2 must have the same size (2\\*Nx2 for N line segments). The elements in the output array are 0 if the segments do not cross, 1 if they cross and 0.5 if the endpoint of one segment touches the other. Line segments that are coincident and touch also return a value of 0.5"
      }
    ],
    "example": "L1 = [ 0,0; 1,1; 0,0; 1,1 ];\r\nL2 = [ 0,1; 1,0; 2,2; 3,3 ];\r\n?linecross(L1,L2);\r\nresult: \r\n1  \r\n0\r\nL1 = [ 0,0; 1,1 ];\r\nL2 = [ 0.5,0.5; 0,1 ]; # The start point of L2 touches L1\r\n?linecross(L1,L2);\r\nresult: \r\n0.5 \r\nL1 = [ 0,0; 1,1 ];\r\nL2 = [ 1,1; 2,2 ]; # The end point of L1 is the same as the start point of L2\r\n?linecross(L1,L2);\r\nresult: \r\n0.5 \r\nL1 = [ 0,0; 1,1 ];\r\n?linecross(L1,L1);\r\nresult: \r\n0.5"
  },
  {
    "name": "lineintersect",
    "description": "Returns the intersection points of two lines in the x-y plane. Note that the intersection point does not have to lie on the segments that define the lines. Use the command linecross to determine if the line segments actually cross .",
    "usage": "lineintersect();",
    "category": "general",
    "markdown": "# lineintersect\r\n\r\nReturns the intersection points of two lines in the x-y plane. Note that the\r\nintersection point does not have to lie on the segments that define the lines. Use the\r\ncommand linecross to determine if the line segments actually cross .\r\n\r\nLine segments are contained in a single matrix of dimension 2\\*Nx2, where there are N\r\nline segments. For example, the matrix L = [ 0,0; 1,1; 0,0; 0,1]; represents two lines\r\nsegments, one from (0,0) to (1,1) and another from (0,0) to (0,1).\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                             |\r\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = lineintersect(L1,L2); | Returns the intersection of the lines represented by the segments in L1 and L2. L1 and L2 must have the same size (2\\*Nx2 for N line segments). The result is a sequence of x,y points in the form Nx2 representing the pairwise intersections of the N lines. There are special cases when |\r\n\r\n- The lines are parallel. In this case, the position returned is (1.#INF,b). The\r\n  presence of 1.#INF can be tested using the script command finite. The value of b is 0\r\n  if the lines coincide and 1 if they do not.\r\n- The points in a segment are degenerate, i.e., the same. In this case, the position\r\n  returned is (1.#INF,b), where b is 0, 1 or 2 if both line segments are degenerate, the\r\n  first is degenerate, or the second is degenerate, respectively.\r\n\r\n**Example**\r\n\r\nIn this first example L1 and L2 are two sets of segments; the result is a 2x2 matrix\r\nwhere the first row is the intersection between the first segments in each set and the\r\nsecond row is the intersection between the second segments in each set.\r\n\r\n```\r\nL1 = [ 0,0; 1,1; 0,10; 1,10];\r\nL2 = [ 0,1; 1,0; 5,0; 5,1];\r\n?lineintersect(L1,L2);\r\nresult: \r\n0.5  0.5  \r\n5  10  \r\n```\r\n\r\nThe second example shows the output in the special cases when the lines do not\r\nintersect, when they coincide or when the segments are degenerate.\r\n\r\n```\r\nL1 = [ 0,0; 1,1];\r\nL2 = [ 1,0; 2,1]; #L2 is parallel to L1\r\nL3 = [ 3,3; 3,3]; #The points in L3 are degenerate\r\n?lineintersect(L1,L1);\r\n?lineintersect(L1,L2);\r\n?lineintersect(L3,L3);\r\n?lineintersect(L3,L1);\r\n?lineintersect(L2,L3);\r\nresult: \r\n1.#INF  1  \r\nresult: \r\n1.#INF  0  \r\nresult: \r\n1.#INF  0  \r\nresult: \r\n1.#INF  1\r\nresult: \r\n1.#INF  2    \r\n```",
    "summary": "Returns the intersection points of two lines in the x-y plane",
    "syntax": [
      {
        "syntax": "out = lineintersect(L1,L2);",
        "description": "Returns the intersection of the lines represented by the segments in L1 and L2. L1 and L2 must have the same size (2\\*Nx2 for N line segments). The result is a sequence of x,y points in the form Nx2 representing the pairwise intersections of the N lines. There are special cases when"
      }
    ],
    "example": "L1 = [ 0,0; 1,1; 0,10; 1,10];\r\nL2 = [ 0,1; 1,0; 5,0; 5,1];\r\n?lineintersect(L1,L2);\r\nresult: \r\n0.5  0.5  \r\n5  10"
  },
  {
    "name": "linspace",
    "description": "Creates a linearly spaced array.",
    "usage": "linspace();",
    "category": "general",
    "markdown": "# linspace\r\n\r\nCreates a linearly spaced array.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                           |\r\n| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\r\n| x = linspace(min,max,num); | x will be an array with num elements, linearly spaced between min and max. If num is set to 1, then x will be the average of min and max. |\r\n\r\n**Examples**\r\n\r\n```\r\n?x=linspace(1,3,4);\r\nresult: \r\n1 \r\n1.66667 \r\n2.33333 \r\n3  \r\n```\r\n\r\nCall linspace with num of 1. The result with be the average of min and max.\r\n\r\n```\r\n?linspace(1,2,1);\r\nresult: \r\n1.5 \r\n```",
    "summary": "Creates a linearly spaced array",
    "syntax": [
      {
        "syntax": "x = linspace(min,max,num);",
        "description": "x will be an array with num elements, linearly spaced between min and max. If num is set to 1, then x will be the average of min and max."
      }
    ],
    "example": ""
  },
  {
    "name": "listjobs",
    "description": "Lists all the jobs in the job manager queue.",
    "usage": "listjobs();",
    "category": "general",
    "markdown": "# listjobs\r\n\r\nLists all the jobs in the job manager queue.\r\n\r\n| **Syntax**          | **Description**                                                                                                                                                                                   |\r\n| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| listjobs(\"solver\"); | Lists all the jobs in the Job queue for specified solver. If the solver is not specified, all the jobs for all solvers will be listed. No argument is necessary for this command in INTERCONNECT. |\r\n\r\n**Example**\r\n\r\nThe following script code will list jobs under FDE solver queue in MODE.\r\n\r\n```\r\n?listjobs(\"FDE\");\r\n```",
    "summary": "Lists all the jobs in the job manager queue",
    "syntax": [
      {
        "syntax": "listjobs(\"solver\");",
        "description": "Lists all the jobs in the Job queue for specified solver. If the solver is not specified, all the jobs for all solvers will be listed. No argument is necessary for this command in INTERCONNECT."
      }
    ],
    "example": "?listjobs(\"FDE\");"
  },
  {
    "name": "load",
    "description": "Loads a simulation project file. If the simulation has been run, the file will also contain the simulation results.",
    "usage": "load();",
    "category": "general",
    "markdown": "# load\r\n\r\nLoads a simulation project file. If the simulation has been run, the file will also\r\ncontain the simulation results.\r\n\r\n| **Syntax**      | **Description**                                                    |\r\n| --------------- | ------------------------------------------------------------------ |\r\n| load(filename); | Loads the simulation file. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nLoads a simulation project file.\r\n\r\n```\r\nfilename=\"simulation.fsp\";\r\nload(filename); # load the file in the current working directory\r\nload(\"C:\\Downloads\\project_name.fsp\") # load the file in a path specified\r\n```",
    "summary": "Loads a simulation project file",
    "syntax": [
      {
        "syntax": "load(filename);",
        "description": "Loads the simulation file. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "loadcustom",
    "description": "Redirects the location of the element library ‘Custom’ folder and reloads the contents of the folder.",
    "usage": "loadcustom();",
    "category": "general",
    "markdown": "# loadcustom\r\n\r\nRedirects the location of the element library ‘Custom’ folder and reloads the contents\r\nof the folder.\r\n\r\n| **Syntax**         | **Description**                                                                                                                                                     |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| loadcustom (path); | Redirects the location of the element library ‘Custom’ folder to a user defined ‘path’. It also reloads the contents of the ‘Custom’ folder in the element library. |\r\n\r\n**Example**\r\n\r\n```\r\n#Redirects the location of the element library ‘Custom’ folder and reloads the contents of the folder from the path \r\n#\"C:/Users/xxx\"\r\nloadcustom(\"C:/Users/xxx\");\r\n```",
    "summary": "Redirects the location of the element library ‘Custom’ folder and reloads the contents of the folder",
    "syntax": [
      {
        "syntax": "loadcustom (path);",
        "description": "Redirects the location of the element library ‘Custom’ folder to a user defined ‘path’. It also reloads the contents of the ‘Custom’ folder in the element library."
      }
    ],
    "example": "#Redirects the location of the element library ‘Custom’ folder and reloads the contents of the folder from the path \r\n#\"C:/Users/xxx\"\r\nloadcustom(\"C:/Users/xxx\");"
  },
  {
    "name": "loaddata",
    "description": "Loads workspace variables or d-card data from a Lumerical data file (ldf) file. If any current variables exist with the same names as those in the file, the current values will be overwritten. This command will automatically detect if the .ldf file contains d-card or script workspace variable data and load them into the d-card deck or script workspace, respectively.",
    "usage": "loaddata();",
    "category": "general",
    "markdown": "# loaddata\r\n\r\nLoads workspace variables or d-card data from a Lumerical data file (ldf) file. If any\r\ncurrent variables exist with the same names as those in the file, the current values\r\nwill be overwritten. This command will automatically detect if the .ldf file contains\r\nd-card or script workspace variable data and load them into the d-card deck or script\r\nworkspace, respectively.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                                                       |\r\n| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| loaddata(\"filename\"); | Reads data script variables or d-card data from the specified file. This function does not return any data. Note: This function will check for the file in the current working directory. If the file to read from is in a different directory, either specify the full path or change the current working directory. |\r\n\r\n**Examples**\r\n\r\nLoads file called mydata.ldf . Then use the workspace and getdata commands to see what\r\nworkspace variables or d-cards have been created.\r\n\r\n```\r\nfilename=\"mydata\";\r\nloaddata(filename);\r\n?workspace;     # view workspace variables\r\n?getdata;     # view d-cards (generally the complete set of data from a monitor)\r\n```",
    "summary": "Loads workspace variables or d-card data from a Lumerical data file (ldf) file",
    "syntax": [
      {
        "syntax": "loaddata(\"filename\");",
        "description": "Reads data script variables or d-card data from the specified file. This function does not return any data. Note: This function will check for the file in the current working directory. If the file to read from is in a different directory, either specify the full path or change the current working directory."
      }
    ],
    "example": ""
  },
  {
    "name": "loaddesignkit",
    "description": "Loads a design kit and directs its contents to a user defined path.",
    "usage": "loaddesignkit();",
    "category": "general",
    "markdown": "# loaddesignkit\r\n\r\nLoads a design kit and directs its contents to a user defined path.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                                  |\r\n| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| loaddesignkit (\"name\", \"path\"); | Loads a design kit named ‘name’ and directs its contents to a user defined ‘path’. The design kit will be available in the element library ‘Design kits’ folder. |\r\n\r\n**Example**\r\n\r\n```\r\n#loads the design kit \"dk\" and direct its contents to the path \"C:/Users/xxx\"\r\nloaddesignkit(\"dk\", \"C:/Users/xxx\");\r\n```",
    "summary": "Loads a design kit and directs its contents to a user defined path",
    "syntax": [
      {
        "syntax": "loaddesignkit (\"name\", \"path\");",
        "description": "Loads a design kit named ‘name’ and directs its contents to a user defined ‘path’. The design kit will be available in the element library ‘Design kits’ folder."
      }
    ],
    "example": "#loads the design kit \"dk\" and direct its contents to the path \"C:/Users/xxx\"\r\nloaddesignkit(\"dk\", \"C:/Users/xxx\");"
  },
  {
    "name": "loadelement",
    "description": "Loads an element from a file created using the [ saveelement ](./saveelement.md) command in the current working directory. The element will be placed in the current schematic editor window.",
    "usage": "loadelement();",
    "category": "general",
    "markdown": "# loadelement\r\n\r\nLoads an element from a file created using the [ saveelement ](./saveelement.md) command\r\nin the current working directory. The element will be placed in the current schematic\r\neditor window.\r\n\r\n| **Syntax**            | **Description**                                                                     |\r\n| --------------------- | ----------------------------------------------------------------------------------- |\r\n| loadelement (\"name\"); | Loads an element from the file in the current working directory with extension ICE. |\r\n\r\nExample\r\n\r\n```\r\n#adds an element star coupler and saves it to an .ice file in the current working directory\r\naddelement(\"Star Coupler\");\r\nsaveelement(\"STAR_1\");\r\n#loads the star coupler element \"STAR_1.ice\" to the schematic editor\r\nloadelement(\"STAR_1.ice\");\r\n#change element position in the schematic editor\r\nset(\"x position\", -200)\r\n```",
    "summary": "Loads an element from a file created using the [ saveelement ](",
    "syntax": [
      {
        "syntax": "loadelement (\"name\");",
        "description": "Loads an element from the file in the current working directory with extension ICE."
      }
    ],
    "example": ""
  },
  {
    "name": "loadgdsfile",
    "description": "Loads a gds file to a layer builder object. The command only functions properly when a layer builder object is included in the simulation and is selected.",
    "usage": "loadgdsfile();",
    "category": "general",
    "markdown": "# loadgdsfile\r\n\r\nLoads a gds file to a layer builder object. The command only functions properly when a\r\nlayer builder object is included in the simulation and is selected.\r\n\r\n| **Syntax**                      | **Description**                                                     |\r\n| ------------------------------- | ------------------------------------------------------------------- |\r\n| loadgdsfile(\"gds_example.gds\"); | Loads the gds file named \"gds_example\" to the layer builder object. |\r\n\r\n**Example**\r\n\r\nPlease refer this example:\r\n[Import and export - GDSII](https://optics.ansys.com/hc/en-us/articles/360034901933-Import-and-export-GDSII)",
    "summary": "Loads a gds file to a layer builder object",
    "syntax": [
      {
        "syntax": "loadgdsfile(\"gds_example.gds\");",
        "description": "Loads the gds file named \"gds_example\" to the layer builder object."
      }
    ],
    "example": ""
  },
  {
    "name": "loadsweep",
    "description": "Loads the sweep object with the previously generated sweep result.",
    "usage": "loadsweep();",
    "category": "general",
    "markdown": "# loadsweep\r\n\r\nLoads the sweep object with the previously generated sweep result.\r\n\r\n| **Syntax**         | **Description**                                                                       |\r\n| ------------------ | ------------------------------------------------------------------------------------- |\r\n| loadsweep;         | Loads previously generated sweep result to all the sweep objects in simulation.       |\r\n| loadsweep(\"name\"); | Loads previously generated sweep result to the specified sweep objects in simulation. |\r\n\r\n**Example**\r\n\r\n```\r\nloadsweep;\r\n```",
    "summary": "Loads the sweep object with the previously generated sweep result",
    "syntax": [
      {
        "syntax": "loadsweep;",
        "description": "Loads previously generated sweep result to all the sweep objects in simulation."
      },
      {
        "syntax": "loadsweep(\"name\");",
        "description": "Loads previously generated sweep result to the specified sweep objects in simulation."
      }
    ],
    "example": "loadsweep;"
  },
  {
    "name": "log",
    "description": "Calculates the natural logarithm function. Input can be complex or negative.",
    "usage": "log();",
    "category": "general",
    "markdown": "# log\r\n\r\nCalculates the natural logarithm function. Input can be complex or negative.\r\n\r\n| **Syntax**    | **Description**                                               |\r\n| ------------- | ------------------------------------------------------------- |\r\n| out = log(x); | The natural logarithm of x. Input can be complex or negative. |\r\n\r\n**Example**\r\n\r\nCheck that the natural logarithm of e is 1.\r\n\r\n```\r\n?Exp=exp(1);\r\nresult: \r\n2.71828 \r\n?log(Exp); # Result should be 1\r\nresult: \r\n1  \r\n```",
    "summary": "Calculates the natural logarithm function",
    "syntax": [
      {
        "syntax": "out = log(x);",
        "description": "The natural logarithm of x. Input can be complex or negative."
      }
    ],
    "example": "?Exp=exp(1);\r\nresult: \r\n2.71828 \r\n?log(Exp); # Result should be 1\r\nresult: \r\n1"
  },
  {
    "name": "log10",
    "description": "Calculates the base 10 logarithm function. Input can be complex or negative.",
    "usage": "log10();",
    "category": "general",
    "markdown": "# log10\r\n\r\nCalculates the base 10 logarithm function. Input can be complex or negative.\r\n\r\n| **Syntax**      | **Description**                                               |\r\n| --------------- | ------------------------------------------------------------- |\r\n| out = log10(x); | The base 10 logarithm of x. Input can be complex or negative. |\r\n\r\n**Example**\r\n\r\nCalculate the base 10 logarithm of a number.\r\n\r\n```\r\n?log10(100);\r\n result: \r\n 2 \r\n```",
    "summary": "Calculates the base 10 logarithm function",
    "syntax": [
      {
        "syntax": "out = log10(x);",
        "description": "The base 10 logarithm of x. Input can be complex or negative."
      }
    ],
    "example": "?log10(100);\r\n result: \r\n 2"
  },
  {
    "name": "logmessage",
    "description": "This function sends messages from scripted elements to the INTERCONNECT output window.",
    "usage": "logmessage();",
    "category": "general",
    "markdown": "# logmessage\r\n\r\nThis function sends messages from scripted elements to the INTERCONNECT output window.\r\n\r\n| **Syntax**  | **Description**                                                                                                                           |\r\n| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\r\n| logmessage; | This function sends messages from scripted elements to the INTERCONNECT output window. It is specially useful to debug scripted elements. |",
    "summary": "This function sends messages from scripted elements to the INTERCONNECT output window",
    "syntax": [
      {
        "syntax": "logmessage;",
        "description": "This function sends messages from scripted elements to the INTERCONNECT output window. It is specially useful to debug scripted elements."
      }
    ],
    "example": ""
  },
  {
    "name": "lognrnd",
    "description": "Generates a log-normal distributed random number. In order to reset the generator seed use the command randreset.",
    "usage": "lognrnd();",
    "category": "general",
    "markdown": "# lognrnd\r\n\r\nGenerates a log-normal distributed random number. In order to reset the generator seed\r\nuse the command randreset.\r\n\r\n| **Syntax**                   | **Description**                                                                                      |\r\n| ---------------------------- | ---------------------------------------------------------------------------------------------------- |\r\n| out = lognrnd (mean,stddev); | Generates a lognormal distributed random number with user defined mean value and standard deviation. |\r\n\r\n**Example**\r\n\r\nThis example shows how to create an histogram of a log-normal distribution.\r\n\r\n```\r\nn = 1000;\r\ny = matrix(n);\r\nmean_val = 1;\r\nstd_dev = 0.25;\r\nfor (i=1:n){\r\n    y(i) = lognrnd(mean_val, std_dev);\r\n}\r\nhistc(y);\r\n```\r\n\r\nThe histogram will look similar to the following one.",
    "summary": "Generates a log-normal distributed random number",
    "syntax": [
      {
        "syntax": "out = lognrnd (mean,stddev);",
        "description": "Generates a lognormal distributed random number with user defined mean value and standard deviation."
      }
    ],
    "example": "n = 1000;\r\ny = matrix(n);\r\nmean_val = 1;\r\nstd_dev = 0.25;\r\nfor (i=1:n){\r\n    y(i) = lognrnd(mean_val, std_dev);\r\n}\r\nhistc(y);"
  },
  {
    "name": "lookupappend",
    "description": "Inserts a new association into an existing lookup table.",
    "usage": "lookupappend();",
    "category": "general",
    "markdown": "# lookupappend\r\n\r\nInserts a new association into an existing lookup table.\r\n\r\n| **Syntax**                                              | **Description**                                          |\r\n| ------------------------------------------------------- | -------------------------------------------------------- |\r\n| lookupappend(\"filename\", \"table\", design, \"extracted\"); | Inserts a new association into an existing lookup table. |\r\n\r\n**Example**\r\n\r\nLoads the lookup table \"coupler_map.ixml\" and prints the cell array that containing all\r\nthe contents of the .ixml file\r\n\r\n```\r\nclear;\r\ntabCoupler = lookupread( \"coupler_map.ixml\" );\r\n?toscript( tabCoupler );\r\n```\r\n\r\nwhere “coupler_map.ixml” is a lookup table containing a map between coupler parameters\r\nand different s-parameters:\r\n\r\n```\r\ntabCoupler=cell(1);\r\ntabCoupler{1}=struct;\r\ntabCoupler{1}.association=cell(1);\r\ntabCoupler{1}.association{1}=struct;\r\ntabCoupler{1}.association{1}.design=cell(1);\r\ntabCoupler{1}.association{1}.design{1}=struct;\r\ntabCoupler{1}.association{1}.design{1}.name='gap';\r\ntabCoupler{1}.association{1}.design{1}.value=3.5e-007;\r\ntabCoupler{1}.association{1}.extracted=cell(1);\r\ntabCoupler{1}.association{1}.extracted{1}=struct;\r\ntabCoupler{1}.association{1}.extracted{1}.name='coupling_length';\r\ntabCoupler{1}.association{1}.extracted{1}.value=7.18624e-006;\r\ntabCoupler{1}.name='coupler_extracted';\r\n```\r\n\r\nThe following commands insert an object into the existing lookup table:\r\n\r\n```\r\nassociation=struct;\r\nassociation.design=cell(1);\r\nassociation.design{1}=struct;\r\nassociation.design{1}.name='gap';\r\nassociation.design{1}.value=5e-007;\r\nassociation.extracted=cell(1);\r\nassociation.extracted{1}=struct;\r\nassociation.extracted{1}.name='coupling_length';\r\nassociation.extracted{1}.value=9e-006;\r\n# insert association at last position\r\ntabCoupler{1}.association = insert( tabCoupler{1}.association, association, 2 );\r\n# print updated values\r\n?toscript(tabCoupler);\r\nlookupwrite( \"coupler_map.ixml\", tabCoupler );\r\n```\r\n\r\nnow the table prints as below:\r\n\r\n```\r\ntabCoupler=cell(1);\r\ntabCoupler{1}=struct;\r\ntabCoupler{1}.association=cell(2);\r\ntabCoupler{1}.association{1}=struct;\r\ntabCoupler{1}.association{1}.design=cell(1);\r\ntabCoupler{1}.association{1}.design{1}=struct;\r\ntabCoupler{1}.association{1}.design{1}.name='gap';\r\ntabCoupler{1}.association{1}.design{1}.value=3.5e-007;\r\ntabCoupler{1}.association{1}.extracted=cell(1);\r\ntabCoupler{1}.association{1}.extracted{1}=struct;\r\ntabCoupler{1}.association{1}.extracted{1}.name='coupling_length';\r\ntabCoupler{1}.association{1}.extracted{1}.value=7.18624e-006;\r\ntabCoupler{1}.association{2}=struct;\r\ntabCoupler{1}.association{2}.design=cell(1);\r\ntabCoupler{1}.association{2}.design{1}=struct;\r\ntabCoupler{1}.association{2}.design{1}.name='gap';\r\ntabCoupler{1}.association{2}.design{1}.value=5e-007;\r\ntabCoupler{1}.association{2}.extracted=cell(1);\r\ntabCoupler{1}.association{2}.extracted{1}=struct;\r\ntabCoupler{1}.association{2}.extracted{1}.name='coupling_length';\r\ntabCoupler{1}.association{2}.extracted{1}.value=9e-006;\r\ntabCoupler{1}.name='coupler_extracted';\r\n```\r\n\r\nThe following commands append a new association into the existing table:\r\n\r\n```\r\nclear;\r\ndesign=cell(1);\r\ndesign{1}=struct;\r\ndesign{1}.name='gap';\r\ndesign{1}.value=6e-007;\r\n# create extracted parameter\r\nextracted=cell(1);\r\nextracted{1}=struct;\r\nextracted{1}.name='coupling_length';\r\nextracted{1}.value=9.9e-006;\r\n# append to existing table\r\nlookupappend( \"coupler_map.ixml\", \"coupler_extracted\", design, extracted );\r\n# print contents\r\n?toscript( lookupread( \"coupler_map.ixml\" ) );\r\n```\r\n\r\nNow the lookup table prints as below:\r\n\r\n```\r\nvalue=cell(1);\r\nvalue{1}=struct;\r\nvalue{1}.association=cell(3);\r\nvalue{1}.association{1}=struct;\r\nvalue{1}.association{1}.design=cell(1);\r\nvalue{1}.association{1}.design{1}=struct;\r\nvalue{1}.association{1}.design{1}.name='gap';\r\nvalue{1}.association{1}.design{1}.value=3.5e-007;\r\nvalue{1}.association{1}.extracted=cell(1);\r\nvalue{1}.association{1}.extracted{1}=struct;\r\nvalue{1}.association{1}.extracted{1}.name='coupling_length';\r\nvalue{1}.association{1}.extracted{1}.value=7.18624e-006;\r\nvalue{1}.association{2}=struct;\r\nvalue{1}.association{2}.design=cell(1);\r\nvalue{1}.association{2}.design{1}=struct;\r\nvalue{1}.association{2}.design{1}.name='gap';\r\nvalue{1}.association{2}.design{1}.value=5e-007;\r\nvalue{1}.association{2}.extracted=cell(1);\r\nvalue{1}.association{2}.extracted{1}=struct;\r\nvalue{1}.association{2}.extracted{1}.name='coupling_length';\r\nvalue{1}.association{2}.extracted{1}.value=9e-006;\r\nvalue{1}.association{3}=struct;\r\nvalue{1}.association{3}.design=cell(1);\r\nvalue{1}.association{3}.design{1}=struct;\r\nvalue{1}.association{3}.design{1}.name='gap';\r\nvalue{1}.association{3}.design{1}.value=6e-007;\r\nvalue{1}.association{3}.extracted=cell(1);\r\nvalue{1}.association{3}.extracted{1}=struct;\r\nvalue{1}.association{3}.extracted{1}.name='coupling_length';\r\nvalue{1}.association{3}.extracted{1}.value=9.9e-006;\r\nvalue{1}.name='coupler_extracted';\r\n```",
    "summary": "Inserts a new association into an existing lookup table",
    "syntax": [
      {
        "syntax": "lookupappend(\"filename\", \"table\", design, \"extracted\");",
        "description": "Inserts a new association into an existing lookup table."
      }
    ],
    "example": "clear;\r\ntabCoupler = lookupread( \"coupler_map.ixml\" );\r\n?toscript( tabCoupler );"
  },
  {
    "name": "lookupclose",
    "description": "Closes a lookup table file previously created with a [ lookupopen ](./lookupopen.md) command.",
    "usage": "lookupclose();",
    "category": "general",
    "markdown": "# lookupclose\r\n\r\nCloses a lookup table file previously created with a [ lookupopen ](./lookupopen.md)\r\ncommand.\r\n\r\n| **Syntax**                | **Description**                                                                                                                      |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |\r\n| lookupclose (\"filename\"); | Closes a file previously created with a lookupopen command. This command is required in order to close any file open by lookupopen . |\r\n\r\n**Example**\r\n\r\nIn order to create the lookup table “new.xml” with table named “new_extracted”:\r\n\r\n```\r\n#open file to write lookup table\r\nlookupopen(\"new.xml\", \"new_extracted\" );\r\n...\r\n#write design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n...\r\n#close file\r\nlookupclose(\"new.xml\");\r\n```",
    "summary": "Closes a lookup table file previously created with a [ lookupopen ](",
    "syntax": [
      {
        "syntax": "lookupclose (\"filename\");",
        "description": "Closes a file previously created with a lookupopen command. This command is required in order to close any file open by lookupopen ."
      }
    ],
    "example": "#open file to write lookup table\r\nlookupopen(\"new.xml\", \"new_extracted\" );\r\n...\r\n#write design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n...\r\n#close file\r\nlookupclose(\"new.xml\");"
  },
  {
    "name": "lookupopen",
    "description": "Opens a file to write a lookup table.",
    "usage": "lookupopen();",
    "category": "general",
    "markdown": "# lookupopen\r\n\r\nOpens a file to write a lookup table.\r\n\r\n| **Syntax**                       | **Description**                                                                                             |\r\n| -------------------------------- | ----------------------------------------------------------------------------------------------------------- |\r\n| lookupopen (\"filename\",\"table\"); | Opens a file to write a lookup table. This command is required before any calls to lookupwrite can be made. |\r\n\r\n**Example**\r\n\r\nIn order to create the lookup table “new.xml” with table named “new_extracted”:\r\n\r\n```\r\n#open file to write lookup table\r\nlookupopen(\"new.xml\", \"new_extracted\" );\r\n...\r\n#write design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n...\r\n#close file\r\nlookupclose(\"new.xml\");\r\n```",
    "summary": "Opens a file to write a lookup table",
    "syntax": [
      {
        "syntax": "lookupopen (\"filename\",\"table\");",
        "description": "Opens a file to write a lookup table. This command is required before any calls to lookupwrite can be made."
      }
    ],
    "example": "#open file to write lookup table\r\nlookupopen(\"new.xml\", \"new_extracted\" );\r\n...\r\n#write design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n...\r\n#close file\r\nlookupclose(\"new.xml\");"
  },
  {
    "name": "lookupread",
    "description": "Finds the nearest extracted value from a file containing a lookup table of design and extracted parameters.",
    "usage": "lookupread();",
    "category": "general",
    "markdown": "# lookupread\r\n\r\nFinds the nearest extracted value from a file containing a lookup table of design and\r\nextracted parameters.\r\n\r\n| **Syntax**                                                | **Description**                                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = lookupread (\"filename\",\"table\",design,\"extracted\"); | Finds the nearest extracted value from a file containing a lookup table of design and extracted parameters. Parameter table is the name of the lookup table located inside the file, design is a cell containing multiple structures that define the design parameters to search, and extracted is the name of the parameter to be extracted. It will return the value located at the nearest design parameters. |\r\n| out = lookupread (\"filename\");                            | Returns a script object, in this case a cell array containing all the contents of the xml file.                                                                                                                                                                                                                                                                                                                  |\r\n\r\n**Example**\r\n\r\nTo load the coupling length index associated to a coupler gap:\r\n\r\n```\r\n#design cell containing design/layout parameters (input parameter to search)#“gap” is the name of the property in the file  \r\n\r\nw_gap=3.5e-07;\r\ndesign = cell(1);\r\ndesign{1} = struct;\r\ndesign{1}.name = \"gap\";\r\ndesign{1}.value = w_gap;\r\n#read coupling length from file (using design as input search “coupling_length”)\r\ncl=lookupread( \"coupler_map.xml\", \"coupler_extracted\", design, \"coupling_length\" );\r\n?c1\r\n7.18624026618721e-06\r\n```\r\n\r\nwhere “coupler_map.xml” is a lookup table containing a map between coupler gap and\r\ncoupling length values:\r\n\r\n```\r\n?xml version=\"1.0\" encoding=\"UTF-8\"?\r\n<lumerical_lookup_table version=\"1.0\" name = \"coupler_extracted\">\r\n  <association>\r\n    <design>\r\n      <value name=\"gap\" type=\"double\">3.5e-07</value>\r\n    </design>\r\n    <extracted>\r\n      <value name=\"coupling_length\" type=\"double\">7.18624026618721e-06</value> \r\n    </extracted> \r\n  </association>\r\n...\r\n</lumerical_lookup_table>\r\n```",
    "summary": "Finds the nearest extracted value from a file containing a lookup table of design and extracted para...",
    "syntax": [
      {
        "syntax": "out = lookupread (\"filename\",\"table\",design,\"extracted\");",
        "description": "Finds the nearest extracted value from a file containing a lookup table of design and extracted parameters. Parameter table is the name of the lookup table located inside the file, design is a cell containing multiple structures that define the design parameters to search, and extracted is the name of the parameter to be extracted. It will return the value located at the nearest design parameters."
      },
      {
        "syntax": "out = lookupread (\"filename\");",
        "description": "Returns a script object, in this case a cell array containing all the contents of the xml file."
      }
    ],
    "example": "#design cell containing design/layout parameters (input parameter to search)#“gap” is the name of the property in the file  \r\n\r\nw_gap=3.5e-07;\r\ndesign = cell(1);\r\ndesign{1} = struct;\r\ndesign{1}.name = \"gap\";\r\ndesign{1}.value = w_gap;\r\n#read coupling length from file (using design as input search “coupling_length”)\r\ncl=lookupread( \"coupler_map.xml\", \"coupler_extracted\", design, \"coupling_length\" );\r\n?c1\r\n7.18624026618721e-06"
  },
  {
    "name": "lookupreadnportsparameter",
    "description": "Returns an interpolated s-parameter cell for specific design parameters from an [xml file containing a lookup table of design](https://optics.ansys.com/hc/en-us/articles/360034416634-INTERCONNECT-XML-lookup-tables-for-element-data).",
    "usage": "lookupreadnportsparameter();",
    "category": "general",
    "markdown": "# lookupreadnportsparameter\r\n\r\nReturns an interpolated s-parameter cell for specific design parameters from an\r\n[xml file containing a lookup table of design](https://optics.ansys.com/hc/en-us/articles/360034416634-INTERCONNECT-XML-lookup-tables-for-element-data).\r\n\r\nThe xml file should have a lookup table associating s-parameter data files with design\r\nparameters. Each s-parameter file associated by the table should be compatible with the\r\n[Optical N Port S-Parameter element](https://optics.ansys.com/hc/en-us/articles/360036107914-Optical-N-Port-S-Parameter-SPAR-INTERCONNECT-Element),\r\nin the exact same format, and should not contain any header.\r\n\r\n| **Syntax**                                                               | **Description**                                                                                |\r\n| ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------- |\r\n| out = lookupreadnportsparameter (\"filename\",\"table\",design,\"extracted\"); | Returns an interpolated s-parameter cell from an xml file containing a lookup table of design: |\r\n\r\n- filename: Name of the xml file.\r\n- table: Name of the lookup table located inside the xml file.\r\n- design: Cell containing multiple structures defining the target design to extract.\r\n- extracted: Name of the parameter inside the lookup table that holds names of the\r\n  s-parameter data file for each design.\r\n\r\nout = lookupreadnportsparameter (\"filename\",\"table\",design,\"extracted\", opt); | Returns\r\nan interpolated s-parameter cell from an xml file containing a lookup table of design\r\nwith interpolation options in the structure opt:\r\n\r\n- filename: Name of the xml file.\r\n- table: Name of the lookup table located inside the xml file.\r\n- design: Cell containing multiple structures defining the target design to extract.\r\n- extracted: Name of the parameter inside the lookup table that holds names of the\r\n  s-parameter data file for each design.\r\n- opt: Structure setting interpolation options. The structure fields are described in\r\n  the table below.\r\n\r\nThe option structure has the following fields, the spelling of each field is\r\ncase-sensitive.\r\n\r\n| **Field** | **Description**                                                         |\r\n| --------- | ----------------------------------------------------------------------- |\r\n| method    | The method used for interpolation. The following options are supported: |\r\n\r\n- spline: Spline interpolation method, this is the default method.\r\n- Geodesic: Geodesic interpolation method which ensures smooth transitions. When\r\n  geodesic interpolation is selected, a similarity check is performed on original data\r\n  points near the interpolated point used for the interpolation, if these points are not\r\n  sufficiently similar, the data is coarse, and a warning is displayed. This method\r\n  cannot be used for extrapolation.\r\n\r\npassivity | Whether passivity is enforced for the s-parameter data prior to\r\ninterpolation. This field only affects results when “geodesic” is selected as the\r\ninterpolation method. When data is non-passive, a warning message is always displayed\r\nfor geodesic interpolation. The following options are supported:\r\n\r\n- enforce: Ensures S-matrix is passive by making sure that the induced 2-norm of the\r\n  s-parameters is less than 1. This is the default method.\r\n- ignore: Ignores passivity of the s-parameters and interpolates as-is.\r\n\r\n**Note** : For more information on how passivity is enforced, see this\r\n[Knowledge Base](https://optics.ansys.com/hc/en-us/articles/360059772393-S-parameter-passive-workflow-guide#toc_4)\r\narticle.\r\n\r\n**Example**\r\n\r\nLoads the s-parameters of a coupler depending on user defined design parameters set up\r\ntarget for interpolation:\r\n\r\n```\r\nfilename = \"coupler.ixml\";\r\ntable = \"coupler\";\r\nradius = 3e-06;\r\ngap = 3e-07;\r\ndesign = cell(2);\r\n#design (input parameters)\r\ndesign{1} = struct;\r\ndesign{1}.name = \"radius\";\r\ndesign{1}.value = radius;\r\ndesign{2} = struct;\r\ndesign{2}.name = \"gap\";\r\ndesign{2}.value = gap; \r\n```\r\n\r\nInterpolate parameters and load into S-parameter cell array using spline interpolation\r\n\r\n```\r\n?M = lookupreadnportsparameter( filename, table, design, \"out_filename\" ); \r\n```\r\n\r\nInterpolate parameters and load into S-parameter cell array using geodesic\r\ninterpolation, ignoring passivity of the element\r\n\r\n```\r\n?M = lookupreadnportsparameter( filename, table, design, \"out_filename\", {\"method\":\"geodesic\",\"passivity\":\"ignore\" ); \r\n```\r\n\r\nSet parameters to element\r\n\r\n```\r\naddelement(\"Optical N Port S-Parameter\");  \r\nsetvalue('SPAR_1','s parameters',M);\r\n```\r\n\r\n“coupler.ixml” is a lookup table containing a map between coupler parameters and\r\ndifferent s-parameters:\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<lumerical_lookup_table version=\"1.0\" name = \"coupler\">\r\n  <association>\r\n    <design>\r\n      <value name=\"radius\" type=\"double\">3e-06</value>\r\n      <value name=\"gap\" type=\"double\">3e-07</value>\r\n    </design>\r\n    <extracted>\r\n      <value name=\"out_filename\" type=\"string\">radius_3_gap_3.txt</value>\r\n    </extracted>\r\n  </association>\r\n</lumerical_lookup_table>\r\n```\r\n\r\nFor example “radius_3_gap_3.txt” file contains s-parameters for the ‘Optical N Port\r\nS-Parameter’ element\r\n\r\n```\r\n(\"port 1\",\"TE\",1,\"port 1\",1,\"transmission\")\r\n(3,3)\r\n 2.262580000000e+014 1.034036580296e-002 -2.629253819969e+000\r\n 2.275690000000e+014 9.716591457652e-003 -2.734774978072e+000\r\n 2.288790000000e+014 6.884340821788e-003 -2.838683842048e+000\r\n(\"port 1\",\"TE\",1,\"port 2\",1,\"transmission\")\r\n(3,3)\r\n 2.262580000000e+014 9.847090174703e-001 1.376105202083e-001\r\n 2.275690000000e+014 9.959778891317e-001 1.450376288706e-001\r\n 2.288790000000e+014 1.002869828593e+000 1.483183421805e-001\r\n```",
    "summary": "Returns an interpolated s-parameter cell for specific design parameters from an [xml file containing...",
    "syntax": [
      {
        "syntax": "out = lookupreadnportsparameter (\"filename\",\"table\",design,\"extracted\");",
        "description": "Returns an interpolated s-parameter cell from an xml file containing a lookup table of design:"
      }
    ],
    "example": "filename = \"coupler.ixml\";\r\ntable = \"coupler\";\r\nradius = 3e-06;\r\ngap = 3e-07;\r\ndesign = cell(2);\r\n#design (input parameters)\r\ndesign{1} = struct;\r\ndesign{1}.name = \"radius\";\r\ndesign{1}.value = radius;\r\ndesign{2} = struct;\r\ndesign{2}.name = \"gap\";\r\ndesign{2}.value = gap;"
  },
  {
    "name": "lookupreadtable",
    "description": "Returns an interpolated matrix from a file containing a lookup table of design and extracted parameters.",
    "usage": "lookupreadtable();",
    "category": "general",
    "markdown": "# lookupreadtable\r\n\r\nReturns an interpolated matrix from a file containing a lookup table of design and\r\nextracted parameters.\r\n\r\n| **Syntax**                                                     | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| -------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = lookupreadtable (\"filename\",\"table\",design,\"extracted\"); | Returns an interpolated matrix from a file containing a lookup table of design and extracted parameters. Parameter table is the name of the lookup table located inside the file, design is a cell containing multiple structures that define the design parameters to search, and extracted is the name of the parameter to be extracted. It will return a matrix that contains multiple columns. The first column is the independent variable. e.g. frequency dependent transmission values. |\r\n\r\n**Example**\r\n\r\nThe script below loads the frequency dependent propagation properties of a bent\r\nwaveguide:\r\n\r\n```\r\nfilename = \"waveguide.ixml\";\r\ntable = \"waveguide\";\r\ndesign = cell(1);\r\n#design (input parameters)\r\ndesign{1} = struct;\r\ndesign{1}.name = \"radius\";\r\ndesign{1}.value = 3e-6;\r\nw_length = 1e-6;\r\nM=lookupreadtable(\"waveguide.ixml\", \"waveguide\", design, \"Filename\" );\r\n# set the s-parameter in scripted element\r\nsetsparameter(\"port 2\", \"port 1\", \"propagation\", M, w_length);\r\nsetsparameter(\"port 1\", \"port 2\", \"propagation\", M, w_length);\r\n```\r\n\r\nwhere “waveguide.ixml” is a lookup table containing a map between waveguide ‘radius’ and\r\n‘Filename’ containing frequency dependent propagation properties:\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<lumerical_lookup_table version=\"1.0\" name = \"waveguide\">\r\n  <association> \r\n    <design>\r\n      <value name=\"radius\" type=\"double\">3e-06</value>\r\n    </design> \r\n    <extracted>\r\n      <value name=\"Filename\" type=\"string\">radius_3.txt</value> \r\n    </extracted>\r\n  </association>\r\n</lumerical_lookup_table>\r\n```\r\n\r\nFor example, “radius_3.txt” file contains a matrix with frequency dependent propagation\r\nproperties\r\n\r\n```\r\n2.315e+14552.62.787.071e+07\r\n2.30918e+14552.72.717.076e+07\r\n2.30335e+14543.32.737.075e+07\r\n2.29753e+14543.32.767.076e+07\r\n2.2917e+14544.72.787.062e+07\r\n2.28588e+14545.52.727.061e+07\r\n2.28006e+14546.62.717.064e+07\r\n2.27423e+14544.22.737.061e+07\r\n2.26841e+14533.12.747.063e+07\r\n2.26258e+14532.22.757.069e+07 \r\n```",
    "summary": "Returns an interpolated matrix from a file containing a lookup table of design and extracted paramet...",
    "syntax": [
      {
        "syntax": "out = lookupreadtable (\"filename\",\"table\",design,\"extracted\");",
        "description": "Returns an interpolated matrix from a file containing a lookup table of design and extracted parameters. Parameter table is the name of the lookup table located inside the file, design is a cell containing multiple structures that define the design parameters to search, and extracted is the name of the parameter to be extracted. It will return a matrix that contains multiple columns. The first column is the independent variable. e.g. frequency dependent transmission values."
      }
    ],
    "example": "filename = \"waveguide.ixml\";\r\ntable = \"waveguide\";\r\ndesign = cell(1);\r\n#design (input parameters)\r\ndesign{1} = struct;\r\ndesign{1}.name = \"radius\";\r\ndesign{1}.value = 3e-6;\r\nw_length = 1e-6;\r\nM=lookupreadtable(\"waveguide.ixml\", \"waveguide\", design, \"Filename\" );\r\n# set the s-parameter in scripted element\r\nsetsparameter(\"port 2\", \"port 1\", \"propagation\", M, w_length);\r\nsetsparameter(\"port 1\", \"port 2\", \"propagation\", M, w_length);"
  },
  {
    "name": "lookupreadvalue",
    "description": "Finds the value from a file containing a lookup table of design and extracted parameters.",
    "usage": "lookupreadvalue();",
    "category": "general",
    "markdown": "# lookupreadvalue\r\n\r\nFinds the value from a file containing a lookup table of design and extracted\r\nparameters.\r\n\r\n| **Syntax**                                                     | **Description**                                                                                                                                                                                                                                                                                                                                                                               |\r\n| -------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = lookupreadvalue (\"filename\",\"table\",design,\"extracted\"); | Find the value from a file containing a lookup table of design and extracted parameters. Parameter table is the name of the lookup table located inside the file, design is a cell containing multiple structures that define the design parameters to search, and extracted is the name of the parameter to be extracted. It will return the value is interpolated at the design parameters. |\r\n\r\n**Example**\r\n\r\nIn order to load the coupling length index associated to a coupler gap:\r\n\r\n```\r\n#design cell containing design/layout parameters (input parameter to search)\r\n#“gap” is the name of the property in the file\r\nw_gap=3.5e-07;\r\ndesign = cell(1);\r\ndesign{1} = struct;\r\ndesign{1}.name = \"gap\";\r\ndesign{1}.value = w_gap;\r\n#read coupling length from file (using design as input search “coupling_length”)\r\ncl=lookupreadvalue( \"coupler_map.ixml\", \"coupler_extracted\", design, \"coupling_length\" );\r\n?cl\r\n7.18624026618721e-06\r\n```\r\n\r\nwhere “coupler_map.ixml” is a lookup table containing a map between coupler gap and\r\ncoupling length values:\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<lumerical_lookup_table version=\"1.0\" name=\"coupler\">\r\n  <association>\r\n    <design>\r\n      <value name=\"gap\" type=\"double\">3.5e-07</value>\r\n    </design>\r\n    <extracted>\r\n      <value name=\"coupling_length\" type=\"double\">7.18624026618721e-06</value>\r\n    </extracted>\r\n  </association>\r\n</lumerical_lookup_table>\r\n```",
    "summary": "Finds the value from a file containing a lookup table of design and extracted parameters",
    "syntax": [
      {
        "syntax": "out = lookupreadvalue (\"filename\",\"table\",design,\"extracted\");",
        "description": "Find the value from a file containing a lookup table of design and extracted parameters. Parameter table is the name of the lookup table located inside the file, design is a cell containing multiple structures that define the design parameters to search, and extracted is the name of the parameter to be extracted. It will return the value is interpolated at the design parameters."
      }
    ],
    "example": "#design cell containing design/layout parameters (input parameter to search)\r\n#“gap” is the name of the property in the file\r\nw_gap=3.5e-07;\r\ndesign = cell(1);\r\ndesign{1} = struct;\r\ndesign{1}.name = \"gap\";\r\ndesign{1}.value = w_gap;\r\n#read coupling length from file (using design as input search “coupling_length”)\r\ncl=lookupreadvalue( \"coupler_map.ixml\", \"coupler_extracted\", design, \"coupling_length\" );\r\n?cl\r\n7.18624026618721e-06"
  },
  {
    "name": "lookupwrite",
    "description": "Writes to a lookup table file with a design and an extracted parameter pair. This function must be called after [ lookupopen ](./lookupopen.md) and before [ lookupclose ](./lookupclose.md) .",
    "usage": "lookupwrite();",
    "category": "general",
    "markdown": "# lookupwrite\r\n\r\nWrites to a lookup table file with a design and an extracted parameter pair. This\r\nfunction must be called after [ lookupopen ](./lookupopen.md) and before\r\n[ lookupclose ](./lookupclose.md) .\r\n\r\n| **Syntax**                                                  | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| ----------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = lookupwrite (\"filename\",\"table\",design, \"extracted\"); | Writes to a lookup table with a design and an extracted parameter pair. The design and extracted parameters are cells that contain multiple structures, allowing for mapping between multiple design and extracted parameters. This function can be called multiple times, for each call the design and extracted parameters will be appended to the current file. This function must be called after lookupopen and before lookupclose . |\r\n| out = lookupwrite (\"filename\");                             | Takes a script object, in this case a cell array containing all the contents of the xml file, and save it to a file.                                                                                                                                                                                                                                                                                                                      |\r\n\r\n**Example**\r\n\r\nThe script below maps two values of waveguide width and height to the effective index\r\nand group index.\r\n\r\n```\r\ndesign = cell(2);\r\n#extracted contains neff and ng\r\nextracted = cell(2);\r\n#design (input parameters)\r\ndesign{1} = struct;\r\ndesign{1}.name = \"width\";\r\ndesign{1}.value = 5.03333e-07;\r\ndesign{2} = struct;\r\ndesign{2}.name = \"heigth\";\r\ndesign{2}.value = 2.18889e-07;\r\n#extracted (output results)\r\nextracted{1} = struct;\r\nextracted{1}.name = \"neff\";\r\nextracted{1}.value = 2.1;\r\nextracted{2} = struct;\r\nextracted{2}.name = \"ng\";\r\nextracted{2}.value = 4.42;\r\n#open file to write table\r\nlookupopen( \"new.xml\", \"new_extracted\" );\r\n#write first design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n#second design/extracted pair\r\ndesign{1}.value = 6.03333e-07;\r\ndesign{2}.value = 1.18889e-07;\r\nextracted{1}.value = 2.2;\r\nextracted{2}.value = 4.45;\r\n#write second design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n#close file\r\nlookupclose( \"new.xml\" );\r\n```\r\n\r\nwhere “new.xml” is a lookup table containing the table “new_extracted”\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<lumerical_lookup_table version=\"1.0\" name = \"new_extracted\">\r\n<association>\r\n  <design>\r\n    <value name=\"width\" type=\"double\">5.03333e-07</value>\r\n    <value name=\"heigth\" type=\"double\">2.18889e-07</value>\r\n  <design>\r\n  <extracted>\r\n    <value name=\"neff\" type=\"double\">2.1</value>\r\n    <value name=\"ng\" type=\"double\">4.42</value>\r\n  </extracted>\r\n</association>\r\n<association>  \r\n  <design>\r\n    <value name=\"width\" type=\"double\">6.03333e-07</value>\r\n    <value name=\"heigth\" type=\"double\">1.18889e-07</value>\r\n  <design>\r\n  <extracted>\r\n    <value name=\"neff\" type=\"double\">2.2</value>\r\n    <value name=\"ng\" type=\"double\">4.45</value>\r\n  </extracted>\r\n</association>\r\n</lumerical_lookup_table>\r\n```",
    "summary": "Writes to a lookup table file with a design and an extracted parameter pair",
    "syntax": [
      {
        "syntax": "out = lookupwrite (\"filename\",\"table\",design, \"extracted\");",
        "description": "Writes to a lookup table with a design and an extracted parameter pair. The design and extracted parameters are cells that contain multiple structures, allowing for mapping between multiple design and extracted parameters. This function can be called multiple times, for each call the design and extracted parameters will be appended to the current file. This function must be called after lookupopen and before lookupclose ."
      },
      {
        "syntax": "out = lookupwrite (\"filename\");",
        "description": "Takes a script object, in this case a cell array containing all the contents of the xml file, and save it to a file."
      }
    ],
    "example": "design = cell(2);\r\n#extracted contains neff and ng\r\nextracted = cell(2);\r\n#design (input parameters)\r\ndesign{1} = struct;\r\ndesign{1}.name = \"width\";\r\ndesign{1}.value = 5.03333e-07;\r\ndesign{2} = struct;\r\ndesign{2}.name = \"heigth\";\r\ndesign{2}.value = 2.18889e-07;\r\n#extracted (output results)\r\nextracted{1} = struct;\r\nextracted{1}.name = \"neff\";\r\nextracted{1}.value = 2.1;\r\nextracted{2} = struct;\r\nextracted{2}.name = \"ng\";\r\nextracted{2}.value = 4.42;\r\n#open file to write table\r\nlookupopen( \"new.xml\", \"new_extracted\" );\r\n#write first design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n#second design/extracted pair\r\ndesign{1}.value = 6.03333e-07;\r\ndesign{2}.value = 1.18889e-07;\r\nextracted{1}.value = 2.2;\r\nextracted{2}.value = 4.45;\r\n#write second design/extracted pair\r\nlookupwrite( \"new.xml\", design, extracted );\r\n#close file\r\nlookupclose( \"new.xml\" );"
  },
  {
    "name": "lower",
    "description": "Converts all the characters in a string to lower case.",
    "usage": "lower();",
    "category": "general",
    "markdown": "# lower\r\n\r\nConverts all the characters in a string to lower case.\r\n\r\n| **Syntax**     | **Description**                  |\r\n| -------------- | -------------------------------- |\r\n| lower(string); | Converts a string to lower case. |\r\n\r\n**Example**\r\n\r\nUse lower case for all the characters in a string.\r\n\r\n```\r\n?lower(\"NAME\");\r\nname\r\n```",
    "summary": "Converts all the characters in a string to lower case",
    "syntax": [
      {
        "syntax": "lower(string);",
        "description": "Converts a string to lower case."
      }
    ],
    "example": "?lower(\"NAME\");\r\nname"
  },
  {
    "name": "ls",
    "description": "Lists files in a directory. Files other than Lumerical project files are also listed.",
    "usage": "ls();",
    "category": "general",
    "markdown": "# ls\r\n\r\nLists files in a directory. Files other than Lumerical project files are also listed.\r\n\r\n| **Syntax**                                     | **Description**                                                                |\r\n| ---------------------------------------------- | ------------------------------------------------------------------------------ |\r\n| out = dir; out = ls;                           | The output is a string. Use ?dir; to write the value to the screen.            |\r\n| out = dir(\"directory\"); out = ls(\"directory\"); | Lists the files in the specified directory. For example, ?ls(\"C:\\\\Downloads\"); |\r\n\r\n**Example**\r\n\r\nUses the splitstring command to get the contents of a directory in a cell (ie. string)\r\narray. Then loop through the array looking for all FDTD project files (.fsp).\r\n\r\n```\r\nfiles = splitstring(dir,endl);    # directory contents in a cell(string) array\r\nfor(i=1:length(files)) {          # loop over all files\r\n if (findstring(files{i},\"fsp\") != -1) {  # look for 'fsp' files\r\n  if (fileexists(files{i})) {       # check if the file exists\r\n   ?files{i};               # output file name\r\n   load(files{i});            # load file\r\n  }\r\n }\r\n}\r\n```",
    "summary": "Lists files in a directory",
    "syntax": [
      {
        "syntax": "out = dir; out = ls;",
        "description": "The output is a string. Use ?dir; to write the value to the screen."
      },
      {
        "syntax": "out = dir(\"directory\"); out = ls(\"directory\");",
        "description": "Lists the files in the specified directory. For example, ?ls(\"C:\\\\Downloads\");"
      }
    ],
    "example": "files = splitstring(dir,endl);    # directory contents in a cell(string) array\r\nfor(i=1:length(files)) {          # loop over all files\r\n if (findstring(files{i},\"fsp\") != -1) {  # look for 'fsp' files\r\n  if (fileexists(files{i})) {       # check if the file exists\r\n   ?files{i};               # output file name\r\n   load(files{i});            # load file\r\n  }\r\n }\r\n}"
  },
  {
    "name": "mapfind",
    "description": "Returns the nearest value from a file containing a map of values. It returns the string value located at the specified nearest point.",
    "usage": "mapfind();",
    "category": "general",
    "markdown": "# mapfind\r\n\r\nReturns the nearest value from a file containing a map of values. It returns the string\r\nvalue located at the specified nearest point.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                    |\r\n| --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = mapfind (filename,x,y);     | Find the nearest value from a file containing a map of values. It returns the string value located at the nearest point (x,y).     |\r\n| out = mapfind (filename,x,y,z);   | Find the nearest value from a file containing a map of values. It returns the string value located at the nearest point (x,y,z).   |\r\n| out = mapfind (filename,x,y,z,w); | Find the nearest value from a file containing a map of values. It returns the string value located at the nearest point (x,y,z,w). |\r\n\r\n**Example**\r\n\r\nLoad the effective index associated to a given waveguide width and height from a text\r\nfile in the current working directory. The file contains the effective index for\r\ndifferent values of width and height, separated by “,”. For example:\r\n\r\nwidth, height, neff\r\n\r\n4.9e-007,2.1e-007,2.38997\r\n\r\n4.9e-007,2.12222e-007,2.39885\r\n\r\n4.9e-007,2.14444e-007,2.40796\r\n\r\n4.9e-007,2.16667e-007,2.41618\r\n\r\nThe first row contains the column headers (optional), and the next four rows contain\r\ndata. The command mapfind is used as follows:\r\n\r\n```\r\n# Width and height we are looking for:\r\nwaveguide_width = 4.9e-007;\r\nwaveguide_height = 2.1e-007;\r\n# Find the effective index of the closest width-height combination (value is returned as a string):\r\nsneff = mapfind( \"neff_map.txt\", waveguide_width, waveguide_height );\r\n#convert the string sneff to a value\r\n?neff = str2num(sneff);\r\nresult: \r\n2.38997  \r\n```",
    "summary": "Returns the nearest value from a file containing a map of values",
    "syntax": [
      {
        "syntax": "out = mapfind (filename,x,y);",
        "description": "Find the nearest value from a file containing a map of values. It returns the string value located at the nearest point (x,y)."
      },
      {
        "syntax": "out = mapfind (filename,x,y,z);",
        "description": "Find the nearest value from a file containing a map of values. It returns the string value located at the nearest point (x,y,z)."
      },
      {
        "syntax": "out = mapfind (filename,x,y,z,w);",
        "description": "Find the nearest value from a file containing a map of values. It returns the string value located at the nearest point (x,y,z,w)."
      }
    ],
    "example": "# Width and height we are looking for:\r\nwaveguide_width = 4.9e-007;\r\nwaveguide_height = 2.1e-007;\r\n# Find the effective index of the closest width-height combination (value is returned as a string):\r\nsneff = mapfind( \"neff_map.txt\", waveguide_width, waveguide_height );\r\n#convert the string sneff to a value\r\n?neff = str2num(sneff);\r\nresult: \r\n2.38997"
  },
  {
    "name": "materialexists",
    "description": "Returns a boolean indicating whether or not a material exists in the material database.",
    "usage": "materialexists();",
    "category": "general",
    "markdown": "# materialexists\r\n\r\nReturns a boolean indicating whether or not a material exists in the material database.\r\n\r\n| **Syntax**                      | **Description**                                                                                         |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------------------- |\r\n| materialexists(\"materialname\"); | Returns 1 if the material named \"materialname\" is present in the material database. Otherwise return 0. |",
    "summary": "Returns a boolean indicating whether or not a material exists in the material database",
    "syntax": [
      {
        "syntax": "materialexists(\"materialname\");",
        "description": "Returns 1 if the material named \"materialname\" is present in the material database. Otherwise return 0."
      }
    ],
    "example": ""
  },
  {
    "name": "matlab",
    "description": "Runs a MATLAB command from the Lumerical script prompt. This gives access to extended mathematical and visualization functionality from the Lumerical script environment. If the MATLAB script integration is not enabled, this function will return an error.",
    "usage": "matlab();",
    "category": "general",
    "markdown": "# matlab\r\n\r\nRuns a MATLAB command from the Lumerical script prompt. This gives access to extended\r\nmathematical and visualization functionality from the Lumerical script environment. If\r\nthe MATLAB script integration is not enabled, this function will return an error.\r\n\r\nThe first time a MATLAB function (matlab, matlabget or matlabput) is called, a MATLAB\r\nsession will be started and a connection will be established with the Lumerical\r\nscripting environment. Once this connection is established, MATLAB commands can be run\r\nusing the matlab function. It is important to understand that the MATLAB and the\r\nLumerical script variable workspaces are completely separate and independent. A MATLAB\r\ncommand cannot act on a variable defined in the Lumerical workspace, and vice-versa.\r\nVariables must be passed between the workspaces using the matlabget and matlabput\r\nfunctions. At any time you may examine the MATLAB workspace or interact with the MATLAB\r\nenvironment by typing commands at the MATLAB script prompt. The working directory of the\r\nMATLAB instance is always set to match the working directory of the Lumerical\r\napplication.\r\n\r\nThe output from the MATLAB commands will be printed at the Lumerical script prompt. One\r\nlimitation of the matlab function is that no error reporting is provided to either the\r\nLumerical script prompt or the MATLAB prompt. MATLAB commands should be tested by typing\r\nthem directly into the MATLAB prompt before they are called from a Lumerical script. The\r\noutput buffer length is roughly 1e5 characters. Additional output will be truncated.\r\n\r\nWhen you have a long sequence of MATLAB commands, you may find it more convenient to\r\nsave them in a MATLAB m-file. Then, you can simply call the m-file by running a single\r\ncommand.\r\n\r\n## See [ MATLAB integration setup ](https://optics.ansys.com/hc/en-us/articles/360026142074) for installation and configuration instructions. Additional tips (particularly for plotting data in Matlab) can be found in the [ MATLAB ](https://optics.ansys.com/hc/en-us/articles/360034416614) section of the online help.\r\n\r\n| **Syntax**                       | **Description**                                                                                                                                          |\r\n| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| matlab(\"command\");               | command: a string containing one or more valid MATLAB commands.                                                                                          |\r\n| matlab(\" command_1 command_2 \"); | Multi-line strings can be used in script files to contain a block of MATLAB commands. Multi-line strings are not supported at the script command prompt. |\r\n\r\n**Examples**\r\n\r\nThis example will show how to use MATLAB's \"surf\" command to make a surface plot of the\r\nreal part of Ex. It assumes that the variables x, y, Ex are already defined in the\r\nLumerical workspace.\r\n\r\n```\r\nmatlabput(x,y,Ex);\r\nmatlab(\"surf(y,x,real(Ex))\");\r\n```\r\n\r\nThis example shows how multiple MATLAB commands can be included in a single matlab\r\nfunction call. A log-spaced vector is created in MATLAB, then imported into the\r\nLumerical workspace.\r\n\r\n```\r\nmatlab(\"\r\n % create a logspaced vector\r\n x_min = 1\r\n x_max = 4\r\n x = logspace(x_min,x_max,1000)\r\n\");\r\nmatlabget(x);\r\n```",
    "summary": "Runs a MATLAB command from the Lumerical script prompt",
    "syntax": [
      {
        "syntax": "matlab(\"command\");",
        "description": "command: a string containing one or more valid MATLAB commands."
      },
      {
        "syntax": "matlab(\" command_1 command_2 \");",
        "description": "Multi-line strings can be used in script files to contain a block of MATLAB commands. Multi-line strings are not supported at the script command prompt."
      }
    ],
    "example": ""
  },
  {
    "name": "matlabget",
    "description": "Copies a variable from the MATLAB workspace to the script variable workspace. The resulting variable will have the same name as the MATLAB variable, and will overwrite any existing variable with the same name. If the variable does not exist in MATLAB, the command will return an error. For more information, please see the matlab command description.",
    "usage": "matlabget();",
    "category": "general",
    "markdown": "# matlabget\r\n\r\nCopies a variable from the MATLAB workspace to the script variable workspace. The\r\nresulting variable will have the same name as the MATLAB variable, and will overwrite\r\nany existing variable with the same name. If the variable does not exist in MATLAB, the\r\ncommand will return an error. For more information, please see the matlab command\r\ndescription.\r\n\r\n## Note: Matlab script integration must be enabled in order to use this command. For more information on how to set this up see the [ Matlab script integration ](https://optics.ansys.com/hc/en-us/articles/360034923913-MATLAB-Script-Integration) page.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                       |\r\n| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| matlabget(var1, var2,...varN); | The arguments to this command are one or more variable names that refer to variables in the MATLAB workspace. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nSee the example in the [ matlab ](./matlab.md) function description.",
    "summary": "Copies a variable from the MATLAB workspace to the script variable workspace",
    "syntax": [
      {
        "syntax": "matlabget(var1, var2,...varN);",
        "description": "The arguments to this command are one or more variable names that refer to variables in the MATLAB workspace. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "matlabload",
    "description": "## Notes",
    "usage": "matlabload();",
    "category": "general",
    "markdown": "# matlabload\r\n\r\n## Notes\r\n\r\n- Starting with Lumerical 2024 R1, MATLAB Linux libraries are no longer packaged with\r\n  the Lumerical Applications\r\n- We still support MATLAB file load and save for versions 7 and greater\r\n- See this\r\n  [KB for more information](https://optics.ansys.com/hc/en-us/articles/360026142074).\r\n\r\nLoad Matlab .mat data into workspace\r\n\r\n| **Syntax**              | **Description**                                            |\r\n| ----------------------- | ---------------------------------------------------------- |\r\n| matlabload(\"filename\"); | Load to the workspace the data of the specified .mat file. |\r\n\r\n**Examples**\r\n\r\nThis is a simple example that shows how to load to workspace from a .mat data file.\r\n\r\n```\r\n#this file has variables data1, data2, data3\r\nmatlabload(\"myData.mat\");  \r\n?workspace;\r\nmatrices:\r\n data1 data2 data3\r\n```",
    "summary": "## Notes",
    "syntax": [
      {
        "syntax": "matlabload(\"filename\");",
        "description": "Load to the workspace the data of the specified .mat file."
      }
    ],
    "example": ""
  },
  {
    "name": "matlabput",
    "description": "Copies a variable from Lumerical's Script Workspace to the MATLAB workspace. The resulting variable in the MATLAB workspace will have the same name as in Lumerical, and will overwrite any existing variable with the same name. If the variable does not exist in the Lumerical workspace, the command will return an error.",
    "usage": "matlabput();",
    "category": "general",
    "markdown": "# matlabput\r\n\r\nCopies a variable from Lumerical's Script Workspace to the MATLAB workspace. The\r\nresulting variable in the MATLAB workspace will have the same name as in Lumerical, and\r\nwill overwrite any existing variable with the same name. If the variable does not exist\r\nin the Lumerical workspace, the command will return an error.\r\n\r\nFor more information, please see the matlab command description.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                      |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| matlabput(var1, var2,...varN); | The arguments to this command are one or more variable names that exist in the Lumerical variable workspace. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nSee the examples in the [ matlab ](./matlab.md) function description.",
    "summary": "Copies a variable from Lumerical's Script Workspace to the MATLAB workspace",
    "syntax": [
      {
        "syntax": "matlabput(var1, var2,...varN);",
        "description": "The arguments to this command are one or more variable names that exist in the Lumerical variable workspace. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "matlabsave",
    "description": "## Notes",
    "usage": "matlabsave();",
    "category": "general",
    "markdown": "# matlabsave\r\n\r\n## Notes\r\n\r\n- Starting with Lumerical 2024 R1, MATLAB Linux libraries are no longer packaged with\r\n  the Lumerical Applications\r\n- We still support MATLAB file load and save for versions 7 and greater\r\n- See this\r\n  [KB for more information](https://optics.ansys.com/hc/en-us/articles/360026142074#toc_3).\r\n\r\nSave Lumerical workspace variables to MATLAB .mat data files.\r\n\r\n| **Syntax**                               | **Description**                                                                                                                    |\r\n| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\r\n| matlabsave(\"\");                          | Save all workspace variables to a .mat file that has the same name as the simulation file. This function does not return any data. |\r\n| matlabsave(\"filename\");                  | Saves all workspace variables to the specified .mat file.                                                                          |\r\n| matlabsave(\"filename\", var1, ..., varN); | Saves the specified workspace variables to the .mat file.                                                                          |\r\n\r\n**Examples**\r\n\r\nSimple example:\r\n\r\n```\r\nx=1:10;\r\ny=x^2;\r\nmatlabsave(\"x_squared_data\", x, y);\r\n```\r\n\r\nSave data from a monitor named xy_monitor. The data is first obtained with script\r\nfunctions such as getdata and transmission. These workspace variables are then saved\r\nwith the matlabsave function. Note that complex file names can be created with the\r\nnum2str command. This is useful when doing parameter sweeps where a unique file name is\r\nrequired for each point in the sweep.\r\n\r\n```\r\n# get raw matrix data from the simulation\r\nmname=\"xy_monitor\";       # monitor name\r\nx=getdata(mname,\"x\");      # position vectors associated with Ex fields\r\ny=getdata(mname,\"y\");      # position vectors associated with Ex fields\r\nEx=getdata(mname,\"Ex\");     # Ex fields at monitor\r\nT=transmission(mname);     # Power transmission through monitor\r\n \r\n# save matrix variables x, y, Ex, T and i to a data file\r\ni=1;\r\nfilename=\"results_\"+num2str(i); # set filename. i could be a loop counter variable.\r\nmatlabsave(filename, x,y,Ex,T,i); \r\n```\r\n\r\nSave a Lumerical dataset (eg. Electric field vs x,y,z,f) to a .mat file. Lumerical\r\ndatasets will be imported into Matlab using the struct data type.\r\n\r\n```\r\n# get electric field dataset from the simulation\r\nmname=\"xy_monitor\";       # monitor name\r\nE=getresult(mname,\"E\");     # E fields at monitor\r\n \r\n# save dataset to mat file\r\nfilename=\"ElectricField\";\r\nmatlabsave(filename, E); \r\n```",
    "summary": "## Notes",
    "syntax": [
      {
        "syntax": "matlabsave(\"\");",
        "description": "Save all workspace variables to a .mat file that has the same name as the simulation file. This function does not return any data."
      },
      {
        "syntax": "matlabsave(\"filename\");",
        "description": "Saves all workspace variables to the specified .mat file."
      },
      {
        "syntax": "matlabsave(\"filename\", var1, ..., varN);",
        "description": "Saves the specified workspace variables to the .mat file."
      }
    ],
    "example": ""
  },
  {
    "name": "matrix",
    "description": "Initialize a matrix. All elements are set to zero.",
    "usage": "matrix();",
    "category": "general",
    "markdown": "# matrix\r\n\r\nInitialize a matrix. All elements are set to zero.\r\n\r\n| **Syntax**              | **Description**                         |\r\n| ----------------------- | --------------------------------------- |\r\n| x = matrix(i,j,k,....); | Initializes an i x j x k x .... matrix. |\r\n\r\n**Examples**\r\n\r\n```\r\n?x=matrix(2,2,2);\r\nresult(i,j,1):\r\n0 0 \r\n0 0 \r\nresult(i,j,2):\r\n0 0 \r\n0 0 \r\n```",
    "summary": "Initialize a matrix",
    "syntax": [
      {
        "syntax": "x = matrix(i,j,k,....);",
        "description": "Initializes an i x j x k x .... matrix."
      }
    ],
    "example": ""
  },
  {
    "name": "matrixdataset",
    "description": "Creates an empty matrix dataset. Matrix datasets are used for data (attributes and parameters) that don't have any spatial dependence (i.e. Reflection vs frequency). For datasets that do have x/y/z spatial coordinates (i.e. electric fields), use [rectilineardataset](./rectilineardataset.md) or [unstructureddataset](./unstructureddataset.md).",
    "usage": "matrixdataset();",
    "category": "general",
    "markdown": "# matrixdataset\r\n\r\nCreates an empty matrix dataset. Matrix datasets are used for data (attributes and\r\nparameters) that don't have any spatial dependence (i.e. Reflection vs frequency). For\r\ndatasets that do have x/y/z spatial coordinates (i.e. electric fields), use\r\n[rectilineardataset](./rectilineardataset.md) or\r\n[unstructureddataset](./unstructureddataset.md).\r\n\r\nMatrix datasets can be parameterized, and can contain an arbitrary number of attributes\r\n(see [addattribute)](./addattribute.md) and parameters (see\r\n[addparameter)](./addparameter.md).\r\n\r\nSee\r\n[Dataset introduction](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets)\r\nfor more information.\r\n\r\n| **Syntax**             | **Description**                                |\r\n| ---------------------- | ---------------------------------------------- |\r\n| matrixdataset;         | Creates an empty dataset.                      |\r\n| matrixdataset(\"name\"); | Creates an empty dataset with the name \"name\". |\r\n\r\n**Examples**\r\n\r\nThis example uses a matrix dataset to store cross section (sigma) data as a function of\r\nfrequency. In this case, the cross section data sigma is the attribute, and frequency is\r\nthe parameter. To allow the user to access the frequency parameter in terms of frequency\r\nor wavelength , both frequency (f) and wavelength (c/f) are added as interdependent\r\nparameters.\r\n\r\n```\r\nsigma = matrixdataset(\"cross_section\");\r\nsigma.addparameter(\"lambda\",c/f,\"f\",f); # add parameter f and lambda\r\nsigma.addattribute(\"sigma\",CS); # add attribute CS\r\nvisualize(sigma); # visualize this dataset in the Visualizer\r\n```\r\n\r\nThe following script code generates some example data, then creates a R(radius,height)\r\ndataset.\r\n\r\n```\r\n# create example results\r\nradius = 0:10; \r\nheight = 1:0.1:3;\r\nreflection = randmatrix(length(radius),length(height)); \r\n# create Reflection dataset\r\nR = matrixdataset(\"R\"); # initialize dataset\r\nR.addparameter(\"radius\",radius); # add radius parameter\r\nR.addparameter(\"height\",height); # add height parameter\r\nR.addattribute(\"R\",reflection); # add reflection attribute\r\n# plot data\r\nimage(radius,height,reflection); # use original matrices\r\nimage(R.radius,R.height,R.R);  # use dataset\r\n# send dataset to visualizer\r\nvisualize(R); \r\n```",
    "summary": "Creates an empty matrix dataset",
    "syntax": [
      {
        "syntax": "matrixdataset;",
        "description": "Creates an empty dataset."
      },
      {
        "syntax": "matrixdataset(\"name\");",
        "description": "Creates an empty dataset with the name \"name\"."
      }
    ],
    "example": ""
  },
  {
    "name": "max",
    "description": "Returns the maximum value in a matrix. For complex numbers, only the real part is considered.",
    "usage": "max();",
    "category": "general",
    "markdown": "# max\r\n\r\nReturns the maximum value in a matrix. For complex numbers, only the real part is\r\nconsidered.\r\n\r\n| **Syntax**    | **Description**                |\r\n| ------------- | ------------------------------ |\r\n| out = max(x); | The maximum value in matrix x. |\r\n\r\n**Example**\r\n\r\nSimple example showing how to find the maximum value of a vector.\r\n\r\n```\r\n?x=linspace(0,3,4);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\n?max(x);\r\nresult: \r\n3\r\n```\r\n\r\nSimple example showing how complex numbers are treated.\r\n\r\n```\r\n?x = 3 + 4i;\r\n?max(x);\r\n?max(abs(x));\r\nresult: \r\n3+4i \r\nresult: \r\n3 \r\nresult: \r\n5 \r\n```\r\n\r\nFind the maximum field intensity at each frequency point.\r\n\r\n```\r\n# plot the maximum value of an 3D E-field by frequency\r\nE2  = getelectric(\"3D field monitor\");\r\nf   = getdata(\"3D field monitor\",\"f\");\r\nE_dim = size(E2);            # dimensions of matrix E\r\ndata = matrix(E_dim(4));        # make a matrix of size E_dim(4) ie. number of freq pts\r\nfor (i=1:E_dim(4)) {\r\n maxVal = max( pinch(E2,4,i) );        # pick out data at a certain freq\r\n data(i)=maxVal;\r\n}\r\nplot(f,data,\"Frequency (Hz)\",\"Maximum E intensity\"); \r\n```",
    "summary": "Returns the maximum value in a matrix",
    "syntax": [
      {
        "syntax": "out = max(x);",
        "description": "The maximum value in matrix x."
      }
    ],
    "example": "?x=linspace(0,3,4);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\n?max(x);\r\nresult: \r\n3"
  },
  {
    "name": "mcfit",
    "description": "The script command runs the multi-coefficient fitting for a file containing multiple frequency dependent transmission values.",
    "usage": "mcfit();",
    "category": "general",
    "markdown": "# mcfit\r\n\r\nThe script command runs the multi-coefficient fitting for a file containing multiple\r\nfrequency dependent transmission values.\r\n\r\n| **Syntax**                                                 | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| ---------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| mcfit(filenamein,filenameout,npoles,tolerance,automatic) ; | Runs the multi-coefficient fitting for a file containing multiple frequency dependent transmission values (filenamein), where each transmission depends on an operating point, and generates a file containing the fitting data (filenameout). The number of poles and the fitting tolerance are defined by parameters npoles and tolerance respectively. The parameter ‘automatic’ define if the fitting will use the user defined npoles or estimate the number of poles automatically. |",
    "summary": "The script command runs the multi-coefficient fitting for a file containing multiple frequency depen...",
    "syntax": [
      {
        "syntax": "mcfit(filenamein,filenameout,npoles,tolerance,automatic) ;",
        "description": "Runs the multi-coefficient fitting for a file containing multiple frequency dependent transmission values (filenamein), where each transmission depends on an operating point, and generates a file containing the fitting data (filenameout). The number of poles and the fitting tolerance are defined by parameters npoles and tolerance respectively. The parameter ‘automatic’ define if the fitting will use the user defined npoles or estimate the number of poles automatically."
      }
    ],
    "example": ""
  },
  {
    "name": "mczfit",
    "description": "Fits a variable gain filter to a family of gain curve data, where each curve in the family corresponds to a value of carrier density, producing a file of gain filter coefficients to be used by the TWLM element.",
    "usage": "mczfit();",
    "category": "general",
    "markdown": "# mczfit\r\n\r\nFits a variable gain filter to a family of gain curve data, where each curve in the\r\nfamily corresponds to a value of carrier density, producing a file of gain filter\r\ncoefficients to be used by the TWLM element.\r\n\r\n| **Syntax**                                                                                                              | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\r\n| ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=mczfit(inputfilename, outputfilebase, centrefrequency, samplerate, maxnumcoef, tol, maxiter, rectangular, rolloff); | Fits a variable gain filter to a family of gain curve data, where each curve in the family corresponds to a value of carrier density, producing a file of gain filter coefficients to be used by the TWLM element. \" **inputfilename** \" is a string containing the name of the input data file (including the suffix). The format of the input data is specified below. \" **outputfilename** \" is a string containing the name (excluding the suffix) of the file containing the gain filter coefficients. \" **centrefrequency** \" is the center frequency of the frequency band for which the gain fitting is to be performed. \" **samplerate** \" is the bandwidth of the frequency band for which the gain fitting is to be performed. \" **maxnumcoef** \" is the maximum number of filter coefficients to be used to fit to the data. \" **tol** \" is the tolerance \" **rectangular** \" is a bool value, it defines the data format. \"true\" represents 'real' and 'imaginary' format; \"false\" represents polar coordinate format with 'amplitude' and 'phase' \" **maxiter** \" is the maximum number of iterations used in fitting to the data. \" **rolloff** \" is the fraction of the bandwidth over which the input frequency data is rolled off to the average of the two values at the band edges. |\r\n\r\n**Implementation detail**\r\n\r\nThe format of the data file is as follows:\r\n\r\n```\r\n(1, Nc)\r\ncarrierdensity_1, carrierdenisty_2, …, carrierdensity_Nc\r\n(Ns, Nc+1)\r\nfreq_1gain_1_1gain_1_2…gain_1_Nc\r\nfreq_2gain_2_1gain_2_2…gain_2_Nc\r\n……………\r\nfreq_Nsgain_Ns_1gain_Ns_2…gain_Ns_Nc\r\n```\r\n\r\nwhere the parameters are defined in the table below:\r\n\r\n| Nc               | The number of gain curvers                                     |\r\n| ---------------- | -------------------------------------------------------------- |\r\n| Ns               | The number of frequency samples                                |\r\n| carrierdensity_j | The carrier density corresponding to the j-th gain curve       |\r\n| freq_i           | The i-th frequency sample                                      |\r\n| gain_i_j         | The gain value for the i-th frequency sample in the j-th curve |\r\n\r\nNotes:\r\n\r\n1. The frequencies must be ordered in ascending order, such that frequency_1 is the\r\n   lowest and frequency_Ns is the highest\r\n1. The gain curves and carrier densities must be ordered in descending order of carrier\r\n   density. That is, carrierdensity_1 is the largest carrier density and\r\n   carrierdensity_Nc is the lowest carrier density, and gain_i_1 is the gain for the\r\n   largest carrier density and i-th frequency sample and gain_i_Nc is the gain for the\r\n   lowest carriest density and i-th frequency sample.\r\n\r\nThe return values are listed in the table below:\r\n\r\n| fit_out                    | A struct with fields                                                                                                                                                        |\r\n| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| frequency                  | A column vector of the frequency sample points                                                                                                                              |\r\n| input                      | A matrix with the column vectors containing the input frequency response to be fit for each operating point                                                                 |\r\n| operatingPoint             | A row vector containing the input operating points corresponding to the input frequency responses in the columns of the input matrix                                        |\r\n| operatingPointInterpolated | A row vector containing values of the linearly interpolated values of operating points between the input values of operating points                                         |\r\n| output                     | A matrix with the column vectors containing the fit frequency response for each input operating point                                                                       |\r\n| outputInterpolated         | A matrix with the column vectors containing the fit frequency response for each linearly interpolated operating point contained in row vector ‘operatingPointInterpolated’. |\r\n\r\nNote:\r\n\r\nThis script function also produces a gain filter coefficients to be used by the TWLM\r\nelement. The name of the file will be outputfilename.mcfdb.\r\n\r\n**Example**\r\n\r\nPlease refer to the application example page\r\n[ Gain Fitting ](https://optics.ansys.com/hc/en-us/articles/360042820953) for the\r\ndetailed usage of this command.",
    "summary": "Fits a variable gain filter to a family of gain curve data, where each curve in the family correspon...",
    "syntax": [
      {
        "syntax": "out=mczfit(inputfilename, outputfilebase, centrefrequency, samplerate, maxnumcoef, tol, maxiter, rectangular, rolloff);",
        "description": "Fits a variable gain filter to a family of gain curve data, where each curve in the family corresponds to a value of carrier density, producing a file of gain filter coefficients to be used by the TWLM element. \" inputfilename \" is a string containing the name of the input data file (including the suffix). The format of the input data is specified below. \" outputfilename \" is a string containing the name (excluding the suffix) of the file containing the gain filter coefficients. \" centrefrequency \" is the center frequency of the frequency band for which the gain fitting is to be performed. \" samplerate \" is the bandwidth of the frequency band for which the gain fitting is to be performed. \" maxnumcoef \" is the maximum number of filter coefficients to be used to fit to the data. \" tol \" is the tolerance \" rectangular \" is a bool value, it defines the data format. \"true\" represents 'real' and 'imaginary' format; \"false\" represents polar coordinate format with 'amplitude' and 'phase' \" maxiter \" is the maximum number of iterations used in fitting to the data. \" rolloff \" is the fraction of the bandwidth over which the input frequency data is rolled off to the average of the two values at the band edges."
      }
    ],
    "example": ""
  },
  {
    "name": "mean",
    "description": "Returns the mean value in a matrix.",
    "usage": "mean();",
    "category": "general",
    "markdown": "# mean\r\n\r\nReturns the mean value in a matrix.\r\n\r\n| **Syntax**     | **Description**                             |\r\n| -------------- | ------------------------------------------- |\r\n| out = mean(a); | The mean value of the matrix a is returned. |\r\n\r\n**Example**\r\n\r\nSimple example showing how to find the mean value of a vector.\r\n\r\n```\r\n?x = linspace(0,3,4);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\n?mean(x);\r\nresult: \r\n1.5\r\n```",
    "summary": "Returns the mean value in a matrix",
    "syntax": [
      {
        "syntax": "out = mean(a);",
        "description": "The mean value of the matrix a is returned."
      }
    ],
    "example": "?x = linspace(0,3,4);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\n?mean(x);\r\nresult: \r\n1.5"
  },
  {
    "name": "mesh",
    "description": "Produces a mesh of the current structure that is required to perform a subsequent calculation. In MODE, it produces a d-card called \"material\" which contains the material properties of the meshed object.",
    "usage": "mesh();",
    "category": "general",
    "markdown": "# mesh\r\n\r\nProduces a mesh of the current structure that is required to perform a subsequent\r\ncalculation. In MODE, it produces a d-card called \"material\" which contains the material\r\nproperties of the meshed object.\r\n\r\nThis is equivalent to pressing the \"mesh structure\" button in the graphical user\r\ninterface of MODE, or \"Mesh\" button in Finite Element IDE.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                        |\r\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| mesh;                | Mesh the current simulation in FDE, DGTD, or FEEM. In MODE, it can be used only with FDE solver. In Finite Element IDE, it meshes the simulation that is present (DGTD or FEEM)        |\r\n| mesh(\"solver_name\"); | Mesh the current simulation in the desired solver defined by the argument \"solver_name\". Argument name is supported only in Finite Element IDE, and the options are \"DGTD\" and \"FEEM\". |",
    "summary": "Produces a mesh of the current structure that is required to perform a subsequent calculation",
    "syntax": [
      {
        "syntax": "mesh;",
        "description": "Mesh the current simulation in FDE, DGTD, or FEEM. In MODE, it can be used only with FDE solver. In Finite Element IDE, it meshes the simulation that is present (DGTD or FEEM)"
      },
      {
        "syntax": "mesh(\"solver_name\");",
        "description": "Mesh the current simulation in the desired solver defined by the argument \"solver_name\". Argument name is supported only in Finite Element IDE, and the options are \"DGTD\" and \"FEEM\"."
      }
    ],
    "example": ""
  },
  {
    "name": "meshgrid3dx",
    "description": "Create a 3D meshgrid in the x direction",
    "usage": "meshgrid3dx();",
    "category": "general",
    "markdown": "# meshgrid3dx\r\n\r\nCreate a 3D meshgrid in the x direction\r\n\r\n| **Syntax**                | **Description**                            |\r\n| ------------------------- | ------------------------------------------ |\r\n| out = meshgrid3dx(x,y,z); | The 3D version of meshgridx and meshgridy. |\r\n\r\n**Examples**\r\n\r\nSee example in meshgridx.",
    "summary": "Create a 3D meshgrid in the x direction",
    "syntax": [
      {
        "syntax": "out = meshgrid3dx(x,y,z);",
        "description": "The 3D version of meshgridx and meshgridy."
      }
    ],
    "example": ""
  },
  {
    "name": "meshgrid3dy",
    "description": "Create a 3D meshgrid in the y direction",
    "usage": "meshgrid3dy();",
    "category": "general",
    "markdown": "# meshgrid3dy\r\n\r\nCreate a 3D meshgrid in the y direction\r\n\r\n| **Syntax**                | **Description**                            |\r\n| ------------------------- | ------------------------------------------ |\r\n| out = meshgrid3dy(x,y,z); | The 3D version of meshgridx and meshgridy. |\r\n\r\n**Examples**\r\n\r\nSee example in meshgridx.",
    "summary": "Create a 3D meshgrid in the y direction",
    "syntax": [
      {
        "syntax": "out = meshgrid3dy(x,y,z);",
        "description": "The 3D version of meshgridx and meshgridy."
      }
    ],
    "example": ""
  },
  {
    "name": "meshgrid3dz",
    "description": "Create a 3D meshgrid in the z direction",
    "usage": "meshgrid3dz();",
    "category": "general",
    "markdown": "# meshgrid3dz\r\n\r\nCreate a 3D meshgrid in the z direction\r\n\r\n| **Syntax**                | **Description**                            |\r\n| ------------------------- | ------------------------------------------ |\r\n| out = meshgrid3dz(x,y,z); | The 3D version of meshgridx and meshgridy. |\r\n\r\n**Examples**\r\n\r\nSee example in meshgridx.",
    "summary": "Create a 3D meshgrid in the z direction",
    "syntax": [
      {
        "syntax": "out = meshgrid3dz(x,y,z);",
        "description": "The 3D version of meshgridx and meshgridy."
      }
    ],
    "example": ""
  },
  {
    "name": "meshgrid4d",
    "description": "Create a 4D meshgrid in any direction.",
    "usage": "meshgrid4d();",
    "category": "general",
    "markdown": "# meshgrid4d\r\n\r\nCreate a 4D meshgrid in any direction.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                             |\r\n| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = meshgrid4d(dim, x1, x2, x3, x4); | The 4D meshgrid function. dim specifies the dimension along which to create the grid x1,x2,x3,x4 are the position vectors in each direction |\r\n\r\n**Examples**\r\n\r\nCreate a 4D frequency vector from a set of position vectors.\r\n\r\n```\r\nx=linspace(-10,10,20);\r\ny=linspace(-10,10,21);\r\nz=linspace(-10,10,22);\r\nf=linspace(0,100,23);\r\nF=meshgrid4d(4,x,y,z,f); # create meshgrid in 4th (frequency) dimension\r\n?size(F);         # size should be equal to the size of each position vector\r\nresult: \r\n20 21 22 23 \r\n```",
    "summary": "Create a 4D meshgrid in any direction",
    "syntax": [
      {
        "syntax": "out = meshgrid4d(dim, x1, x2, x3, x4);",
        "description": "The 4D meshgrid function. dim specifies the dimension along which to create the grid x1,x2,x3,x4 are the position vectors in each direction"
      }
    ],
    "example": ""
  },
  {
    "name": "meshgridx",
    "description": "Create a 2D meshgrid in the x direction",
    "usage": "meshgridx();",
    "category": "general",
    "markdown": "# meshgridx\r\n\r\nCreate a 2D meshgrid in the x direction\r\n\r\n| **Syntax**            | **Description**                                                                                          |\r\n| --------------------- | -------------------------------------------------------------------------------------------------------- |\r\n| out = meshgridx(x,y); | If x and y are single column (or single row vectors), of dimension nX1 and mX1 respectively, the command |\r\n\r\n- X = meshgridx(x,y);\r\n\r\nWill create a 2D matrix of dimension nXm where X(i,j)=x(i).\r\n\r\n**Examples**\r\n\r\nThis example uses the image function to show the output of meshgrid. See the image\r\nfunction help for another example that uses meshgrid.\r\n\r\n```\r\nx=linspace(0,10,100);\r\ny=linspace(0,10,10);\r\nimage(x,y,meshgridx(x,y),\"x\",\"y\",\"meshgridx\");\r\nimage(x,y,meshgridy(x,y),\"x\",\"y\",\"meshgridy\");\r\n```\r\n\r\nThe following figures show the output of the the example code.\r\n\r\nThis example uses the mesh grid functions to create an image plot of a 2D gaussian\r\nfunction Z(x,y)=exp( -x^2-y^2).\r\n\r\n```\r\nx=linspace(-3,3,100); \r\ny=x; \r\nX=meshgridx(x,y); \r\nY=meshgridy(x,y); \r\nZ=exp( -X^2 -Y^2); \r\nimage(x,y,Z);\r\n```",
    "summary": "Create a 2D meshgrid in the x direction",
    "syntax": [
      {
        "syntax": "out = meshgridx(x,y);",
        "description": "If x and y are single column (or single row vectors), of dimension nX1 and mX1 respectively, the command"
      }
    ],
    "example": ""
  },
  {
    "name": "meshgridy",
    "description": "Create a 2D meshgrid in the y direction",
    "usage": "meshgridy();",
    "category": "general",
    "markdown": "# meshgridy\r\n\r\nCreate a 2D meshgrid in the y direction\r\n\r\n| **Syntax**            | **Description**                                                                                          |\r\n| --------------------- | -------------------------------------------------------------------------------------------------------- |\r\n| out = meshgridy(x,y); | If x and y are single column (or single row vectors), of dimension nX1 and mX1 respectively, the command |\r\n\r\n- Y = meshgridy(x,y);\r\n\r\nWill create a 2D matrix of dimension nXm where Y(i,j)=y(j).\r\n\r\n**Examples**\r\n\r\nSee example in meshgridx.",
    "summary": "Create a 2D meshgrid in the y direction",
    "syntax": [
      {
        "syntax": "out = meshgridy(x,y);",
        "description": "If x and y are single column (or single row vectors), of dimension nX1 and mX1 respectively, the command"
      }
    ],
    "example": ""
  },
  {
    "name": "message",
    "description": "Creates a message window that displays some text. The user must hit Enter, or click the OK button to continue.",
    "usage": "message();",
    "category": "general",
    "markdown": "# message\r\n\r\nCreates a message window that displays some text. The user must hit Enter, or click the\r\nOK button to continue.\r\n\r\n| **Syntax**       | **Description**                                                              |\r\n| ---------------- | ---------------------------------------------------------------------------- |\r\n| message(\"text\"); | Creates a window that displays text. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nThis example shows how to use the message command.\r\n\r\n```\r\nmessage(\"Click Close to continue\"); \r\n```",
    "summary": "Creates a message window that displays some text",
    "syntax": [
      {
        "syntax": "message(\"text\");",
        "description": "Creates a window that displays text. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "mie3d",
    "description": "The function mie3d can be used to calculate the scattering, absorption, and extinction efficiencies of a spherical particle made of any (non-magnetic) material embedded in any ambient dielectric material. The efficiencies are simply the cross sections normalized to the geometric cross section of the particle (\\\\(\\\\pi r^2\\\\)).",
    "usage": "mie3d();",
    "category": "general",
    "markdown": "# mie3d\r\n\r\nThe function mie3d can be used to calculate the scattering, absorption, and extinction\r\nefficiencies of a spherical particle made of any (non-magnetic) material embedded in any\r\nambient dielectric material. The efficiencies are simply the cross sections normalized\r\nto the geometric cross section of the particle (\\\\(\\\\pi r^2\\\\)).\r\n\r\n### References:\r\n\r\n[1] Bohren C.F. and D.R. Huffman, “Absorption and Scattering of Light by Small\r\nParticles”, John Wiley, New York, NY, 1983.\r\n\r\n[2] Documentation of Mätzler C. “MATLAB Functions for Mie Scattering and Absorption,\r\nVersion 2”, IAP Res. Rep. No. 2002-11, August, 2002.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Q = mie3d(m,x);      | The result Q is a struct which contains quantities Qext, Qabs and Qscat (Qext = Qabs+Qscat). These will have the same length as x. The arguments are: m: the ratio of the refractive index of the sphere to the refractive index of the ambient dielectric medium. This quantity may be complex-valued because the refractive index of the sphere may be complex. This quantity should either have a singleton value, or be the same length of x for dispersive media. x: the size parameter which is defined as 2*pi*r/lambda0\\*n1 where lambda0 is the free space wavelength, r is the sphere radius, and n1 is the real-valued refractive index of the ambient medium. |\r\n| Q = mie3d(m,x,nmax); | nmax : the maximum number of orders to calculate for the mie coefficients. The default value is 0, and in this case the nmax = ceil(x+4\\*x^(1/3))+2. There is typically no need to modify the default value.                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n\r\n**Example**\r\n\r\nIn this example we will calculate and compare the extinction efficiencies for 1 micron\r\nspheres of n=1.5, dispersive glass and gold over the visible spectrum.\r\n\r\n```\r\n# input parameters\r\nn1 = 1;\r\nn2 = 1.5;\r\nlambda0 = linspace(400e-9,700e-9,10000);\r\nradius = 1000e-9;\r\n# calculate m,x and call mie3d\r\nm = n2/n1;\r\nx = 2*pi*radius/lambda0*n1;\r\nQ1 = mie3d(m,x);\r\n# recalculate with dispersive glass\r\nn2 = getindex(\"SiO2 (Glass) - Palik\",c/lambda0);\r\nm = n2/n1;\r\nQ2 = mie3d(m,x);\r\n# recalculate with Al\r\nn2 = getindex(\"Au (Gold) - Palik\",c/lambda0);\r\nm = n2/n1;\r\nQ3 = mie3d(m,x);\r\nplot(lambda0*1e9,Q1.Qext,Q2.Qext,Q3.Qext,\"wavelength (nm)\",\"Q extinction\");\r\nlegend(\"n = 1.5\",\"Glass (Palik)\",\"Gold (Palik)\");\r\n```",
    "summary": "The function mie3d can be used to calculate the scattering, absorption, and extinction efficiencies ...",
    "syntax": [
      {
        "syntax": "Q = mie3d(m,x);",
        "description": "The result Q is a struct which contains quantities Qext, Qabs and Qscat (Qext = Qabs+Qscat). These will have the same length as x. The arguments are: m: the ratio of the refractive index of the sphere to the refractive index of the ambient dielectric medium. This quantity may be complex-valued because the refractive index of the sphere may be complex. This quantity should either have a singleton value, or be the same length of x for dispersive media. x: the size parameter which is defined as 2*pi*r/lambda0\\*n1 where lambda0 is the free space wavelength, r is the sphere radius, and n1 is the real-valued refractive index of the ambient medium."
      },
      {
        "syntax": "Q = mie3d(m,x,nmax);",
        "description": "nmax : the maximum number of orders to calculate for the mie coefficients. The default value is 0, and in this case the nmax = ceil(x+4\\*x^(1/3))+2. There is typically no need to modify the default value."
      }
    ],
    "example": "# input parameters\r\nn1 = 1;\r\nn2 = 1.5;\r\nlambda0 = linspace(400e-9,700e-9,10000);\r\nradius = 1000e-9;\r\n# calculate m,x and call mie3d\r\nm = n2/n1;\r\nx = 2*pi*radius/lambda0*n1;\r\nQ1 = mie3d(m,x);\r\n# recalculate with dispersive glass\r\nn2 = getindex(\"SiO2 (Glass) - Palik\",c/lambda0);\r\nm = n2/n1;\r\nQ2 = mie3d(m,x);\r\n# recalculate with Al\r\nn2 = getindex(\"Au (Gold) - Palik\",c/lambda0);\r\nm = n2/n1;\r\nQ3 = mie3d(m,x);\r\nplot(lambda0*1e9,Q1.Qext,Q2.Qext,Q3.Qext,\"wavelength (nm)\",\"Q extinction\");\r\nlegend(\"n = 1.5\",\"Glass (Palik)\",\"Gold (Palik)\");"
  },
  {
    "name": "mie3ds12",
    "description": "The function mie3ds12 can be used to calculate the scattered far field of any (non-magnetic) material embedded in any ambient dielectric material. The function returns the scattering functions S1 and S2. The scattered far field can be calculated by",
    "usage": "mie3ds12();",
    "category": "general",
    "markdown": "# mie3ds12\r\n\r\nThe function mie3ds12 can be used to calculate the scattered far field of any\r\n(non-magnetic) material embedded in any ambient dielectric material. The function\r\nreturns the scattering functions S1 and S2. The scattered far field can be calculated by\r\n\r\n$$\\\\begin{array}{l}{E\\_{1}=\\\\frac{e^{i i v}}{-i k r} \\\\cos \\\\varphi \\\\cdot S\\_{2}(\\\\cos\r\n\\\\theta)} \\\\\\\\ {E\\_{\\\\perp}=\\\\frac{e^{i k r}}{i k r} \\\\sin \\\\varphi \\\\cdot S\\_{1}(\\\\cos\r\n\\\\theta)}\\\\end{array} $$\r\n\r\nWhere E || is the field in the scattering plane and E ⊥ is the field orthogonal to the\r\nscattering plane. The scattering plane is defined by the incident and scattered\r\ndirections. The angle θ is the angle within the scattering plane (with respect to the\r\nincident angle) and the angle φ is the angle between the incident electric field and the\r\nscattering plane.\r\n\r\n### References:\r\n\r\n[1] Bohren C.F. and D.R. Huffman, “Absorption and Scattering of Light by Small\r\nParticles”, John Wiley, New York, NY, 1983.\r\n\r\n[2] Documentation of Mätzler C. “MATLAB Functions for Mie Scattering and Absorption,\r\nVersion 2”, IAP Res. Rep. No. 2002-11, August, 2002.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\r\n| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| S = mie3ds12(u,m,x);      | The result Q is a struct which contains quantities S1, S2 which has dimensions NxM where N is the length of u and M is the length of x. The arguments are: u: this is cos(q) m: the ratio of the refractive index of the sphere to the refractive index of the ambient dielectric medium. This quantity may be complex-valued because the refractive index of the sphere may be complex. This quantity should either have a singleton value, or be the same length of x for dispersive media. x: the size parameter which is defined as 2*pi*r/lambda0\\*n1 where lambda0 is the free space wavelength, r is the sphere radius and n1 is the real-valued refractive index of the ambient medium. |\r\n| S = mie3ds12(u,m,x,nmax); | nmax : the maximum number of orders to calculate for the mie coefficients. The default value is 0, and in this case the nmax = ceil(x+4\\*x^(1/3))+2. There is typically no need to modify the default value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\r\n\r\n**Example**\r\n\r\nFor example, lets calculate field in XY and YZ planes for 500nm light that is incident\r\nalong the y axis, polarized along the z axis.\r\n\r\n```\r\n# input parameters\r\nn1 = 1;\r\nn2 = 1.5;\r\nlambda0 = 500e-9;\r\nradius = 500e-9;\r\n# calculate m,x and call mie3ds12\r\nm = n2/n1;\r\nx = 2*pi*radius/lambda0*n1;\r\ntheta = linspace(0,2*pi,1000);\r\nS = mie3ds12(cos(theta),m,x);\r\nk = 2*pi/lambda0 * n1;\r\nR = 1; # radius of 1m\r\n# XY plane: phi = 90, Etang = EP, Eperp = Ez = ES\r\nphi = 90*pi/180;\r\nEtang = exp(1i*k*R)/(-1i*k*R)*cos(phi)*S.S2;\r\nEperp = exp(1i*k*R)/(1i*k*R)*sin(phi)*S.S1;\r\npolar(theta,abs(Etang),abs(Eperp),\"\",\"\",\"XY plane\");\r\nlegend(\"|EP|\",\"|ES|\");\r\n# YZ plane: phi = 0, Etang = EP, Eperp = Ex = ES\r\nphi = 0;\r\nEtang = exp(1i*k*R)/(-1i*k*R)*cos(phi)*S.S2;\r\nEperp = exp(1i*k*R)/(1i*k*R)*sin(phi)*S.S1;\r\npolar(theta,abs(Etang),abs(Eperp),\"\",\"\",\"YZ plane\");\r\nlegend(\"|EP|\",\"|ES|\");\r\n```",
    "summary": "The function mie3ds12 can be used to calculate the scattered far field of any (non-magnetic) materia...",
    "syntax": [
      {
        "syntax": "S = mie3ds12(u,m,x);",
        "description": "The result Q is a struct which contains quantities S1, S2 which has dimensions NxM where N is the length of u and M is the length of x. The arguments are: u: this is cos(q) m: the ratio of the refractive index of the sphere to the refractive index of the ambient dielectric medium. This quantity may be complex-valued because the refractive index of the sphere may be complex. This quantity should either have a singleton value, or be the same length of x for dispersive media. x: the size parameter which is defined as 2*pi*r/lambda0\\*n1 where lambda0 is the free space wavelength, r is the sphere radius and n1 is the real-valued refractive index of the ambient medium."
      },
      {
        "syntax": "S = mie3ds12(u,m,x,nmax);",
        "description": "nmax : the maximum number of orders to calculate for the mie coefficients. The default value is 0, and in this case the nmax = ceil(x+4\\*x^(1/3))+2. There is typically no need to modify the default value."
      }
    ],
    "example": "# input parameters\r\nn1 = 1;\r\nn2 = 1.5;\r\nlambda0 = 500e-9;\r\nradius = 500e-9;\r\n# calculate m,x and call mie3ds12\r\nm = n2/n1;\r\nx = 2*pi*radius/lambda0*n1;\r\ntheta = linspace(0,2*pi,1000);\r\nS = mie3ds12(cos(theta),m,x);\r\nk = 2*pi/lambda0 * n1;\r\nR = 1; # radius of 1m\r\n# XY plane: phi = 90, Etang = EP, Eperp = Ez = ES\r\nphi = 90*pi/180;\r\nEtang = exp(1i*k*R)/(-1i*k*R)*cos(phi)*S.S2;\r\nEperp = exp(1i*k*R)/(1i*k*R)*sin(phi)*S.S1;\r\npolar(theta,abs(Etang),abs(Eperp),\"\",\"\",\"XY plane\");\r\nlegend(\"|EP|\",\"|ES|\");\r\n# YZ plane: phi = 0, Etang = EP, Eperp = Ex = ES\r\nphi = 0;\r\nEtang = exp(1i*k*R)/(-1i*k*R)*cos(phi)*S.S2;\r\nEperp = exp(1i*k*R)/(1i*k*R)*sin(phi)*S.S1;\r\npolar(theta,abs(Etang),abs(Eperp),\"\",\"\",\"YZ plane\");\r\nlegend(\"|EP|\",\"|ES|\");"
  },
  {
    "name": "min",
    "description": "Returns the minimum value in a matrix. For complex numbers, only the real part is considered.",
    "usage": "min();",
    "category": "general",
    "markdown": "# min\r\n\r\nReturns the minimum value in a matrix. For complex numbers, only the real part is\r\nconsidered.\r\n\r\n| **Syntax**    | **Description**                |\r\n| ------------- | ------------------------------ |\r\n| out = min(x); | The minimum value in matrix x. |\r\n\r\n**Example**\r\n\r\nA simple example showing how you can find the minimum of a real array.\r\n\r\n```\r\n?x=linspace(0,3,4);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\n?min(x);\r\nresult: \r\n0 \r\n```\r\n\r\nIf the array has complex numbers only the real part is considered, as shown below.\r\n\r\n```\r\n?x = 3 + 4i;\r\n?min(x);\r\n?min(abs(x));\r\nresult: \r\n3+4i \r\nresult: \r\n3 \r\nresult: \r\n5 \r\n```",
    "summary": "Returns the minimum value in a matrix",
    "syntax": [
      {
        "syntax": "out = min(x);",
        "description": "The minimum value in matrix x."
      }
    ],
    "example": "?x=linspace(0,3,4);\r\nresult: \r\n0 \r\n1 \r\n2 \r\n3 \r\n?min(x);\r\nresult: \r\n0"
  },
  {
    "name": "mod",
    "description": "Finds the modulus after division.",
    "usage": "mod();",
    "category": "general",
    "markdown": "# mod\r\n\r\nFinds the modulus after division.\r\n\r\n| **Syntax**      | **Description**                                                                                                                                                                                                |\r\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = mod(x,y); | Returns x - n\\*y where n = floor(x/y) if y is not equal to 0. The input x can be a real array or a real scalar, while y must be a real scalar. The following are true by convention: mod(x,0) = x mod(x,x) = 0 |\r\n\r\n**Example**\r\n\r\nFind the modulus of a matrix after dividing each element by a scalar:\r\n\r\n```\r\n?A=[1,2;3,4];\r\n?mod(A,2);\r\nresult: \r\n1  2  \r\n3  4  \r\nresult: \r\n1  0  \r\n1  0\r\n```",
    "summary": "Finds the modulus after division",
    "syntax": [
      {
        "syntax": "out = mod(x,y);",
        "description": "Returns x - n\\*y where n = floor(x/y) if y is not equal to 0. The input x can be a real array or a real scalar, while y must be a real scalar. The following are true by convention: mod(x,0) = x mod(x,x) = 0"
      }
    ],
    "example": "?A=[1,2;3,4];\r\n?mod(A,2);\r\nresult: \r\n1  2  \r\n3  4  \r\nresult: \r\n1  0  \r\n1  0"
  },
  {
    "name": "move",
    "description": "Moves selected objects.",
    "usage": "move();",
    "category": "general",
    "markdown": "# move\r\n\r\nMoves selected objects.\r\n\r\n| **Syntax**      | **Description**                                                         |\r\n| --------------- | ----------------------------------------------------------------------- |\r\n| move(dx);       | In 2D or 3D, move by dx                                                 |\r\n| move(dx,dy);    | In 2D or 3D, move by dx and dy. This function does not return any data. |\r\n| move(dx,dy,dz); | In 3D, move by dx, dy, and dz. In 2D, dz will be ignored.               |\r\n\r\n**Example**\r\n\r\nMoves the object named substrate 1um in the z direction.\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\nmove(0, 1e-6,0); \r\n```",
    "summary": "Moves selected objects",
    "syntax": [
      {
        "syntax": "move(dx);",
        "description": "In 2D or 3D, move by dx"
      },
      {
        "syntax": "move(dx,dy);",
        "description": "In 2D or 3D, move by dx and dy. This function does not return any data."
      },
      {
        "syntax": "move(dx,dy,dz);",
        "description": "In 3D, move by dx, dy, and dz. In 2D, dz will be ignored."
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"substrate\");\r\nselect(\"substrate\");\r\nmove(0, 1e-6,0);"
  },
  {
    "name": "mqwgain",
    "description": "The script command mqwgain calculates gain and spontaneous emission for TE and TM modes in multiple quantum well structures using the 4x4 k.p electronic band structure method [1-3]. The conduction band is parabolic, while heavy and light hole valence bands are mixed according to the 4x4 k.p method and they are nonparabolic.",
    "usage": "mqwgain();",
    "category": "general",
    "markdown": "# mqwgain\r\n\r\nThe script command mqwgain calculates gain and spontaneous emission for TE and TM modes\r\nin multiple quantum well structures using the 4x4 k.p electronic band structure method\r\n[1-3]. The conduction band is parabolic, while heavy and light hole valence bands are\r\nmixed according to the 4x4 k.p method and they are nonparabolic.\r\n\r\nThe solver includes a material database of common III-V semiconductors, ternary alloys,\r\nand quaternary alloys. Material properties may be generated automatically for arbitrary\r\nalloy compositions or may be input manually. The supported materials are listed in the\r\ntable below:\r\n\r\n| **III-V semiconductors** | **Ternary alloys** | **Quaternary Alloys** |\r\n| ------------------------ | ------------------ | --------------------- |\r\n| AlAs                     | AlxGa1-xAs         | InxGa1-xAsyP1-y       |\r\n| GaAs                     | AlxGa1-xP          | AlxGayIn1-x-yAs       |\r\n| InAs                     | AlxIn1-xP          |                       |\r\n| AlP                      | GaAsxP1-x          |                       |\r\n| GaP                      | InxAl1-xAs         |                       |\r\n| InP                      | InAsxP1-x          |                       |\r\n| InxGa1-xAs               |                    |                       |\r\n| InxGa1-xP                |                    |                       |\r\n\r\nWhen database materials are used, the properties of ternary alloys P(AxB1−xD) are\r\ninterpolated from the corresponding properties of the base materials (P(AD) and P(BD))\r\naccording to the formula\r\n\r\n$$ P\\\\left(A_x\r\nB\\_{1-x}D\\\\right)=xP\\\\left(AD\\\\right)+\\\\left(1-x\\\\right)P\\\\left(BD\\\\right)+x\\\\left(1-x\\\\right)C,\r\n$$\r\n\r\nwhere x is the composition fraction and C is the bowing parameter (quadratic\r\ncoefficient).\r\n\r\nQuaternary alloys of type AxB1-xCyD1-y (two group III and two group V elements) are\r\ncomposed from the interpolation of ternary alloy constituents \\[4\\]:\r\n\r\n$$\r\nP\\\\left(A_xB\\_{1-x}C_yD\\_{1-y}\\\\right)=\\\\frac{x\\\\left(1-x\\\\right)\\\\left[\\\\left(1-y\\\\right)P\\\\left(A_xB\\_{1-x}D\\\\right)+yP\\\\left(A_xB\\_{1-x}C\\\\right)\\\\right]+y\\\\left(1-y\\\\right)\\\\left[xP\\\\left(AC_yD\\_{1-y}\\\\right)+\\\\left(1-x\\\\right)P\\\\left(BC_yD\\_{1-y}\\\\right)\\\\right]}{x\\\\left(1-x\\\\right)+y\\\\left(1-y\\\\right)},\r\n$$\r\n\r\nfor composition fractions x and y. For example, a combination of the properties of\r\nInxGa1−xP, InxGa1−xAs, InAsyP1−y, and GaAsyP1−y is used to define the properties of\r\nInxGa1−xAsyP1−y.\r\n\r\nQuaternary alloys of type AxByC1-x-yD (three group III elements and one group V element)\r\nare composed from the interpolation of ternary alloy constituents \\[4\\]:\r\n\r\n$$\r\nP\\\\left(A_xB_yC\\_{1-x-y}D\\\\right)=\\\\frac{xyP\\\\left(A\\_{1-u}B_uD\\\\right)+y(1-x-y)P\\\\left(B\\_{1-v}C\\_{v}D\\\\right)+x(1-x-y)P\\\\left(A\\_{1-w}C\\_{w}D\\\\right)}{xy+y(1-x-y)+x(1-x-y)},\r\n$$\r\n\r\nfor composition fractions x and y and u = (1-x+y)/2, v = (2-x-2y)/2, w = (2-2x-y)/2. For\r\nexample, a combination of the properties of Al1-uGauAs, Ga1-vInvAs, and Al1-wInwAs, is\r\nused to define the properties of AlxGayIn1-x-yAs.\r\n\r\n| **Syntax**                                                         | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| result = mqwgain(stack_properties, simulation_parameters, config); | stack_properties: struct with fields that define MQW stack geometry and material properties. simulation_parameters: struct with fields that define simulation parameters for which the output will be calculated. config: struct with fields that configure the behavior of the simulation. result: struct or a cell of structs in case of multiple partitions, where each struct contains 4 datasets: spatial band diagram, band structure in (E,k) space, spatial wave functions for each (E,k) state, and emission coefficients. |\r\n| result = mqwgain(stack_properties, simulation_parameters);         | same as above, but using all default values for the fields in the config struct.                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\r\n\r\n## Stack properties\r\n\r\n**stack_properties** is a struct with the following fields:\r\n\r\n| **Field** | **Default**                                         | **Units** | **Type** | **Description**                                                                                                                                                                                                                                 |\r\n| --------- | --------------------------------------------------- | --------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| gamma     |                                                     | eV        | Scalar   | Linewidth broadening due to intraband relaxation rate. Represents full width at half maximum of a Lorentzian.                                                                                                                                   |\r\n| neff      |                                                     |           | Matrix   | Effective index vs. frequency. Two-column matrix: the first column is the frequency (Hz), and the second column is the effective index. Effective index values will be linearly interpolated onto the photon frequency grid for the simulation. |\r\n| length    |                                                     | m         | Matrix   | The thickness of each layer, Nx1 array (N layers)                                                                                                                                                                                               |\r\n| material  |                                                     |           | Cell     | Material definitions, length N cell array. See below for a description of options to specify material properties.                                                                                                                               |\r\n| strain    | 0                                                   | (a0-a)/a  | Matrix   | Strain in each layer as a fraction, negative values for compressive strain. Nx1 array (N layers).                                                                                                                                               |\r\n| vb        | Not included                                        |           | Struct   | Specification for valence band absolute energy. If not defined, then material.vb field is used by default.                                                                                                                                      |\r\n| eps       | quantum mechanical average over MQW stack materials |           | Scalar   | Relative static permittivity. Needed when exciton model is used.                                                                                                                                                                                |\r\n\r\n**stack_properties.material** is a cell array (one element per layer) where each element\r\nis a struct. The struct can be defined in 2 ways.\r\n\r\nFirst, automatically generated by calling [ buildmqwmaterial ](./buildmqwmaterial.md)\r\nscript command:\r\n\r\n| **Coefficient** | **Units** | **Description**                                                          |\r\n| --------------- | --------- | ------------------------------------------------------------------------ |\r\n| eg              | eV        | Band gap                                                                 |\r\n| ep              | eV        | Energy parameter for the optical matrix element                          |\r\n| me              | 1/m0      | Electron effective mass                                                  |\r\n| gamma1          |           | Luttinger parameter                                                      |\r\n| gamma2          |           | Luttinger parameter                                                      |\r\n| gamma3          |           | Luttinger parameter                                                      |\r\n| ac              | eV        | Conduction band deformation potential                                    |\r\n| av              | eV        | Valence band deformation potential                                       |\r\n| b               | eV        | Valence band deformation potential                                       |\r\n| c11             | N/m2      | Elastic stiffness coefficient                                            |\r\n| c12             | N/m2      | Elastic stiffness coefficient                                            |\r\n| lc              | m         | Lattice constant                                                         |\r\n| vb              | eV        | Valence band absolute energy (all layers should have a common reference) |\r\n| eps             |           | Relative static permittivity                                             |\r\n\r\nSecond, using **stack_properties.material:**\r\n\r\n| **Coefficient**   | **Type** | **Description**                                 |\r\n| ----------------- | -------- | ----------------------------------------------- |\r\n| database_material | String   | Name of the material                            |\r\n| x                 | 0        | Material composition (if ternary or quaternary) |\r\n| y                 | 0        | Material composition (if quaternary)            |\r\n\r\n## Stack properties\r\n\r\n**stack_properties.vb** is a struct with the following fields:\r\n\r\n| **Field** | **Default** | **Units** | **Type** | **Description**                                                                                                    |\r\n| --------- | ----------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------------ |\r\n| method    | palankovski |           | String   | Method for calculating valence band offsets. If “direct” is specified, the offsets must be provided (see offsets). |\r\n| offsets   |             | eV        | Matrix   | Directly specified valence band offsets, Nx1 array (N layers).                                                     |\r\n\r\n**simulation_parameters** is a struct with the following fields:\r\n\r\n| **Field**       | **Default**               | **Units** | **Type** | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\r\n| --------------- | ------------------------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| T               |                           | K         | Scalar   | Simulation temperature. This parameter is ignored when the exciton model is used and full depletion of the quantum wells is assumed (valence band full, conduction band empty).                                                                                                                                                                                                                                                                                                                                           |\r\n| V               |                           | V         | Matrix   | Electrostatic potential vs. position. A two-column matrix, with position (m) specified in the first column and potential (eV) specified in the second column. Potential values will be linearly interpolated onto the simulation grid. The first layer is assumed to start at z=0.                                                                                                                                                                                                                                        |\r\n| kt              | linspace(0,2*pi/a*0.1,51) | 1/m       | Matrix   | Transverse k values are used in the band structure calculation. When the exciton model is turned on only the number of kt points is considered, while the values are ignored and instead defined based on a special quadrature method used by the solver.                                                                                                                                                                                                                                                                 |\r\n| stackpartitions | empty matrix              |           | Matrix   | Matrix of size (number of partitions) x 2, where each row represents the start and end layer index for one partition using 1-based indexing. Start and end layers should be barriers. For example, [1,3;3,5] represents two partitions where the first partition contains layers (1,2,3) and the second partition contains layers (3,4,5), where layers 1, 3, and 5 represent barriers.                                                                                                                                   |\r\n| cden            |                           | 1/m3      | Matrix   | Carrier density array. Matrix of size (number of partitions) x (number of different density profiles). If there is more than one partition this enables defining spatially dependent density, where each partition has a different density. If there is no partitioning, each density profile is a scalar representing the average density over the entire stack. This parameter is ignored when the exciton model is used and full depletion of the quantum wells is assumed (valence band full, conduction band empty). |\r\n| phfreq          |                           | Hz        | Matrix   | Photon frequency array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n\r\n**config** is a struct with the following fields:\r\n\r\n| **Field**          | **Default** | **Units** | **Type**         | **Description**                                                                                                                                                                                                                                                                          |\r\n| ------------------ | ----------- | --------- | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| bcs                | See below   | See below | Struct           | Boundary conditions struct.                                                                                                                                                                                                                                                              |\r\n| dz                 | 1e-10       | m         | Scalar           | Grid spacing ≥ 1Å.                                                                                                                                                                                                                                                                       |\r\n| numeigenvalues     | 30          |           | Scalar           | The maximum number of bands to calculate by the eigensolver at each kt.                                                                                                                                                                                                                  |\r\n| numqwsubbandsCB    | 2           |           | Scalar           | The maximum number of conduction subbands to use for exciton mixing. Increasing this value results in a more accurate but longer simulation. In general, around 2-4 subbands per coupled well should be used.                                                                            |\r\n| numqwsubbandsVB    | 2           |           | Scalar           | The maximum number of valence subbands to use for exciton mixing. Increasing this value results in a more accurate but longer simulation. This does not include spin, so the actual number of subbands is 2x this value. Generally, around 2-4 subbands per coupled well should be used. |\r\n| numqwsubbands      | 2           |           | Scalar           | The maximum number of subbands (both conduction and valence) to use for exciton mixing. (This field is deprecated. Recommend using numqwsubbandsCB/VB instead.)                                                                                                                          |\r\n| materialdb         |             |           | String or struct | A string specifying the path to the material database or empty struct for the default database.                                                                                                                                                                                          |\r\n| cbvalley           | Gamma       |           | String           | Choose the conduction band valley for interpolation of material properties: “Gamma”, “X”, “L”, or “All” (default is “Gamma”; option “All” uses the lowest band gap to select).                                                                                                           |\r\n| reusebandstructure | false       |           | Boolean          | If there is partitioning and this option is true, the MQW band structure calculated in the first partition will be reused in all other partitions, reducing simulation time. This is a good approximation whenever partitions have a similar band diagram (up to a constant shift).      |\r\n| exciton            | false       |           | Boolean          | Turns on exciton model.                                                                                                                                                                                                                                                                  |\r\n| wfthetadependence  | false       |           | Boolean          | Turns on the angular dependence of the exciton wave function in the plane of quantum wells.                                                                                                                                                                                              |\r\n\r\n**config.bcs** is a struct with the following fields:\r\n\r\n| **Field**      | **Default**                                   | **Units**        | **Type** | **Description**                                                                                                                                                                                                                                                                            |\r\n| -------------- | --------------------------------------------- | ---------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| pmlactive      | false                                         |                  | Boolean  | Enable perfectly matched layer at boundaries.                                                                                                                                                                                                                                              |\r\n| pmlcutoff      | [1e-2,1e-2]                                   |                  | Matrix   | Threshold ratio (PML probability density)/(MQW probability density), one for conduction and one for valence bands, to reject eigenstates with excess conduction and valence band probability densities located in the PMLs, 2x1 array. The QW bound states are those below this threshold. |\r\n| pmllength      | [10e-9,10e-9]                                 | m                | Matrix   | PML thickness for left and right boundaries, 2x1 array.                                                                                                                                                                                                                                    |\r\n| pmlcoefficient | \\[0.5+1i*0.5,0.5+1i*0.5,-1+1i*1.4,-1+1i*1.4\\] |                  | Matrix   | PML complex coordinate stretching coefficients. First two elements are for left and right PML for the conduction band and the other two for the valence band.                                                                                                                              |\r\n| hwcutoff       | [5e-4,5e-4]                                   | \\\\( A^{-3/2} \\\\) | Matrix   | Threshold wave function slope, one for conduction and one for valence bands, to reject eigenstates that do not decay enough at the left and right hard-wall boundaries, 2x1 array. The QW bound states are those below this threshold.                                                     |\r\n\r\n**result** is a cell of structs for each partition if there is partitioning, or a struct\r\nif there is no partitioning, where structs contain the following fields:\r\n\r\n| **Syntax**    | **Type** | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| ------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| banddiagram   | dataset  | Conduction and valence band edge including strain, but not including quantum confinement effects (i.e. subbands).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| bandstructure | dataset  | (E,kt) band diagram for conduction and valence bands. With the exciton model turned off the attributes are: conduction_band, valence_band_lo, and valence_band_up, where the 4x4 k.p basis in the valence band is transformed into two 2x2 bases (lo for lower and up for upper). For more information look at references [1] and [2]. With the exciton model turned on the attributes are: conduction_band, valence_band, with the 4x4 k.p basis in the valence band (the basis is not transformed). Parameters are kt and subband.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| wavefunction  | dataset  | Spatial wavefunction for each (E,kt) point. With the exciton model turned on the attributes are: conduction_band_1, valence_band_lo_1, valence_band_lo_2, valence_band_up_1, valence_band_up_2, where the 4x4 k.p basis in the valence band is split into two 2x2 bases (lo for lower and up for upper) and the vectors in each 2x2 basis are designated with 1 and 2. For more information look at references [1] and [2]. With the exciton model turned on the attributes are: conduction_band_1, valence_band_1, valence_band_2, valence_band_3, valence_band_4, with the 4x4 k.p basis in the valence band (the basis is not transformed) and the vectors in the 4x4 basis designated with 1, 2, 3, and 4. Parameters are coordinate, kt, and subband.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| ome           | dataset  | Optical matrix element. With excitons turned off: Magnitude squared of the momentum matrix element divided by the free electron mass. In the units of \\\\(eV\\\\). Attributes are ome_lo_TE, ome_lo_TM, ome_up_TE, ome_up_TM, where TE and TM designate optical modes and up and lo refer to the 2x2 bases, same as for the bandstructure and wavefunction. Parameters are kt (transverse wave vector), CBsubband (conduction band subband index) and VBsubband (valence band subband index). With excitons turned on: Oscillator strength per unit area in the units of \\\\(1/nm^2\\\\). Attributes are ome_TE and ome_TM where TE and TM designate optical modes. Parameters are the exciton orbital quantum number (orbital) and angular momentum quantum number (angularMomentum).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\r\n| emission      | dataset  | Gain and spontaneous emission coefficients in the units of [1/m]. Attributes are: spontaneous_TE, spontaneous_TM, stimulated_TE, stimulated_TM, where TE and TM stand for electromagnetic modes. Parameters are: frequency/energy/wavelength and ndensity (charge density). Emission coefficients are calculated for the total stack thickness, including barriers. If only the quantum well thickness is of interest, excluding barriers, these coefficients should be scaled by multiplying with (total length)/(total QW length). It is important to ensure that emission coefficients apply only to the thickness used for the calculation of the mode overlap with the gain region. When using partitioning, there will be overlapping barriers between different partitions, e.g. simulation_parameters.stackpartitions = [1,3;3,5], where 1, 3, and 5 are barriers. In that case emission coefficients for each partition again apply to the total thickness of that partition, meaning there may be some double-counting with respect to the mode overlap region thickness. To avoid this, emission coefficients can be scaled to apply to quantum wells only, or to apply to a portion of the partition that does not overlap with adjacent partitions. When the exciton model is turned on the attributes become: absorption_TE, absorption_TM. These represent the absorption coefficients (negative gain) in the units of [1/m]. The spontaneous emission is not calculated due to the assumption of the depleted carrier density in the quantum wells. |\r\n| ex            | dataset  | Exciton energies Ex. Exciton energies are a function of exciton orbital quantum number (orbital) and angular momentum quantum number (angularMomentum).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| phix          | dataset  | Exciton wavefunctions PhiX in the momentum (in-plane wavevector) space. The wave function coefficients are parametrized in terms of conduction band subband index (cSubband), valence band subband index (vSubband), transverse wave vector (kt), and angular momentum quantum number (angularMomentum), and orbital quantum number (orbital).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\r\n\r\n## Material Definitions\r\n\r\nMaterial parameters are important for the accurate calculation of the MQW band structure\r\nand emission characteristics. Many parameters are used to model the optical and\r\nelectronic material behavior. Some parameters for alloys of compound semiconductors are\r\nnot available from experiments and must be generated from interpolation of known values.\r\nExperimental results may depend on growth conditions and layer thickness, and adjustment\r\nof some material parameters may be necessary to obtain agreement with measurements.\r\n\r\nLumerical provides a default material database with the MQW gain solver. These\r\nparameters are used automatically when the layer materials are defined by a name and\r\ncomposition fraction. The following code sets the material in layer 2 as Al 0.41 Ga 0.59\r\nAs\r\n\r\n```\r\nmaterials = cell(3); \r\n#... \r\nmaterials{2} = struct; \r\nmaterials{2}.database_material = \"AlGaAs\"; \r\nmaterials{2}.x = 0.41; \r\n```\r\n\r\nYou can also choose to use your own material database (in the same format) instead of\r\nthe default material database supplied by Lumerical. By specifying the path of that\r\ndatabase in the simulation configuration struct, you can instruct the solver to use\r\nthose material definitions, e.g.\r\n\r\n```\r\nconfig.materialdb = \"/home/auser/myfolder/my_material_db.json\"; \r\n```\r\n\r\nUsing this approach, the material parameters of the compound semiconductors can be\r\nmodified, but the default interpolation used by the solver will still be applied to\r\ngenerate parameters for ternary and quaternary semiconductors. The assignment of\r\nmaterials to layers does not change.\r\n\r\nAlternately, a material definition can be read directly from a material database\r\n(default or custom) and loaded as a struct into the script workspace using the\r\n[buildmqwmaterial ](./buildmqwmaterial.md) command. For example,\r\n\r\n```\r\nmymat = buildmqwmaterial(\"/home/auser/myfolder/my_material_db.json\", 300, \"InAlAs\", 0.47);  \r\n```\r\n\r\nwill read the necessary properties from the material database and build a material\r\ndefinition at T=300K with composition fraction x=0.47 for In 0.47 Al 0.53 As. The result\r\nis a structure with the coefficients required by the MQW solver. A struct with these\r\nfields can be assigned to a material layer and used directly by the solver, e.g.\r\n\r\n```\r\nmaterials = cell(3); \r\n#... \r\nmaterials{2} = buildmqwmaterial(\"/home/auser/myfolder/my_material_db.json\", 300, \"InAlAs\", 0.47);\r\n```\r\n\r\n### References\r\n\r\n[1] D. Ahn et al., J. Appl. Phys. 64, 4056 (1988)\r\n\r\n[2] S. L. Chuang, Physics of Optoelectronic Devices\r\n\r\n[3] Chuang, Phys. Rev. B, 43, 9649 (1991)\r\n\r\n[4] Vurgaftman et al., J. Appl. Phys., 89, 5815 (2001)\r\n\r\n[5] C. Y.-P. Chao et al., Phys. Rev. B, 48, 8210 (1993)",
    "summary": "The script command mqwgain calculates gain and spontaneous emission for TE and TM modes in multiple ...",
    "syntax": [
      {
        "syntax": "AlAs",
        "description": "AlxGa1-xAs"
      },
      {
        "syntax": "GaAs",
        "description": "AlxGa1-xP"
      },
      {
        "syntax": "InAs",
        "description": "AlxIn1-xP"
      },
      {
        "syntax": "AlP",
        "description": "GaAsxP1-x"
      },
      {
        "syntax": "GaP",
        "description": "InxAl1-xAs"
      },
      {
        "syntax": "InP",
        "description": "InAsxP1-x"
      }
    ],
    "example": ""
  },
  {
    "name": "mult",
    "description": "Performs matrix multiplication of two or more matrices. The dimensions of the matrices have to match.",
    "usage": "mult();",
    "category": "general",
    "markdown": "# mult\r\n\r\nPerforms matrix multiplication of two or more matrices. The dimensions of the matrices\r\nhave to match.\r\n\r\n| **Syntax**          | **Description**                                                                                                                                                                     |\r\n| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = mult(A,B,...) | Returns the matrix multiplication of matrices A, B, C ... Dimension of matrices must match; for example, if A is an MxN matrix and B is a NXP matrix, mult(A,B) has dimensions MxP. |\r\n\r\n**Example**\r\n\r\nFind the matrix product of two matrices.\r\n\r\n```\r\nA = [ 1, 2; 2, 4];\r\nB = [ 2, 5; -1, 3];\r\n?mult(A,B);\r\nresult: \r\n0 11 \r\n0 22 \r\n?mult(A,B,[1;2]);\r\nresult: \r\n22 \r\n44\r\n```",
    "summary": "Performs matrix multiplication of two or more matrices",
    "syntax": [
      {
        "syntax": "out = mult(A,B,...)",
        "description": "Returns the matrix multiplication of matrices A, B, C ... Dimension of matrices must match; for example, if A is an MxN matrix and B is a NXP matrix, mult(A,B) has dimensions MxP."
      }
    ],
    "example": "A = [ 1, 2; 2, 4];\r\nB = [ 2, 5; -1, 3];\r\n?mult(A,B);\r\nresult: \r\n0 11 \r\n0 22 \r\n?mult(A,B,[1;2]);\r\nresult: \r\n22 \r\n44"
  },
  {
    "name": "mv",
    "description": "Moves a file to a new location. Path can be specified.",
    "usage": "mv();",
    "category": "general",
    "markdown": "# mv\r\n\r\nMoves a file to a new location. Path can be specified.\r\n\r\n| **Syntax**                         | **Description**                                               |\r\n| ---------------------------------- | ------------------------------------------------------------- |\r\n| mv(\"file1\",\"file2\");               | Moves file1 to file2. This function does not return any data. |\r\n| mv(\"path1\\\\file1\",\"path2\\\\file2\"); | Moves file1 in path1 to file2 in path2.                       |\r\n\r\n**Note** : This command cannot be used while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Examples**\r\n\r\nMoves \"myscript.lsf\" to c:\\\\working and renames it \"temp.lsf\".\r\n\r\n```\r\nmv(\"c:\\myscript.lsf\",\"c:\\working\\temp.lsf\");\r\n```",
    "summary": "Moves a file to a new location",
    "syntax": [
      {
        "syntax": "mv(\"file1\",\"file2\");",
        "description": "Moves file1 to file2. This function does not return any data."
      },
      {
        "syntax": "mv(\"path1\\\\file1\",\"path2\\\\file2\");",
        "description": "Moves file1 in path1 to file2 in path2."
      }
    ],
    "example": ""
  },
  {
    "name": "near2far",
    "description": "Calculates the far field at the specified points using the provided near field monitor data.",
    "usage": "near2far();",
    "category": "general",
    "markdown": "# near2far\r\n\r\nCalculates the far field at the specified points using the provided near field monitor\r\ndata.\r\n\r\n| **Syntax**                              | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = near2far(nearfield, farfield, n); | Calculates the far field using the provided near field monitor data at the specified far field points. The input unstructured data set specifying the near fields must contain an attribute named 'E' parametrized by frequency. The output is an unstructured data set with an attribute named 'E' containing the far field. The far field frequencies are determined by the near field frequencies while the far field points, connectivity matrix and surface normals associated with the output data set are taken from the unstructured data set specifying the far field points. |\r\n\r\n| **Parameter** |          | **Default value** | **Type**              | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| ------------- | -------- | ----------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| nearfield     | required |                   | unstructured data set | Near field data in the format returned by DFT monitors. The electric field can be sampled on a segmented line or on a triangulated surface. If sampled on a segmented line, the electric field is assumed to come from a 2D simulation and the 2D integral kernel is used for the far field projection. Similarly, if the electric field is sampled on a triangulated surface, it is assumed to come from a 3D simulation and the 3D integral kernel is used for the projection (see the provided reference). |\r\n| farfield      | required |                   | unstructured data set | Far field points to be used in the projection. If the near fields are sampled on segmented line, the far field points must be specified using a segmented line. Similarly, if the near fields are sampled on a triangulated surface, the far field points must be sampled on a triangulated surface. The command createsphericalsurface can be used to easily create an unstructured data set with a segmented line or a triangulated surface.                                                                |\r\n| n             | optional | 1.0               | number or vector      | Background refractive index of the far field medium. It can be a single number or a vector with the same length as the near field frequency parameter.                                                                                                                                                                                                                                                                                                                                                        |\r\n\r\n## Note: Far field integration For integration of far field over a range of angles, the script command quadtri can be used. See [ quadtri ](./quadtri.md) for more information.\r\n\r\n**Example**\r\n\r\nThis example performs a far field projection on a sphere using the near field data\r\ncollected from a monitor named \"monitor\".\r\n\r\n```\r\nsurf = createsphericalsurface;\r\nE_near = getresult(\"DGTD::monitor\",\"fields\");\r\nE_far = near2far(E_near,surf);\r\nvisualize(E_far); \r\n```\r\n\r\nFor more information on how far field projections are computed please refer to:\r\n\r\nJohn B. Schneider, Understanding the Finite-Difference Time-Domain Method, Chapter 14:\r\nNear-to-Far-Field Transformation, 2010 Available at:\r\n[ http://www.eecs.wsu.edu/~schneidj/ufdtd/ ](http://www.eecs.wsu.edu/~schneidj/ufdtd/)",
    "summary": "Calculates the far field at the specified points using the provided near field monitor data",
    "syntax": [
      {
        "syntax": "out = near2far(nearfield, farfield, n);",
        "description": "Calculates the far field using the provided near field monitor data at the specified far field points. The input unstructured data set specifying the near fields must contain an attribute named 'E' parametrized by frequency. The output is an unstructured data set with an attribute named 'E' containing the far field. The far field frequencies are determined by the near field frequencies while the far field points, connectivity matrix and surface normals associated with the output data set are taken from the unstructured data set specifying the far field points."
      }
    ],
    "example": "surf = createsphericalsurface;\r\nE_near = getresult(\"DGTD::monitor\",\"fields\");\r\nE_far = near2far(E_near,surf);\r\nvisualize(E_far);"
  },
  {
    "name": "new",
    "description": "Same as newproject. It creates a new simulation project file. If there is an existing project file in the GUI, the old project file will not be saved.",
    "usage": "new();",
    "category": "general",
    "markdown": "# new\r\n\r\nSame as newproject. It creates a new simulation project file. If there is an existing\r\nproject file in the GUI, the old project file will not be saved.\r\n\r\n| **Syntax** | **Description**             |\r\n| ---------- | --------------------------- |\r\n| new;       | Creates a new project file. |\r\n\r\n**Examples**\r\n\r\nCreates a new project with the newcommand.\r\n\r\n```\r\nnew;\r\n```",
    "summary": "Same as newproject",
    "syntax": [
      {
        "syntax": "new;",
        "description": "Creates a new project file."
      }
    ],
    "example": ""
  },
  {
    "name": "newproject",
    "description": "Creates a new simulation project file. If there is an existing project file in the GUI, the old project file will not be saved.",
    "usage": "newproject();",
    "category": "general",
    "markdown": "# newproject\r\n\r\nCreates a new simulation project file. If there is an existing project file in the GUI,\r\nthe old project file will not be saved.\r\n\r\n| **Syntax**  | **Description**                                                           |\r\n| ----------- | ------------------------------------------------------------------------- |\r\n| newproject; | Creates a new layout environment. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nCreates a new project with the newproject command.\r\n\r\n```\r\nnewproject;\r\n```\r\n\r\nHowever, for FDTD and MODE, users can have more choices:\r\n\r\nFor MODE, it can have numerical variables:\r\n\r\n| **Syntax**          | **Description** |\r\n| ------------------- | --------------- |\r\n| newproject(option); | The options are |\r\n\r\n1. use default file and material database as template\r\n1. use current file and material database as template\r\n1. open a file browser to select and existing file as a template\r\n\r\nThe default option is 1.\r\n\r\n**Examples**\r\n\r\nCreates a new project with the newproject command.\r\n\r\n```\r\nnewproject; \r\nnewproject(2); # open a template using current file and material database\r\n```\r\n\r\nFor FDTD, the variables can be either numerical, or string:\r\n\r\n| **Syntax**          | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\r\n| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| newproject(option); | The options can be number or string: 1 or 'default': use default file and material database as template 2 or 'RF': use default RF template 3 or 'current': use current file and material database as template 4 or 'existing': open a file browser to select and existing file as a template The default option is 1. Since most material data in the Material Database is for optical frequencies, open a RF project will not modify the original material data in the material database. |\r\n\r\n**Examples**\r\n\r\nCreates a new project with the newproject command.\r\n\r\n```\r\nnewproject; # open a template for optical frequency simulation \r\nnewproject('RF');# open a template for RF simulation \r\nnewproject(2); # open a template for RF simulation\r\n```",
    "summary": "Creates a new simulation project file",
    "syntax": [
      {
        "syntax": "newproject;",
        "description": "Creates a new layout environment. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "newwizard",
    "description": "Used to create a new user defined wizard. Opens a new wizard window.",
    "usage": "newwizard();",
    "category": "general",
    "markdown": "# newwizard\r\n\r\nUsed to create a new user defined wizard. Opens a new wizard window.\r\n\r\n| **Syntax**                 | **Description** |\r\n| -------------------------- | --------------- |\r\n| newwizard( w, h, \"title\"); |                 |\r\n\r\n- w and h (width and height) are specified in pixels. The minimum values for w and h are\r\n  200\\.\r\n- title is the wizard window title.\r\n\r\n**Examples**\r\n\r\nIn this example we will make a widget that will make 4 power monitors in the shape of a\r\nsquare to encase a 2D simulation. Create a new script file and add the following code to\r\nit:\r\n\r\n```\r\n#open the new wizard\r\nnewwizard(300,200,\"Power Box Wizard\");\r\nwizardoption(\"fontsize\",12);\r\nwizardoption(\"fieldwidth\",150);\r\nwizardoption(\"fieldheight\",20);\r\nwizardoption(\"margin\",20);\r\nnewwizardpage(\"Go\");\r\nwizardwidget(\"label\",endl+\"Choose the dimensions in for the Power Box\"+endl);\r\nwizardoption(\"margin\",50);\r\nwizardwidget(\"number\",\"x min (um):\");\r\nwizardwidget(\"number\",\"x max (um):\");\r\nwizardwidget(\"number\",\"y min (um):\");\r\nwizardwidget(\"number\",\"y max (um):\");\r\n# get the user set dimensions\r\nout = runwizard;\r\nxmin=wizardgetdata(1)*1e-6;\r\nxmax=wizardgetdata(2)*1e-6;\r\nymin=wizardgetdata(3)*1e-6;\r\nymax=wizardgetdata(4)*1e-6;\r\nkillwizard;\r\n### break if the user cancelled\r\nif(out==0) {\r\n?\"User cancelled\";\r\nbreak;\r\n}\r\n#if the user pressed \"Go\", add the monitor box\r\nmonitors;\r\naddpower;\r\nset(\"monitor type\",\"Linear X\");\r\nset(\"name\",\"x1\");\r\nset(\"x\",(xmax+xmin)/2);\r\nset(\"y\",ymin);\r\nset(\"x span\",xmax-xmin);\r\ncopy;\r\nset(\"name\",\"x2\");\r\nset(\"x\",(xmax+xmin)/2);\r\nset(\"y\",ymax);\r\naddpower;\r\nset(\"name\",\"y1\");\r\nset(\"monitor type\",\"Linear Y\");\r\nset(\"y\",(ymax+ymin)/2);\r\nset(\"x\",xmin);\r\nset(\"y span\",ymax-ymin);\r\ncopy;\r\nset(\"name\",\"y2\");\r\nset(\"y\",(ymax+ymin)/2);\r\nset(\"x\",xmax);  \r\n```",
    "summary": "Used to create a new user defined wizard",
    "syntax": [],
    "example": ""
  },
  {
    "name": "newwizardpage",
    "description": "This creates a page for the wizard and should be done before adding any widgets.",
    "usage": "newwizardpage();",
    "category": "general",
    "markdown": "# newwizardpage\r\n\r\nThis creates a page for the wizard and should be done before adding any widgets.\r\n\r\n| **Syntax**                          | **Description**                                                                                                        |\r\n| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |\r\n| newwizardpage( \"label1\");           | Creates a button with the label \"label1\". Typically, this will be \"Done\" or \"OK\".                                      |\r\n| newwizardpage( \"label1\", \"label2\"); | Creates two buttons with labels \"label1\" and \"label2\". These will typically be \"Next\" and \"Back\" or \"Done\" and \"Back\". |\r\n\r\n**Examples**\r\n\r\nSee the newwizard page for an example.",
    "summary": "This creates a page for the wizard and should be done before adding any widgets",
    "syntax": [
      {
        "syntax": "newwizardpage( \"label1\");",
        "description": "Creates a button with the label \"label1\". Typically, this will be \"Done\" or \"OK\"."
      },
      {
        "syntax": "newwizardpage( \"label1\", \"label2\");",
        "description": "Creates two buttons with labels \"label1\" and \"label2\". These will typically be \"Next\" and \"Back\" or \"Done\" and \"Back\"."
      }
    ],
    "example": ""
  },
  {
    "name": "nonorm",
    "description": "Does not normalize the data to the source power. The actual field intensities will be used in all calculations. This function controls the checkbox located in Settings - Normalization state. Note, this command works in both the Layout and Analysis mode.",
    "usage": "nonorm();",
    "category": "general",
    "markdown": "# nonorm\r\n\r\nDoes not normalize the data to the source power. The actual field intensities will be\r\nused in all calculations. This function controls the checkbox located in Settings -\r\nNormalization state. Note, this command works in both the Layout and Analysis mode.\r\n\r\n| **Syntax** | **Description**                                               |\r\n| ---------- | ------------------------------------------------------------- |\r\n| nonorm;    | Use no normalization. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThis example shows how to switch to the nonorm state.\r\n\r\n```\r\nnonorm;\r\n```",
    "summary": "Does not normalize the data to the source power",
    "syntax": [
      {
        "syntax": "nonorm;",
        "description": "Use no normalization. This function does not return any data."
      }
    ],
    "example": "nonorm;"
  },
  {
    "name": "norm",
    "description": "Returns the natural norm of a matrix induced by the L2-norm (spectral norm). For a matrix A this is the square root of the maximum eigenvalue of the matrix product A H A, where A H is the conjugate transpose of A.",
    "usage": "norm();",
    "category": "general",
    "markdown": "# norm\r\n\r\nReturns the natural norm of a matrix induced by the L2-norm (spectral norm). For a\r\nmatrix A this is the square root of the maximum eigenvalue of the matrix product A H A,\r\nwhere A H is the conjugate transpose of A.\r\n\r\nNote that for a N-dimensional complex vector x = [x 1 ,x 2 ,...,x N ] this reduces to\r\nthe usual norm:\r\n\r\n$$ |x|=\\\\sqrt{\\\\sum\\_{i=1}^{N} x\\_{i}^{\\*}\r\nx\\_{i}}=\\\\sqrt{\\\\sum\\_{i=1}^{N}\\\\left|x\\_{i}\\\\right|^{2}} $$\r\n\r\n| **Syntax**     | **Description**                            |\r\n| -------------- | ------------------------------------------ |\r\n| out = norm(y); | Returns the spectral norm of the matrix y. |\r\n\r\n**Example**\r\n\r\nFind the usual norm of real and complex vectors.\r\n\r\n```\r\ny1=[1,2,3];\r\ny2=[1+1i,2,3]; #y2 has complex elements\r\n?norm(y1);\r\n?norm(y2);\r\nresult: \r\n3.74166  \r\nresult: \r\n3.87298  \r\n# Confirm the results with the usual definition:\r\n?sqrt(sum(conj(y1)*y1));\r\n?sqrt(sum(conj(y2)*y2));\r\nresult: \r\n3.74166  \r\nresult: \r\n3.87298+0i  \r\n```\r\n\r\nFind the usual norm of a complex matrix.\r\n\r\n```\r\nA=[1,2+7i,3;7+3i,0,9];\r\n?norm(A);\r\n?sqrt(max(eig(mult(ctranspose(A),A)))); # confirm the result using the definition\r\nresult: \r\n12.332  \r\nresult: \r\n12.332  \r\n```",
    "summary": "Returns the natural norm of a matrix induced by the L2-norm (spectral norm)",
    "syntax": [
      {
        "syntax": "out = norm(y);",
        "description": "Returns the spectral norm of the matrix y."
      }
    ],
    "example": "y1=[1,2,3];\r\ny2=[1+1i,2,3]; #y2 has complex elements\r\n?norm(y1);\r\n?norm(y2);\r\nresult: \r\n3.74166  \r\nresult: \r\n3.87298  \r\n# Confirm the results with the usual definition:\r\n?sqrt(sum(conj(y1)*y1));\r\n?sqrt(sum(conj(y2)*y2));\r\nresult: \r\n3.74166  \r\nresult: \r\n3.87298+0i"
  },
  {
    "name": "normpdf",
    "description": "Evaluates the normal (Gaussian) probability density function (PDF) for real-valued argument x",
    "usage": "normpdf();",
    "category": "general",
    "markdown": "# normpdf\r\n\r\nEvaluates the normal (Gaussian) probability density function (PDF) for real-valued\r\nargument x\r\n\r\n$$ f(x)=\\\\frac{1}{\\\\sqrt{2\\\\pi \\\\sigma^{2}}}e^{-\\\\frac{(x-\\\\mu)^{2}}{2\\\\sigma^{2}}} $$\r\n\r\nwhere µ is the mean and σ is the standard deviation. By default, μ=0 and σ=1.\r\n\r\n| **Syntax**              | **Description**                                                                                                                             |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f = normpdf(x)          | Returns the normal (Gaussian) probability density function (PDF) for real-valued argument x. By default, μ=0 and σ=1                        |\r\n| f = normpdf(x,mu,sigma) | Returns the normal (Gaussian) probability density function (PDF) for real-valued argument x. µ is the mean and σ is the standard deviation. |",
    "summary": "Evaluates the normal (Gaussian) probability density function (PDF) for real-valued argument x",
    "syntax": [
      {
        "syntax": "f = normpdf(x)",
        "description": "Returns the normal (Gaussian) probability density function (PDF) for real-valued argument x. By default, μ=0 and σ=1"
      },
      {
        "syntax": "f = normpdf(x,mu,sigma)",
        "description": "Returns the normal (Gaussian) probability density function (PDF) for real-valued argument x. µ is the mean and σ is the standard deviation."
      }
    ],
    "example": ""
  },
  {
    "name": "now",
    "description": "Display the Unix time",
    "usage": "now();",
    "category": "general",
    "markdown": "# now\r\n\r\nDisplay the Unix time\r\n\r\n| **Syntax** | **Description**                |\r\n| ---------- | ------------------------------ |\r\n| ?now;      | Displays the current UNIX time |\r\n\r\n### Example\r\n\r\n```\r\n?now;\r\nresult:\r\n1494022382266\r\n```\r\n\r\nGet the simulation job runtime\r\n\r\n```\r\nload(\"simulationfile\");  \r\nswitchtolayout;  \r\nct1=now;  \r\nrun;  \r\nct2=now;  \r\nctmin=(ct2-ct1)/1000/60;  \r\nctsec=(ct2-ct1)/1000/60*60;  \r\n?\"CPU runtime: \"+ num2str(ctmin) +\" min\";  \r\n?\"CPU runtime: \"+ num2str(ctsec) +\" sec\";\r\n```\r\n",
    "summary": "Display the Unix time",
    "syntax": [
      {
        "syntax": "?now;",
        "description": "Displays the current UNIX time"
      }
    ],
    "example": ""
  },
  {
    "name": "num2str",
    "description": "Converts an integer, floating point number, or matrix into a string. Matrices can only be 1D or 2D. Users can use the format script command to change the precision of the output or since the 2019b r6 releases, users can specify the format by providing a second argument to the command.",
    "usage": "num2str();",
    "category": "general",
    "markdown": "# num2str\r\n\r\nConverts an integer, floating point number, or matrix into a string. Matrices can only\r\nbe 1D or 2D. Users can use the format script command to change the precision of the\r\noutput or since the 2019b r6 releases, users can specify the format by providing a\r\nsecond argument to the command.\r\n\r\n| **Syntax**                                                                                                                                                                                                                                                     | **Description**                                                                                                                                        |\r\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = num2str(x);                                                                                                                                                                                                                                              | Converts the number x into a string. x can also be a 1D or 2D matrix. The tab character (rather than space) will be used as delimiter between columns. |\r\n| out = num2str(x, format);                                                                                                                                                                                                                                      | Converts the number x into a string. x can also be a 1D or 2D matrix. The format type options include:                                                 |\r\n| **integers** :                                                                                                                                                                                                                                                 |                                                                                                                                                        |\r\n| %u: unsigned integer, takes the absolute value of the input                                                                                                                                                                                                    |                                                                                                                                                        |\r\n| %d: decimal signed integer, rounds the input                                                                                                                                                                                                                   |                                                                                                                                                        |\r\n| %i: decimal signed integer, rounds the input                                                                                                                                                                                                                   |                                                                                                                                                        |\r\n| **floating point** :                                                                                                                                                                                                                                           |                                                                                                                                                        |\r\n| %f: double                                                                                                                                                                                                                                                     |                                                                                                                                                        |\r\n| %g: double                                                                                                                                                                                                                                                     |                                                                                                                                                        |\r\n| %G: double, capital 'E' used for the exponential notation                                                                                                                                                                                                      |                                                                                                                                                        |\r\n| **exponential** :                                                                                                                                                                                                                                              |                                                                                                                                                        |\r\n| %e: double                                                                                                                                                                                                                                                     |                                                                                                                                                        |\r\n| %E: double, capital 'E' used for the exponential notation With the above format type options, both width and precision can be defined for the conversion. Boost formatting can also be used. These flags appear directly after the \"%\" in the format argument: |                                                                                                                                                        |\r\n| **flags** :                                                                                                                                                                                                                                                    |                                                                                                                                                        |\r\n| +: shows sign for all numbers                                                                                                                                                                                                                                  |                                                                                                                                                        |\r\n| 0: pad to full width with leading zero                                                                                                                                                                                                                         |                                                                                                                                                        |\r\n\r\n**Example**\r\n\r\nConvert the number pi into a string.\r\n\r\n```\r\nformat long;\r\n?num2str(pi);\r\n3.141592653589793\r\n```\r\n\r\nConvert a 2D matrix into a string and write to a text file.\r\n\r\n```\r\nX=meshgridx(1:2,1:3);\r\n?num2str(X);\r\nwrite(\"filename.txt\",num2str(X));> 1 1 1> 2 2 2\r\n```\r\n\r\nConvert the number pi into a string formatted as an integer with a minimum width of 4\r\ncharacters.\r\n\r\n```\r\n?num2str(pi, \"%4d\");  \r\nWarning: prompt line 1: Double values rounded to integers  \r\n> 3\r\n```\r\n\r\nConvert the number pi into a string formatted as a floating-point number with 3 digits\r\nafter the decimal place.\r\n\r\n```\r\n?num2str(pi, \"%.3f\");3.142\r\n```\r\n\r\nConvert the number pi into a string with a minimum width of 8 characters and 3\r\ncharacters after the decimal place.\r\n\r\n```\r\n?num2str(pi, \"%8.3f\"); 3.142\r\n```\r\n\r\nConvert the number pi into a string with a minimum width of 8 characters and 3\r\ncharacters after the decimal place, and pad the full width with leading 0s.\r\n\r\n```\r\n?num2str(pi, \"%08.3f\");0003.142\r\n```\r\n\r\nConvert the number 4\\*pi into a string with exponential notation and 4 decimal points.\r\n\r\n```\r\n?num2str(4*pi, \"%.4e\");1.2566e+01\r\n```",
    "summary": "Converts an integer, floating point number, or matrix into a string",
    "syntax": [
      {
        "syntax": "out = num2str(x);",
        "description": "Converts the number x into a string. x can also be a 1D or 2D matrix. The tab character (rather than space) will be used as delimiter between columns."
      },
      {
        "syntax": "out = num2str(x, format);",
        "description": "Converts the number x into a string. x can also be a 1D or 2D matrix. The format type options include:"
      }
    ],
    "example": "format long;\r\n?num2str(pi);\r\n3.141592653589793"
  },
  {
    "name": "nummodes",
    "description": "Returns the number of eigenmodes found in the FDE solver mode list.",
    "usage": "nummodes();",
    "category": "general",
    "markdown": "# nummodes\r\n\r\nReturns the number of eigenmodes found in the FDE solver mode list.\r\n\r\n| **Syntax**  | **Description**                               |\r\n| ----------- | --------------------------------------------- |\r\n| n=nummodes; | n will be equal to the number of modes found. |",
    "summary": "Returns the number of eigenmodes found in the FDE solver mode list",
    "syntax": [
      {
        "syntax": "n=nummodes;",
        "description": "n will be equal to the number of modes found."
      }
    ],
    "example": ""
  },
  {
    "name": "ones",
    "description": "Initialize a matrix. All elements are set to one.",
    "usage": "ones();",
    "category": "general",
    "markdown": "# ones\r\n\r\nInitialize a matrix. All elements are set to one.\r\n\r\n| **Syntax**            | **Description**                         |\r\n| --------------------- | --------------------------------------- |\r\n| x = ones(i,j,k,....); | Initializes an i x j x k x .... matrix. |\r\n\r\n**Examples**\r\n\r\n```\r\n?x=ones(2,2,2);\r\nresult(i,j,1):\r\n1 1 \r\n1 1 \r\nresult(i,j,2):\r\n1 1 \r\n1 1 \r\n```",
    "summary": "Initialize a matrix",
    "syntax": [
      {
        "syntax": "x = ones(i,j,k,....);",
        "description": "Initializes an i x j x k x .... matrix."
      }
    ],
    "example": ""
  },
  {
    "name": "opensession",
    "description": "An interoperability command that opens a server session of selected Lumerical product via automation API. Once the session is opened, client product can call the server to execute arbitrary Lumerical script command(s) and execute them. Opened Lumerical session also allows to send and get variables from/to workspace.",
    "usage": "opensession();",
    "category": "general",
    "markdown": "# opensession\r\n\r\nAn interoperability command that opens a server session of selected Lumerical product\r\nvia automation API. Once the session is opened, client product can call the server to\r\nexecute arbitrary Lumerical script command(s) and execute them. Opened Lumerical session\r\nalso allows to send and get variables from/to workspace.\r\n\r\n| **Syntax**                | **Description**                                                                                                                              |\r\n| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| s2=opensession('device'); | When executed, this command will open a session of Device via the automation API. Accepted parameters: 'fdtd' 'mode' 'device' 'interconnect' |\r\n\r\n### Example\r\n\r\nThe following code example opens Device as a server, sends local variable 'x' to Device\r\nworkspace followed by a command to manipulate the variable and the retrieves the result\r\nbefore closing the session:\r\n\r\n```\r\n#Opend Device session\r\ns2=opensession('device');\r\n#Declare local variable x\r\nx=2;\r\n#Send the local variable to Device workspace via API\r\nputremotedata(s2,'x_device',x);\r\n#Send script command to Device via API andsquare the variable\r\nevalremote(s2,\"y_device=x_device^2;\");\r\n#Get the variable from Device worksapace via API \r\n?y=getremotedata(s2,'y_device');\r\n#Close the session\r\nclosesession(s2);\r\n```",
    "summary": "An interoperability command that opens a server session of selected Lumerical product via automation...",
    "syntax": [
      {
        "syntax": "s2=opensession('device');",
        "description": "When executed, this command will open a session of Device via the automation API. Accepted parameters: 'fdtd' 'mode' 'device' 'interconnect'"
      }
    ],
    "example": ""
  },
  {
    "name": "operatingsystem",
    "description": "Returns the current operating system.",
    "usage": "operatingsystem();",
    "category": "general",
    "markdown": "# operatingsystem\r\n\r\nReturns the current operating system.\r\n\r\n| **Syntax**       | **Description**                                                                              |\r\n| ---------------- | -------------------------------------------------------------------------------------------- |\r\n| operatingsystem; | Returns the current operating system. Valid return values are “windows”, “apple” or “linux”. |\r\n\r\n**Example**\r\n\r\n```\r\n>?operatingsystem;\r\nwindows\r\n```",
    "summary": "Returns the current operating system",
    "syntax": [
      {
        "syntax": "operatingsystem;",
        "description": "Returns the current operating system. Valid return values are “windows”, “apple” or “linux”."
      }
    ],
    "example": ">?operatingsystem;\r\nwindows"
  },
  {
    "name": "optimizeposition",
    "description": "The optimizeposition command calculates the x shift, y shift, and z shift resulting in maximum overlap between the specified mode and d-card when using the FDE solver.",
    "usage": "optimizeposition();",
    "category": "general",
    "markdown": "# optimizeposition\r\n\r\nThe optimizeposition command calculates the x shift, y shift, and z shift resulting in\r\nmaximum overlap between the specified mode and d-card when using the FDE solver.\r\n\r\nThe x shift, y shift, and z shift correspond to the offset in the d-card profile in x,\r\ny, and z.\r\n\r\nThis function also populates the overlap and power coupling as well as the x shift, y\r\nshift, and z shift positions in the Overlap analysis tab of the Eigensolver Analysis\r\nwindow, similarly to when you click on the \"Optimize position\" button in the GUI.\r\n\r\nSee the [ overlap ](./overlap.md) function for more details about overlap and coupling\r\ncalculations.\r\n\r\n| **Syntax**                                          | **Description** |\r\n| --------------------------------------------------- | --------------- |\r\n| out = optimizeposition(mode number, d-card number); |                 |\r\n\r\n- mode number: the mode number in the mode list\r\n- d-card number: the number of the d-card in the deck\r\n\r\nNote that the \"shift d-card center\" option must be selected in order to use this\r\nfunction.\r\n\r\n**Examples**\r\n\r\nThis example shows how to use the optimizeposition command to calculate the x shift, y\r\nshift, and z shift between a specified mode and d-card resulting in maximum overlap,\r\nprint out the shift values and the optimal overlap and power coupling with the applied\r\nshift.\r\n\r\n```\r\nsetanalysis(\"shift d-card center\",1);  \r\nshift = optimizeposition(4,1); # find x, y, z shift resulting in optimal overlap between  \r\n                               # the 4th mode in the mode list and the 1st mode in the deck  \r\n\r\n?\"x shift:\"+num2str(shift(1));  \r\n?\"y shift:\"+num2str(shift(2));  \r\n?\"z shift:\"+num2str(shift(3));  \r\n\r\nout = overlap(\"mode4\",\"global_mode1\",shift(1),shift(2),shift(3));  \r\n?\"maximum overlap:\"+num2str(out(1));  \r\n?\"maximum power coupling:\"+num2str(out(2));\r\n```",
    "summary": "The optimizeposition command calculates the x shift, y shift, and z shift resulting in maximum overl...",
    "syntax": [],
    "example": ""
  },
  {
    "name": "or",
    "description": "Is the logical OR function. Imaginary components of x and y are ignored.",
    "usage": "or();",
    "category": "general",
    "markdown": "# or\r\n\r\nIs the logical OR function. Imaginary components of x and y are ignored.\r\n\r\n| **Syntax** | **Description** |\r\n| ---------- | --------------- |\r\n| out = y    | x;              |\r\n| y or x;    | Same as         |\r\n\r\n**Examples**\r\n\r\nThis example shows the usage of the \"|\" and OR function.\r\n\r\n```\r\n? (2) | (4);\r\nresult: \r\n1 \r\n?(3 > 4) or (4 >3);\r\nresult: \r\n1  \r\n? (0+1i) | (0);\r\nresult: \r\n0 \r\n```",
    "summary": "Is the logical OR function",
    "syntax": [
      {
        "syntax": "out = y",
        "description": "x;"
      },
      {
        "syntax": "y or x;",
        "description": "Same as"
      }
    ],
    "example": ""
  },
  {
    "name": "orbit",
    "description": "This command performs an elliptical viewing orbit of the structure in the perspective view. Note that the commands [setview](./setview.md), [getview](./getview.md) and [redraw](./redraw.md) make it possible to create any type of orbit you would like in your own script file.",
    "usage": "orbit();",
    "category": "general",
    "markdown": "# orbit\r\n\r\nThis command performs an elliptical viewing orbit of the structure in the perspective\r\nview. Note that the commands [setview](./setview.md), [getview](./getview.md) and\r\n[redraw](./redraw.md) make it possible to create any type of orbit you would like in\r\nyour own script file.\r\n\r\n| **Syntax**                      | **Description**                                                                                               |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------------------------- |\r\n| orbit;                          | Performs an orbit of the current perspective view.                                                            |\r\n| orbit(zoom_factor);             | Performs an orbit with the specified minimum zoom factor. By default the zoom factor is 1.5.                  |\r\n| orbit(zoom_factor, frame_rate); | Performs an orbit with the specified frame rate specified in frames per second. The default frame rate is 15. |\r\n\r\n**Example**\r\n\r\nType in orbit in the prompt and you will see that the perspective view is in rotation.",
    "summary": "This command performs an elliptical viewing orbit of the structure in the perspective view",
    "syntax": [
      {
        "syntax": "orbit;",
        "description": "Performs an orbit of the current perspective view."
      },
      {
        "syntax": "orbit(zoom_factor);",
        "description": "Performs an orbit with the specified minimum zoom factor. By default the zoom factor is 1.5."
      },
      {
        "syntax": "orbit(zoom_factor, frame_rate);",
        "description": "Performs an orbit with the specified frame rate specified in frames per second. The default frame rate is 15."
      }
    ],
    "example": ""
  },
  {
    "name": "overlap",
    "description": "Returns the overlap and power coupling between two modes calculated by the FDE solver or recorded by frequency monitors from an FDTD or varFDTD simulation, or field profiles recorded in rectilinear datasets.",
    "usage": "overlap();",
    "category": "general",
    "markdown": "# overlap\r\n\r\nReturns the overlap and power coupling between two modes calculated by the FDE solver or\r\nrecorded by frequency monitors from an FDTD or varFDTD simulation, or field profiles\r\nrecorded in rectilinear datasets.\r\n\r\nOverlap measures the fraction of electromagnetic fields that overlap between the two\r\nfield profiles (modes). This is also the fraction of power from mode2 that can propagate\r\nin mode1 (for both forward and backward propagating fields). The absolute value of the\r\nentire formula is to ensure it is positive.\r\n\r\n$$ {\\\\text { overlap }=\\\\left| \\\\operatorname{Re} \\\\left\\[\\\\frac{(\\\\int \\\\mathbf{E}_{1}\r\n\\\\times \\\\mathbf{H}_{2}^{*} \\\\cdot d \\\\mathbf{S}) (\\\\int \\\\mathbf{E}_{2} \\\\times\r\n\\\\mathbf{H}_{1}^{*} \\\\cdot d \\\\mathbf{S} ) }{\\\\int \\\\mathbf{E}_{1} \\\\times\r\n\\\\mathbf{H}_{1}^{*} \\\\cdot d \\\\mathbf{S} }\\\\right\\] \\\\frac{1}{ \\\\operatorname{Re} (\r\n\\\\int \\\\mathbf{E}_{2} \\\\times \\\\mathbf{H}_{2}^{*} \\\\cdot d \\\\mathbf{S} )} \\\\right| } $$\r\n\r\n| **Syntax**                   | **Description** |\r\n| ---------------------------- | --------------- |\r\n| out = overlap(mode2, mode1); |                 |\r\n\r\n- mode2, mode1: modes to calculate overlaps for, inputs can be\r\n  1. Mode D-CARDs in FDE, string input, e.g., ‘mode1’, ‘mode2’\r\n  1. Names of frequency domain monitors in FDTD, string input, e.g., ‘m1’, ‘m2’\r\n  1. Rectilinear datasets, see below for more information\r\n- out(1): the mode overlap\r\n- out(2): the mode power coupling\r\n\r\nout = overlap(mode2, mode1, x, y,z); | Mode alignment can be adjusted before overlap is\r\ncalculated.\r\n\r\n- x offset\r\n- y offset\r\n- z offset\r\n\r\nThe offset is applied to the second mode listed, i.e. ‘mode1’ in this case. All inputs\r\n(FDE mode names, frequency monitors, rectilinear datasets) are valid also for the syntax\r\nwith alignment adjustment.\r\n\r\n## Using Rectilinear Datasets\r\n\r\nStarting in 2024R2.3, rectilinear datasets with arbitrary field profiles are supported\r\nin addition to monitor names and D-CARDs.\r\n\r\nRectilinear datasets **cannot** be mixed with other input types, however, data can be\r\nextracted from modes using the\r\n[getresult script command](https://optics.ansys.com/hc/en-us/articles/360034409854-getresult-Script-command),\r\nshown in the examples below.\r\n\r\nWhen using rectilinear datasets, they should contain attribute names ‘E’ and ‘H’, which\r\nwill be used as the electric and magnetic fields, respectively. If no attribute name ‘E’\r\nis found, the first attribute of the dataset is assumed to be the electric field. If no\r\nattribute ‘H’ is found, the first attribute of the dataset after the electric field\r\nattribute is assumed to be the magnetic field.\r\n\r\n**Examples**\r\n\r\nThis example shows how to use the overlap command to calculate the overlap and power\r\ncoupling between two modes.\r\n\r\n```\r\ncopydcard(\"mode1\",\"test_mode1\");copydcard(\"mode2\",\"test_mode2\");\r\nout = overlap(\"test_mode1\",\"test_mode2\");\r\n?out(1);  # overlap  \r\n?out(2);  # power coupling  \r\n  \r\n#The same result as above, but using rectilinear datasets  \r\nEH1 = getresult(\"mode1\",\"E\"); #getresult used to extract E and H data  \r\nH1 = getresult(\"mode1\",\"H\");  \r\nEH1.addattribute(\"H\",H1.H);  \r\nEH2 = getresult(\"mode2\",\"E\");  \r\nH2 = getresult(\"mode2\",\"H\");  \r\nEH2.addattribute(\"H\",H2.H);  \r\nout2 = overlap(EH1,EH2);  \r\n?out2(1); # overlap  \r\n?out2(2); # power coupling\r\n```",
    "summary": "Returns the overlap and power coupling between two modes calculated by the FDE solver or recorded by...",
    "syntax": [],
    "example": ""
  },
  {
    "name": "packagedesignkit",
    "description": "Creates a .cml from a existing folder under Custom library.",
    "usage": "packagedesignkit();",
    "category": "general",
    "markdown": "# packagedesignkit\r\n\r\nCreates a .cml from a existing folder under Custom library.\r\n\r\n| **Syntax**                                            | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| packagedesignkit(name, filename, encrypt, overwrite); | Creates a design kit file named ‘filename.cml’ from the custom folder named ‘name’. If 'encrypt' = false, it will be packaged without encryption and if 'encrypt' = true, the package will be encrypted. If ‘overwrite’ is true, it will overwrite an existing design kit file with the same name, if ‘overwrite’ is false, it will ask the user for confirmation before overwriting. The default setting for 'overwrite' is false. |\r\n\r\n**Example**\r\n\r\n```\r\n#packages a compact model library in the Custom folder with encryption\r\npackagedesignkit(\"dk\", \"dk.cml\", true, true);\r\n```",
    "summary": "Creates a ",
    "syntax": [
      {
        "syntax": "packagedesignkit(name, filename, encrypt, overwrite);",
        "description": "Creates a design kit file named ‘filename.cml’ from the custom folder named ‘name’. If 'encrypt' = false, it will be packaged without encryption and if 'encrypt' = true, the package will be encrypted. If ‘overwrite’ is true, it will overwrite an existing design kit file with the same name, if ‘overwrite’ is false, it will ask the user for confirmation before overwriting. The default setting for 'overwrite' is false."
      }
    ],
    "example": "#packages a compact model library in the Custom folder with encryption\r\npackagedesignkit(\"dk\", \"dk.cml\", true, true);"
  },
  {
    "name": "parsebackannotation",
    "description": "Parses the waveguide back annotation.",
    "usage": "parsebackannotation();",
    "category": "general",
    "markdown": "# parsebackannotation\r\n\r\nParses the waveguide back annotation.\r\n\r\n| **Syntax**                          | **Description**                                                                                                                                                                                                                                                                    |\r\n| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| parsebackannotation(backannotation) | Parses the waveguide back annotation. The annotation contains a list of mode labels, and for each mode a list of temperature and wavelength dependent propagation parameters are provided. The function returns a cell vector containing multiple structures with the parsed data. |\r\n\r\n**Example**\r\n\r\n```\r\nsIn = \"( ( 'TE' ( '26.85' '1.5475u' 0.0501323 2.4485 4.19145 0.000138683 ) ( '26.85' '1.5u' 0.0501323 2.4485 4.19145 0.000138683 ) ) ( 'TM' ( '26.85' '1.5475u' 17.3718 1.785382 3.76608 -0.019477 ) ( '26.85' '1.5u' 17.3718 1.785382 3.76608 -0.019477 ) ) ( 'TX' ( '26.85' '1.5650u' 0.0485085 2.42879 4.19216 0.000133047 ) ( '26.85' '1.5u' 0.0485085 2.42879 4.19216 0.000133047 ) ) ( 'TY' ( '49.85' '1.5475u' 0.0501048 2.45306 4.19667 0.000154927 ) ( '49.85' '1.5u' 0.b0501048 2.45306 4.19667 0.000154927 ) ) ) \";\r\nx=parsebackannotation(sIn);\r\n?toscript(x);\r\nx=cell(4);\r\nx{1}=struct;\r\nx{1}.dispersion=matrix(2);\r\nx{1}.dispersion(1)=0.000138683;\r\nx{1}.dispersion(2)=0.000138683;\r\nx{1}.dispersion_temperature_sensitivity=matrix(2);\r\nx{1}.dispersion_temperature_sensitivity(1)=0;\r\nx{1}.dispersion_temperature_sensitivity(2)=0;\r\nx{1}.effective_index=matrix(2);\r\nx{1}.effective_index(1)=2.4485;\r\nx{1}.effective_index(2)=2.4485;\r\nx{1}.effective_index_temperature_sensitivity=matrix(2);\r\nx{1}.effective_index_temperature_sensitivity(1)=0;\r\nx{1}.effective_index_temperature_sensitivity(2)=0; …\r\n```",
    "summary": "Parses the waveguide back annotation",
    "syntax": [
      {
        "syntax": "parsebackannotation(backannotation)",
        "description": "Parses the waveguide back annotation. The annotation contains a list of mode labels, and for each mode a list of temperature and wavelength dependent propagation parameters are provided. The function returns a cell vector containing multiple structures with the parsed data."
      }
    ],
    "example": "sIn = \"( ( 'TE' ( '26.85' '1.5475u' 0.0501323 2.4485 4.19145 0.000138683 ) ( '26.85' '1.5u' 0.0501323 2.4485 4.19145 0.000138683 ) ) ( 'TM' ( '26.85' '1.5475u' 17.3718 1.785382 3.76608 -0.019477 ) ( '26.85' '1.5u' 17.3718 1.785382 3.76608 -0.019477 ) ) ( 'TX' ( '26.85' '1.5650u' 0.0485085 2.42879 4.19216 0.000133047 ) ( '26.85' '1.5u' 0.0485085 2.42879 4.19216 0.000133047 ) ) ( 'TY' ( '49.85' '1.5475u' 0.0501048 2.45306 4.19667 0.000154927 ) ( '49.85' '1.5u' 0.b0501048 2.45306 4.19667 0.000154927 ) ) ) \";\r\nx=parsebackannotation(sIn);\r\n?toscript(x);\r\nx=cell(4);\r\nx{1}=struct;\r\nx{1}.dispersion=matrix(2);\r\nx{1}.dispersion(1)=0.000138683;\r\nx{1}.dispersion(2)=0.000138683;\r\nx{1}.dispersion_temperature_sensitivity=matrix(2);\r\nx{1}.dispersion_temperature_sensitivity(1)=0;\r\nx{1}.dispersion_temperature_sensitivity(2)=0;\r\nx{1}.effective_index=matrix(2);\r\nx{1}.effective_index(1)=2.4485;\r\nx{1}.effective_index(2)=2.4485;\r\nx{1}.effective_index_temperature_sensitivity=matrix(2);\r\nx{1}.effective_index_temperature_sensitivity(1)=0;\r\nx{1}.effective_index_temperature_sensitivity(2)=0; …"
  },
  {
    "name": "parsewaveguidebackannotation",
    "description": "Parses the waveguide back annotation at a given temperature in Celsius.",
    "usage": "parsewaveguidebackannotation();",
    "category": "general",
    "markdown": "# parsewaveguidebackannotation\r\n\r\nParses the waveguide back annotation at a given temperature in Celsius.\r\n\r\n| **Syntax**                                                | **Description**                                                                                                                                                                                                                                                                                                                                     |\r\n| --------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| parsewaveguidebackannotation(backannotation, temperature) | Parses the waveguide back annotation at a given temperature in Celsius. The annotation contains a list of mode labels, and for each mode a list of temperature and wavelength dependent propagation parameters are provided. The function returns a cell vector containing multiple structures with the parsed data at the given input temperature. |\r\n\r\n**Example**\r\n\r\n```\r\nsIn = \"( ( 'TE' ( '26.85' '1.5475u' 0.0501323 2.4485 4.19145 0.000138683 ) ( '26.85' '1.5u' 0.0501323 2.4485 4.19145 0.000138683 ) ) ( 'TM' ( '26.85' '1.5475u' 17.3718 1.785382 3.76608 -0.019477 ) ( '26.85' '1.5u' 17.3718 1.785382 3.76608 -0.019477 ) ) ( 'TX' ( '26.85' '1.5650u' 0.0485085 2.42879 4.19216 0.000133047 ) ( '26.85' '1.5u' 0.0485085 2.42879 4.19216 0.000133047 ) ) ( 'TY' ( '49.85' '1.5475u' 0.0501048 2.45306 4.19667 0.000154927 ) ( '49.85' '1.5u' 0.0501048 2.45306 4.19667 0.000154927 ) ) ) \";\r\nx= parsewaveguidebackannotation(sIn, 10);\r\n?toscript(x);\r\nx=cell(4);\r\nx{1}=struct;\r\nx{1}.label='TE';\r\nx{1}.orthogonal_identifier=1;\r\nx{1}.propagation=matrix(2,5);\r\nx{1}.propagation(1,1)=1.99862e+014;\r\nx{1}.propagation(2,1)=1.93727e+014;\r\nx{1}.propagation(1,2)=0.0501323;…\r\n```",
    "summary": "Parses the waveguide back annotation at a given temperature in Celsius",
    "syntax": [
      {
        "syntax": "parsewaveguidebackannotation(backannotation, temperature)",
        "description": "Parses the waveguide back annotation at a given temperature in Celsius. The annotation contains a list of mode labels, and for each mode a list of temperature and wavelength dependent propagation parameters are provided. The function returns a cell vector containing multiple structures with the parsed data at the given input temperature."
      }
    ],
    "example": "sIn = \"( ( 'TE' ( '26.85' '1.5475u' 0.0501323 2.4485 4.19145 0.000138683 ) ( '26.85' '1.5u' 0.0501323 2.4485 4.19145 0.000138683 ) ) ( 'TM' ( '26.85' '1.5475u' 17.3718 1.785382 3.76608 -0.019477 ) ( '26.85' '1.5u' 17.3718 1.785382 3.76608 -0.019477 ) ) ( 'TX' ( '26.85' '1.5650u' 0.0485085 2.42879 4.19216 0.000133047 ) ( '26.85' '1.5u' 0.0485085 2.42879 4.19216 0.000133047 ) ) ( 'TY' ( '49.85' '1.5475u' 0.0501048 2.45306 4.19667 0.000154927 ) ( '49.85' '1.5u' 0.0501048 2.45306 4.19667 0.000154927 ) ) ) \";\r\nx= parsewaveguidebackannotation(sIn, 10);\r\n?toscript(x);\r\nx=cell(4);\r\nx{1}=struct;\r\nx{1}.label='TE';\r\nx{1}.orthogonal_identifier=1;\r\nx{1}.propagation=matrix(2,5);\r\nx{1}.propagation(1,1)=1.99862e+014;\r\nx{1}.propagation(2,1)=1.93727e+014;\r\nx{1}.propagation(1,2)=0.0501323;…"
  },
  {
    "name": "partitionvolume",
    "description": "Enters into the partition volume mode.",
    "usage": "partitionvolume();",
    "category": "general",
    "markdown": "# partitionvolume\r\n\r\nEnters into the partition volume mode.\r\n\r\n| **Syntax**       | **Description**                       |\r\n| ---------------- | ------------------------------------- |\r\n| partitionvolume; | Enters into the partition volume mode |\r\n\r\n**Example**\r\n\r\nCreate a new simulation in CHARGE, HEAT, FEEM, or DGTD and switch to partition mode.\r\n\r\n```\r\nnewproject;  # create a new simulation file\r\nadddgtdsolver;    # add the DGTD solver\r\npartitionvolume;      # go to the partition volume mode\r\n```",
    "summary": "Enters into the partition volume mode",
    "syntax": [
      {
        "syntax": "partitionvolume;",
        "description": "Enters into the partition volume mode"
      }
    ],
    "example": "newproject;  # create a new simulation file\r\nadddgtdsolver;    # add the DGTD solver\r\npartitionvolume;      # go to the partition volume mode"
  },
  {
    "name": "pastefromclipboard",
    "description": "Pastes the contents of the system clipboard into the layout environment. Equivalent to 'Ctrl-V'.",
    "usage": "pastefromclipboard();",
    "category": "general",
    "markdown": "# pastefromclipboard\r\n\r\nPastes the contents of the system clipboard into the layout environment. Equivalent to\r\n'Ctrl-V'.\r\n\r\n| **Syntax**          | **Description**                    |\r\n| ------------------- | ---------------------------------- |\r\n| pastefromclipboard; | Paste contents of system clipboard |\r\n\r\n**Examples**\r\n\r\nSee example in copytoclipboard function.",
    "summary": "Pastes the contents of the system clipboard into the layout environment",
    "syntax": [
      {
        "syntax": "pastefromclipboard;",
        "description": "Paste contents of system clipboard"
      }
    ],
    "example": ""
  },
  {
    "name": "pastesweep",
    "description": "Pastes a sweep/optimization/Monte Carlo analysis item from clipboard to the \"Optimizations and Sweeps\" tab.",
    "usage": "pastesweep();",
    "category": "general",
    "markdown": "# pastesweep\r\n\r\nPastes a sweep/optimization/Monte Carlo analysis item from clipboard to the\r\n\"Optimizations and Sweeps\" tab.\r\n\r\n| **Syntax**          | **Description**                                                                                                                                                                                                                                                                                                                        |\r\n| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| pastesweep(\"name\"); | Pastes a sweep/optimization/Monte Carlo analysis item from clipboard. \"name\" is the absolute name of the parent item where the new analysis item will be pasted as a child. If the name is empty, paste the new analysis item as a top-most item. Returns the absolute name of the new item. Returns empty string if paste got failed. |\r\n\r\n**Example**\r\n\r\nPlease refer to the [ copysweep ](./copysweep.md) script page for implementation\r\nexample.",
    "summary": "Pastes a sweep/optimization/Monte Carlo analysis item from clipboard to the \"Optimizations and Sweep...",
    "syntax": [
      {
        "syntax": "pastesweep(\"name\");",
        "description": "Pastes a sweep/optimization/Monte Carlo analysis item from clipboard. \"name\" is the absolute name of the parent item where the new analysis item will be pasted as a child. If the name is empty, paste the new analysis item as a top-most item. Returns the absolute name of the new item. Returns empty string if paste got failed."
      }
    ],
    "example": ""
  },
  {
    "name": "pause",
    "description": "Pauses program for a time.",
    "usage": "pause();",
    "category": "general",
    "markdown": "# pause\r\n\r\nPauses program for a time.\r\n\r\n| **Syntax**   | **Description**                                                                                                                                                                               |\r\n| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| pause(time); | Pauses script for time, measured in seconds. Hit the space bar to force the script to continue. Hit the ESCAPE key to break the script at this point. This function does not return any data. |\r\n\r\n**Examples**\r\n\r\nPauses for 5 seconds.\r\n\r\n```\r\npause(5);\r\n```\r\n\r\nPauses until user clicks space bar.\r\n\r\n```\r\n?\"Part 1 complete. Hit space bar to proceed with part 2.\";\r\npause(10000);\r\n```",
    "summary": "Pauses program for a time",
    "syntax": [
      {
        "syntax": "pause(time);",
        "description": "Pauses script for time, measured in seconds. Hit the space bar to force the script to continue. Hit the ESCAPE key to break the script at this point. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "pearson4pdf",
    "description": "Evaluate the Pearson IV probability density function (PDF) for real-valued argument x",
    "usage": "pearson4pdf();",
    "category": "general",
    "markdown": "# pearson4pdf\r\n\r\nEvaluate the Pearson IV probability density function (PDF) for real-valued argument x\r\n\r\n$$\r\n\\\\frac{1}{f(x)}\\\\frac{df}{dx}=\\\\frac{(x-\\\\lambda)+a\\_{0}}{b\\_{0}+b\\_{1}(x-\\\\lambda)+b\\_{2}(x-\\\\lambda)^{2}}\r\n$$\r\n\r\nThe Pearson PDF is categorized as type IV when the discriminant b0 +b1 x+b2 x2 has no\r\nreal roots. The Pearson IV PDF is typically defined in terms of the coefficients a0 ,b0\r\n,b1 and b2 that depend on the variance σ2 , skewness γ1 , and kurtosis β2 . For a given\r\nset of data, users can use\r\n[fitpearson4pdf](https://optics.ansys.com/hc/en-us/articles/360034926693) to get the\r\nnecessary parameters such as σ2 , γ1 , and β2 .\r\n\r\n| **Syntax**                               | **Description**                                                                                                                                           |\r\n| ---------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| f = pearson4pdf(x)                       | Returns the Pearson IV probability density function (PDF) for real-valued argument x, equivalent to normal distribution N(0,1).                           |\r\n| f = pearson4pdf(x,mu,sigma,gamma1,beta2) | Returns the Pearson IV probability density function (PDF) for real-valued argument x. Please see above for the definition of µ, σ, γ1 , and β2 (β2 =3+δ). |",
    "summary": "Evaluate the Pearson IV probability density function (PDF) for real-valued argument x",
    "syntax": [
      {
        "syntax": "f = pearson4pdf(x)",
        "description": "Returns the Pearson IV probability density function (PDF) for real-valued argument x, equivalent to normal distribution N(0,1)."
      },
      {
        "syntax": "f = pearson4pdf(x,mu,sigma,gamma1,beta2)",
        "description": "Returns the Pearson IV probability density function (PDF) for real-valued argument x. Please see above for the definition of µ, σ, γ1 , and β2 (β2 =3+δ)."
      }
    ],
    "example": ""
  },
  {
    "name": "permute",
    "description": "This function is a more general version of the transpose function. It allows matrix dimensions to be rearranged as needed.",
    "usage": "permute();",
    "category": "general",
    "markdown": "# permute\r\n\r\nThis function is a more general version of the transpose function. It allows matrix\r\ndimensions to be rearranged as needed.\r\n\r\n| **Syntax**                     | **Description**                                                                         |\r\n| ------------------------------ | --------------------------------------------------------------------------------------- |\r\n| out = permute(A, [i,j,k, ...]) | Returns a matrix with the same elements as A but with rearranged dimensions i,j,k, etc. |\r\n\r\n**Example**\r\n\r\nThe permute function can do the same as the transpose function.\r\n\r\n```\r\n?A=[1,2,3;4,5,6];\r\n?B=permute(A,[1,2]); # do nothing\r\n?B=permute(A,[2,1]); # swap rows and columns. same as transpose\r\n?B=transpose(A);   # transpose function, for comparison\r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 4 \r\n2 5 \r\n3 6 \r\nresult: \r\n1 4 \r\n2 5 \r\n3 6 \r\n```\r\n\r\nHowever, the permute function is more general and allows for additional operations.\r\n\r\n```\r\nA=matrix(2,3,4);\r\nA(1:2,1:3,1) = [1, 2, 3; 4, 5, 6];\r\nA(1:2,1:3,2) = [7, 8, 9; 10,11,12];\r\nA(1:2,1:3,3) = [13,14,15;16,17,18];\r\nA(1:2,1:3,4) = [19,20,21;22,23,24];\r\n?A;\r\n?B=permute(A,[1,2,3]);  # do nothing\r\n?B=permute(A,[3,2,1]);  # transpose 1st and 3rd dimension\r\nB=permute(A,[2,1,3]);   # transpose 1st & 2nd dimension\r\n?C=reshape(B,[1,2*3*4]); # then reshape to a single row vector\r\nresult(i,j,1):\r\n1 2 3 \r\n4 5 6 \r\nresult(i,j,2):\r\n7 8 9 \r\n10 11 12 \r\nresult(i,j,3):\r\n13 14 15 \r\n16 17 18 \r\nresult(i,j,4):\r\n19 20 21 \r\n22 23 24 \r\nresult(i,j,1):\r\n1 2 3 \r\n4 5 6 \r\nresult(i,j,2):\r\n7 8 9 \r\n10 11 12 \r\nresult(i,j,3):\r\n13 14 15 \r\n16 17 18 \r\nresult(i,j,4):\r\n19 20 21 \r\n22 23 24 \r\nresult(i,j,1):\r\n1 2 3 \r\n7 8 9 \r\n13 14 15 \r\n19 20 21 \r\nresult(i,j,2):\r\n4 5 6 \r\n10 11 12 \r\n16 17 18 \r\n22 23 24 \r\nresult: \r\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \r\n```",
    "summary": "This function is a more general version of the transpose function",
    "syntax": [
      {
        "syntax": "out = permute(A, [i,j,k, ...])",
        "description": "Returns a matrix with the same elements as A but with rearranged dimensions i,j,k, etc."
      }
    ],
    "example": "?A=[1,2,3;4,5,6];\r\n?B=permute(A,[1,2]); # do nothing\r\n?B=permute(A,[2,1]); # swap rows and columns. same as transpose\r\n?B=transpose(A);   # transpose function, for comparison\r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 4 \r\n2 5 \r\n3 6 \r\nresult: \r\n1 4 \r\n2 5 \r\n3 6"
  },
  {
    "name": "pinch",
    "description": "Removes singleton dimensions from a matrix.",
    "usage": "pinch();",
    "category": "general",
    "markdown": "# pinch\r\n\r\nRemoves singleton dimensions from a matrix.\r\n\r\n| **Syntax**      | **Description**                                                                            |\r\n| --------------- | ------------------------------------------------------------------------------------------ |\r\n| out = pinch(x); | Removes all singleton dimensions. For example, if x is a matrix of dimension 1x1x1xM, then |\r\n\r\n- y=pinch(x);\r\n\r\nwill return a Mx1 matrix where\r\n\r\n- y(i) = x(1,1,1,i);\r\n\r\npinch(x,i); | Removes a specified dimension. If x is an NxMxKxP matrix then\r\n\r\n- y=pinch(x,2);\r\n\r\nwill return an NxKxP matrix where\r\n\r\n- y(i,j,k) = x(i,1,j,k)\r\n\r\npinch(x,i,j); | Removes a specified dimension but keeps a specific index for the\r\ndimension being removed. If x is an NxMxKxP matrix then\r\n\r\n- y=pinch(x,2,4);\r\n\r\nwill return an NxKxP matrix where\r\n\r\n- y(i,j,k) = x(i,4,j,k)\r\n\r\n**Example**\r\n\r\nThis example shows how pinch can be used to remove singleton dimensions from a matrix.\r\nThe matrix command is used to create a 6x1x4x1 matrix. Applying the pinch function to\r\nthis matrix will remove the two singleton dimensions, resulting in a 6x4 matrix.\r\n\r\n```\r\nx=matrix(6,1,4,1);\r\n?size(x);\r\nresult: \r\n6 1 4 1 \r\n?size(pinch(x));\r\nresult: \r\n6 4 \r\n```\r\n\r\nSuppose the power monitor named \"field\" is a 2D monitor in the XY plane set to record\r\nmultiple frequency points between 200THz and 300THz. In this case, the variable Ex will\r\nbe a 4D matrix, where the dimensions are length(X) by length(Y) by length(Z) by\r\nlength(F). Since this is a 2D monitor in the XY plane, there will be only one Z\r\nposition, which means the length of the third dimension (Z) will be 1.\r\n\r\nWith the pinch and find commands, we can select a particular frequency to be imaged.\r\nFirst, the find command is used to determine the index of the frequency value closest to\r\n250THz. Next, the pinch command is used to select the data in Ex corresponding to that\r\nfrequency. A second pinch command is used to remove the singleton Z dimension. The end\r\nresult is the 2D matrix Ex(x,y) at a specific value of z and f.\r\n\r\n```\r\nm=\"field\";      # monitor name\r\nx=getdata(m,\"x\");  # get monitor data\r\ny=getdata(m,\"y\");\r\nz=getdata(m,\"z\");\r\nf=getdata(m,\"f\");\r\nEx=getdata(m,\"Ex\");\r\nfi=find(f,250e12);  # find the index that corresponds to f=250THz\r\nEx=real(Ex);     # take real part of Ex    \r\n?\"Size of x: \"+num2str(length(x)); # print the matrix size to the screen\r\n?\"Size of y: \"+num2str(length(y));\r\n?\"Size of z: \"+num2str(length(z));\r\n?\"Size of f: \"+num2str(length(f));\r\n?\"Size of Ex: \"+num2str(size(Ex));\r\nto_plot=pinch(Ex,4,fi);   # select frequency. Size will be length(x) by length(y) by length(z)\r\nto_plot=pinch(to_plot);   # remove singleton z dimension. Size will be length(x) by length(y)\r\nimage(x*1e6,y*1e6,to_plot, \"x (um)\",\"y (um)\",\"Ex at \"+num2str(f(fi)/1e12)+ \" THz\" ); \r\n```",
    "summary": "Removes singleton dimensions from a matrix",
    "syntax": [
      {
        "syntax": "out = pinch(x);",
        "description": "Removes all singleton dimensions. For example, if x is a matrix of dimension 1x1x1xM, then"
      }
    ],
    "example": "x=matrix(6,1,4,1);\r\n?size(x);\r\nresult: \r\n6 1 4 1 \r\n?size(pinch(x));\r\nresult: \r\n6 4"
  },
  {
    "name": "plot",
    "description": "Creates line plots. All data sets must be sampled on the same position vector.",
    "usage": "plot();",
    "category": "general",
    "markdown": "# plot\r\n\r\nCreates line plots. All data sets must be sampled on the same position vector.\r\n\r\nSee plotxy for data sets that are sampled on different position vectors.\r\n\r\n| **Syntax**                                           | **Description**                                                                                                    |\r\n| ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\r\n| out = plot(x,y);                                     | Creates a plot of y vs x, y and x are both 1D vectors with the same length. The figure number is returned.         |\r\n| plot(x,y);                                           | x is a nx1 matrix. y is a nxm matrix. This will generate a graph with m lines. (y(1:n,1) vs x, y(1:n,2) vs x, etc) |\r\n| plot(x,y1,y2,y3);                                    | Creates a plot with 3 curves, x,y1, y2, y3 must be the same length, returns the figure number.                     |\r\n| plot(x,y, \"x label\", \"y label\", \"title\");            | Creates a plot of y vs x with axis labels and a title, returns the figure number.                                  |\r\n| plot(x,y, \"x label\", \"y label\", \"title\", \"options\"); | Creates a plot with desired options. Options are listed in the table below. Returns the figure number.             |\r\n\r\nPlot options. May include multiple plot options in a single string, such as\r\n\r\n```\r\n\"plot type=line, color=blue, pen=--, linewidth=2\"\r\n```\r\n\r\n| plot type               | line point bar               |\r\n| ----------------------- | ---------------------------- |\r\n| marker style            | x o + s (square) d (diamond) |\r\n| pen                     | -- : -. -..                  |\r\n| x axis location         | top bottom                   |\r\n| y axis location         | left right                   |\r\n| color                   | blue red etc.                |\r\n| greyscale               |                              |\r\n| plot lines              |                              |\r\n| plot bar                |                              |\r\n| plot points             |                              |\r\n| marker size (default=4) | #                            |\r\n| linewidth (default=1)   | #                            |\r\n\r\n**Examples**\r\n\r\nThis example will generate a figure with two lines: sin(x) and (sin(x))^2.\r\n\r\n```\r\nx=linspace(0,10,100);\r\ny1=sin(x);\r\ny2=y1^2;\r\nplot(x,y1,y2,\"x\",\"y\",\"title\");\r\nlegend(\"sin(x)\", \"sin(x)^2\");\r\n```\r\n\r\nThe following figure shows the output of the the example code.\r\n\r\nThis example will generate a figure with two lines: sin(x) and sin(x)^2 with more\r\nplotting options.\r\n\r\n```\r\nx=linspace(0,10,100);\r\ny1=sin(x);\r\ny2=y1^2;\r\nplot(x,y1,\"x\",\"y\",\"title\", \"plot type=line, color=red, pen=-., linewidth=2\");\r\nholdon;\r\nplot(x,y2,\"x\",\"y\",\"title\", \"plot type=line, color=blue, pen=--, linewidth=2\");\r\nlegend(\"sin(x)\", \"sin(x)^2\");\r\n```\r\n\r\nThe following figure shows the output of the the example code.",
    "summary": "Creates line plots",
    "syntax": [
      {
        "syntax": "out = plot(x,y);",
        "description": "Creates a plot of y vs x, y and x are both 1D vectors with the same length. The figure number is returned."
      },
      {
        "syntax": "plot(x,y);",
        "description": "x is a nx1 matrix. y is a nxm matrix. This will generate a graph with m lines. (y(1:n,1) vs x, y(1:n,2) vs x, etc)"
      },
      {
        "syntax": "plot(x,y1,y2,y3);",
        "description": "Creates a plot with 3 curves, x,y1, y2, y3 must be the same length, returns the figure number."
      },
      {
        "syntax": "plot(x,y, \"x label\", \"y label\", \"title\");",
        "description": "Creates a plot of y vs x with axis labels and a title, returns the figure number."
      },
      {
        "syntax": "plot(x,y, \"x label\", \"y label\", \"title\", \"options\");",
        "description": "Creates a plot with desired options. Options are listed in the table below. Returns the figure number."
      }
    ],
    "example": ""
  },
  {
    "name": "plotxy",
    "description": "Creates line plots. In particular, this function is used when the data sets are sampled on different position vectors.",
    "usage": "plotxy();",
    "category": "general",
    "markdown": "# plotxy\r\n\r\nCreates line plots. In particular, this function is used when the data sets are sampled\r\non different position vectors.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                        |\r\n| --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = plotxy(x,y);                                  | Creates a plot of y vs x, y and x are both 1D vectors with the same length. The figure number is returned.                                                                             |\r\n| plotxy(x1,y1,x2,y2,xn,yn);                          | Creates a plot with multiple curves. The xn-yn pairs must have the same length, but x1, x2, and xn can have different start-end values and resolutions. The figure number is returned. |\r\n| plotxy(x1,y1,x2,y2, \"x label\", \"y label\", \"title\"); | Creates line plots with axis labels and a title, returns the figure number.                                                                                                            |\r\n\r\n**Example**\r\n\r\nThis example will generate a figure with two functions with different resolutions:\r\n\r\n```\r\nx1=linspace(0,2*pi,15);\r\ny1=sin(x1);\r\nx2=linspace(1,pi,3);\r\ny2=x2/2;\r\nplotxy(x1,y1,x2,y2,\"x\",\"y\",\"title\");\r\nlegend(\"y1=sin(x1) - 15 pts\",\"y2=x2/2 - 3 pts\");\r\n```\r\n\r\nThe following figure shows the output of the the example code.",
    "summary": "Creates line plots",
    "syntax": [
      {
        "syntax": "out = plotxy(x,y);",
        "description": "Creates a plot of y vs x, y and x are both 1D vectors with the same length. The figure number is returned."
      },
      {
        "syntax": "plotxy(x1,y1,x2,y2,xn,yn);",
        "description": "Creates a plot with multiple curves. The xn-yn pairs must have the same length, but x1, x2, and xn can have different start-end values and resolutions. The figure number is returned."
      },
      {
        "syntax": "plotxy(x1,y1,x2,y2, \"x label\", \"y label\", \"title\");",
        "description": "Creates line plots with axis labels and a title, returns the figure number."
      }
    ],
    "example": "x1=linspace(0,2*pi,15);\r\ny1=sin(x1);\r\nx2=linspace(1,pi,3);\r\ny2=x2/2;\r\nplotxy(x1,y1,x2,y2,\"x\",\"y\",\"title\");\r\nlegend(\"y1=sin(x1) - 15 pts\",\"y2=x2/2 - 3 pts\");"
  },
  {
    "name": "polar",
    "description": "Creates polar plots. All data sets must be sampled on the same array of angle values.",
    "usage": "polar();",
    "category": "general",
    "markdown": "# polar\r\n\r\nCreates polar plots. All data sets must be sampled on the same array of angle values.\r\n\r\nSee polar2 for data sets that are sampled on different arrays of theta values.\r\n\r\n| **Syntax**                                                 | **Description**                                                                                                                                                                                                                                                                                                                                                                          |\r\n| ---------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = polar(theta,rho)                                     | Creates a polar coordinate plot of the angle theta versus the radius rho. theta is the angle from the x-axis to the radius vector specified in radians; rho is the length of the radius vector. Theta and rho can be vectors of the same length, or if the length of theta is n, then rho can be a nxm matrix, which corresponds to m sets of rho values. The figure number is returned. |\r\n| polar(theta,rho1,rho2,rho3)                                | Creates a polar plot with three curves. theta, rho1, rho2, rho3 must be of the same length. The figure number is returned.                                                                                                                                                                                                                                                               |\r\n| polar(theta,rho,\"x label\", \"y label\", \"title\")             | Creates a polar plot with axis labels and a title. The figure number is returned.                                                                                                                                                                                                                                                                                                        |\r\n| polar(theta,rho,\"x label\", \"y label\", \"title\", \"options\"); | Creates a polar plot with desired options. Options can be be                                                                                                                                                                                                                                                                                                                             |\r\n\r\n- greyscale\r\n- polar (use with plot command to generate the same plot as the polar script command)\r\n- any comma separated list of the above\r\n\r\nReturns the figure number.\r\n\r\n**Example**\r\n\r\nCreate a simple polar plot.\r\n\r\n```\r\ntheta = linspace(0,2*pi,100);\r\nr = cos(theta);\r\npolar(theta,r);\r\n```\r\n\r\nThe following figure shows the output of the the example code.",
    "summary": "Creates polar plots",
    "syntax": [
      {
        "syntax": "out = polar(theta,rho)",
        "description": "Creates a polar coordinate plot of the angle theta versus the radius rho. theta is the angle from the x-axis to the radius vector specified in radians; rho is the length of the radius vector. Theta and rho can be vectors of the same length, or if the length of theta is n, then rho can be a nxm matrix, which corresponds to m sets of rho values. The figure number is returned."
      },
      {
        "syntax": "polar(theta,rho1,rho2,rho3)",
        "description": "Creates a polar plot with three curves. theta, rho1, rho2, rho3 must be of the same length. The figure number is returned."
      },
      {
        "syntax": "polar(theta,rho,\"x label\", \"y label\", \"title\")",
        "description": "Creates a polar plot with axis labels and a title. The figure number is returned."
      },
      {
        "syntax": "polar(theta,rho,\"x label\", \"y label\", \"title\", \"options\");",
        "description": "Creates a polar plot with desired options. Options can be be"
      }
    ],
    "example": "theta = linspace(0,2*pi,100);\r\nr = cos(theta);\r\npolar(theta,r);"
  },
  {
    "name": "polar2",
    "description": "Creates polar plots. In particular, this function is used when the data sets are sampled on different arrays of angle values.",
    "usage": "polar2();",
    "category": "general",
    "markdown": "# polar2\r\n\r\nCreates polar plots. In particular, this function is used when the data sets are sampled\r\non different arrays of angle values.\r\n\r\n| **Syntax**                                                  | **Description**                                                                                                                                                                                                                                                                                                                                                                          |\r\n| ----------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = polar2(theta,rho)                                     | Creates a polar coordinate plot of the angle theta versus the radius rho. theta is the angle from the x-axis to the radius vector specified in radians; rho is the length of the radius vector. Theta and rho can be vectors of the same length, or if the length of theta is n, then rho can be a nxm matrix, which corresponds to m sets of rho values. The figure number is returned. |\r\n| polar2(theta1,rho1,theta2,rho2)                             | Creates a plot with two curves. The two data sets can be sampled on different theta vectors.                                                                                                                                                                                                                                                                                             |\r\n| polar2(theta,rho,\"x label\", \"y label\", \"title\")             | Creates a plot of y vs x with axis labels and a title, returns the figure number.                                                                                                                                                                                                                                                                                                        |\r\n| polar2(theta,rho,\"x label\", \"y label\", \"title\", \"options\"); | Creates a plot with desired options. Options can be be                                                                                                                                                                                                                                                                                                                                   |\r\n\r\n- greyscale\r\n- polar (same as the polar script command)\r\n- any comma separated list of the above\r\n\r\nReturns the figure number.\r\n\r\n**Example**\r\n\r\nPlot in polar coordinates two different data sets.\r\n\r\n```\r\ntheta1 = linspace(0,2*pi,100);\r\nr1 = cos(theta1);\r\ntheta2 = linspace(0,pi,50);\r\nr2 = sin(theta2);\r\npolar2(theta1,r1,theta2,r2);\r\n```\r\n\r\nThe following figure shows the output of the the example code.",
    "summary": "Creates polar plots",
    "syntax": [
      {
        "syntax": "out = polar2(theta,rho)",
        "description": "Creates a polar coordinate plot of the angle theta versus the radius rho. theta is the angle from the x-axis to the radius vector specified in radians; rho is the length of the radius vector. Theta and rho can be vectors of the same length, or if the length of theta is n, then rho can be a nxm matrix, which corresponds to m sets of rho values. The figure number is returned."
      },
      {
        "syntax": "polar2(theta1,rho1,theta2,rho2)",
        "description": "Creates a plot with two curves. The two data sets can be sampled on different theta vectors."
      },
      {
        "syntax": "polar2(theta,rho,\"x label\", \"y label\", \"title\")",
        "description": "Creates a plot of y vs x with axis labels and a title, returns the figure number."
      },
      {
        "syntax": "polar2(theta,rho,\"x label\", \"y label\", \"title\", \"options\");",
        "description": "Creates a plot with desired options. Options can be be"
      }
    ],
    "example": "theta1 = linspace(0,2*pi,100);\r\nr1 = cos(theta1);\r\ntheta2 = linspace(0,pi,50);\r\nr2 = sin(theta2);\r\npolar2(theta1,r1,theta2,r2);"
  },
  {
    "name": "polarimage",
    "description": "Creates 2D polar image plots. This is typically used to plot far field data.",
    "usage": "polarimage();",
    "category": "general",
    "markdown": "# polarimage\r\n\r\nCreates 2D polar image plots. This is typically used to plot far field data.\r\n\r\n| **Syntax**              | **Description**                                              |\r\n| ----------------------- | ------------------------------------------------------------ |\r\n| polarimage(ux,uy,data); | Creates a 2D image plot. data must be of dimension N x M and |\r\n\r\n- ux is of dimension N x 1, where ux goes from -1 to 1\r\n- uy is of dimension M x 1, where uy goes from -1 to 1\r\n\r\nout = polarimage(ux,uy,data, \"x label\", \"y label\", \"title\"); | Creates a 2D image plot\r\nwith axis labels Optionally returns the figure number.\\\r\npolarimage(ux,uy,data, \"x label\", \"y label\", \"title\", \"options\"); | Creates a 2D image\r\nplot with axis labels and options, options can be\r\n\r\n- logplot\r\n\r\n**Example**\r\n\r\nThis example generates an image of a simple 2D Gaussian function.\r\n\r\n```\r\nux=linspace(-1,1,51);\r\nuy=linspace(-1,1,61);\r\nUx=meshgridx(ux,uy);\r\nUy=meshgridy(ux,uy);\r\ndata = exp( 1-Ux^2-Uy^2);\r\n# plot data with both the image and polarimage script functions\r\nimage(ux,uy,data,\"ux\",\"uy\",\"Image plot\");   \r\npolarimage(ux,uy,data,\"ux\",\"uy\",\"Polar Image plot\");\r\n```\r\n\r\nThe following figure shows the resulting figures.\r\n\r\nThis example shows how this function might be used with the far field projection\r\nfunctions.\r\n\r\n```\r\nm=\"monitor1\";   # monitor name\r\nux=farfieldux(m); # position vectors\r\nuy=farfielduy(m);\r\nE2=farfield3d(m); # Far field E2 data\r\npolarimage(ux,uy,E2,\"ux\",\"uy\",\"far field |E|^2\");  \r\n```",
    "summary": "Creates 2D polar image plots",
    "syntax": [
      {
        "syntax": "polarimage(ux,uy,data);",
        "description": "Creates a 2D image plot. data must be of dimension N x M and"
      }
    ],
    "example": "ux=linspace(-1,1,51);\r\nuy=linspace(-1,1,61);\r\nUx=meshgridx(ux,uy);\r\nUy=meshgridy(ux,uy);\r\ndata = exp( 1-Ux^2-Uy^2);\r\n# plot data with both the image and polarimage script functions\r\nimage(ux,uy,data,\"ux\",\"uy\",\"Image plot\");   \r\npolarimage(ux,uy,data,\"ux\",\"uy\",\"Polar Image plot\");"
  },
  {
    "name": "polyand",
    "description": "Combines two polygons into one using the Boolean 'and' operation.",
    "usage": "polyand();",
    "category": "general",
    "markdown": "# polyand\r\n\r\nCombines two polygons into one using the Boolean 'and' operation.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**           | **Description**                                            |\r\n| -------------------- | ---------------------------------------------------------- |\r\n| V3 = polyand(V1,V2); | Returns a new polygon, V3, that is the 'and' of V1 and V2. |\r\n\r\n**Example**\r\n\r\nIn this example, we create two polygons and then show how the different Boolean\r\noperations can be done. We set up a mesh and use the inpoly function so that we can\r\nimage the polygons and easily see the result.\r\n\r\n```\r\n# set up a mesh for imaging polygons with the inpoly command\r\nx = linspace(-1,3,200);\r\ny = linspace(-1,3,200);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\n# enter 2 polygons and the polygon boolean operations\r\nV1 = [ 0,0; 1,0; 1,1; 0,1];\r\nV2 = [ 0,0; 2,2; 0,2];\r\nV3 = polyand(V1,V2);\r\nV4 = polyor(V1,V2);\r\nV5 = polydiff(V1,V2);\r\nV6 = polydiff(V2,V1);\r\nV7 = polyxor(V2,V1);\r\n# image all the polygons\r\nimage(x,y,inpoly(V1,X,Y),\"x\",\"y\",\"V1\");\r\nimage(x,y,inpoly(V2,X,Y),\"x\",\"y\",\"V2\");\r\nimage(x,y,inpoly(V3,X,Y),\"x\",\"y\",\"V1 and V2\");\r\nimage(x,y,inpoly(V4,X,Y),\"x\",\"y\",\"V1 or V2\");\r\nimage(x,y,inpoly(V5,X,Y),\"x\",\"y\",\"V1 - V2\");\r\nimage(x,y,inpoly(V6,X,Y),\"x\",\"y\",\"V2 - V1\");\r\nimage(x,y,inpoly(V7,X,Y),\"x\",\"y\",\"V1 xor V2\");\r\n```\r\n\r\nThe results are shown in the following images\r\n\r\n|\\\r\n---|---\\\r\n|\\\r\n|\\\r\n|\r\n\r\n## Note: Other 2D or 3D objects This command only works for 2D polygons. For other 2D or 3D objects, user may use the [ mesh order ](https://optics.ansys.com/hc/en-us/articles/360034915233-Mesh-Order) to combine multiple overlapped objects",
    "summary": "Combines two polygons into one using the Boolean 'and' operation",
    "syntax": [
      {
        "syntax": "V3 = polyand(V1,V2);",
        "description": "Returns a new polygon, V3, that is the 'and' of V1 and V2."
      }
    ],
    "example": "# set up a mesh for imaging polygons with the inpoly command\r\nx = linspace(-1,3,200);\r\ny = linspace(-1,3,200);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\n# enter 2 polygons and the polygon boolean operations\r\nV1 = [ 0,0; 1,0; 1,1; 0,1];\r\nV2 = [ 0,0; 2,2; 0,2];\r\nV3 = polyand(V1,V2);\r\nV4 = polyor(V1,V2);\r\nV5 = polydiff(V1,V2);\r\nV6 = polydiff(V2,V1);\r\nV7 = polyxor(V2,V1);\r\n# image all the polygons\r\nimage(x,y,inpoly(V1,X,Y),\"x\",\"y\",\"V1\");\r\nimage(x,y,inpoly(V2,X,Y),\"x\",\"y\",\"V2\");\r\nimage(x,y,inpoly(V3,X,Y),\"x\",\"y\",\"V1 and V2\");\r\nimage(x,y,inpoly(V4,X,Y),\"x\",\"y\",\"V1 or V2\");\r\nimage(x,y,inpoly(V5,X,Y),\"x\",\"y\",\"V1 - V2\");\r\nimage(x,y,inpoly(V6,X,Y),\"x\",\"y\",\"V2 - V1\");\r\nimage(x,y,inpoly(V7,X,Y),\"x\",\"y\",\"V1 xor V2\");"
  },
  {
    "name": "polyarea",
    "description": "Returns the area of a polygon. The area is positive if the vertices are defined in a counter-clockwise direction, and negative if the vertices are defined in a clockwise direction.",
    "usage": "polyarea();",
    "category": "general",
    "markdown": "# polyarea\r\n\r\nReturns the area of a polygon. The area is positive if the vertices are defined in a\r\ncounter-clockwise direction, and negative if the vertices are defined in a clockwise\r\ndirection.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**         | **Description**                                                                                                                            |\r\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = polyarea(V); | Returns the area of V. The sign of the area indicates if V is defined in a counter-clockwise (positive) or clockwise (negative) direction. |\r\n\r\n**Example**\r\n\r\nCalculate the area of a square of side length 1:\r\n\r\n```\r\nV = [ 0,0; 1,0; 1,1; 0,1];\r\n?polyarea(V);\r\nresult:\r\n1\r\n```",
    "summary": "Returns the area of a polygon",
    "syntax": [
      {
        "syntax": "out = polyarea(V);",
        "description": "Returns the area of V. The sign of the area indicates if V is defined in a counter-clockwise (positive) or clockwise (negative) direction."
      }
    ],
    "example": "V = [ 0,0; 1,0; 1,1; 0,1];\r\n?polyarea(V);\r\nresult:\r\n1"
  },
  {
    "name": "polydft",
    "description": "Returns the chirped z-transform of a set of data. The polydft function is very similar to a two-dimensional czt function with the difference being that the E function does not need to be finely sampled and only providing the vertices of a polygon as input range of the function would be enough to perform the transform. The only limit however is that E is considered constant within the limits of the polygon. The polygon mesh can be created using the inpoly function.",
    "usage": "polydft();",
    "category": "general",
    "markdown": "# polydft\r\n\r\nReturns the chirped z-transform of a set of data. The polydft function is very similar\r\nto a two-dimensional czt function with the difference being that the E function does not\r\nneed to be finely sampled and only providing the vertices of a polygon as input range of\r\nthe function would be enough to perform the transform. The only limit however is that E\r\nis considered constant within the limits of the polygon. The polygon mesh can be created\r\nusing the inpoly function.\r\n\r\n| **Syntax**              | **Description**                                                                                                                      |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |\r\n| out = polydft(E,kx,ky); | Returns the two dimensional chirped z-transform of E. kx and ky must be linearly spaced sets of wavenumbers but can cover any range. |\r\n\r\n**Example**\r\n\r\nThis example demonstrates two different approaches for calculating the discrete Fourier\r\ntransform (DFT) of a piecewise constant 2D function on the xy-plane. The function is\r\ndefined as having the value of one inside the polygonal area specified by the vertices\r\npoly_vert. One approach uses the polydft command directly on the polygon vertices, the\r\nother approach uses a finely staircased representation of the function and the czt\r\ncommand.\r\n\r\n```\r\n# -------\r\n# Inputs:\r\n# -------\r\n# xy-plane region\r\nx_span = y_span = 5.0;\r\n# area inside the above region where function is nonzero\r\npoly_vert = [0.25*x_span,0.35*y_span;\r\n             0.50*x_span,0.15*y_span;\r\n             0.75*x_span,0.35*y_span;\r\n             0.75*x_span,0.65*y_span;\r\n             0.50*x_span,0.85*y_span;\r\n             0.25*x_span,0.65*y_span];\r\n# grid for staircasing the above polygon\r\nNx = Ny = 2^8;\r\n# ---------\r\n# Function:\r\n# ---------\r\ndelta_x = x_span/Nx;\r\ndelta_y = y_span/Ny;\r\nx = delta_x*linspace(0.0,Nx-1,Nx);\r\ny = delta_y*linspace(0.0,Ny-1,Ny);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\npoly_fun = inpoly(poly_vert,X,Y);\r\nimage(x,y,poly_fun,\"x\",\"y\",\"staircased function\");\r\n# ----\r\n# DFT:\r\n# ----\r\n# using the czt command\r\ndelta_fx = 1.0/(Nx*delta_x);\r\ndelta_fy = 1.0/(Ny*delta_y);\r\nfx = delta_fx*linspace(-0.5*(Nx-1),0.5*(Nx-1),Nx);\r\nkx = 2.0*pi*fx;\r\nfy = delta_fy*linspace(-0.5*(Ny-1),0.5*(Ny-1),Ny);\r\nky = 2.0*pi*fy;\r\npoly_fun_czt = czt(poly_fun,x,y,kx,ky)/(Nx*Ny);\r\nimage(kx,ky,abs(poly_fun_czt),\"kx\",\"ky\",\"czt\");\r\n# using the polydft command\r\nKx = meshgridx(kx,ky);\r\nKy = meshgridy(kx,ky);\r\npoly_fun_polydft = polydft(poly_vert,Kx,Ky)/(x_span*y_span);\r\nimage(x,y,abs(poly_fun_polydft),\"kx\",\"ky\",\"polydft\");\r\n# ------------------------\r\n# Function Reconstruction:\r\n# ------------------------\r\n# from czt\r\npoly_fun_from_czt = czt(poly_fun_czt,-kx,-ky,x,y);\r\nimage(x,y,real(poly_fun_from_czt),\"x\",\"y\",\"reconstruction from czt\");\r\n# from polydft\r\npoly_fun_from_polydft = czt(poly_fun_polydft,-kx,-ky,x,y);\r\nimage(x,y,real(poly_fun_from_polydft),\"x\",\"y\",\"reconstruction from polydft\"); \r\n```",
    "summary": "Returns the chirped z-transform of a set of data",
    "syntax": [
      {
        "syntax": "out = polydft(E,kx,ky);",
        "description": "Returns the two dimensional chirped z-transform of E. kx and ky must be linearly spaced sets of wavenumbers but can cover any range."
      }
    ],
    "example": "# -------\r\n# Inputs:\r\n# -------\r\n# xy-plane region\r\nx_span = y_span = 5.0;\r\n# area inside the above region where function is nonzero\r\npoly_vert = [0.25*x_span,0.35*y_span;\r\n             0.50*x_span,0.15*y_span;\r\n             0.75*x_span,0.35*y_span;\r\n             0.75*x_span,0.65*y_span;\r\n             0.50*x_span,0.85*y_span;\r\n             0.25*x_span,0.65*y_span];\r\n# grid for staircasing the above polygon\r\nNx = Ny = 2^8;\r\n# ---------\r\n# Function:\r\n# ---------\r\ndelta_x = x_span/Nx;\r\ndelta_y = y_span/Ny;\r\nx = delta_x*linspace(0.0,Nx-1,Nx);\r\ny = delta_y*linspace(0.0,Ny-1,Ny);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\npoly_fun = inpoly(poly_vert,X,Y);\r\nimage(x,y,poly_fun,\"x\",\"y\",\"staircased function\");\r\n# ----\r\n# DFT:\r\n# ----\r\n# using the czt command\r\ndelta_fx = 1.0/(Nx*delta_x);\r\ndelta_fy = 1.0/(Ny*delta_y);\r\nfx = delta_fx*linspace(-0.5*(Nx-1),0.5*(Nx-1),Nx);\r\nkx = 2.0*pi*fx;\r\nfy = delta_fy*linspace(-0.5*(Ny-1),0.5*(Ny-1),Ny);\r\nky = 2.0*pi*fy;\r\npoly_fun_czt = czt(poly_fun,x,y,kx,ky)/(Nx*Ny);\r\nimage(kx,ky,abs(poly_fun_czt),\"kx\",\"ky\",\"czt\");\r\n# using the polydft command\r\nKx = meshgridx(kx,ky);\r\nKy = meshgridy(kx,ky);\r\npoly_fun_polydft = polydft(poly_vert,Kx,Ky)/(x_span*y_span);\r\nimage(x,y,abs(poly_fun_polydft),\"kx\",\"ky\",\"polydft\");\r\n# ------------------------\r\n# Function Reconstruction:\r\n# ------------------------\r\n# from czt\r\npoly_fun_from_czt = czt(poly_fun_czt,-kx,-ky,x,y);\r\nimage(x,y,real(poly_fun_from_czt),\"x\",\"y\",\"reconstruction from czt\");\r\n# from polydft\r\npoly_fun_from_polydft = czt(poly_fun_polydft,-kx,-ky,x,y);\r\nimage(x,y,real(poly_fun_from_polydft),\"x\",\"y\",\"reconstruction from polydft\");"
  },
  {
    "name": "polydiff",
    "description": "Combines two polygons into one by taking the difference.",
    "usage": "polydiff();",
    "category": "general",
    "markdown": "# polydiff\r\n\r\nCombines two polygons into one by taking the difference.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**            | **Description**                           |\r\n| --------------------- | ----------------------------------------- |\r\n| V3 = polydiff(V1,V2); | Returns a new polygon, V3, that is V1-V2. |\r\n\r\n**Example**\r\n\r\nSee example in the polyand function description.",
    "summary": "Combines two polygons into one by taking the difference",
    "syntax": [
      {
        "syntax": "V3 = polydiff(V1,V2);",
        "description": "Returns a new polygon, V3, that is V1-V2."
      }
    ],
    "example": ""
  },
  {
    "name": "polyfit",
    "description": "Calculates a polynomial fit based on linear regression. The data can be complex.",
    "usage": "polyfit();",
    "category": "general",
    "markdown": "# polyfit\r\n\r\nCalculates a polynomial fit based on linear regression. The data can be complex.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                       |\r\n| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| p = polyfit(x, y, N); | Returns the coefficients for a polynomial p(x) of degree N that is the best fit for the data in y. \\\\( p(x)=p_1 + p_2x^1+p_3x^2+...+p_Nx^{N-1}+p\\_{N+1}x^N \\\\) The length of the coefficients is N+1. |\r\n\r\n**Example**\r\n\r\nIn this example random noise is added to a smooth function. A polynomial fit of the\r\nnoisy data allows to recover the original function approximately.\r\n\r\n```\r\nclear;\r\nx = linspace(0,10,100);\r\nnoise_amp = 200;\r\ny_original = 3.2 + 2i*x + 4.5*x^2 - 0.04*x^3;\r\ny_noise = y_original + noise_amp*(randmatrix(length(x))-0.5);\r\nfit = polyfit(x,y_noise,3);\r\ny_fit = fit(1) + fit(2)*x + fit(3)*x^2 + fit(4)*x^3;\r\nplot(x,abs(y_original),abs(y_noise),abs(y_fit));\r\nlegend(\"y_original\",\"y_noise\",\"y_fit\");\r\n?fit;\r\nresult: \r\n-20.3301+1.67422e-013i # fit(1)\r\n19.7752+2i  # fit(2)\r\n-0.477739+4.58522e-014i # fit(3) \r\n0.304786-4.35069e-015i # fit(4)\r\n```",
    "summary": "Calculates a polynomial fit based on linear regression",
    "syntax": [
      {
        "syntax": "p = polyfit(x, y, N);",
        "description": "Returns the coefficients for a polynomial p(x) of degree N that is the best fit for the data in y. \\\\( p(x)=p_1 + p_2x^1+p_3x^2+...+p_Nx^{N-1}+p\\_{N+1}x^N \\\\) The length of the coefficients is N+1."
      }
    ],
    "example": "clear;\r\nx = linspace(0,10,100);\r\nnoise_amp = 200;\r\ny_original = 3.2 + 2i*x + 4.5*x^2 - 0.04*x^3;\r\ny_noise = y_original + noise_amp*(randmatrix(length(x))-0.5);\r\nfit = polyfit(x,y_noise,3);\r\ny_fit = fit(1) + fit(2)*x + fit(3)*x^2 + fit(4)*x^3;\r\nplot(x,abs(y_original),abs(y_noise),abs(y_fit));\r\nlegend(\"y_original\",\"y_noise\",\"y_fit\");\r\n?fit;\r\nresult: \r\n-20.3301+1.67422e-013i # fit(1)\r\n19.7752+2i  # fit(2)\r\n-0.477739+4.58522e-014i # fit(3) \r\n0.304786-4.35069e-015i # fit(4)"
  },
  {
    "name": "polygrow",
    "description": "Expand or shrink a polygon. Resulting polygons will have the same number of vertices and the same order as polygon V. Consider using polyclean before using polygrow.",
    "usage": "polygrow();",
    "category": "general",
    "markdown": "# polygrow\r\n\r\nExpand or shrink a polygon. Resulting polygons will have the same number of vertices and\r\nthe same order as polygon V. Consider using polyclean before using polygrow.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\\\(\\\\ge\\\\) 3 is the number of vertices. The dimension 2 corresponds to the x and y\r\npositions. For example, a square of side length 1 can be described by V = \\[ 0,0; 1,0;\r\n1,1; 0,1\\] or V = [ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**                                                         | **Description**                                                                                   |\r\n| ------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- |\r\n| polygrow(V, delta, {\"tolerance\": tol_value, \"legacy\": true/false}) | Returns the vertices of a new polygon that has grown by delta. To shrink a polygon, use delta< 0. |\r\n\r\n- For vertices in counter-clockwise order and delta > 0, edges are moved to their right\r\n  by delta (positive to expand, negative to shrink)\r\n- Tolerance is used to identify seams (which are not grown) and bowtie-vertices (which\r\n  are pinned in place). Set the legacy option to 'true' to skip this check.\r\n- An attempt is made to prevent self-intersection at sharp corners.\r\n- Value delta can be either scalar or matrix (result will be either a polygon or a\r\n  cell-array of polygons)\r\n\r\n**Example**\r\n\r\nThe following example shows the vertices of a square of side length 1 expanded by 0.1 on\r\nall sides with the tolerance of 1e-15. Setting the 'legacy' value to 'false' allows\r\nidentifying seams and bowtie-vertices.\r\n\r\n```\r\nV = [ 0,0; 1,0; 1,1; 0,1];  \r\n?polygrow(V, 0.1, {\"tolerance\": 1e-15, \"legacy\": false});  \r\n  \r\nresult:   \r\n-0.1 -0.1   \r\n 1.1 -0.1   \r\n 1.1  1.1   \r\n-0.1  1.1 \r\n```",
    "summary": "Expand or shrink a polygon",
    "syntax": [
      {
        "syntax": "polygrow(V, delta, {\"tolerance\": tol_value, \"legacy\": true/false})",
        "description": "Returns the vertices of a new polygon that has grown by delta. To shrink a polygon, use delta< 0."
      }
    ],
    "example": "V = [ 0,0; 1,0; 1,1; 0,1];  \r\n?polygrow(V, 0.1, {\"tolerance\": 1e-15, \"legacy\": false});  \r\n  \r\nresult:   \r\n-0.1 -0.1   \r\n 1.1 -0.1   \r\n 1.1  1.1   \r\n-0.1  1.1"
  },
  {
    "name": "polyintersect",
    "description": "Determines if two polygons intersect.",
    "usage": "polyintersect();",
    "category": "general",
    "markdown": "# polyintersect\r\n\r\nDetermines if two polygons intersect.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**                  | **Description** |\r\n| --------------------------- | --------------- |\r\n| out = polyintersect(V1,V2); | Returns         |\r\n\r\n- 0 if the polygons do not overlap\r\n- 0.5 if the polygons touch\r\n- 1 if they overlap\r\n- 2 if one polygon completely encloses the other\r\n\r\n**Example**\r\n\r\nThe following example illustrates the different possible intersection situations for two\r\npolygons:\r\n\r\n```\r\nV1 = [ 0,0; 1,0; 1,1; 0,1];\r\nV2 = [ 0,0; 2,0; 2,2; 0,1];\r\n?polyintersect(V1,V2);\r\nresult: \r\n2 \r\n?polyintersect(V1,V2+0.5); #Shift V2 to the right by 0.5\r\nresult: \r\n1 \r\n?polyintersect(V1,V2+1); #Shift V2 to the right by 1\r\nresult: \r\n0.5 \r\n?polyintersect(V1,V2+2); #Shift V2 to the right by 2\r\nresult: \r\n0\r\n```",
    "summary": "Determines if two polygons intersect",
    "syntax": [
      {
        "syntax": "out = polyintersect(V1,V2);",
        "description": "Returns"
      }
    ],
    "example": "V1 = [ 0,0; 1,0; 1,1; 0,1];\r\nV2 = [ 0,0; 2,0; 2,2; 0,1];\r\n?polyintersect(V1,V2);\r\nresult: \r\n2 \r\n?polyintersect(V1,V2+0.5); #Shift V2 to the right by 0.5\r\nresult: \r\n1 \r\n?polyintersect(V1,V2+1); #Shift V2 to the right by 1\r\nresult: \r\n0.5 \r\n?polyintersect(V1,V2+2); #Shift V2 to the right by 2\r\nresult: \r\n0"
  },
  {
    "name": "polyor",
    "description": "Combines two polygons into one using the Boolean 'or' operation.",
    "usage": "polyor();",
    "category": "general",
    "markdown": "# polyor\r\n\r\nCombines two polygons into one using the Boolean 'or' operation.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**          | **Description**                                           |\r\n| ------------------- | --------------------------------------------------------- |\r\n| V3 = polyor(V1,V2); | Returns a new polygon, V3, that is the 'or' of V1 and V2. |\r\n\r\n**Example**\r\n\r\nSee example in the polyand function description.",
    "summary": "Combines two polygons into one using the Boolean 'or' operation",
    "syntax": [
      {
        "syntax": "V3 = polyor(V1,V2);",
        "description": "Returns a new polygon, V3, that is the 'or' of V1 and V2."
      }
    ],
    "example": ""
  },
  {
    "name": "polyxor",
    "description": "Combines two polygons into one using the Boolean 'xor' operation.",
    "usage": "polyxor();",
    "category": "general",
    "markdown": "# polyxor\r\n\r\nCombines two polygons into one using the Boolean 'xor' operation.\r\n\r\nThe polygon vertices are contained in a single matrix of dimension Nx2 (or 2xN), where N\r\n\\>= 3 is the number of vertices. The dimension 2 corresponds to the x,y positions. For\r\nexample, a square of side length 1 can be described by V = [ 0,0; 1,0; 1,1; 0,1] or V =\r\n[ 0,1,1,0;0,0,1,1].\r\n\r\n| **Syntax**           | **Description**                                            |\r\n| -------------------- | ---------------------------------------------------------- |\r\n| V3 = polyxor(V1,V2); | Returns a new polygon, V3, that is the 'xor' of V1 and V2. |\r\n\r\n**Example**\r\n\r\nSee example in the polyand function description.",
    "summary": "Combines two polygons into one using the Boolean 'xor' operation",
    "syntax": [
      {
        "syntax": "V3 = polyxor(V1,V2);",
        "description": "Returns a new polygon, V3, that is the 'xor' of V1 and V2."
      }
    ],
    "example": ""
  },
  {
    "name": "precision",
    "description": "Truncates a number to the precision specified by the user. The precision is specified by the desired number of significant figures used when rounding the number.",
    "usage": "precision();",
    "category": "general",
    "markdown": "# precision\r\n\r\nTruncates a number to the precision specified by the user. The precision is specified by\r\nthe desired number of significant figures used when rounding the number.\r\n\r\n| **Syntax**             | **Description**                                                                          |\r\n| ---------------------- | ---------------------------------------------------------------------------------------- |\r\n| out = precision (y,p); | Truncates y to a user defined precision p. Where p is the number of significant figures. |\r\n\r\n### Example\r\n\r\nShow different values of ‘pi’ depending on the user defined precision.\r\n\r\n```\r\n?pi;\r\nresult: \r\n3.14159  \r\n?precision(pi,2);\r\nresult: \r\n3.1 \r\n?precision(pi,3);\r\nresult: \r\n3.14 \r\n?precision(pi,4);\r\nresult: \r\n3.142\r\n?precision(pi/100,4);\r\nresult: \r\n0.03142 \r\n```",
    "summary": "Truncates a number to the precision specified by the user",
    "syntax": [
      {
        "syntax": "out = precision (y,p);",
        "description": "Truncates y to a user defined precision p. Where p is the number of significant figures."
      }
    ],
    "example": ""
  },
  {
    "name": "print",
    "description": "Prints a string.",
    "usage": "print();",
    "category": "general",
    "markdown": "# print\r\n\r\nPrints a string.\r\n\r\n| **Syntax**            | **Description**                                  |\r\n| --------------------- | ------------------------------------------------ |\r\n| print(\"hello world\"); | Prints the string defined in the quotation mark. |\r\n\r\n**Examples**\r\n\r\n```\r\na = \"my string\";\r\nprint(a);my string\r\nprint('Hello World!');Hello World!\r\n```",
    "summary": "Prints a string",
    "syntax": [
      {
        "syntax": "print(\"hello world\");",
        "description": "Prints the string defined in the quotation mark."
      }
    ],
    "example": ""
  },
  {
    "name": "probe",
    "description": "Places a probe analyzer at a specified port of a specified element.",
    "usage": "probe();",
    "category": "general",
    "markdown": "# probe\r\n\r\nPlaces a probe analyzer at a specified port of a specified element.\r\n\r\n| **Syntax**             | **Description**                                                    |\r\n| ---------------------- | ------------------------------------------------------------------ |\r\n| probe (\"name\",\"port\"); | Places a probe analyzer at a given element name at the given port. |\r\n\r\n**Example**\r\n\r\n```\r\n#adds a straight waveguide element to the schematic editor and adds a probe to \"port 2\" of it\r\naddelement(\"Straight Waveguide\");\r\nprobe(\"WGD_1\", \"port 2\");\r\n```",
    "summary": "Places a probe analyzer at a specified port of a specified element",
    "syntax": [
      {
        "syntax": "probe (\"name\",\"port\");",
        "description": "Places a probe analyzer at a given element name at the given port."
      }
    ],
    "example": "#adds a straight waveguide element to the schematic editor and adds a probe to \"port 2\" of it\r\naddelement(\"Straight Waveguide\");\r\nprobe(\"WGD_1\", \"port 2\");"
  },
  {
    "name": "prod",
    "description": "Returns the product of elements in a matrix.",
    "usage": "prod();",
    "category": "general",
    "markdown": "# prod\r\n\r\nReturns the product of elements in a matrix.\r\n\r\n| **Syntax**       | **Description**                                               |\r\n| ---------------- | ------------------------------------------------------------- |\r\n| out = prod(x);   | Product of all the elements in matrix x, over all dimensions. |\r\n| out = prod(x,n); | Product elements of x over the specified dimension n.         |\r\n\r\n**Example**\r\n\r\nThis example shows how you can multiply all the elements of a matrix or just the\r\nelements over a specified dimension.\r\n\r\n```\r\n?a = [1,2;3,4]; # define a 2x2 matrix\r\nresult: \r\n1 2 \r\n3 4 \r\n?prod(a); # multiply all elements\r\nresult: \r\n24\r\n?prod(a,2); # muliply over the second dimension only\r\nresult: \r\n2\r\n12\r\n```",
    "summary": "Returns the product of elements in a matrix",
    "syntax": [
      {
        "syntax": "out = prod(x);",
        "description": "Product of all the elements in matrix x, over all dimensions."
      },
      {
        "syntax": "out = prod(x,n);",
        "description": "Product elements of x over the specified dimension n."
      }
    ],
    "example": "?a = [1,2;3,4]; # define a 2x2 matrix\r\nresult: \r\n1 2 \r\n3 4 \r\n?prod(a); # multiply all elements\r\nresult: \r\n24\r\n?prod(a,2); # muliply over the second dimension only\r\nresult: \r\n2\r\n12"
  },
  {
    "name": "propagate",
    "description": "Calculates the resulting mode profile of an arbitrary mode after it has propagated through a waveguide for some distance. This is done by decomposing the mode into modes supported by the waveguide. Each supported mode is then propagated through the waveguide. The resulting modes are then added coherently to give the final mode profile. The modes used in this calculation are obtained from one or more FDE simulations.",
    "usage": "propagate();",
    "category": "general",
    "markdown": "# propagate\r\n\r\nCalculates the resulting mode profile of an arbitrary mode after it has propagated\r\nthrough a waveguide for some distance. This is done by decomposing the mode into modes\r\nsupported by the waveguide. Each supported mode is then propagated through the\r\nwaveguide. The resulting modes are then added coherently to give the final mode profile.\r\nThe modes used in this calculation are obtained from one or more FDE simulations.\r\n\r\nSee the [ overlap ](./overlap.md) function for more details about overlap and coupling\r\ncalculations.\r\n\r\n| **Syntax**                        | **Description** |\r\n| --------------------------------- | --------------- |\r\n| out = propagate(mode, d, n1, n2); |                 |\r\n\r\n- mode: the name of the monitor containing the mode to propagate\r\n- d: distance to propagate\r\n- n1: minimum index\r\n- n2: maximum index\r\n- out: the name of the resulting dataset created by the propagate command\r\n\r\nout = propagate(mode, d, n1, n2, x, y); | Mode alignment can be adjusted before\r\npropagate is calculated.\r\n\r\n- x offset\r\n- y offset\r\n\r\n**Examples**\r\n\r\nThis example is adapted from the polarization_rotator.lsf from\r\n[ polarization rotation](https://optics.ansys.com/hc/en-us/articles/360042799593). You\r\ncan download waveguideA.lms and waveguideB.lms from the\r\n[ polarization rotation](https://optics.ansys.com/hc/en-us/articles/360042799593) page.\r\n\r\nThe following script takes the first mode on the mode list from waveguide A and\r\npropagates this mode in waveguide B a distance of L_rotation. It generates a plot of\r\n|E|^2 for the mode from waveguide A and the mode after propagation in waveguide B.\r\n\r\n```\r\n# find the indices of the top 2 modes of waveguide B  \r\nn1 = getdata(\"mode1\",\"neff\");  \r\nn2 = getdata(\"mode2\",\"neff\");  \r\nlambda_0 = c/getdata(\"mode1\",\"f\");  \r\n\r\n# estimate the propagation length required to rotate polarization  \r\nL_rotation = lambda_0/2/real(n1-n2);  \r\n\r\n# propagate by L_rotation  \r\nmode_L = propagate(\"TE_A\",L_rotation,n1,n2);  \r\n\r\n?getdata(mode_L,\"accounted_transmission\");  \r\nresult:   \r\n0.845998   \r\n\r\n?getdata(mode_L); # to see a list of the available data  \r\nf x y z num_modes Ex Ey Ez Hx  \r\nHy Hz accounted_transmission accounted_reflection \r\n```",
    "summary": "Calculates the resulting mode profile of an arbitrary mode after it has propagated through a wavegui...",
    "syntax": [],
    "example": ""
  },
  {
    "name": "protectproperty",
    "description": "Protects the ‘property’ of a given ‘element’.",
    "usage": "protectproperty();",
    "category": "general",
    "markdown": "# protectproperty\r\n\r\nProtects the ‘property’ of a given ‘element’.\r\n\r\n| **Syntax**                                  | **Description**                                                                                                                                                                                                                     |\r\n| ------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| protectproperty (element,property,protect); | Protects the ‘property’ of a given ‘element’. The argument 'protect' is a boolean value. If ‘protect’ is true the property is protected, if 'protect' is false the property is unprotected. The default value of ‘protect' is true. |\r\n\r\n**Example**\r\n\r\n```\r\ncreatecompound;\r\naddproperty(\"COMPOUND_1\", \"test_property\");\r\nprotectproperty(\"COMPOUND_1\", \"test_property\", 1);\r\n```",
    "summary": "Protects the ‘property’ of a given ‘element’",
    "syntax": [
      {
        "syntax": "protectproperty (element,property,protect);",
        "description": "Protects the ‘property’ of a given ‘element’. The argument 'protect' is a boolean value. If ‘protect’ is true the property is protected, if 'protect' is false the property is unprotected. The default value of ‘protect' is true."
      }
    ],
    "example": "createcompound;\r\naddproperty(\"COMPOUND_1\", \"test_property\");\r\nprotectproperty(\"COMPOUND_1\", \"test_property\", 1);"
  },
  {
    "name": "putremotedata",
    "description": "An interoperability command that will send a variable from the client workspace into the server workspace via an active session. This works for matrices and strings (and not for structs and cell arrays).",
    "usage": "putremotedata();",
    "category": "general",
    "markdown": "# putremotedata\r\n\r\nAn interoperability command that will send a variable from the client workspace into the\r\nserver workspace via an active session. This works for matrices and strings (and not for\r\nstructs and cell arrays).\r\n\r\n| **Syntax**              | **Description**                                                                                                 |\r\n| ----------------------- | --------------------------------------------------------------------------------------------------------------- |\r\n| putremotedata(s,'y',x); | Creates variable y in the server workspace that has value of x in the client workspace via an active session s. |\r\n\r\n### Example\r\n\r\nThe following code example opens Device as a server, sends local variable 'x' to Device\r\nworkspace followed by a command to manipulate the variable and the retrieves the result\r\nbefore closing the session:\r\n\r\n```\r\n#Opend Device session\r\ns2=opensession('device');\r\n#Declare local variable x\r\nx=2;\r\n#Send the local variable to Device workspace via API\r\nputremotedata(s2,'x_device',x);\r\n#Send script command to Device via API andsquare the variable\r\nevalremote(s2,\"y_device=x_device^2;\");\r\n#Get the variable from Device worksapace via API \r\n?y=getremotedata(s2,'y_device');\r\n#Close the session\r\nclosesession(s2);\r\n```",
    "summary": "An interoperability command that will send a variable from the client workspace into the server work...",
    "syntax": [
      {
        "syntax": "putremotedata(s,'y',x);",
        "description": "Creates variable y in the server workspace that has value of x in the client workspace via an active session s."
      }
    ],
    "example": ""
  },
  {
    "name": "pwd",
    "description": "Returns the current working directory.",
    "usage": "pwd();",
    "category": "general",
    "markdown": "# pwd\r\n\r\nReturns the current working directory.\r\n\r\n| **Syntax** | **Description**                                    |\r\n| ---------- | -------------------------------------------------- |\r\n| out = pwd; | Returns the current working directory as a string. |\r\n\r\n**Examples**\r\n\r\nPrints the current working directory to the screen.\r\n\r\n```\r\n?path=pwd;\r\nC:\\demo\r\n```",
    "summary": "Returns the current working directory",
    "syntax": [
      {
        "syntax": "out = pwd;",
        "description": "Returns the current working directory as a string."
      }
    ],
    "example": ""
  },
  {
    "name": "quadtet",
    "description": "Calculates the numerical integral of data on a 3D finite element mesh.",
    "usage": "quadtet();",
    "category": "general",
    "markdown": "# quadtet\r\n\r\nCalculates the numerical integral of data on a 3D finite element mesh.\r\n\r\n| **Syntax**                | **Description**                                                       |\r\n| ------------------------- | --------------------------------------------------------------------- |\r\n| out = quadtet(tet,vtx,u); | outputs a scalar, the integral of u on the finite element mesh, where |\r\n\r\n- tet: the connectivity array, Mx4, containing row entries that index the four vertices\r\n  of M tetrahedra\r\n- vtx: the vertex array, Nx3, containing row entries of (x,y,z) pairs that locate the N\r\n  vertex points\r\n- u: the data on the finite element mesh (Nx1)\r\n\r\n**Example**\r\n\r\nThe following is a simple example that shows how to calculate the approximate integral\r\nof u on a finite element mesh.\r\n\r\n```\r\n# define 8 vertex points in the shape of a cube\r\n# point[#1;#2;#3;#4;#5;#6;#7;#8]\r\nvtx = [1,0,0; 0,0,0; 0,1,0; 1,1,0; 1,0,1; 0,0,1; 0,1,1; 1,1,1];\r\n# make six tetrahedrals from the 8 vertex points, volume=1/6\r\ntet = [1,2,4,8; 1,2,5,8; 2,5,6,8; 2,3,7,8; 2,6,7,8; 2,3,4,8];\r\n# Define result values at each vertex point\r\n# point #1,#2,#3,#4,#5,#6,#7,#8\r\nu=[4, 3.5, 3, 2.5, 2, 1.5, 1, 0.5];\r\n# the result of this integral should be 2.16667\r\n?I = quadtet(tet,vtx,u);\r\nresult: \r\n2.16667 \r\n```",
    "summary": "Calculates the numerical integral of data on a 3D finite element mesh",
    "syntax": [
      {
        "syntax": "out = quadtet(tet,vtx,u);",
        "description": "outputs a scalar, the integral of u on the finite element mesh, where"
      }
    ],
    "example": "# define 8 vertex points in the shape of a cube\r\n# point[#1;#2;#3;#4;#5;#6;#7;#8]\r\nvtx = [1,0,0; 0,0,0; 0,1,0; 1,1,0; 1,0,1; 0,0,1; 0,1,1; 1,1,1];\r\n# make six tetrahedrals from the 8 vertex points, volume=1/6\r\ntet = [1,2,4,8; 1,2,5,8; 2,5,6,8; 2,3,7,8; 2,6,7,8; 2,3,4,8];\r\n# Define result values at each vertex point\r\n# point #1,#2,#3,#4,#5,#6,#7,#8\r\nu=[4, 3.5, 3, 2.5, 2, 1.5, 1, 0.5];\r\n# the result of this integral should be 2.16667\r\n?I = quadtet(tet,vtx,u);\r\nresult: \r\n2.16667"
  },
  {
    "name": "quadtri",
    "description": "Calculates the numerical integral of data collected on a 2D triangle mesh using first order trapezoidal quadrature.",
    "usage": "quadtri();",
    "category": "general",
    "markdown": "# quadtri\r\n\r\nCalculates the numerical integral of data collected on a 2D triangle mesh using first\r\norder trapezoidal quadrature.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                        |\r\n| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = quadtri(tri,vtx,u,n); | Calculates the integral of data collected on triangle mesh. A scalar is returned if the input data corresponds to a scalar quantity and a vector with three components is returned if the input data corresponds to a vector quantity. |\r\n\r\n| **Parameter** |          | **Default value** | **Type** | **Description**                                                                                                                                                                                                                                      |\r\n| ------------- | -------- | ----------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| tri           | required |                   | matrix   | [Mx3] connectivity matrix for the M triangle elements on the mesh.                                                                                                                                                                                   |\r\n| vtx           | required |                   | matrix   | [Nx2] or [Nx3] matrix containing the (x,y,z) coordinates of the N vertices of the mesh. If the matrix has only two columns, the z coordinate is assumed to be zero.                                                                                  |\r\n| u             | required |                   | matrix   | [Nx1] or [Nx3] matrix containing the data to be integrated at the location of each vertex. If the matrix is of size [Nx1], the data is assumed to be a scalar quantity. If the matrix is of size [Nx3], the data is assumed to be a vector quantity. |\r\n| n             | optional | empty             | matrix   | [Mx3] matrix with the surface normal vectors for each of the M triangles on the mesh. The columns correspond to the (x,y,z) components of each vector. This input is required only if the data to be integrated is a vector quantity.                |\r\n\r\n**Example**\r\n\r\nThe following example finds the approximate integral of u on a finite element mesh.\r\n\r\n```\r\n# define 4 vertices in the shape of a rectangle, \r\n#point[#1;#2;#3;#4]\r\nvtx = [0,0; 4,0; 4,3; 0,3];\r\n# make two triangles (#1,#2,#4) and (#2,#3,#4) with area = 6\r\ntri = [1,2,4; 2,3,4];\r\n# Define result values at each vertex point, \r\n#point #1, #2, #3, #4\r\nu=[4,3,2,0];\r\n# the result of this integral should be \r\n# ((4+3+0)/3 + (3+2+0)/3)*6 = 24\r\n?I = quadtri(tri,vtx,u);\r\nresult: \r\n24 \r\n```",
    "summary": "Calculates the numerical integral of data collected on a 2D triangle mesh using first order trapezoi...",
    "syntax": [
      {
        "syntax": "out = quadtri(tri,vtx,u,n);",
        "description": "Calculates the integral of data collected on triangle mesh. A scalar is returned if the input data corresponds to a scalar quantity and a vector with three components is returned if the input data corresponds to a vector quantity."
      }
    ],
    "example": "# define 4 vertices in the shape of a rectangle, \r\n#point[#1;#2;#3;#4]\r\nvtx = [0,0; 4,0; 4,3; 0,3];\r\n# make two triangles (#1,#2,#4) and (#2,#3,#4) with area = 6\r\ntri = [1,2,4; 2,3,4];\r\n# Define result values at each vertex point, \r\n#point #1, #2, #3, #4\r\nu=[4,3,2,0];\r\n# the result of this integral should be \r\n# ((4+3+0)/3 + (3+2+0)/3)*6 = 24\r\n?I = quadtri(tri,vtx,u);\r\nresult: \r\n24"
  },
  {
    "name": "rand",
    "description": "Generates a uniform random number between 0 and 1. In order to reset the generator seed use the command randreset.",
    "usage": "rand();",
    "category": "general",
    "markdown": "# rand\r\n\r\nGenerates a uniform random number between 0 and 1. In order to reset the generator seed\r\nuse the command randreset.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                     |\r\n| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = rand;                 | Generates a uniform random number between 0 and 1.                                                                                  |\r\n| out = rand(min,max);        | Generates a random number between min and max. By default, min and max are 0 and 1 respectively.                                    |\r\n| out = rand(min,max,option); | option = 1: output is a double precision number between min and max (default) option = 2: output is an integer between min and max. |\r\n\r\n**Example**\r\n\r\nSimple examples of the output of rand.\r\n\r\n```\r\n?rand;\r\nresult: \r\n0.528733 \r\n?rand(0,10,1);\r\nresult: \r\n9.33399  \r\n?rand(0,10,2);\r\nresult: \r\n5 \r\n```\r\n\r\nGenerate two Gaussian random numbers (Y1 and Y2) using the polar form of the Box Muller\r\ntransform.\r\n\r\n```\r\n# choose mean and variance\r\nmean_value = 0;\r\nvariance_value = 1;\r\nw=1;\r\nfor(0;(w>1)|(w==1);0){ # while w>=1\r\n  x1 = 2*rand - 1;\r\n  x2 = 2*rand - 1;\r\n  w = x1^2 + x2^2;\r\n}\r\nw = sqrt( (-2*log( w ) ) / w );\r\ny1 = x1 * w;\r\ny2 = x2 * w;\r\n?Y1 = mean_value + sqrt(variance_value) * y1;\r\n?Y2 = mean_value + sqrt(variance_value) * y2;\r\nresult: \r\n0.198101  \r\nresult: \r\n-2.05023   \r\n```",
    "summary": "Generates a uniform random number between 0 and 1",
    "syntax": [
      {
        "syntax": "out = rand;",
        "description": "Generates a uniform random number between 0 and 1."
      },
      {
        "syntax": "out = rand(min,max);",
        "description": "Generates a random number between min and max. By default, min and max are 0 and 1 respectively."
      },
      {
        "syntax": "out = rand(min,max,option);",
        "description": "option = 1: output is a double precision number between min and max (default) option = 2: output is an integer between min and max."
      }
    ],
    "example": "?rand;\r\nresult: \r\n0.528733 \r\n?rand(0,10,1);\r\nresult: \r\n9.33399  \r\n?rand(0,10,2);\r\nresult: \r\n5"
  },
  {
    "name": "randmatrix",
    "description": "Initialize a matrix. All elements are random numbers between 0 and 1.",
    "usage": "randmatrix();",
    "category": "general",
    "markdown": "# randmatrix\r\n\r\nInitialize a matrix. All elements are random numbers between 0 and 1.\r\n\r\n| **Syntax**                  | **Description**                                                                              |\r\n| --------------------------- | -------------------------------------------------------------------------------------------- |\r\n| x = randmatrix(i,j,k,....); | Initializes an i x j x k x .... matrix. The elements are all random numbers between 0 and 1. |\r\n\r\n**Examples**\r\n\r\n```\r\n?x=randmatrix(2,2,2);\r\nresult(i,j,1):\r\n0.202368 0.503983 \r\n0.570605 0.89404 \r\nresult(i,j,2):\r\n0.740623 0.669118 \r\n0.888394 0.295022  \r\n```",
    "summary": "Initialize a matrix",
    "syntax": [
      {
        "syntax": "x = randmatrix(i,j,k,....);",
        "description": "Initializes an i x j x k x .... matrix. The elements are all random numbers between 0 and 1."
      }
    ],
    "example": ""
  },
  {
    "name": "randn",
    "description": "Generates a normally distributed random number. In order to reset the generator seed use the command randreset.",
    "usage": "randn();",
    "category": "general",
    "markdown": "# randn\r\n\r\nGenerates a normally distributed random number. In order to reset the generator seed use\r\nthe command randreset.\r\n\r\n| **Syntax**                | **Description**                                                                                     |\r\n| ------------------------- | --------------------------------------------------------------------------------------------------- |\r\n| out = randn;              | Generates a normally distributed random number with mean 0 and standard deviation 1.                |\r\n| out = randn(mean,stddev); | Generates a normally distributed random number with user defined mean value and standard deviation. |\r\n\r\n**Example**\r\n\r\nThis example shows how to create an histogram of a normal distribution.\r\n\r\n```\r\nn = 1000;\r\ny = matrix(n);\r\nmean_val = 1;\r\nstd_dev = 0.25;\r\nfor (i=1:n){\r\n    y(i) = randn(mean_val, std_dev);\r\n}\r\nhistc(y);\r\n```\r\n\r\nThe histogram will look similar to the following one.",
    "summary": "Generates a normally distributed random number",
    "syntax": [
      {
        "syntax": "out = randn;",
        "description": "Generates a normally distributed random number with mean 0 and standard deviation 1."
      },
      {
        "syntax": "out = randn(mean,stddev);",
        "description": "Generates a normally distributed random number with user defined mean value and standard deviation."
      }
    ],
    "example": "n = 1000;\r\ny = matrix(n);\r\nmean_val = 1;\r\nstd_dev = 0.25;\r\nfor (i=1:n){\r\n    y(i) = randn(mean_val, std_dev);\r\n}\r\nhistc(y);"
  },
  {
    "name": "randnmatrix",
    "description": "Initialize a matrix. All elements are normally distributed random numbers with mean 0 and standard distribution 1.",
    "usage": "randnmatrix();",
    "category": "general",
    "markdown": "# randnmatrix\r\n\r\nInitialize a matrix. All elements are normally distributed random numbers with mean 0\r\nand standard distribution 1.\r\n\r\n| **Syntax**                   | **Description**                                                                                                                        |\r\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\r\n| x = randnmatrix(i,j,k,....); | Initializes an i x j x k x .... matrix. The elements are all random normally distributed numbers with mean 0 and standard deviation 1. |",
    "summary": "Initialize a matrix",
    "syntax": [
      {
        "syntax": "x = randnmatrix(i,j,k,....);",
        "description": "Initializes an i x j x k x .... matrix. The elements are all random normally distributed numbers with mean 0 and standard deviation 1."
      }
    ],
    "example": ""
  },
  {
    "name": "read",
    "description": "Reads data from a text file as a string. The supported file format is ASCII.",
    "usage": "read();",
    "category": "general",
    "markdown": "# read\r\n\r\nReads data from a text file as a string. The supported file format is ASCII.\r\n\r\n| **Syntax**            | **Description**                                                                                                                                                                                                                                                                                                                |\r\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| read(filename, size); | Read a text file as a string for the user defined size 'size'. The default value for size is 1e+6, if not specified. Note: This function will check for the file in the current working directory. If the file to read from is in a different directory, either specify the full path or change the current working directory. |\r\n\r\n**Note** : This command cannot be used while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Examples**\r\n\r\nIf you have a text file called testfile.txt with the following strings:\r\n\r\nString saved in text file\r\n\r\n```\r\nM=read(\"testfile.txt\");\r\n\r\n\r\n?M;\r\nString saved in text file\r\n```",
    "summary": "Reads data from a text file as a string",
    "syntax": [
      {
        "syntax": "read(filename, size);",
        "description": "Read a text file as a string for the user defined size 'size'. The default value for size is 1e+6, if not specified. Note: This function will check for the file in the current working directory. If the file to read from is in a different directory, either specify the full path or change the current working directory."
      }
    ],
    "example": ""
  },
  {
    "name": "readdata",
    "description": "Reads a file with data in a row/column format. User can import numerical values stored in text files with the readdata command. The data must be correctly formatted so each row has the same number of columns. Readdata will ignore any line that begins with a letter. The supported file format is ASCII.",
    "usage": "readdata();",
    "category": "general",
    "markdown": "# readdata\r\n\r\nReads a file with data in a row/column format. User can import numerical values stored\r\nin text files with the readdata command. The data must be correctly formatted so each\r\nrow has the same number of columns. Readdata will ignore any line that begins with a\r\nletter. The supported file format is ASCII.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                                                                                  |\r\n| --------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| M=readdata(\"filename.txt\"); | Will load the text file filename into matrix variable M. Any lines starting with a letter are ignored. Note: This function will check for the file in the current working directory. If the file to read from is in a different directory, either specify the full path or change the current working directory. |\r\n\r\n**Examples**\r\n\r\nIf you have a text file called testfile.txt with the following data:\r\n\r\nTime Value\r\n\r\n0.0 3.2e-6\r\n\r\n1.0 2.8e10\r\n\r\n2.0 4.1e5\r\n\r\n3.0 3.3\r\n\r\nThe first rows contains the column headers, and the next four rows contain data. In this\r\ncase, readdata will ignore the first line, and import the data as a 4x2 matrix.\r\n\r\n```\r\nM=readdata(\"testfile.txt\");\r\n?M;\r\nresult: \r\n0 3.2e-006 \r\n1 2.8e+010 \r\n2 4.1e+005 \r\n3 3.3 \r\n```",
    "summary": "Reads a file with data in a row/column format",
    "syntax": [
      {
        "syntax": "M=readdata(\"filename.txt\");",
        "description": "Will load the text file filename into matrix variable M. Any lines starting with a letter are ignored. Note: This function will check for the file in the current working directory. If the file to read from is in a different directory, either specify the full path or change the current working directory."
      }
    ],
    "example": ""
  },
  {
    "name": "readnportsparameterat",
    "description": "Interpolates the [S-Parameter sweep](https://optics.ansys.com/hc/en-us/articles/360036107934-The-S-parameter-sweep) file with the specified parameter values.",
    "usage": "readnportsparameterat();",
    "category": "general",
    "markdown": "# readnportsparameterat\r\n\r\nInterpolates the\r\n[S-Parameter sweep](https://optics.ansys.com/hc/en-us/articles/360036107934-The-S-parameter-sweep)\r\nfile with the specified parameter values.\r\n\r\n| **Syntax**                                             | **Description**                                                                                                                                                                                                                                                                                                                                             |\r\n| ------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| M = readnportsparameterat(“filename”, sweep_param)     | Interpolates the S-Parameter sweep file with the specified parameter values, using the spline interpolation method. filename: S-Parameter sweep file. sweep_param: specified sweep parameters, usually in the format of a matrix.                                                                                                                           |\r\n| M = readnportsparameterat“filename”, sweep_param, opt) | Interpolates the S-Parameter sweep file with the specified parameter values, using interpolation options set in the structure named opt. filename: S-Parameter sweep file. sweep_param: specified sweep parameters, usually in the format of a matrix. opt: Structure setting interpolation options. The structure fields are described in the table below. |\r\n\r\nThe option structure has the following fields, the spelling of each field is\r\ncase-sensitive.\r\n\r\n| **Field** | **Description**                                                         |\r\n| --------- | ----------------------------------------------------------------------- |\r\n| method    | The method used for interpolation. The following options are supported: |\r\n\r\n- spline: Spline interpolation method, this is the default method.\r\n- Geodesic: Geodesic interpolation method which ensures smooth transitions. When\r\n  geodesic interpolation is selected, a similarity check is performed on original data\r\n  points near the interpolated point used for the interpolation, if these points are not\r\n  sufficiently similar, the data is coarse and a warning is displayed. This method\r\n  cannot be used for extrapolation.\r\n\r\npassivity | Whether passivity is enforced for the s-parameter data prior to\r\ninterpolation. This field only affects results when “geodesic” is selected as the\r\ninterpolation method. When data is non-passive, a warning message is always displayed.\r\nThe following options are supported:\r\n\r\n- enforce: Ensures S-matrix is passive by making sure that the induced 2-norm of the\r\n  s-parameters is less than 1. This is the default method.\r\n- ignore: Ignores passivity of the s-parameters and interpolates as-is.\r\n\r\n**Note** : For more information on how passivity is enforced, see this\r\n[Knowledge Base](https://optics.ansys.com/hc/en-us/articles/360059772393-S-parameter-passive-workflow-guide#toc_4)\r\narticle.\r\n\r\n**Example**\r\n\r\nThe following script interpolates the S-Parameter file \" coupler_s_parameter_sweep.txt \"\r\nwith the specified parameters that defined in a matrix named \"sweep_param\". Then this\r\ninterpolated s-parameter can be assigned to a s-parameter element.\r\n\r\n```\r\n#Here, the variables radius, Lc, and gap has been set previously  \r\nsweep_param = matrix( 3 );  \r\nsweep_param(1)=radius;  \r\nsweep_param(2)=Lc;  \r\nsweep_param(3)=gap;  \r\n?M = readnportsparameterat(\"coupler_s_parameter_sweep.txt\", sweep_param );\r\n```\r\n\r\nThe following script interpolates the same S-Parameter file, but with the geodesic\r\noption and ignoring passivity.\r\n\r\n```\r\n?M = readnportsparameterat(\"coupler_s_parameter_sweep.txt\", sweep_param, {\"method\":\"geodesic\", \"passivity\":\"ignore\"});\r\n```",
    "summary": "Interpolates the [S-Parameter sweep](https://optics",
    "syntax": [
      {
        "syntax": "M = readnportsparameterat(“filename”, sweep_param)",
        "description": "Interpolates the S-Parameter sweep file with the specified parameter values, using the spline interpolation method. filename: S-Parameter sweep file. sweep_param: specified sweep parameters, usually in the format of a matrix."
      },
      {
        "syntax": "M = readnportsparameterat“filename”, sweep_param, opt)",
        "description": "Interpolates the S-Parameter sweep file with the specified parameter values, using interpolation options set in the structure named opt. filename: S-Parameter sweep file. sweep_param: specified sweep parameters, usually in the format of a matrix. opt: Structure setting interpolation options. The structure fields are described in the table below."
      }
    ],
    "example": "#Here, the variables radius, Lc, and gap has been set previously  \r\nsweep_param = matrix( 3 );  \r\nsweep_param(1)=radius;  \r\nsweep_param(2)=Lc;  \r\nsweep_param(3)=gap;  \r\n?M = readnportsparameterat(\"coupler_s_parameter_sweep.txt\", sweep_param );"
  },
  {
    "name": "readstltriangles",
    "description": "Imports a matrix of vertex positions from an STL file.",
    "usage": "readstltriangles();",
    "category": "general",
    "markdown": "# readstltriangles\r\n\r\nImports a matrix of vertex positions from an STL file.\r\n\r\n| **Syntax**                                           | **Description**                                                                                                                                                                                                                                     |\r\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=readstltriangles(\"filename.stl\",scaling_factor); | Returns an Mx3 matrix with vertices from all STL triangles from the specified STL file. scaling_factor: An STL file does not contain unit data. To import data in units of microns, set this value to 1e-6. For nanometers, set this value to 1e-9. |\r\n\r\n**Example**\r\n\r\nThe following script command will read the STL file named \"sample_file.stl\" and save the\r\nvertex positions assuming units of micron.\r\n\r\n```\r\nvtx = readstltriangles(\"sample_file.stl\",1e-6);\r\n```",
    "summary": "Imports a matrix of vertex positions from an STL file",
    "syntax": [
      {
        "syntax": "out=readstltriangles(\"filename.stl\",scaling_factor);",
        "description": "Returns an Mx3 matrix with vertices from all STL triangles from the specified STL file. scaling_factor: An STL file does not contain unit data. To import data in units of microns, set this value to 1e-6. For nanometers, set this value to 1e-9."
      }
    ],
    "example": "vtx = readstltriangles(\"sample_file.stl\",1e-6);"
  },
  {
    "name": "real",
    "description": "Returns the real part of a number or matrix.",
    "usage": "real();",
    "category": "general",
    "markdown": "# real\r\n\r\nReturns the real part of a number or matrix.\r\n\r\n| **Syntax**     | **Description**             |\r\n| -------------- | --------------------------- |\r\n| out = real(x); | Returns the real part of x. |\r\n\r\n**Example**\r\n\r\nCalculate the real part of numbers in an array.\r\n\r\n```\r\n?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?real(x);\r\nresult: \r\n0 \r\n2 \r\n```",
    "summary": "Returns the real part of a number or matrix",
    "syntax": [
      {
        "syntax": "out = real(x);",
        "description": "Returns the real part of x."
      }
    ],
    "example": "?x=linspace(0, 2+1i,2);\r\nresult: \r\n0+0i \r\n2+1i \r\n?real(x);\r\nresult: \r\n0 \r\n2"
  },
  {
    "name": "rectilineardataset",
    "description": "Creates an empty rectilinear dataset that is associate with the x/y/z coordinates (ex. E and H fields). Like matrix datasets, rectilinear datasets can be parameterized, and can contain an arbitrary number of attributes (see [addattribute)](./addattribute.md) and parameters (see [addparameter)](./addparameter.md).",
    "usage": "rectilineardataset();",
    "category": "general",
    "markdown": "# rectilineardataset\r\n\r\nCreates an empty rectilinear dataset that is associate with the x/y/z coordinates (ex. E\r\nand H fields). Like matrix datasets, rectilinear datasets can be parameterized, and can\r\ncontain an arbitrary number of attributes (see [addattribute)](./addattribute.md) and\r\nparameters (see [addparameter)](./addparameter.md).\r\n\r\nSee\r\n[Dataset introduction](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets)\r\nfor more information.\r\n\r\nFor datasets that are not associated with the x/y/z coordinates (ex. transmission as a\r\nfunction of frequency), see [ matrixdataset](./matrixdataset.md).\r\n\r\n| **Syntax**                                | **Description**                                                                                                                                                                                                     |\r\n| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| rectilineardataset(x,y,z);                | Creates a empty rectilinear dataset associated with the coordinates x/y/z. Arguments 'x', 'y' and 'z' may be different lengths and the total number of points is the product of their lengths.                      |\r\n| rectilineardataset(\"dataset_name\",x,y,z); | Creates a empty rectilinear dataset named \"dataset_name\" associated with the coordinates x/y/z. Arguments 'x', 'y' and 'z' may be different lengths and the total number of points is the product of their lengths. |\r\n\r\n**Examples**\r\n\r\nThis example creates a rectilinear dataset (with the name \"Absorption\") that contains 2\r\ndata attributes: the power absorption Pabs, and the refractive index n. Both attributes\r\nare a function of the spatial parameters x/y/z and frequency 'f'. To allow the user to\r\naccess the frequency parameter in terms of frequency or wavelength , both frequency (f)\r\nand wavelength (c/f) are added as interdependent parameters.\r\n\r\n```\r\nAbsorption = rectilineardataset(\"Absorption\",x,y,z);\r\nAbsorption.addparameter(\"lambda\",c/f,\"f\",f);\r\nAbsorption.addattribute(\"Pabs\",Pabs);\r\nAbsorption.addattribute(\"refractive index\",n);\r\nvisualize(Absorption); # visualize this dataset in the Visualizer\r\n```\r\n\r\nThe following script code shows how to get the raw data from a frequency monitor in FDTD\r\n(using getdata), and how to manually create a dataset from that data. It also shows how\r\nto directly get the electric field dataset from the monitor in a single command (using\r\ngetresult).\r\n\r\n```\r\n# monitor name\r\nm=\"monitor\";\r\n# get individual data elements with getdata\r\nx=getdata(m,\"x\");\r\ny=getdata(m,\"y\");\r\nz=getdata(m,\"z\");\r\nf=getdata(m,\"f\");\r\nEx=getdata(m,\"Ex\");\r\nEy=getdata(m,\"Ey\");\r\nEz=getdata(m,\"Ez\");\r\n# create the electric field dataset from the raw data\r\nE_manual = rectilineardataset(\"E_manual\",x,y,z);  # initialize dataset and provide spatial position vectors\r\nE_manual.addparameter(\"lambda\",c/f,\"f\",f);  # add additional parameter: frequency \r\nE_manual.addattribute(\"E\",Ex,Ey,Ez);     # add vector electric field attribute\r\n# all of the above commands can be avoided with a single getresult command\r\nE_fromMonitor = getresult(m,\"E\");\r\n```\r\n\r\nThe following script code shows how to access the data stored in the 'E_manual' dataset\r\ncreated in the above example\r\n\r\n```\r\n# output contents of dataset to prompt\r\n?E_manual;\r\n# Get parameters\r\nx   = E_manual.x;\r\ny   = E_manual.y;\r\nz   = E_manual.z;\r\nf   = E_manual.f;\r\nlambda = E_manual.lambda;\r\nx_1  = E_manual.x(1); \r\n# Get attributes. Remember that E is a vector quantity\r\nEx = E_manual.Ex; # Ex component\r\nEy = E_manual.Ey; # Ey component\r\nEz = E_manual.Ez; # Ez component\r\nE2 = E_manual.E2; # |E|^2\r\nE = E_manual.E;  # get all components in a single matrix. An extra dimension of length 3 will be added to the matrix, for each vector component.\r\n```",
    "summary": "Creates an empty rectilinear dataset that is associate with the x/y/z coordinates (ex",
    "syntax": [
      {
        "syntax": "rectilineardataset(x,y,z);",
        "description": "Creates a empty rectilinear dataset associated with the coordinates x/y/z. Arguments 'x', 'y' and 'z' may be different lengths and the total number of points is the product of their lengths."
      },
      {
        "syntax": "rectilineardataset(\"dataset_name\",x,y,z);",
        "description": "Creates a empty rectilinear dataset named \"dataset_name\" associated with the coordinates x/y/z. Arguments 'x', 'y' and 'z' may be different lengths and the total number of points is the product of their lengths."
      }
    ],
    "example": ""
  },
  {
    "name": "redo",
    "description": "Redos a command after a previous [undo](./undo.md).",
    "usage": "redo();",
    "category": "general",
    "markdown": "# redo\r\n\r\nRedos a command after a previous [undo](./undo.md).\r\n\r\n| **Syntax** | **Description**                                                           |\r\n| ---------- | ------------------------------------------------------------------------- |\r\n| redo;      | Redo command after previous undo. This function does not return any data. |",
    "summary": "Redos a command after a previous [undo](",
    "syntax": [
      {
        "syntax": "redo;",
        "description": "Redo command after previous undo. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "redraw",
    "description": "Forces the graphical viewports of the CAD or the schematic layout drawing to update. The viewports update automatically by default, so this command is only required after using the redrawoff command.",
    "usage": "redraw();",
    "category": "general",
    "markdown": "# redraw\r\n\r\nForces the graphical viewports of the CAD or the schematic layout drawing to update. The\r\nviewports update automatically by default, so this command is only required after using\r\nthe redrawoff command.\r\n\r\n| **Syntax** | **Description**                                           |\r\n| ---------- | --------------------------------------------------------- |\r\n| redraw;    | Redraws graphics. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThis example shows how to add objects more quickly by disabling the automatic redrawing.\r\nThe following FOR loop will run much faster when the automatic redrawing is disabled.\r\n\r\n```\r\nredrawoff;    # disable automatic redrawing\r\nfor (i=1:1000) { # add 1000 objects\r\n addcircle;\r\n set(\"radius\",100e-9); \r\n set(\"x\",i*1e-8);\r\n if (i==500) {\r\n  redraw;   # force one redraw half way through loop\r\n }\r\n}\r\nredrawon;     # enable automatic redrawing\r\n```",
    "summary": "Forces the graphical viewports of the CAD or the schematic layout drawing to update",
    "syntax": [
      {
        "syntax": "redraw;",
        "description": "Redraws graphics. This function does not return any data."
      }
    ],
    "example": "redrawoff;    # disable automatic redrawing\r\nfor (i=1:1000) { # add 1000 objects\r\n addcircle;\r\n set(\"radius\",100e-9); \r\n set(\"x\",i*1e-8);\r\n if (i==500) {\r\n  redraw;   # force one redraw half way through loop\r\n }\r\n}\r\nredrawon;     # enable automatic redrawing"
  },
  {
    "name": "redrawmode",
    "description": "This command can be used to determine the current status of automatic redrawing. It can also be used to set the current status of automatic redrawing. The graphics will be redrawn after any script command that may change the properties of a graphical object.",
    "usage": "redrawmode();",
    "category": "general",
    "markdown": "# redrawmode\r\n\r\nThis command can be used to determine the current status of automatic redrawing. It can\r\nalso be used to set the current status of automatic redrawing. The graphics will be\r\nredrawn after any script command that may change the properties of a graphical object.\r\n\r\n| **Syntax**        | **Description**                                                |\r\n| ----------------- | -------------------------------------------------------------- |\r\n| out = redrawmode; | The value of out indicates if automatic redrawing is off or on |\r\n\r\n- out=1: automatic redrawing is on\r\n- out=0: automatic redrawing is off\r\n\r\nout = redrawmode(in); | Set the automatic redrawing off or on. To turn it on, use in=1.\r\nTo turn it off, use in=0. The value of out is set after executing the command so that\r\nout=in once this command has been executed.\r\n\r\n**Example**\r\n\r\nThis example uses redrawmode to turn automatic redrawing off, then restore automatic\r\nredrawing to the state it had before executing this script.\r\n\r\n```\r\nredraw_state = redrawmode;\r\nredrawoff;\r\nfor(i=1:60) {\r\n  addcircle;\r\n  set(\"x\",i*1e-6);\r\n}\r\nredrawmode(redraw_state);\r\n```",
    "summary": "This command can be used to determine the current status of automatic redrawing",
    "syntax": [
      {
        "syntax": "out = redrawmode;",
        "description": "The value of out indicates if automatic redrawing is off or on"
      }
    ],
    "example": "redraw_state = redrawmode;\r\nredrawoff;\r\nfor(i=1:60) {\r\n  addcircle;\r\n  set(\"x\",i*1e-6);\r\n}\r\nredrawmode(redraw_state);"
  },
  {
    "name": "redrawoff",
    "description": "Disables automatic updating of the graphical viewports in the CAD or the schematic layout drawing. This can greatly increase the speed of scripts that add large numbers of objects.",
    "usage": "redrawoff();",
    "category": "general",
    "markdown": "# redrawoff\r\n\r\nDisables automatic updating of the graphical viewports in the CAD or the schematic\r\nlayout drawing. This can greatly increase the speed of scripts that add large numbers of\r\nobjects.\r\n\r\n| **Syntax** | **Description**                                                                                                                                                     |\r\n| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| redrawoff; | Prevents redrawing of graphics. This function does not return any data. Cannot use this command in group setup scripts since redrawing is automatically turned off. |\r\n\r\n**Example**\r\n\r\nThis example shows how to add objects more quickly by disabling the automatic redrawing.\r\nThe following FOR loop will run much faster when the automatic redrawing is disabled.\r\n\r\n```\r\nredrawoff;    # disable automatic redrawing\r\nfor (i=1:1000) { # add 1000 objects\r\n addcircle;\r\n set(\"radius\",100e-9); \r\n set(\"x\",i*1e-8);\r\n if (i==500) {\r\n  redraw;   # force one redraw half way through loop\r\n }\r\n}\r\nredrawon;     # enable automatic redrawing\r\n```",
    "summary": "Disables automatic updating of the graphical viewports in the CAD or the schematic layout drawing",
    "syntax": [
      {
        "syntax": "redrawoff;",
        "description": "Prevents redrawing of graphics. This function does not return any data. Cannot use this command in group setup scripts since redrawing is automatically turned off."
      }
    ],
    "example": "redrawoff;    # disable automatic redrawing\r\nfor (i=1:1000) { # add 1000 objects\r\n addcircle;\r\n set(\"radius\",100e-9); \r\n set(\"x\",i*1e-8);\r\n if (i==500) {\r\n  redraw;   # force one redraw half way through loop\r\n }\r\n}\r\nredrawon;     # enable automatic redrawing"
  },
  {
    "name": "redrawon",
    "description": "Enables automatic updating of the graphical viewports in the CAD or the schematic layout drawing. Automatic updating is the default behavior, so this command is only required after using the redrawoff command.",
    "usage": "redrawon();",
    "category": "general",
    "markdown": "# redrawon\r\n\r\nEnables automatic updating of the graphical viewports in the CAD or the schematic layout\r\ndrawing. Automatic updating is the default behavior, so this command is only required\r\nafter using the redrawoff command.\r\n\r\n| **Syntax** | **Description**                                                  |\r\n| ---------- | ---------------------------------------------------------------- |\r\n| redrawon;  | Turns redrawing back on. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThis example shows how to add objects more quickly by disabling the automatic redrawing.\r\nThe following FOR loop will run much faster when the automatic redrawing is disabled.\r\n\r\n```\r\nredrawoff;    # disable automatic redrawing\r\nfor (i=1:1000) { # add 1000 objects\r\n addcircle;\r\n set(\"radius\",100e-9); \r\n set(\"x\",i*1e-8);\r\n if (i==500) {\r\n  redraw;   # force one redraw half way through loop\r\n }\r\n}\r\nredrawon;     # enable automatic redrawing\r\n```",
    "summary": "Enables automatic updating of the graphical viewports in the CAD or the schematic layout drawing",
    "syntax": [
      {
        "syntax": "redrawon;",
        "description": "Turns redrawing back on. This function does not return any data."
      }
    ],
    "example": "redrawoff;    # disable automatic redrawing\r\nfor (i=1:1000) { # add 1000 objects\r\n addcircle;\r\n set(\"radius\",100e-9); \r\n set(\"x\",i*1e-8);\r\n if (i==500) {\r\n  redraw;   # force one redraw half way through loop\r\n }\r\n}\r\nredrawon;     # enable automatic redrawing"
  },
  {
    "name": "refresh",
    "description": "This command reloads the current project.",
    "usage": "refresh();",
    "category": "general",
    "markdown": "# refresh\r\n\r\nThis command reloads the current project.\r\n\r\n| **Syntax** | **Description**                                                                                                                                                                                                                                                                               |\r\n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| refresh;   | Reloads the current project. This is particularly useful when changing the ‘library’ property of a reference element. Reference elements must be manually ‘refreshed’ or reloaded if the ‘library’ property is modified – otherwise the use will have to save and reload the current project. |\r\n\r\n### Example\r\n\r\n```\r\n>setnamed(\"WG_1\",\"library\",\"::design kits::pdaflow\");\r\n>refresh;\r\n```",
    "summary": "This command reloads the current project",
    "syntax": [
      {
        "syntax": "refresh;",
        "description": "Reloads the current project. This is particularly useful when changing the ‘library’ property of a reference element. Reference elements must be manually ‘refreshed’ or reloaded if the ‘library’ property is modified – otherwise the use will have to save and reload the current project."
      }
    ],
    "example": ""
  },
  {
    "name": "reloaddesignkit",
    "description": "Reloads the contents of a design kit from the element library ‘Design kits’ folder.",
    "usage": "reloaddesignkit();",
    "category": "general",
    "markdown": "# reloaddesignkit\r\n\r\nReloads the contents of a design kit from the element library ‘Design kits’ folder.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                                                                      |\r\n| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| reloaddesignkit (\"name\", [\"version\"]); | Reloads the contents of a design kit named ‘name’ from the element library ‘Design kits’ folder with the version 'version'. \"version\" is optional and by default is an empty string. |\r\n\r\n**Example**\r\n\r\n```\r\n#reloads the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\nreloaddesignkit(\"LCML\", \"v1.1\");\r\n```",
    "summary": "Reloads the contents of a design kit from the element library ‘Design kits’ folder",
    "syntax": [
      {
        "syntax": "reloaddesignkit (\"name\", [\"version\"]);",
        "description": "Reloads the contents of a design kit named ‘name’ from the element library ‘Design kits’ folder with the version 'version'. \"version\" is optional and by default is an empty string."
      }
    ],
    "example": "#reloads the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\nreloaddesignkit(\"LCML\", \"v1.1\");"
  },
  {
    "name": "removecustom",
    "description": "Removes a folder in the Custom folder in Element Library.",
    "usage": "removecustom();",
    "category": "general",
    "markdown": "# removecustom\r\n\r\nRemoves a folder in the Custom folder in Element Library.\r\n\r\n| **Syntax**                  | **Description**                                                                                 |\r\n| --------------------------- | ----------------------------------------------------------------------------------------------- |\r\n| removecustom(\"foldername\"); | Removes a folder with the name specified by foldername in the Custom folder in Element Library. |\r\n\r\n**Example**\r\n\r\n```\r\n#removes the folder \"new folder\" in the Custom folder in Element Library\r\nremovecustom(\"new folder\");\r\n```",
    "summary": "Removes a folder in the Custom folder in Element Library",
    "syntax": [
      {
        "syntax": "removecustom(\"foldername\");",
        "description": "Removes a folder with the name specified by foldername in the Custom folder in Element Library."
      }
    ],
    "example": "#removes the folder \"new folder\" in the Custom folder in Element Library\r\nremovecustom(\"new folder\");"
  },
  {
    "name": "removedesignkit",
    "description": "Removes an existing design kit from the element library ‘Design kits’ folder.",
    "usage": "removedesignkit();",
    "category": "general",
    "markdown": "# removedesignkit\r\n\r\nRemoves an existing design kit from the element library ‘Design kits’ folder.\r\n\r\n| **Syntax**                            | **Description**                                                                                                                                                      |\r\n| ------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| removedesignkit(\"name\", [\"version\"]); | Removes a design kit named ‘name’ from the element library ‘Design kits’ folder with the version 'version'. \"version\" is optional and by default is an empty string. |\r\n\r\n**Example**\r\n\r\n```\r\n#removes the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\nremovedesignkit(\"LCML\", \"v1.1\");\r\n```",
    "summary": "Removes an existing design kit from the element library ‘Design kits’ folder",
    "syntax": [
      {
        "syntax": "removedesignkit(\"name\", [\"version\"]);",
        "description": "Removes a design kit named ‘name’ from the element library ‘Design kits’ folder with the version 'version'. \"version\" is optional and by default is an empty string."
      }
    ],
    "example": "#removes the design kit \"LCML\" with version v1.1 from the element library ‘Design kits’ folder\r\nremovedesignkit(\"LCML\", \"v1.1\");"
  },
  {
    "name": "removeexpansion",
    "description": "Removes a DFT monitor from a mode expansion monitor.",
    "usage": "removeexpansion();",
    "category": "general",
    "markdown": "# removeexpansion\r\n\r\nRemoves a DFT monitor from a mode expansion monitor.\r\n\r\n| **Syntax**               | **Description**                                                                                                                |\r\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| removeexpansion(\"name\"); | Removes the DFT monitor with the specified name from the \"Monitors for expansion\" list of the selected mode expansion monitor. |\r\n\r\n**Example**\r\n\r\nRefer to the [setexpansion](./setexpansion.md) command",
    "summary": "Removes a DFT monitor from a mode expansion monitor",
    "syntax": [
      {
        "syntax": "removeexpansion(\"name\");",
        "description": "Removes the DFT monitor with the specified name from the \"Monitors for expansion\" list of the selected mode expansion monitor."
      }
    ],
    "example": ""
  },
  {
    "name": "removeport",
    "description": "Removes a port from a compound/script element (Note that this command does not apply for primitive elements).",
    "usage": "removeport();",
    "category": "general",
    "markdown": "# removeport\r\n\r\nRemoves a port from a compound/script element (Note that this command does not apply for\r\nprimitive elements).\r\n\r\n| **Syntax**                     | **Description**                                                                            |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------ |\r\n| removeport(\"element\", \"port\"); | Removes \"port\" from \"element\". Returns 1 if the port is successfully removed, 0 otherwise. |\r\n\r\n**Example**\r\n\r\nOpen this example file compound_element.icp from\r\n[ Compound Elements ](**%20to%20be%20defined%20**) and input the following script\r\n\r\n```\r\ndisconnect(\"Optical Network Analyzer\",\"input 1\",\"Compound Element\",\"port 2\");\r\ndisconnect(\"Optical Network Analyzer\",\"output\",\"Compound Element\",\"port 1\");\r\nremoveport(\"Compound Element\",\"port 1\"); #delete the port\r\naddport(\"Compound Element\",\"port 1\",\"input\",\"optical Signal\"); #add port\r\n```",
    "summary": "Removes a port from a compound/script element (Note that this command does not apply for primitive e...",
    "syntax": [
      {
        "syntax": "removeport(\"element\", \"port\");",
        "description": "Removes \"port\" from \"element\". Returns 1 if the port is successfully removed, 0 otherwise."
      }
    ],
    "example": "disconnect(\"Optical Network Analyzer\",\"input 1\",\"Compound Element\",\"port 2\");\r\ndisconnect(\"Optical Network Analyzer\",\"output\",\"Compound Element\",\"port 1\");\r\nremoveport(\"Compound Element\",\"port 1\"); #delete the port\r\naddport(\"Compound Element\",\"port 1\",\"input\",\"optical Signal\"); #add port"
  },
  {
    "name": "removesweepparameter",
    "description": "Removes a parameter from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item.",
    "usage": "removesweepparameter();",
    "category": "general",
    "markdown": "# removesweepparameter\r\n\r\nRemoves a parameter from a parameter sweep/optimization/Monte Carlo/S-parameter sweep\r\nitem.\r\n\r\n| **Syntax**                                      | **Description**                                                                                                                                                                      |\r\n| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| removesweepparameter(\"name\", \"parameter_name\"); | Removes a parameter from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item. \"name\" is the absolute name of an analysis item. \"parameter_name\" is the parameter name. |\r\n\r\n**Examples**\r\n\r\nThis example shows how to remove a parameter from a sweep. Please download the example\r\nfile from the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\nremovesweepparameter(\"thickness_sweep\", \"thickness\");\r\n```\r\n\r\nThis example shows how to remove the second row from the s-matrix mapping table in an\r\nS-parameter matrix sweep.\r\n\r\n```\r\nremovesweepparameter(\"s-parameter sweep\",2);\r\n```",
    "summary": "Removes a parameter from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item",
    "syntax": [
      {
        "syntax": "removesweepparameter(\"name\", \"parameter_name\");",
        "description": "Removes a parameter from a parameter sweep/optimization/Monte Carlo/S-parameter sweep item. \"name\" is the absolute name of an analysis item. \"parameter_name\" is the parameter name."
      }
    ],
    "example": ""
  },
  {
    "name": "removesweepresult",
    "description": "Removes a result from a sweep/optimization/Monte Carlo item.",
    "usage": "removesweepresult();",
    "category": "general",
    "markdown": "# removesweepresult\r\n\r\nRemoves a result from a sweep/optimization/Monte Carlo item.\r\n\r\n| **Syntax**                                | **Description**                                                                                               |\r\n| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------- |\r\n| removesweepresult(\"name\", \"result_name\"); | Removes a result from a sweep/optimization/Monte Carlo item. \"name\" is the absolute name of an analysis item. |\r\n\r\n**Example**\r\n\r\nThis example shows how to remove a result from a sweep. Please download the example file\r\nfrom the\r\n[ Parameter sweeps ](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweeps)\r\npage Associate files.\r\n\r\n```\r\nremovesweepresult(\"thickness_sweep\", \"T\");\r\n```",
    "summary": "Removes a result from a sweep/optimization/Monte Carlo item",
    "syntax": [
      {
        "syntax": "removesweepresult(\"name\", \"result_name\");",
        "description": "Removes a result from a sweep/optimization/Monte Carlo item. \"name\" is the absolute name of an analysis item."
      }
    ],
    "example": "removesweepresult(\"thickness_sweep\", \"T\");"
  },
  {
    "name": "renameport",
    "description": "Renames the port name for a Compound or Scripted element.",
    "usage": "renameport();",
    "category": "general",
    "markdown": "# renameport\r\n\r\nRenames the port name for a Compound or Scripted element.\r\n\r\n| **Syntax**                                                    | **Description**                                           |\r\n| ------------------------------------------------------------- | --------------------------------------------------------- |\r\n| renameport(\"element name\", \"old port name\", \"new port name\"); | Renames the port name for a Compound or Scripted element. |\r\n\r\n**Example**\r\n\r\n```\r\n#renames the port name \"port 1\" to \"port a\" for the element \"COMPOUND_1\"\r\nrenameport(\"COMPOUND_1\", \"port 1\", \"port a\"); \r\n```",
    "summary": "Renames the port name for a Compound or Scripted element",
    "syntax": [
      {
        "syntax": "renameport(\"element name\", \"old port name\", \"new port name\");",
        "description": "Renames the port name for a Compound or Scripted element."
      }
    ],
    "example": "#renames the port name \"port 1\" to \"port a\" for the element \"COMPOUND_1\"\r\nrenameport(\"COMPOUND_1\", \"port 1\", \"port a\");"
  },
  {
    "name": "replace",
    "description": "Replaces a substring of a string with a new string. The start position of the substring must be specified. This function can also be used to add a substring to a string at a given position.",
    "usage": "replace();",
    "category": "general",
    "markdown": "# replace\r\n\r\nReplaces a substring of a string with a new string. The start position of the substring\r\nmust be specified. This function can also be used to add a substring to a string at a\r\ngiven position.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                                                                                                                                                          |\r\n| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| snew = replace(s,pos,len,s1); | Replaces len characters of s, starting at position pos, with the string in s1. If len is 0, it will insert the string s1 between pos-1 and pos. If len is -1 (or any values less than 0) it will replace all remaining characters in s with s1, starting at pos. The position pos can be 1 to length(s). |\r\n\r\n**Example**\r\n\r\nThese examples show how to replace substrings in a string or insert a substring at a\r\nspecific location in a string.\r\n\r\n```\r\n?replace(\"1234567\",3,1,\"aa\");\r\n12aa4567\r\n?replace(\"1234567\",3,0,\"aa\"); #insert a string\r\n12aa34567\r\n?replace(\"1234567\",3,-1,\"aa\");\r\n12aa\r\n```",
    "summary": "Replaces a substring of a string with a new string",
    "syntax": [
      {
        "syntax": "snew = replace(s,pos,len,s1);",
        "description": "Replaces len characters of s, starting at position pos, with the string in s1. If len is 0, it will insert the string s1 between pos-1 and pos. If len is -1 (or any values less than 0) it will replace all remaining characters in s with s1, starting at pos. The position pos can be 1 to length(s)."
      }
    ],
    "example": "?replace(\"1234567\",3,1,\"aa\");\r\n12aa4567\r\n?replace(\"1234567\",3,0,\"aa\"); #insert a string\r\n12aa34567\r\n?replace(\"1234567\",3,-1,\"aa\");\r\n12aa"
  },
  {
    "name": "replacelibrary",
    "description": "Replaces all instances of the current library in the Custom library.",
    "usage": "replacelibrary();",
    "category": "general",
    "markdown": "# replacelibrary\r\n\r\nReplaces all instances of the current library in the Custom library.\r\n\r\n| **Syntax**                    | **Description**                                                                    |\r\n| ----------------------------- | ---------------------------------------------------------------------------------- |\r\n| replacelibrary(previous,new); | Replaces all instances of the current library ‘previous’ by the new library ‘new’. |\r\n",
    "summary": "Replaces all instances of the current library in the Custom library",
    "syntax": [
      {
        "syntax": "replacelibrary(previous,new);",
        "description": "Replaces all instances of the current library ‘previous’ by the new library ‘new’."
      }
    ],
    "example": ""
  },
  {
    "name": "replacestring",
    "description": "Replaces all the instances of a substring in a string with a new string.",
    "usage": "replacestring();",
    "category": "general",
    "markdown": "# replacestring\r\n\r\nReplaces all the instances of a substring in a string with a new string.\r\n\r\n| **Syntax**                     | **Description**                                                                                   |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------------- |\r\n| snew = replacestring(s,s1,s2); | Replaces all instances of s1 in s with s2. If s1 is not found, the original string s is returned. |\r\n\r\n**Example**\r\n\r\nReplace a substring in a string at all the places where it occurs.\r\n\r\n```\r\n?replacestring(\"test12test34\",\"test\",\"NEWTEST\");\r\nNEWTEST12NEWTEST34\r\n```",
    "summary": "Replaces all the instances of a substring in a string with a new string",
    "syntax": [
      {
        "syntax": "snew = replacestring(s,s1,s2);",
        "description": "Replaces all instances of s1 in s with s2. If s1 is not found, the original string s is returned."
      }
    ],
    "example": "?replacestring(\"test12test34\",\"test\",\"NEWTEST\");\r\nNEWTEST12NEWTEST34"
  },
  {
    "name": "reportmeshstatistics",
    "description": "Returns statistical information about the mesh grid of the simulation. This command can be used to compare the size and the quality of different mesh grids between different simulations or solvers. The script can only be applied to tetrahedral (3D) and triangular (2D) meshes and thus does not apply to 1D simulations.",
    "usage": "reportmeshstatistics();",
    "category": "general",
    "markdown": "# reportmeshstatistics\r\n\r\nReturns statistical information about the mesh grid of the simulation. This command can\r\nbe used to compare the size and the quality of different mesh grids between different\r\nsimulations or solvers. The script can only be applied to tetrahedral (3D) and\r\ntriangular (2D) meshes and thus does not apply to 1D simulations.\r\n\r\n| **Syntax**                           | **Description**                                                        |\r\n| ------------------------------------ | ---------------------------------------------------------------------- |\r\n| out = reportmeshstatistics(mesh,ID); | Returns statistical information about the mesh grid of the simulation. |\r\n\r\n| **Parameter** |          | **Default value**                        | **Type**              | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\r\n| ------------- | -------- | ---------------------------------------- | --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| mesh          | required |                                          | unstructured data set | An unstructured data set including the finite element mesh grid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\r\n| ID            | optional | An array of all the available domain IDs | array of integers     | An array of integer numbers including the domain IDs (indices) of the elements of the mesh that the report should be restricted to                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\r\n| out           |          |                                          | struct                | The output includes attributes that provide information such as numElements (total number of elements in the grid), numFaces (total number of faces in the grid), numVertices (total number of vertices in the grid), elementSizeMeasure (an array of values of insphere or incircle radius in SI units for all the elements in the grid which can be used as a measure of the size of each element) and elementQualityMeasure (an array of values of minimum dihedral angle in degrees for all the elements in the grid which can be used as a measure of the quality of each element) |\r\n\r\n**Examples**\r\n\r\nThis example obtains the mesh grid from 'grid' attribute of the DGTD solver and stores\r\nthe statistics related to that mesh and displays the number of faces in the mesh grid.\r\nNote that the mesh grid has to be formed before running this example.\r\n\r\n```\r\ngrid=getresult(\"DGTD\",\"grid\");\r\nout=reportmeshstatistics(grid);\r\n?out.numFaces;\r\n```",
    "summary": "Returns statistical information about the mesh grid of the simulation",
    "syntax": [
      {
        "syntax": "out = reportmeshstatistics(mesh,ID);",
        "description": "Returns statistical information about the mesh grid of the simulation."
      }
    ],
    "example": ""
  },
  {
    "name": "reshape",
    "description": "Reshapes the matrix A to have a given size i,j,k.The product of the specified dimensions, i*j*k\\*..., must be the same as that of the original matrix A.",
    "usage": "reshape();",
    "category": "general",
    "markdown": "# reshape\r\n\r\nReshapes the matrix A to have a given size i,j,k.The product of the specified\r\ndimensions, i*j*k\\*..., must be the same as that of the original matrix A.\r\n\r\n| **Syntax**                     | **Description**                                                                               |\r\n| ------------------------------ | --------------------------------------------------------------------------------------------- |\r\n| out = reshape(A, [i,j,k, ...]) | Returns an array with the same elements as A but reshaped to have the size i by j by k by ... |\r\n\r\n**Example**\r\n\r\nSimple example showing how to reshape a 2D matrix.\r\n\r\n```\r\n?A=[1,2,3;4,5,6];\r\n?B=reshape(A,[2,3]); # do nothing\r\n?B=reshape(A,[3,2]); # reshape to 3 rows, 2 columns\r\n?B=reshape(A,[1,6]); # create single row vector\r\n?B=transpose(A);   # transpose function, for comparison\r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 5 \r\n4 3 \r\n2 6 \r\nresult: \r\n1 4 2 5 3 6 \r\nresult: \r\n1 4 \r\n2 5 \r\n3 6 \r\n```\r\n\r\nMatrices of higher dimensionality can also be reshaped.\r\n\r\n```\r\nA=matrix(2,3,4);\r\nA(1:2,1:3,1) = [1, 2, 3; 4, 5, 6];\r\nA(1:2,1:3,2) = [7, 8, 9; 10,11,12];\r\nA(1:2,1:3,3) = [13,14,15;16,17,18];\r\nA(1:2,1:3,4) = [19,20,21;22,23,24];\r\n?A;\r\n?B=reshape(A,[6,4]);   # reshape to 2D matrix\r\n?B=reshape(A,[1,2*3*4]); # reshape all data into a single row vector\r\nB=permute(A,[2,1,3]);   # transpose 1st & 2nd dimension\r\n?C=reshape(B,[1,2*3*4]); # then reshape to a single row vector\r\nresult(i,j,1):\r\n1 2 3 \r\n4 5 6 \r\nresult(i,j,2):\r\n7 8 9 \r\n10 11 12 \r\nresult(i,j,3):\r\n13 14 15 \r\n16 17 18 \r\nresult(i,j,4):\r\n19 20 21 \r\n22 23 24 \r\nresult: \r\n1 7 13 19 \r\n4 10 16 22 \r\n2 8 14 20 \r\n5 11 17 23 \r\n3 9 15 21 \r\n6 12 18 24 \r\nresult: \r\n1 4 2 5 3 6 7 10 8 11 9 12 13 16 14 17 15 18 19 22 20 23 21 24 \r\nresult: \r\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \r\n```",
    "summary": "Reshapes the matrix A to have a given size i,j,k",
    "syntax": [
      {
        "syntax": "out = reshape(A, [i,j,k, ...])",
        "description": "Returns an array with the same elements as A but reshaped to have the size i by j by k by ..."
      }
    ],
    "example": "?A=[1,2,3;4,5,6];\r\n?B=reshape(A,[2,3]); # do nothing\r\n?B=reshape(A,[3,2]); # reshape to 3 rows, 2 columns\r\n?B=reshape(A,[1,6]); # create single row vector\r\n?B=transpose(A);   # transpose function, for comparison\r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 2 3 \r\n4 5 6 \r\nresult: \r\n1 5 \r\n4 3 \r\n2 6 \r\nresult: \r\n1 4 2 5 3 6 \r\nresult: \r\n1 4 \r\n2 5 \r\n3 6"
  },
  {
    "name": "resume",
    "description": "Resume the simulation from previously created [checkpoint](https://optics.ansys.com/hc/en-us/articles/360034382534-FDTD-solver-Simulation-Object#h_01HQ233EQNZ88X91YBEKF8SQ9R). When the simulation finishes, all simulation data will be saved to the current simulation file. The updated simulation file will then be re-loaded by the GUI.",
    "usage": "resume();",
    "category": "general",
    "markdown": "# resume\r\n\r\nResume the simulation from previously created\r\n[checkpoint](https://optics.ansys.com/hc/en-us/articles/360034382534-FDTD-solver-Simulation-Object#h_01HQ233EQNZ88X91YBEKF8SQ9R).\r\nWhen the simulation finishes, all simulation data will be saved to the current\r\nsimulation file. The updated simulation file will then be re-loaded by the GUI.\r\n\r\n| **Syntax**       | **Description**                                                                                                    |\r\n| ---------------- | ------------------------------------------------------------------------------------------------------------------ |\r\n| resume;          | Launch the simulation in parallel mode as defined in the resource manager. This function does not return any data. |\r\n| resume(option1); | Option1 (default: 3) can be:                                                                                       |\r\n\r\n- 1: resume FDTD in single processor mode (legacy) avoiding any use of MPI.\r\n- 2: resume FDTD in single processor mode (legacy). Pop-up dialogs no longer take focus.\r\n- 3: resume FDTD in parallel mode as defined in the resource manager.\r\n\r\n**Requirements to resume**\r\n\r\n- Project must be identical with the exception of \"auto shutoff min\" and \"auto shutoff\r\n  max\".\r\n- Project can be in either layout or analysis mode. Simulation can still be resumed\r\n  after switching to layout.\r\n- Each of multiple/distributed/MPI processes must have access to its particular\r\n  checkpoint file. User may need to\r\n  [specify process rank allocation](https://software.intel.com/en-us/mpi-developer-guide-linux-controlling-process-placement).\r\n- Processor layout, MPI technology (mpich or impi etc), platform (linux/mac/windows),\r\n  CPU architecture, and Lumerical build number must be the same\r\n\r\n**Memory usage**\r\n\r\n- Checkpointing or resuming from checkpoint does not require extra memory\r\n\r\n**Supported Objects**\r\n\r\n- All source and monitors types.\r\n- To resume a movie monitor, the previous movie file must still exist on disk. Otherwise\r\n  the movie monitor will be ignored.",
    "summary": "Resume the simulation from previously created [checkpoint](https://optics",
    "syntax": [
      {
        "syntax": "resume;",
        "description": "Launch the simulation in parallel mode as defined in the resource manager. This function does not return any data."
      },
      {
        "syntax": "resume(option1);",
        "description": "Option1 (default: 3) can be:"
      }
    ],
    "example": ""
  },
  {
    "name": "resumejobs",
    "description": "Resume all simulations in the job manager queue from previously created checkpoint. The script execution will be paused while the jobs run, then resume when all of the simulations have completed successfully. If errors occur, the script will not proceed.",
    "usage": "resumejobs();",
    "category": "general",
    "markdown": "# resumejobs\r\n\r\nResume all simulations in the job manager queue from previously created checkpoint. The\r\nscript execution will be paused while the jobs run, then resume when all of the\r\nsimulations have completed successfully. If errors occur, the script will not proceed.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                                                                                                                   |\r\n| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| resumejobs;                 | Resume jobs in the Job queue for FDTD. Use the computer resources and parallel settings that are specified in the Resource Manager.                                                                                                               |\r\n| resumejobs(\"FDTD\", option); | Resume jobs in the Job queue for FDTD. option=0: resume jobs in single process mode using only the local computer. option=1: resume jobs using the computer resources and parallel settings that are specified in the Resource Manager. (default) |",
    "summary": "Resume all simulations in the job manager queue from previously created checkpoint",
    "syntax": [
      {
        "syntax": "resumejobs;",
        "description": "Resume jobs in the Job queue for FDTD. Use the computer resources and parallel settings that are specified in the Resource Manager."
      },
      {
        "syntax": "resumejobs(\"FDTD\", option);",
        "description": "Resume jobs in the Job queue for FDTD. option=0: resume jobs in single process mode using only the local computer. option=1: resume jobs using the computer resources and parallel settings that are specified in the Resource Manager. (default)"
      }
    ],
    "example": ""
  },
  {
    "name": "rm",
    "description": "Deletes a file. A path can be specified.",
    "usage": "rm();",
    "category": "general",
    "markdown": "# rm\r\n\r\nDeletes a file. A path can be specified.\r\n\r\n| **Syntax**                       | **Description**                                                      |\r\n| -------------------------------- | -------------------------------------------------------------------- |\r\n| del(\"filename\"); rm(\"filename\"); | Deletes the file \"filename\". This function does not return any data. |\r\n\r\n**Note** : This command cannot be used while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Examples**\r\n\r\nDeletes a file.\r\n\r\n```\r\ndel(\"project_name.fsp\") # deletes the file in the current working directory\r\ndel(\"C:\\Downloads\\project_name.fsp\") # deletes the file in a path specified\r\n```",
    "summary": "Deletes a file",
    "syntax": [
      {
        "syntax": "del(\"filename\"); rm(\"filename\");",
        "description": "Deletes the file \"filename\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "rotateelement",
    "description": "Rotates element in the schematic editor.",
    "usage": "rotateelement();",
    "category": "general",
    "markdown": "# rotateelement\r\n\r\nRotates element in the schematic editor.\r\n\r\n| **Syntax**                | **Description**                          |\r\n| ------------------------- | ---------------------------------------- |\r\n| rotateelement(\"element\"); | Rotates element in the schematic editor. |\r\n\r\n**Example**\r\n\r\nIf a \"waveguide1\" is added in the schematic editor,\r\n\r\n```\r\nrotateelement(\"waveguide1\");\r\n```\r\n\r\nwill rotate the element and its properties 90 degrees counter-clock wise.",
    "summary": "Rotates element in the schematic editor",
    "syntax": [
      {
        "syntax": "rotateelement(\"element\");",
        "description": "Rotates element in the schematic editor."
      }
    ],
    "example": "rotateelement(\"waveguide1\");"
  },
  {
    "name": "round",
    "description": "Rounds a number to the nearest integer.",
    "usage": "round();",
    "category": "general",
    "markdown": "# round\r\n\r\nRounds a number to the nearest integer.\r\n\r\n| **Syntax**      | **Description**                  |\r\n| --------------- | -------------------------------- |\r\n| out = round(x); | Rounds x to the nearest integer. |\r\n\r\n**Example**\r\n\r\nExample output from round function.\r\n\r\n```\r\n?x=[1.49,-1.49,1.5,1.55,-1.55];\r\n?round(x);\r\nresult: \r\n1.49  -1.49  1.5  1.55  -1.55  \r\nresult: \r\n1  -1  2  2  -2   \r\n```\r\n\r\nThis example shows how to use round to help implement the mod function.\r\n\r\n```\r\nmod_dividend= 10;\r\nmod_divisor = 3;\r\nmod_temp1=mod_dividend/mod_divisor;\r\nmod_temp2=round(mod_temp1);\r\nif (mod_temp1 >= mod_temp2) {\r\n mod_remainder= round( (mod_temp1 - mod_temp2)*mod_divisor );\r\n} else {\r\n mod_remainder= round( (1+mod_temp1 - mod_temp2)*mod_divisor );\r\n} \r\n?mod_remainder;\r\nresult: \r\n1      \r\n```",
    "summary": "Rounds a number to the nearest integer",
    "syntax": [
      {
        "syntax": "out = round(x);",
        "description": "Rounds x to the nearest integer."
      }
    ],
    "example": "?x=[1.49,-1.49,1.5,1.55,-1.55];\r\n?round(x);\r\nresult: \r\n1.49  -1.49  1.5  1.55  -1.55  \r\nresult: \r\n1  -1  2  2  -2"
  },
  {
    "name": "run",
    "description": "Run the current simulation. When the simulation finishes, all simulation data will be saved to the current simulation file. The updated simulation file will then be re-loaded by the GUI. This function does not return any data.",
    "usage": "run();",
    "category": "general",
    "markdown": "# run\r\n\r\nRun the current simulation. When the simulation finishes, all simulation data will be\r\nsaved to the current simulation file. The updated simulation file will then be re-loaded\r\nby the GUI. This function does not return any data.\r\n\r\nFor MODE, CHARGE, HEAT, FEEM, DGTD,\r\n\r\n| **Syntax**     | **Description**                                                                                         |\r\n| -------------- | ------------------------------------------------------------------------------------------------------- |\r\n| run;           | Launch the simulation in parallel mode as defined in the resource manager.                              |\r\n| run(“solver”); | Launch the simulation using the specified “solver” in parallel mode as defined in the resource manager. |\r\n\r\nFor FDTD and RCWA,\r\n\r\n| **Syntax**                                                                                                                                                                                             | **Description**                                                                                                              |\r\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| run;                                                                                                                                                                                                   |                                                                                                                              |\r\n| Launch the simulation using the resource set in the [run simulation group](https://optics.ansys.com/hc/en-us/articles/36952912384403-Ansys-Lumerical-FDTD-Modern-User-Interface) of the simulator tab. |                                                                                                                              |\r\n| run(\"solver\");                                                                                                                                                                                         | Launch the simulation using the specified “solver”, using the resource set in the run simulation group of the simulator tab. |\r\n| run(\"solver\", \"resource_type\")                                                                                                                                                                         | Launch the simulation using solver and resource_type:                                                                        |\r\n\r\n- solver: solver name, can be “FDTD”, “RCWA”\r\n- resource_type: resource type, can be \"CPU\", \"GPU\" for FDTD, and “CPU” only for RCWA\r\n\r\nThis allows to use the specified resource without affecting the CPU/GPU selection set in\r\nthe\r\n[run simulation group](https://optics.ansys.com/hc/en-us/articles/36952912384403-Ansys-Lumerical-FDTD-Modern-User-Interface)\r\nof the simulator tab.\\\r\nrun(\"solver\", \"resource_type\", \"resource_name\"); | Launch the simulation using solver,\r\nresource_type, and with a specified resource_name:\r\n\r\n- solver: solver name, can be “FDTD”, “RCWA”\r\n- resource_type: resource type, can be \"CPU\", \"GPU\" for FDTD, and “CPU” only for RCWA\r\n- resource_name: resource name, must follow a resource set in the\r\n  [resource configuration window](https://optics.ansys.com/hc/en-us/articles/360058790674-Resource-configuration-elements-and-controls)\r\n\r\nrun(\"FDTD\", \"GPU\", \"resource_name\", CUDA_VISIBLE_DEVICE_values); | Launch an FDTD GPU\r\nsimulation with a specified resource_name and CUDA_VISIBLE_DEVICE_values:\r\n\r\n- resource_name: resource name, must follow a resource set in the resource configuration\r\n  window\r\n- CUDA_VISIBLE_DEVICE_values: GPUs to be used specified by the environment variable\r\n  CUDA_VISIBLE_DEVICE, can be a single value or a matrix representing multiple GPUs\r\n\r\nFor INTERCONNECT,\r\n\r\n| **Syntax** | **Description**                                                                                                              |\r\n| ---------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| run;       | Launch the simulation. The simulation will be run using the settings from the first active resource in the resource manager. |\r\n\r\nWhen using\r\n[Ansys Cloud Burst Compute™ for Lumerical](https://optics.ansys.com/hc/en-us/articles/39824576734867-Ansys-Cloud-Burst-Compute-for-Lumerical),\r\n\r\n| **Syntax**                                               | **Description**                |\r\n| -------------------------------------------------------- | ------------------------------ |\r\n| run(“solver”, “resource_type”, “burst”, burst_settings); | Submits the current burst job: |\r\n\r\n- solver: Name of the solver, currently, only “FDTD” is supported\r\n- resource_type: Type of simulation to run, either “CPU” or “GPU”\r\n- burst_settings: Optional, settings structure to use for the current job submission.\r\n  The structure fields should match the results obtained from\r\n  [getresource](https://optics.ansys.com/hc/en-us/articles/360034931353-getresource-Script-command).\r\n\r\n**Example**\r\n\r\nCreate and run a new simulation in FDTD.\r\n\r\n```\r\nnewproject;  # create a new simulation file\r\naddfdtd;    # add the FDTD simulation region\r\nadddipole;   # add a diopole source\r\nrun;      # run the simulation in parallel mode\r\n```",
    "summary": "Run the current simulation",
    "syntax": [
      {
        "syntax": "run;",
        "description": "Launch the simulation in parallel mode as defined in the resource manager."
      },
      {
        "syntax": "run(“solver”);",
        "description": "Launch the simulation using the specified “solver” in parallel mode as defined in the resource manager."
      }
    ],
    "example": "newproject;  # create a new simulation file\r\naddfdtd;    # add the FDTD simulation region\r\nadddipole;   # add a diopole source\r\nrun;      # run the simulation in parallel mode"
  },
  {
    "name": "runanalysis",
    "description": "Runs the analysis script in analysis objects.",
    "usage": "runanalysis();",
    "category": "general",
    "markdown": "# runanalysis\r\n\r\nRuns the analysis script in analysis objects.\r\n\r\nNote: Scripts that already have data are not re-run; to re-run a script, first clear\r\ndata using clearanalysis.\r\n\r\n| **Syntax**                 | **Description**                                                                                                   |\r\n| -------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| runanalysis;               | Runs the analysis scripts in all analysis objects in the simulation file. This function does not return any data. |\r\n| runanalysis(\"group name\"); | Runs the analysis script in the analysis object named \"group name\". This function does not return any data.       |",
    "summary": "Runs the analysis script in analysis objects",
    "syntax": [
      {
        "syntax": "runanalysis;",
        "description": "Runs the analysis scripts in all analysis objects in the simulation file. This function does not return any data."
      },
      {
        "syntax": "runanalysis(\"group name\");",
        "description": "Runs the analysis script in the analysis object named \"group name\". This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "runfinalize",
    "description": "This script command finalizes a step by step simulation.",
    "usage": "runfinalize();",
    "category": "general",
    "markdown": "# runfinalize\r\n\r\nThis script command finalizes a step by step simulation.\r\n\r\n| **Syntax**   | **Description**                                                                                                                                              |\r\n| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| runfinalize; | Finalizes a step by step simulation. This command should be used in combination with runinitialize and runstep, and it is typically used for co-simulations. |",
    "summary": "This script command finalizes a step by step simulation",
    "syntax": [
      {
        "syntax": "runfinalize;",
        "description": "Finalizes a step by step simulation. This command should be used in combination with runinitialize and runstep, and it is typically used for co-simulations."
      }
    ],
    "example": ""
  },
  {
    "name": "runinitialize",
    "description": "This script command initializes a step by step simulation.",
    "usage": "runinitialize();",
    "category": "general",
    "markdown": "# runinitialize\r\n\r\nThis script command initializes a step by step simulation.\r\n\r\n| **Syntax**     | **Description**                                                                                                                                                                                                      |\r\n| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| runinitialize; | Initialize a step by step simulation, different from ‘run’ the simulation is only initialized. This command should be used in combination with runstep and runfinalize, and it is typically used for co-simulations. |",
    "summary": "This script command initializes a step by step simulation",
    "syntax": [
      {
        "syntax": "runinitialize;",
        "description": "Initialize a step by step simulation, different from ‘run’ the simulation is only initialized. This command should be used in combination with runstep and runfinalize, and it is typically used for co-simulations."
      }
    ],
    "example": ""
  },
  {
    "name": "runjobs",
    "description": "Run all simulations in the job manager queue. The script execution will be paused while the jobs run, then resume when all of the simulations have completed successfully. If errors occur, the script will not proceed.",
    "usage": "runjobs();",
    "category": "general",
    "markdown": "# runjobs\r\n\r\nRun all simulations in the job manager queue. The script execution will be paused while\r\nthe jobs run, then resume when all of the simulations have completed successfully. If\r\nerrors occur, the script will not proceed.\r\n\r\nFor Ansys Lumerical FDTD™, Ansys Lumerical MODE™, Ansys Lumerical Multiphysics™, and\r\nAnsys Lumerical INTERCONNECT™\r\n\r\n| **Syntax**                 | **Description**                                                                                                                                                                                                                                      |\r\n| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| runjobs;                   | Run jobs in the Job queue for existing (active) solver. Use the computer resources and parallel settings that are specified in the Resource Manager.                                                                                                 |\r\n| runjobs(\"solver\", option); | Run jobs in the Job queue for specified solver. option=0: run jobs in single process mode using only the local computer. option=1: run jobs using the computer resources and parallel settings that are specified in the Resource Manager. (default) |\r\n\r\nWhen using\r\n[Ansys Cloud Burst Compute™ for Lumerical](https://optics.ansys.com/hc/en-us/articles/39824576734867-Ansys-Cloud-Burst-Compute-for-Lumerical),\r\n\r\n| **Syntax**                                                   | **Description**                                                                                    |\r\n| ------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |\r\n| runjobs(“solver”, “resource_type”, “burst”, burst_settings); | Run jobs in the job queue for the specified solver using Ansys Cloud Burst Compute™ for Lumerical: |\r\n\r\n- solver: Name of the solver, currently, only “FDTD” is supported\r\n- resource_type: Type of simulation to run, either “CPU” or “GPU”\r\n- burst_settings: Settings structure to use for the current job submission. The\r\n  structure fields should match the results obtained from getresource. The “queue” field\r\n  must be specified in this structure. Any fields left blank uses default settings.\r\n\r\n**Example**\r\n\r\nThe following script code illustrates how to use the addjob and runjobs script commands\r\nto do a parameter sweep. The initial for loop creates a simulation file for each point\r\nin the sweep and adds the simulations to the job queue. Next, the runjobs command will\r\nrun all simulations in the job queue. If multiple computer resources are configured in\r\nthe Resource Manager, then simulations will run concurrently. When all of the\r\nsimulations are complete, a second for loop is used to re-load each simulation file and\r\ndo the required analysis.\r\n\r\n```\r\n# create 10 simulation files and add them to the job queue\r\nnewproject;\r\naddvarfdtd;\r\nadddipole;\r\naddcircle;\r\nrad=linspace(1e-6,10e-6,10);\r\nfor(i=1:10) {\r\nsetnamed(\"circle\",\"radius\",rad(i));\r\nsave(\"temp_\"+num2str(i));\r\naddjob(currentfilename);\r\n}\r\nrunjobs;\r\n# run all jobs in the job queue\r\nrunjobs;\r\n# load each simulation and do required analysis\r\nfor(i=1:10) {\r\n load(\"temp_\"+num2str(i));\r\n ...\r\n}\r\n```",
    "summary": "Run all simulations in the job manager queue",
    "syntax": [
      {
        "syntax": "runjobs;",
        "description": "Run jobs in the Job queue for existing (active) solver. Use the computer resources and parallel settings that are specified in the Resource Manager."
      },
      {
        "syntax": "runjobs(\"solver\", option);",
        "description": "Run jobs in the Job queue for specified solver. option=0: run jobs in single process mode using only the local computer. option=1: run jobs using the computer resources and parallel settings that are specified in the Resource Manager. (default)"
      }
    ],
    "example": "# create 10 simulation files and add them to the job queue\r\nnewproject;\r\naddvarfdtd;\r\nadddipole;\r\naddcircle;\r\nrad=linspace(1e-6,10e-6,10);\r\nfor(i=1:10) {\r\nsetnamed(\"circle\",\"radius\",rad(i));\r\nsave(\"temp_\"+num2str(i));\r\naddjob(currentfilename);\r\n}\r\nrunjobs;\r\n# run all jobs in the job queue\r\nrunjobs;\r\n# load each simulation and do required analysis\r\nfor(i=1:10) {\r\n load(\"temp_\"+num2str(i));\r\n ...\r\n}"
  },
  {
    "name": "runoptimization",
    "description": "Optimizes a property from a chosen element under specified condition.",
    "usage": "runoptimization();",
    "category": "general",
    "markdown": "# runoptimization\r\n\r\nOptimizes a property from a chosen element under specified condition.\r\n\r\n| **Syntax**                                                                                                          | **Description**                                                                                                                                                                                                                     |\r\n| ------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| x=runoptimization(element, property, min, max, analyzer, result, ’target’, target, tolerance=1e-9, iterations=2000) | Optimizes property from element until a target for an analyzer result is reached. Function returns an array with two columns, the firs column contains the property values and the second column contains the result values.        |\r\n| x=runoptimization(element, property, min, max, analyzer, result, ’minimize’, tolerance=1e-9, iterations=2000)       | Optimizes property from element until a minimum value for an analyzer result is reached. Function returns an array with two columns, the firs column contains the property values and the second column contains the result values. |\r\n| x=runoptimization(element, property, min, max, analyzer, result, ’maximize’, tolerance=1e-9, iterations=2000)       | Optimizes property from element until a maximum value for an analyzer result is reached. Function returns an array with two columns, the firs column contains the property values and the second column contains the result values. |\r\n\r\n**Example**\r\n\r\n### The following script line optimizes the thermal noise for a PIN Photodetector for target\r\n\r\n```\r\nx=runoptimization(\"PIN Photodetector\",\"thermal noise\",1e-20,1e-17,\"Eye Diagram\",\"measurement/Q factor\",\"target\",6,1e-2);\r\n```\r\n\r\n### The following script line searches the minimum cutoff frequency for a LP Bessel Filter\r\n\r\n```\r\nx=runoptimization(\"LP Bessel Filter\",\"cutoff frequency\",1e+09,1e+10,\"Eye Diagram\",\"measurement/log of BER\",\"minimize\");\r\n```\r\n\r\n### The following script line searches the maximum cutoff frequency for a LP Bessel Filter\r\n\r\n```\r\nx=runoptimization(\"LP Bessel Filter\",\"cutoff frequency\",1e+09,1e+10,\"Eye Diagram\",\"measurement/Q factor\",\"maximize\");\r\n```\r\n",
    "summary": "Optimizes a property from a chosen element under specified condition",
    "syntax": [
      {
        "syntax": "x=runoptimization(element, property, min, max, analyzer, result, ’target’, target, tolerance=1e-9, iterations=2000)",
        "description": "Optimizes property from element until a target for an analyzer result is reached. Function returns an array with two columns, the firs column contains the property values and the second column contains the result values."
      },
      {
        "syntax": "x=runoptimization(element, property, min, max, analyzer, result, ’minimize’, tolerance=1e-9, iterations=2000)",
        "description": "Optimizes property from element until a minimum value for an analyzer result is reached. Function returns an array with two columns, the firs column contains the property values and the second column contains the result values."
      },
      {
        "syntax": "x=runoptimization(element, property, min, max, analyzer, result, ’maximize’, tolerance=1e-9, iterations=2000)",
        "description": "Optimizes property from element until a maximum value for an analyzer result is reached. Function returns an array with two columns, the firs column contains the property values and the second column contains the result values."
      }
    ],
    "example": "x=runoptimization(\"PIN Photodetector\",\"thermal noise\",1e-20,1e-17,\"Eye Diagram\",\"measurement/Q factor\",\"target\",6,1e-2);"
  },
  {
    "name": "runparallel",
    "description": "Launch the simulation in parallel mode. Equivalent to run and run(3). When the simulation finishes, all simulation data will be saved to the current file. This command has been deprecated. Use run.",
    "usage": "runparallel();",
    "category": "general",
    "markdown": "# runparallel\r\n\r\nLaunch the simulation in parallel mode. Equivalent to run and run(3). When the\r\nsimulation finishes, all simulation data will be saved to the current file. This command\r\nhas been deprecated. Use run.\r\n\r\n| **Syntax**   | **Description**                                                                                                    |\r\n| ------------ | ------------------------------------------------------------------------------------------------------------------ |\r\n| runparallel; | Launch the simulation in parallel mode as defined in the resource manager. This function does not return any data. |\r\n\r\n**Example**\r\n\r\n```\r\nnewproject;\r\naddfdtd;    \r\nadddipole;  \r\nrunparallel;      \r\n```",
    "summary": "Launch the simulation in parallel mode",
    "syntax": [
      {
        "syntax": "runparallel;",
        "description": "Launch the simulation in parallel mode as defined in the resource manager. This function does not return any data."
      }
    ],
    "example": "newproject;\r\naddfdtd;    \r\nadddipole;  \r\nrunparallel;"
  },
  {
    "name": "runsetup",
    "description": "Runsetup forces the setup scripts of structure and analysis groups to run.",
    "usage": "runsetup();",
    "category": "general",
    "markdown": "# runsetup\r\n\r\nRunsetup forces the setup scripts of structure and analysis groups to run.\r\n\r\nIn most cases, it is not necessary to use this function, as group setup scripts\r\nautomatically re-run at the end of script, if the object has been modified. It is only\r\nnecessary to use this function when you need to force the setup script to run before the\r\nend of your script file.\r\n\r\n| **Syntax** | **Description**                        |\r\n| ---------- | -------------------------------------- |\r\n| runsetup;  | Forces setup scripts of groups to run. |\r\n\r\n**Examples**\r\n\r\nWe use the runsetup command to force the group setup script to run before the script is\r\nfinished, This allows us to get the properties of a child of the group.\r\n\r\n```\r\n# Create a structure group. \r\ndeleteall;\r\naddstructuregroup;\r\nadduserprop(\"radius\",2,0.5e-6);\r\nmyscript =      \"addcircle; \\n\";\r\nmyscript = myscript + \"copy(1e-6); \\n\";\r\nmyscript = myscript + \"selectall; \\n\";\r\nmyscript = myscript + \"set(\\\"radius\\\",radius);\";\r\nset(\"name\",\"dimer\");\r\nset(\"script\",myscript); \r\n# Try to get the radius of the circle\r\n# objects within the group. This command will fail\r\n# without the runsetup function, which forces the \r\n# group setup script to run.\r\nrunsetup;\r\n?getnamed(\"dimer::circle\",\"radius\");\r\n```",
    "summary": "Runsetup forces the setup scripts of structure and analysis groups to run",
    "syntax": [
      {
        "syntax": "runsetup;",
        "description": "Forces setup scripts of groups to run."
      }
    ],
    "example": ""
  },
  {
    "name": "runstartupscripts",
    "description": "Runs the start-up scripts.",
    "usage": "runstartupscripts();",
    "category": "general",
    "markdown": "# runstartupscripts\r\n\r\nRuns the start-up scripts.\r\n\r\n| **Syntax**         | **Description**                            |\r\n| ------------------ | ------------------------------------------ |\r\n| runstartupscripts; | Runs the start-up scripts in the order of: |\r\n\r\n1. global shared startup script\r\n1. global $(PRODUCT) startup script\r\n1. local shared start-up script\r\n1. local $(PRODUCT) start-up script\r\n\r\n**Examples**\r\n\r\nThe following examples runs the \"runstartupscripts\" in INTERCONNECT with the scripts in\r\n\"Shared Startup.lsf\" and \"INTERCONNECT Startup.lsf\" as below, respectively:\r\n\r\n```\r\n# Shared Startup.lsf\r\nclear;\r\n?a = 1;\r\n# INTERCONNECT Startup.lsf\r\nclear;\r\n?b = 2;\r\n```\r\n\r\nThe output result:\r\n\r\n```\r\nrunstartupscripts;\r\nShared Startup;\r\nresult: \r\n1  \r\nRunning script: /Users/$(Username)/.config/Lumerical/INTERCONNECT Startup.lsf\r\nINTERCONNECT Startup;\r\nresult: \r\n2  \r\n```",
    "summary": "Runs the start-up scripts",
    "syntax": [
      {
        "syntax": "runstartupscripts;",
        "description": "Runs the start-up scripts in the order of:"
      }
    ],
    "example": ""
  },
  {
    "name": "runstep",
    "description": "This script command runs a single simulation step.",
    "usage": "runstep();",
    "category": "general",
    "markdown": "# runstep\r\n\r\nThis script command runs a single simulation step.\r\n\r\n| **Syntax** | **Description**                                                                                                                                            |\r\n| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| runstep;   | Runs a single simulation step. This command should be used in combination with runinitialize and runfinalize, and it is typically used for co-simulations. |",
    "summary": "This script command runs a single simulation step",
    "syntax": [
      {
        "syntax": "runstep;",
        "description": "Runs a single simulation step. This command should be used in combination with runinitialize and runfinalize, and it is typically used for co-simulations."
      }
    ],
    "example": ""
  },
  {
    "name": "runsweep",
    "description": "Runs a parameter sweep or optimization task.",
    "usage": "runsweep();",
    "category": "general",
    "markdown": "# runsweep\r\n\r\nRuns a parameter sweep or optimization task.\r\n\r\n| **Syntax**                            | **Description**                                                                                                   |\r\n| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| runsweep;                             | Runs all sweeps and optimization tasks. In FDTD, this will run tasks in CPU mode.                                 |\r\n| runsweep(\"taskname\");                 | Runs only the sweep or optimization named taskname. In FDTD, this will run the sweep or optimization in CPU mode. |\r\n| runsweep(“resource_type”);            | FDTD only, runs all sweeps and optimization tasks using a specified resource_type, either “GPU” or “CPU”          |\r\n| runsweep(\"taskname\",”resource_type”); | FDTD only, runs the sweep or optimization named taskname using a specified resource_type, either “CPU” or “GPU”.  |\r\n\r\nWhen using\r\n[Ansys Cloud Burst Compute™ for Lumerical](https://optics.ansys.com/hc/en-us/articles/39824576734867-Ansys-Cloud-Burst-Compute-for-Lumerical),\r\n\r\n| **Syntax**                                                     | **Description**                                                                                                                                                 |\r\n| -------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| runsweep(“taskname”,”resource_type”, “burst”, burst_settings); | Run a single parameter sweep with a specific type of resource. An error is returned in the sweep uses a solver that does not support Ansys Cloud Burst Compute: |\r\n\r\n- taskname: Name of sweep to run\r\n- resource_type: Type of resource to run, either “CPU” or “GPU”\r\n- burst_settings: Optional, settings structure to use for the current job submission.\r\n  The structure fields should match the results obtained from\r\n  [getresource](https://optics.ansys.com/hc/en-us/articles/360034931353-getresource-Script-command).\r\n  If left empty, default settings are used.\r\n\r\nrunsweep(“type”,”burst”, burst_settings); | Run all sweeps with the specified resource\r\ntype. The settings are applied to all sweeps. An error is returned if a sweep in the\r\nlist does not support Ansys Cloud Burst Compute:\r\n\r\n- type: Type of resource to run, either “CPU” or “GPU”\r\n- burst_settings: Optional, settings structure to use for the current job submission.\r\n  The structure fields should match the results obtained from\r\n  [getresource](https://optics.ansys.com/hc/en-us/articles/360034931353-getresource-Script-command).\r\n  If left empty, default settings are used.\r\n\r\n**Example**\r\n\r\n```\r\nrunsweep;\r\nrunsweep(\"thickness_sweep\");\r\n```",
    "summary": "Runs a parameter sweep or optimization task",
    "syntax": [
      {
        "syntax": "runsweep;",
        "description": "Runs all sweeps and optimization tasks. In FDTD, this will run tasks in CPU mode."
      },
      {
        "syntax": "runsweep(\"taskname\");",
        "description": "Runs only the sweep or optimization named taskname. In FDTD, this will run the sweep or optimization in CPU mode."
      },
      {
        "syntax": "runsweep(“resource_type”);",
        "description": "FDTD only, runs all sweeps and optimization tasks using a specified resource_type, either “GPU” or “CPU”"
      },
      {
        "syntax": "runsweep(\"taskname\",”resource_type”);",
        "description": "FDTD only, runs the sweep or optimization named taskname using a specified resource_type, either “CPU” or “GPU”."
      }
    ],
    "example": "runsweep;\r\nrunsweep(\"thickness_sweep\");"
  },
  {
    "name": "runwizard",
    "description": "Runs the wizard and returns a value indicating which button was pressed.",
    "usage": "runwizard();",
    "category": "general",
    "markdown": "# runwizard\r\n\r\nRuns the wizard and returns a value indicating which button was pressed.\r\n\r\n| **Syntax**       | **Description**                                                                                                                                                                                                               |\r\n| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = runwizard; | Returns either 0, +1 or -1. 0 means the user pressed Cancel, 1 means the user pressed the first button (created by calling newwizardpage) and -1 means the user pressed the second button (created by calling newwizardpage). |\r\n\r\n**Examples**\r\n\r\nSee the newwizard page for an example.",
    "summary": "Runs the wizard and returns a value indicating which button was pressed",
    "syntax": [
      {
        "syntax": "out = runwizard;",
        "description": "Returns either 0, +1 or -1. 0 means the user pressed Cancel, 1 means the user pressed the first button (created by calling newwizardpage) and -1 means the user pressed the second button (created by calling newwizardpage)."
      }
    ],
    "example": ""
  },
  {
    "name": "save",
    "description": "Saves a simulation project file. If the simulation has been run, the file will also contain the simulation results, such as sweep and optimization data.",
    "usage": "save();",
    "category": "general",
    "markdown": "# save\r\n\r\nSaves a simulation project file. If the simulation has been run, the file will also\r\ncontain the simulation results, such as sweep and optimization data.\r\n\r\n| **Syntax**      | **Description**                                                                         |\r\n| --------------- | --------------------------------------------------------------------------------------- |\r\n| save;           | Open a file browser to save the file. This function does not return any data.           |\r\n| save(filename); | Save with the specified name to the current working directory. A path can be specified. |\r\n\r\n**Examples**\r\n\r\nSaves the current profile file\r\n\r\n```\r\nsave(\"project_name\"); # saves the file in the current working directory\r\nsave(\"C:\\Downloads\\project_name.fsp\") # saves the file in a path specified\r\n```\r\n\r\n###",
    "summary": "Saves a simulation project file",
    "syntax": [
      {
        "syntax": "save;",
        "description": "Open a file browser to save the file. This function does not return any data."
      },
      {
        "syntax": "save(filename);",
        "description": "Save with the specified name to the current working directory. A path can be specified."
      }
    ],
    "example": ""
  },
  {
    "name": "savedata",
    "description": "Saves workspace variables to a Lumerical data file (ldf) file. To save monitor (D-card) data to an ldf file, see the savedcard function.",
    "usage": "savedata();",
    "category": "general",
    "markdown": "# savedata\r\n\r\nSaves workspace variables to a Lumerical data file (ldf) file. To save monitor (D-card)\r\ndata to an ldf file, see the savedcard function.\r\n\r\n| **Syntax**                            | **Description**                                                                            |\r\n| ------------------------------------- | ------------------------------------------------------------------------------------------ |\r\n| savedata(\"filename\");                 | Saves all current variables to the specified file. This function does not return any data. |\r\n| savedata(\"filename\", var1, var2,...); | Saves only variables with the specified names to file.                                     |\r\n\r\n**Examples**\r\n\r\nThis is a simple example that shows how to save two workspace variables to a .ldf data\r\nfile.\r\n\r\n```\r\nx=1:10;\r\ny=x^2;\r\nsavedata(\"x_squared_data\", x, y);\r\n```\r\n\r\nThis example shows a section of code that could be used to save some specific data from\r\na monitor named xy_monitor. The data is first obtained with script functions such as\r\ngetdata and transmission. These workspace variables are then saved with the savedata\r\nfunction.\r\n\r\nNote that the complex file names can be created with the num2str command. This is useful\r\nwhen doing parameter sweeps where a unique file name is required for each point in the\r\nsweep.\r\n\r\n```\r\n# get data from the simulation to be saved\r\nmname=\"xy_monitor\";       # monitor name\r\nx=getdata(mname,\"x\");      # position vectors associated with Ex fields\r\ny=getdata(mname,\"y\");      # position vectors associated with Ex fields\r\nEx=getdata(mname,\"Ex\");     # Ex fields at monitor\r\nT=transmission(mname);     # Power transmission through monitor\r\n \r\n# save variables x, y, Ex, T and i to a data file\r\nfilename=\"results_\"+num2str(i); # set filename. i could be a loop counter variable.\r\nsavedata(filename, x,y,Ex,T,i); \r\n```",
    "summary": "Saves workspace variables to a Lumerical data file (ldf) file",
    "syntax": [
      {
        "syntax": "savedata(\"filename\");",
        "description": "Saves all current variables to the specified file. This function does not return any data."
      },
      {
        "syntax": "savedata(\"filename\", var1, var2,...);",
        "description": "Saves only variables with the specified names to file."
      }
    ],
    "example": ""
  },
  {
    "name": "savedcard",
    "description": "Saves d-card data to a Lumerical data file (ldf) file. D-cards are generally used to store monitor data, but can also be used to store data from solver objects.",
    "usage": "savedcard();",
    "category": "general",
    "markdown": "# savedcard\r\n\r\nSaves d-card data to a Lumerical data file (ldf) file. D-cards are generally used to\r\nstore monitor data, but can also be used to store data from solver objects.\r\n\r\nData is saved in the nonorm state. See the\r\n[ units and normalization ](https://optics.ansys.com/hc/en-us/articles/360034397034)\r\nsection of the reference guide for more information.\r\n\r\n| **Syntax**                                   | **Description**                                                                                                 |\r\n| -------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |\r\n| savedcard(\"filename\");                       | Saves all current d-cards (local and global) to the specified ldf file. This function does not return any data. |\r\n| savedcard(\"filename\", \"name1\", \"name2\",...); | Saves only the d-cards with the specified names, \"name1\", \"name2\", etc.                                         |\r\n\r\n**Examples**\r\n\r\nThis example shows how to save all data from the monitor named xy_monitor.\r\n\r\n```\r\n?getdata; # view all d-cards\r\nsavedcard(\"monitor_data\",\"::model::xy_monitor\");\r\n```\r\n\r\nThis example shows how to save the required data after performing a frequency sweep in\r\nMODE. This is equivalent to the GUI option \"Export for Interconnect\".\r\n\r\n```\r\nsavedcard(\"FileName\", \"::model::FDE::data::frequencysweep\");\r\n```",
    "summary": "Saves d-card data to a Lumerical data file (ldf) file",
    "syntax": [
      {
        "syntax": "savedcard(\"filename\");",
        "description": "Saves all current d-cards (local and global) to the specified ldf file. This function does not return any data."
      },
      {
        "syntax": "savedcard(\"filename\", \"name1\", \"name2\",...);",
        "description": "Saves only the d-cards with the specified names, \"name1\", \"name2\", etc."
      }
    ],
    "example": ""
  },
  {
    "name": "saveelement",
    "description": "Saves an element to a .ice file in the current working directory.",
    "usage": "saveelement();",
    "category": "general",
    "markdown": "# saveelement\r\n\r\nSaves an element to a .ice file in the current working directory.\r\n\r\n| **Syntax**            | **Description**                                                                                                                         |\r\n| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |\r\n| saveelement (\"name\"); | Save an element to a file. The element will be saved with the current element name in the current working directory with extension ICE. |\r\n\r\n**Example**\r\n\r\n```\r\n#adds an element star coupler and saves it to an .ice file in the current working directory\r\naddelement(\"Star Coupler\");\r\nsaveelement(\"STAR_1\");\r\n```",
    "summary": "Saves an element to a ",
    "syntax": [
      {
        "syntax": "saveelement (\"name\");",
        "description": "Save an element to a file. The element will be saved with the current element name in the current working directory with extension ICE."
      }
    ],
    "example": "#adds an element star coupler and saves it to an .ice file in the current working directory\r\naddelement(\"Star Coupler\");\r\nsaveelement(\"STAR_1\");"
  },
  {
    "name": "savesweep",
    "description": "Creates and saves the simulations files to a folder in the working directory, this script command is equivalent to the GUI \"Save to files\" operation.",
    "usage": "savesweep();",
    "category": "general",
    "markdown": "# savesweep\r\n\r\nCreates and saves the simulations files to a folder in the working directory, this\r\nscript command is equivalent to the GUI \"Save to files\" operation.\r\n\r\n| **Syntax**         | **Description**                                                |\r\n| ------------------ | -------------------------------------------------------------- |\r\n| savesweep;         | Saves the simulation files of all sweep objects in simulation. |\r\n| savesweep(\"name\"); | Saves the simulation files of the specified sweep object.      |\r\n| **Example**        |                                                                |\r\n\r\n```\r\nsavesweep;\r\n```",
    "summary": "Creates and saves the simulations files to a folder in the working directory, this script command is...",
    "syntax": [
      {
        "syntax": "savesweep;",
        "description": "Saves the simulation files of all sweep objects in simulation."
      },
      {
        "syntax": "savesweep(\"name\");",
        "description": "Saves the simulation files of the specified sweep object."
      }
    ],
    "example": ""
  },
  {
    "name": "scorrcoef",
    "description": "Generates a spatial correlation matrix.",
    "usage": "scorrcoef();",
    "category": "general",
    "markdown": "# scorrcoef\r\n\r\nGenerates a spatial correlation matrix.\r\n\r\n| **Syntax**                               | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scorrcoef(x_pos, y_pos, x_corr, y_corr); | Generates a spatial correlation matrix. x_pos and y_pos are vectors containing the x and y layout coordinate respectively, and x_corr and y_corr are the correlation values for the x and y coordinates respectively. Correlation is defined as a Gaussian function: $$ \\\\begin{array}{l}{c\\\\left\\[(x, y)_{i},(x, y)_{j}\\\\right\\]=\\\\exp \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{\\\\left(x\\_{j}-x\\_{i}\\\\right)^{2}}{\\\\sigma\\_{x}^{2}}+\\\\frac{\\\\left(y\\_{j}-y\\_{i}\\\\right)^{2}}{\\\\sigma\\_{y}^{2}}\\\\right)\\\\right)} \\\\\\\\ {x=\\\\left[-\\\\frac{x\\_{\\\\text { span }}}{2},+\\\\frac{x\\_{\\\\text { span }}}{2}\\\\right]} \\\\\\\\ {y=\\\\left[-\\\\frac{y\\_{\\\\text { span }}}{2},+\\\\frac{y\\_{\\\\text { span }}}{2}\\\\right]}\\\\end{array} $$ |",
    "summary": "Generates a spatial correlation matrix",
    "syntax": [
      {
        "syntax": "scorrcoef(x_pos, y_pos, x_corr, y_corr);",
        "description": "Generates a spatial correlation matrix. x_pos and y_pos are vectors containing the x and y layout coordinate respectively, and x_corr and y_corr are the correlation values for the x and y coordinates respectively. Correlation is defined as a Gaussian function: $$ \\\\begin{array}{l}{c\\\\left\\[(x, y)_{i},(x, y)_{j}\\\\right\\]=\\\\exp \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{\\\\left(x\\_{j}-x\\_{i}\\\\right)^{2}}{\\\\sigma\\_{x}^{2}}+\\\\frac{\\\\left(y\\_{j}-y\\_{i}\\\\right)^{2}}{\\\\sigma\\_{y}^{2}}\\\\right)\\\\right)} \\\\\\\\ {x=\\\\left[-\\\\frac{x\\_{\\\\text { span }}}{2},+\\\\frac{x\\_{\\\\text { span }}}{2}\\\\right]} \\\\\\\\ {y=\\\\left[-\\\\frac{y\\_{\\\\text { span }}}{2},+\\\\frac{y\\_{\\\\text { span }}}{2}\\\\right]}\\\\end{array} $$"
      }
    ],
    "example": ""
  },
  {
    "name": "scriptautorun",
    "description": "Disable or enable running script files automatically by typing the script name.",
    "usage": "scriptautorun();",
    "category": "general",
    "markdown": "# scriptautorun\r\n\r\nDisable or enable running script files automatically by typing the script name.\r\n\r\n| **Syntax**             | **Description** |\r\n| ---------------------- | --------------- |\r\n| scriptautorun(option); | The options are |\r\n\r\n- 0: disables automatic running of script files\r\n- 1: enables automatic running of script files\r\n\r\n**Examples**\r\n\r\nThe following examples assume you have created a script file called hello_world.lsf that\r\nprints the message \"hello\". You will get the error message \"Error: prompt line 3:\r\nhello_world is not a valid function or variable name\" when running the following\r\ncommands because scriptautorun is disabled.\r\n\r\n```\r\nclear;\r\nscriptautorun(0); #disable autorun\r\nhello_world;\r\n```\r\n\r\nWhen you enable scriptautorun the script file is executed and the message \"hello\" will\r\nappear in the script prompt.\r\n\r\n```\r\nclear;\r\nscriptautorun(1); #enable autorun\r\nhello_world;\r\n```\r\n\r\nIf scriptautorun is disabled you can still run script files using the function feval.\r\n\r\n```\r\nclear;\r\nscriptautorun(0); #disable autorun\r\nfeval(\"hello_world\");\r\n```",
    "summary": "Disable or enable running script files automatically by typing the script name",
    "syntax": [
      {
        "syntax": "scriptautorun(option);",
        "description": "The options are"
      }
    ],
    "example": ""
  },
  {
    "name": "select",
    "description": "Selects objects with a given name in the current group scope. A failed select command will have the same result as the unselectall command.",
    "usage": "select();",
    "category": "general",
    "markdown": "# select\r\n\r\nSelects objects with a given name in the current group scope. A failed select command\r\nwill have the same result as the unselectall command.\r\n\r\n| **Syntax**                  | **Description**                                                                                                                                    |\r\n| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| select(\"name\");             | Selects objects with the name \"name\" in the current group scope. This function does not return any data.                                           |\r\n| select(\"group name::name\"); | Selects all objects with the name \"name\" located in the group named \"group name\". The group named \"group name\" must be in the current group scope. |\r\n\r\n**Example**\r\n\r\nAdd two objects and select the first object for other settings.\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"substrate\");\r\naddring;\r\nselect(\"substrate\");\r\n```",
    "summary": "Selects objects with a given name in the current group scope",
    "syntax": [
      {
        "syntax": "select(\"name\");",
        "description": "Selects objects with the name \"name\" in the current group scope. This function does not return any data."
      },
      {
        "syntax": "select(\"group name::name\");",
        "description": "Selects all objects with the name \"name\" located in the group named \"group name\". The group named \"group name\" must be in the current group scope."
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"substrate\");\r\naddring;\r\nselect(\"substrate\");"
  },
  {
    "name": "selectall",
    "description": "Selects all objects in the current group scope.",
    "usage": "selectall();",
    "category": "general",
    "markdown": "# selectall\r\n\r\nSelects all objects in the current group scope.\r\n\r\n| **Syntax** | **Description**                                                                         |\r\n| ---------- | --------------------------------------------------------------------------------------- |\r\n| selectall; | Selects all objects in the current group scope. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThis function is often used in\r\n[Structure Groups](https://optics.ansys.com/hc/en-us/articles/360034382434-Structure-Groups).",
    "summary": "Selects all objects in the current group scope",
    "syntax": [
      {
        "syntax": "selectall;",
        "description": "Selects all objects in the current group scope. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "selectfigure",
    "description": "Selects a figure, which will be shown on screen (gives it focus). A warning will be generated if the figure does not exist.",
    "usage": "selectfigure();",
    "category": "general",
    "markdown": "# selectfigure\r\n\r\nSelects a figure, which will be shown on screen (gives it focus). A warning will be\r\ngenerated if the figure does not exist.\r\n\r\n| **Syntax**       | **Description**                                                                   |\r\n| ---------------- | --------------------------------------------------------------------------------- |\r\n| selectfigure;    | Selects the last figure that was created. This function does not return any data. |\r\n| selectfigure(1); | Selects figure 1.                                                                 |\r\n\r\n**Example**\r\n\r\nSee exportfigure example.",
    "summary": "Selects a figure, which will be shown on screen (gives it focus)",
    "syntax": [
      {
        "syntax": "selectfigure;",
        "description": "Selects the last figure that was created. This function does not return any data."
      },
      {
        "syntax": "selectfigure(1);",
        "description": "Selects figure 1."
      }
    ],
    "example": ""
  },
  {
    "name": "selectmode",
    "description": "Selects a mode from the mode list. All modes found in a simulation are numbered based on their effective index and they are displayed in the mode list in the Eigensolver analysis window.",
    "usage": "selectmode();",
    "category": "general",
    "markdown": "# selectmode\r\n\r\nSelects a mode from the mode list. All modes found in a simulation are numbered based on\r\ntheir effective index and they are displayed in the mode list in the Eigensolver\r\nanalysis window.\r\n\r\n| **Syntax**        | **Description**                                                                                                                                                                                                   |\r\n| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| selectmode(N);    | Select the Nth mode from the mode list.                                                                                                                                                                           |\r\n| selectmode([N]);  | Select mode(s) from a scalar matrix argument; multiple modes can be selected by listing multiple elements in [N], e.g., [1,2,3].                                                                                  |\r\n| selectmode(name); | Selects the desired mode where name is a string containing the name of a mode. Modes are named mode1, mode2, ..modeN. This form of the command is compatible with the [ bestoverlap ](./bestoverlap.md) function. |\r\n\r\n**Examples**\r\n\r\nBoth these commands select the third mode in the list:\r\n\r\n```\r\nselectmode(3);selectmode(\"mode3\");\r\n```\r\n\r\nSelects the 3rd, 5th, and 6th modes.\r\n\r\n```\r\nselectmode([3,5,6]);\r\n```\r\n\r\nSelects the modes 2 through 5, and 8.\r\n\r\n```\r\nselectmode([[2:5];8]);\r\n```\r\n\r\nThis command selects the mode that has the best overlap with the D-card named\r\n\"reference\"\r\n\r\n```\r\nselectmode(bestoverlap(\"reference\"));\r\n```",
    "summary": "Selects a mode from the mode list",
    "syntax": [
      {
        "syntax": "selectmode(N);",
        "description": "Select the Nth mode from the mode list."
      },
      {
        "syntax": "selectmode([N]);",
        "description": "Select mode(s) from a scalar matrix argument; multiple modes can be selected by listing multiple elements in [N], e.g., [1,2,3]."
      },
      {
        "syntax": "selectmode(name);",
        "description": "Selects the desired mode where name is a string containing the name of a mode. Modes are named mode1, mode2, ..modeN. This form of the command is compatible with the [ bestoverlap ](./bestoverlap.md) function."
      }
    ],
    "example": ""
  },
  {
    "name": "selectpartial",
    "description": "Selects any objects with a given partial name.",
    "usage": "selectpartial();",
    "category": "general",
    "markdown": "# selectpartial\r\n\r\nSelects any objects with a given partial name.\r\n\r\n| **Syntax**                                      | **Description**                                                                                                                                                                                                   |\r\n| ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| selectpartial(\"partialname\");                   | Selects any objects where \"partialname\" can be found in the object name provided the object is not in a group. To select objects located in groups see the command below. This function does not return any data. |\r\n| selectpartial(\"partialgroupname::partialname\"); | Selects any objects where \"partialgroupname\" can be found in the group name and \"partialname\" can be found in the object name.                                                                                    |\r\n\r\n**Example**\r\n\r\nCreate two objects and put them in a group. Make an additional copy of the triangle\r\nobject within the group.\r\n\r\n```\r\n#create a substrate with a channel etched in the center. Put the objects in a group\r\naddrect;\r\naddtriangle;\r\nselectpartial(\"angle\"); # select both the triANGLE and rectANGLE objects\r\naddtogroup(\"structure\");# add selected to group\r\n#select the etch and copy to create a second channel\r\nselectpartial(\"structure::tri\"); # select the TRIangle\r\ncopy(1e-6);            # copy the TRIangle\r\n```",
    "summary": "Selects any objects with a given partial name",
    "syntax": [
      {
        "syntax": "selectpartial(\"partialname\");",
        "description": "Selects any objects where \"partialname\" can be found in the object name provided the object is not in a group. To select objects located in groups see the command below. This function does not return any data."
      },
      {
        "syntax": "selectpartial(\"partialgroupname::partialname\");",
        "description": "Selects any objects where \"partialgroupname\" can be found in the group name and \"partialname\" can be found in the object name."
      }
    ],
    "example": "#create a substrate with a channel etched in the center. Put the objects in a group\r\naddrect;\r\naddtriangle;\r\nselectpartial(\"angle\"); # select both the triANGLE and rectANGLE objects\r\naddtogroup(\"structure\");# add selected to group\r\n#select the etch and copy to create a second channel\r\nselectpartial(\"structure::tri\"); # select the TRIangle\r\ncopy(1e-6);            # copy the TRIangle"
  },
  {
    "name": "set",
    "description": "Sets a property of currently selected objects.",
    "usage": "set();",
    "category": "general",
    "markdown": "# set\r\n\r\nSets a property of currently selected objects.\r\n\r\nNote that most objects can not be modified when the solver is in Analysis mode. In such\r\nsituations, this command will return an error.\r\n\r\n| **Syntax**               | **Description**                                                                                                                                                                                                                                                                                                                                        |\r\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| ?set;                    | Returns a list of the properties of the selected object(s) that can be changed with the set command.                                                                                                                                                                                                                                                   |\r\n| set(\"property\",value);   | This will set the properties of a currently selected object, including pull-downs and check boxes. It cannot be used to set the value of a selected object in a group. Value can be a number or string. This function does not return any data.                                                                                                        |\r\n| set(struct);             | A struct can be accepted in place of \"property\"-value pair of arguments.                                                                                                                                                                                                                                                                               |\r\n| set(\"property\",value,i); | This form can be used to set the property of the ith selected object when multiple objects are selected. It cannot be used to set the value of a selected object in a group. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. |\r\n\r\n**Examples**\r\n\r\nSet the radius of any selected objects (sphere, ring, circle) with a property called\r\nradius to 1e-6.\r\n\r\n```\r\nset(\"radius\",1e-6);\r\n```\r\n\r\nSet the name property of all selected objects to reflection.\r\n\r\n```\r\nset(\"name\",\"reflection\");\r\n```\r\n\r\nSet a checkbox to 0 to uncheck. Set to 1 to check.\r\n\r\n```\r\nset(\"check box label name\",0);  # unselect checkbox \r\n```\r\n\r\nTo disable an object.\r\n\r\n```\r\nset(\"enabled\",0);\r\n```\r\n\r\nSet the x min boundary condition to be the first choice in the pull-down menu.\r\n\r\n```\r\nset(\"x min bc\",1);\r\n```\r\n\r\nSet the x min boundary condition to the string \"PML\".\r\n\r\n```\r\nset(\"x min bc\",\"PML\");\r\n```\r\n\r\nSet the PML profile of the FDTD region\r\n\r\n```\r\nset(\"pml profile\", 2);\r\n```\r\n\r\nSet the PML profiles for individual boundary\r\n\r\n```\r\nset(\"same settings on all boundaries\",0);\r\nset(\"pml profile\", [1,1,2,1,1,1]); # setting y min bc to \"stabilized\", and all other bc to \"standard\"\r\n```\r\n\r\nAdd 2 microns to the radius of all objects named \"circle\".\r\n\r\n```\r\nselect(\"circle\");\r\nfor (i=1:getnumber) {\r\n rad=get(\"radius\",i);\r\n set(\"radius\",rad+2e-6,i);\r\n} \r\n```\r\n\r\nSet and get the vertices of a polygon object. We create an octagon with a radius of 1um.\r\n\r\n```\r\naddpoly;\r\ntheta=linspace(0,2*pi,9);\r\ntheta=theta(1:8);\r\nx=cos(theta)*1e-6;\r\ny=sin(theta)*1e-6;\r\nV=[x,y];\r\nset(\"vertices\",V);\r\n?get(\"vertices\");\r\nresult: \r\n1e-006 0 \r\n7.07107e-007 7.07107e-007 \r\n6.12323e-023 1e-006 \r\n-7.07107e-007 7.07107e-007 \r\n-1e-006 1.22465e-022 \r\n-7.07107e-007 -7.07107e-007 \r\n-1.83697e-022 -1e-006 \r\n7.07107e-007 -7.07107e-007 \r\n```\r\n\r\nSee a list of the properties of a rectangle.\r\n\r\n```\r\naddrect;\r\n?get;\r\nalpha\r\ncolor opacity\r\ndetail\r\nenabled\r\nfirst axis\r\ngrid attribute name\r\nindex\r\nindex units\r\nmaterial\r\nmesh order\r\nname\r\noverride color opacity from material database\r\noverride mesh order from material database\r\nrender type\r\nrotation 1\r\nrotation 2\r\nrotation 3\r\nsecond axis\r\nset color opacity from material database\r\nset mesh order from material database\r\nthird axis\r\nx\r\nx max\r\nx min\r\nx span\r\ny\r\ny max\r\ny min\r\ny span\r\nz\r\nz max\r\nz min\r\nz span\r\n```\r\n\r\nUse struct as an input to set the coordinates and dimensions of a currently selected\r\nobject called \"rectangle\":\r\n\r\n```\r\ncoordinates = {\"x\" : -3e-7,  \r\n               \"x span\" : 1e-6,  \r\n               \"y\" : 5e-6,  \r\n               \"y span\" : 1e-5,  \r\n               \"z\" : 1e-7,  \r\n               \"z span\" : 2.2e-7};  \r\n  \r\nset(coordinates);\r\n```\r\n\r\n**Notes**\r\n\r\nIn INTERCONNECT, the element property value must be entered in the set command using the\r\nfixed standard unit. In some cases, the standard unit is different from the default unit\r\nin the Property View. Following is an example of setting the ONA center frequency. The\r\ncenter frequency default unit is THz, while the standard unit is Hz, and when using the\r\nset command, the value needs to be in Hz:\r\n\r\n```\r\nselect(\"ONA\");\r\nset(\"center frequency\", 193.1e12); \r\n```\r\n\r\nTo find the standard unit for an element property, open the element's help page on the\r\nKnowledge Page, and look at the Default unit column. A note is included for cases where\r\nthe default and standard units differ. For example, see the center frequency of the\r\n[ONA](https://optics.ansys.com/hc/en-us/articles/360036617973).",
    "summary": "Sets a property of currently selected objects",
    "syntax": [
      {
        "syntax": "?set;",
        "description": "Returns a list of the properties of the selected object(s) that can be changed with the set command."
      },
      {
        "syntax": "set(\"property\",value);",
        "description": "This will set the properties of a currently selected object, including pull-downs and check boxes. It cannot be used to set the value of a selected object in a group. Value can be a number or string. This function does not return any data."
      },
      {
        "syntax": "set(struct);",
        "description": "A struct can be accepted in place of \"property\"-value pair of arguments."
      },
      {
        "syntax": "set(\"property\",value,i);",
        "description": "This form can be used to set the property of the ith selected object when multiple objects are selected. It cannot be used to set the value of a selected object in a group. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree."
      }
    ],
    "example": ""
  },
  {
    "name": "setactivesolver",
    "description": "Sets the specified solver as the active solver. For example, this can be used to toggle between the FDE, varFDTD, and EME simulations in MODE.",
    "usage": "setactivesolver();",
    "category": "general",
    "markdown": "# setactivesolver\r\n\r\nSets the specified solver as the active solver. For example, this can be used to toggle\r\nbetween the FDE, varFDTD, and EME simulations in MODE.\r\n\r\n| **Syntax**                      | **Description**                                              |\r\n| ------------------------------- | ------------------------------------------------------------ |\r\n| ?setactivesolver;               | Lists all the possible solver choices                        |\r\n| setactivesolver('solver_name'); | Set the solver with the specified name as the active solver. |\r\n\r\n**Example**\r\n\r\nIf the solver is not set, this command will add it.\r\n\r\n```\r\nsetactivesolver(\"EME\");\r\n?getactivesolver;\r\nEME\r\n```\r\n\r\nWhen \"EME\" solver is already added, this command will set it as active; if it is not\r\nadded yet, this command will add this solver and set it as active.",
    "summary": "Sets the specified solver as the active solver",
    "syntax": [
      {
        "syntax": "?setactivesolver;",
        "description": "Lists all the possible solver choices"
      },
      {
        "syntax": "setactivesolver('solver_name');",
        "description": "Set the solver with the specified name as the active solver."
      }
    ],
    "example": "setactivesolver(\"EME\");\r\n?getactivesolver;\r\nEME"
  },
  {
    "name": "setanalysis",
    "description": "Sets calculation parameters in MODE' FDE and FEEM analysis window.",
    "usage": "setanalysis();",
    "category": "general",
    "markdown": "# setanalysis\r\n\r\nSets calculation parameters in MODE' FDE and FEEM analysis window.\r\n\r\n| **Syntax**                      | **Description**                                  |\r\n| ------------------------------- | ------------------------------------------------ |\r\n| ?setanalysis;                   | Lists all the parameters in the analysis window. |\r\n| setanalysis(\"property\", value); | Sets\"property\" to value.                         |\r\n\r\n**Example**\r\n\r\nTo perform a frequency sweep on the first mode and plot the dispersion:\r\n\r\n```\r\nswitchtolayout;  \r\nfindmodes;  \r\n  \r\nselectmode(1);  \r\nsetanalysis(\"track selected mode\",1);  \r\nsetanalysis(\"detailed dispersion calculation\",1);  \r\n  \r\nfrequencysweep;  \r\n\r\nD=getdata(\"frequencysweep\",\"D\");  \r\nf=getdata(\"frequencysweep\",\"f_D\");  \r\nplot(c/f*1e6,D*1e6,\"Wavelength (um)\", \"Dispersion (ps/nm/km)\");\r\n```",
    "summary": "Sets calculation parameters in MODE' FDE and FEEM analysis window",
    "syntax": [
      {
        "syntax": "?setanalysis;",
        "description": "Lists all the parameters in the analysis window."
      },
      {
        "syntax": "setanalysis(\"property\", value);",
        "description": "Sets\"property\" to value."
      }
    ],
    "example": "switchtolayout;  \r\nfindmodes;  \r\n  \r\nselectmode(1);  \r\nsetanalysis(\"track selected mode\",1);  \r\nsetanalysis(\"detailed dispersion calculation\",1);  \r\n  \r\nfrequencysweep;  \r\n\r\nD=getdata(\"frequencysweep\",\"D\");  \r\nf=getdata(\"frequencysweep\",\"f_D\");  \r\nplot(c/f*1e6,D*1e6,\"Wavelength (um)\", \"Dispersion (ps/nm/km)\");"
  },
  {
    "name": "setconnectionrouting",
    "description": "This command sets the connection routing for a given connection.",
    "usage": "setconnectionrouting();",
    "category": "general",
    "markdown": "# setconnectionrouting\r\n\r\nThis command sets the connection routing for a given connection.\r\n\r\n| **Syntax**                                                                        | **Description**                                                                                                                                                                                                                                                                                                       |\r\n| --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| setconnectionrouting (element, port, type); setconnectionrouting (element, type); | This command sets the connection routing for a given connection. If only the element and the type are provided, all connections to the element port will have the same type. If element name, port and type are provided, only the specific element port connection will be affected. type = \"direct\" or \"manhattan\". |",
    "summary": "This command sets the connection routing for a given connection",
    "syntax": [
      {
        "syntax": "setconnectionrouting (element, port, type); setconnectionrouting (element, type);",
        "description": "This command sets the connection routing for a given connection. If only the element and the type are provided, all connections to the element port will have the same type. If element name, port and type are provided, only the specific element port connection will be affected. type = \"direct\" or \"manhattan\"."
      }
    ],
    "example": ""
  },
  {
    "name": "setdevice",
    "description": "Sets the type of device used to run the simulation in the [FDTD Resource Selection Group](https://optics.ansys.com/hc/en-us/articles/36952912384403-Ansys-Lumerical-FDTD-Modern-User-Interface#run_simulation_group). This command can only be used if there is an FDTD simulation region present.",
    "usage": "setdevice();",
    "category": "general",
    "markdown": "# setdevice\r\n\r\nSets the type of device used to run the simulation in the\r\n[FDTD Resource Selection Group](https://optics.ansys.com/hc/en-us/articles/36952912384403-Ansys-Lumerical-FDTD-Modern-User-Interface#run_simulation_group).\r\nThis command can only be used if there is an FDTD simulation region present.\r\n\r\n| **Syntax**                | **Description**                                                      |\r\n| ------------------------- | -------------------------------------------------------------------- |\r\n| setdevice(“device_type”); | Sets the type of device used to run the simulation, via device_type: |\r\n\r\n- device_type: type of device, can be “CPU” or “GPU”",
    "summary": "Sets the type of device used to run the simulation in the [FDTD Resource Selection Group](https://op...",
    "syntax": [
      {
        "syntax": "setdevice(“device_type”);",
        "description": "Sets the type of device used to run the simulation, via device_type:"
      }
    ],
    "example": ""
  },
  {
    "name": "seteigensolver",
    "description": "Mode sources, mode expansion monitors, and ports in FDTD and MODE, and each individual cell in EME have embedded eigensolvers. This script command makes it possible to set the properties of that eigensolver without using the GUI.",
    "usage": "seteigensolver();",
    "category": "general",
    "markdown": "# seteigensolver\r\n\r\nMode sources, mode expansion monitors, and ports in FDTD and MODE, and each individual\r\ncell in EME have embedded eigensolvers. This script command makes it possible to set the\r\nproperties of that eigensolver without using the GUI.\r\n\r\nChanging any values of the embedded eigensolver with this command will automatically\r\ninvalidate any existing mode data. This means that new updates based on overlap\r\ncalculations with previous modes will fail after using this command. Therefore please\r\ncall this command before making any calls to updatesourcemode or updatemodes.\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                      |\r\n| --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?seteigensolver;                  | Returns a list of the properties of the embedded eigensolver                                                                                         |\r\n| seteigensolver(\"property\",value); | This will set the eigensolver properties of the currently selected objects. Value can be a number or string. This function does not return any data. |\r\n\r\n**Example**\r\n\r\n1. Change the radius of curvature for a mode expansion calculation, and calculate the\r\n   first 10 modes which can be subsequently used for mode expansion. Please open\r\n   ring_resonator2.lms from the [ ring resonator example ](**%20to%20be%20defined%20**)\r\n   using the varFDTD solver in MODE:\r\n\r\n```\r\nselect(\"expansion\");\r\n\r\n\r\nseteigensolver(\"bent waveguide\",true);\r\nseteigensolver(\"bend radius\",10e-6);\r\nupdatemodes(1:10);\r\n```\r\n\r\n2\\. Change the number of trial modes for cell 1 in EME:\r\n\r\n```\r\nselect(\"EME::Cells::cell_1\");  \r\nseteigensolver(\"number of trial modes\",25);\r\n```\r\n\r\nAlso see the examples in the [ addmodeexpansion ](./addmodeexpansion.md) , and\r\n[ addport ](https://optics.ansys.com/hc/en-us/articles/360034924793-addport) script\r\nfunctions.",
    "summary": "Mode sources, mode expansion monitors, and ports in FDTD and MODE, and each individual cell in EME h...",
    "syntax": [
      {
        "syntax": "?seteigensolver;",
        "description": "Returns a list of the properties of the embedded eigensolver"
      },
      {
        "syntax": "seteigensolver(\"property\",value);",
        "description": "This will set the eigensolver properties of the currently selected objects. Value can be a number or string. This function does not return any data."
      }
    ],
    "example": "select(\"expansion\");\r\n\r\n\r\nseteigensolver(\"bent waveguide\",true);\r\nseteigensolver(\"bend radius\",10e-6);\r\nupdatemodes(1:10);"
  },
  {
    "name": "setemeanalysis",
    "description": "Sets calculation parameters in MODE' EME analysis window.",
    "usage": "setemeanalysis();",
    "category": "general",
    "markdown": "# setemeanalysis\r\n\r\nSets calculation parameters in MODE' EME analysis window.\r\n\r\n| Syntax                             | Description                                          |\r\n| ---------------------------------- | ---------------------------------------------------- |\r\n| ?setemeanalysis;                   | Lists all the parameters in the EME analysis window. |\r\n| setemeanalysis(\"property\", value); | Sets the parameter named \"property\" to value.        |\r\n\r\n**Examples**\r\n\r\nThis code will display the properties that can be set, and set the group spans column in\r\nthe EME analysis window's EME setup section.\r\n\r\n```\r\n# display properties that can be set using setemeanalysis command  \r\n?setemeanalysis;  \r\n\r\n# set group spans property to 1 micron (for 3 cell groups)  \r\nsetemeanalysis(\"group spans\",[1e-6;1e-6;1e-6]);\r\n```\r\n\r\nThis code will set up, run and collect the user s-matrix result from the propagation\r\nsweep tool in Analysis mode.\r\n\r\n```\r\n# set propagation sweep settings  \r\nsetemeanalysis(\"propagation sweep\",1);  \r\nsetemeanalysis(\"parameter\",\"group span 2\");  \r\nsetemeanalysis(\"start\",10e-6);  \r\nsetemeanalysis(\"stop\",200e-6);  \r\nsetemeanalysis(\"number of points\",10);  \r\n\r\n# run propagation sweep tool  \r\nemesweep;  \r\n\r\n# get propagation sweep result  \r\nS = getemesweep('S');\r\n```\r\n\r\nThis code will set up, run and export the user s-matrix result from the wavelength sweep\r\ntool in Analysis mode to a file named \"s_param\".\r\n\r\n```\r\n# set wavelength sweep settings  \r\nsetemeanalysis(\"wavelength sweep\", 1);  \r\nsetemeanalysis(\"start wavelength\", 1.5e-6);  \r\nsetemeanalysis(\"stop wavelength\", 1.6e-6);  \r\nsetemeanalysis(\"number of wavelength points\", 31);  \r\nsetemeanalysis(\"calculate group delays\", 1);  \r\n\r\n# run wavelength sweep tool  \r\nemesweep(\"wavelength sweep\");  \r\n\r\n# export the wavelength sweep result  \r\nexportemesweep(\"s_param\");\r\n```",
    "summary": "Sets calculation parameters in MODE' EME analysis window",
    "syntax": [
      {
        "syntax": "?setemeanalysis;",
        "description": "Lists all the parameters in the EME analysis window."
      },
      {
        "syntax": "setemeanalysis(\"property\", value);",
        "description": "Sets the parameter named \"property\" to value."
      }
    ],
    "example": ""
  },
  {
    "name": "setexpansion",
    "description": "Associates a DFT monitor with a mode expansion monitor.",
    "usage": "setexpansion();",
    "category": "general",
    "markdown": "# setexpansion\r\n\r\nAssociates a DFT monitor with a mode expansion monitor.\r\n\r\n| **Syntax**                           | **Description**                                                                                                              |\r\n| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| ?setexpansion;                       | List all monitors under the \"Monitors for expansion\" list for the selected mode expansion monitor.                           |\r\n| setexpansion(\"name\", \"dft_monitor\"); | Adds the \"dft_monitor\" to the \"Monitors for expansion\" list of the selected mode expansion monitor, with the specified name. |\r\n\r\n**Example**\r\n\r\nPlease open \\[[ring_resonator.fsp]\\] from the\r\n[Ring resonator example](https://optics.ansys.com/hc/en-us/articles/360042800293) and do\r\nthe following.\r\n\r\n```\r\n?setexpansion;\r\ndrop2  ::model::drop2\r\nin  ::model::in\r\nthrough  ::model::through\r\ndrop  ::model::drop\r\n```\r\n\r\nIt shows all four DFT monitors to be expanded.\r\n\r\nFor the same file, type in\r\n\r\n```\r\n setexpansion(\"test\", \"in\");\r\n```\r\n\r\nThen the DFT monitor \"in\" is added to the list of the \"expansion\" monitor with the name\r\nof \"test\".\r\n\r\nType in removeexpansion(\"test\") the \"test\" is removed from the list.",
    "summary": "Associates a DFT monitor with a mode expansion monitor",
    "syntax": [
      {
        "syntax": "?setexpansion;",
        "description": "List all monitors under the \"Monitors for expansion\" list for the selected mode expansion monitor."
      },
      {
        "syntax": "setexpansion(\"name\", \"dft_monitor\");",
        "description": "Adds the \"dft_monitor\" to the \"Monitors for expansion\" list of the selected mode expansion monitor, with the specified name."
      }
    ],
    "example": "?setexpansion;\r\ndrop2  ::model::drop2\r\nin  ::model::in\r\nthrough  ::model::through\r\ndrop  ::model::drop"
  },
  {
    "name": "setexpression",
    "description": "The script command sets the selected element's specified property to the mentioned expression.",
    "usage": "setexpression();",
    "category": "general",
    "markdown": "# setexpression\r\n\r\nThe script command sets the selected element's specified property to the mentioned\r\nexpression.\r\n\r\n| **Syntax**                   | **Description**                                                 |\r\n| ---------------------------- | --------------------------------------------------------------- |\r\n| setexpression (name,p,expr); | Set the property ‘p’ of element ‘name’ to an expression ‘expr’. |\r\n\r\n**Example**\r\n\r\nTo set a label for the temperature ad \"%Temp%\" of a waveguide named \"Straight\r\nWaveguide_1\", use the following script\r\n\r\n```\r\nsetexpression(\"Straight Waveguide_1\",\"temperature\",\"%Temp%\");\r\n```",
    "summary": "The script command sets the selected element's specified property to the mentioned expression",
    "syntax": [
      {
        "syntax": "setexpression (name,p,expr);",
        "description": "Set the property ‘p’ of element ‘name’ to an expression ‘expr’."
      }
    ],
    "example": "setexpression(\"Straight Waveguide_1\",\"temperature\",\"%Temp%\");"
  },
  {
    "name": "setfield",
    "description": "The script command assigns a value to a structure input field.",
    "usage": "setfield();",
    "category": "general",
    "markdown": "# setfield\r\n\r\nThe script command assigns a value to a structure input field.\r\n\r\n| **Syntax**                            | **Description**                                   |\r\n| ------------------------------------- | ------------------------------------------------- |\r\n| output= setfield(input, field,value); | Assigns a ‘value’ to a structure ‘input’ ‘field’. |\r\n\r\n### Example\r\n\r\n```\r\n>x=struct;\r\n>x=setfield(x,'t',10);\r\n>?x.t;\r\nresult: \r\n10\r\n```",
    "summary": "The script command assigns a value to a structure input field",
    "syntax": [
      {
        "syntax": "output= setfield(input, field,value);",
        "description": "Assigns a ‘value’ to a structure ‘input’ ‘field’."
      }
    ],
    "example": ""
  },
  {
    "name": "setglobalmonitor",
    "description": "Sets global monitor properties. This command will return an error in analysis mode.",
    "usage": "setglobalmonitor();",
    "category": "general",
    "markdown": "# setglobalmonitor\r\n\r\nSets global monitor properties. This command will return an error in analysis mode.\r\n\r\n| **Syntax**                          | **Description**                                                                                      |\r\n| ----------------------------------- | ---------------------------------------------------------------------------------------------------- |\r\n| ?setglobalmonitor;                  | Returns a list of the global monitor properties                                                      |\r\n| setglobalmonitor(\"property\",value); | Set the global monitor property named \"property\" to a value. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nSet the global number of monitored frequency points to 11, then confirm value was set\r\nproperly.\r\n\r\n```\r\nsetglobalmonitor(\"frequency points\",11);\r\n?getglobalmonitor(\"frequency points\");\r\nresult: \r\n11  \r\n```",
    "summary": "Sets global monitor properties",
    "syntax": [
      {
        "syntax": "?setglobalmonitor;",
        "description": "Returns a list of the global monitor properties"
      },
      {
        "syntax": "setglobalmonitor(\"property\",value);",
        "description": "Set the global monitor property named \"property\" to a value. This function does not return any data."
      }
    ],
    "example": "setglobalmonitor(\"frequency points\",11);\r\n?getglobalmonitor(\"frequency points\");\r\nresult: \r\n11"
  },
  {
    "name": "setglobalsource",
    "description": "Sets global source properties. This command will return an error in analysis mode.",
    "usage": "setglobalsource();",
    "category": "general",
    "markdown": "# setglobalsource\r\n\r\nSets global source properties. This command will return an error in analysis mode.\r\n\r\n| **Syntax**                         | **Description**                                                                                     |\r\n| ---------------------------------- | --------------------------------------------------------------------------------------------------- |\r\n| ?setglobalsource;                  | Returns a list of the global source properties                                                      |\r\n| setglobalsource(\"property\",value); | Set the global source property named \"property\" to a value. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nSet the global start wavelength to 400nm, then confirm value was set properly.\r\n\r\n```\r\nsetglobalsource(\"wavelength start\",400e-9);\r\n?getglobalsource(\"wavelength start\");\r\nresult: \r\n4e-007 \r\n```",
    "summary": "Sets global source properties",
    "syntax": [
      {
        "syntax": "?setglobalsource;",
        "description": "Returns a list of the global source properties"
      },
      {
        "syntax": "setglobalsource(\"property\",value);",
        "description": "Set the global source property named \"property\" to a value. This function does not return any data."
      }
    ],
    "example": "setglobalsource(\"wavelength start\",400e-9);\r\n?getglobalsource(\"wavelength start\");\r\nresult: \r\n4e-007"
  },
  {
    "name": "seticon",
    "description": "Sets a user defined icon for an element.",
    "usage": "seticon();",
    "category": "general",
    "markdown": "# seticon\r\n\r\nSets a user defined icon for an element.\r\n\r\n| **Syntax**           | **Description**                                                                                                                   |\r\n| -------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\r\n| seticon (name,icon); | Set a user defined icon for element ‘name’. Parameter ‘icon’ should be a vector image format SVG (Scalable Vector Graphics) file. |\r\n\r\n**Example**\r\n\r\nSet the icon ‘transmission.svg’ to an existing compound element ‘COMPOUND_1’\r\n\r\n```\r\nseticon(\"COMPOUND_1\",\"transmission.svg\");\r\n```",
    "summary": "Sets a user defined icon for an element",
    "syntax": [
      {
        "syntax": "seticon (name,icon);",
        "description": "Set a user defined icon for element ‘name’. Parameter ‘icon’ should be a vector image format SVG (Scalable Vector Graphics) file."
      }
    ],
    "example": "seticon(\"COMPOUND_1\",\"transmission.svg\");"
  },
  {
    "name": "setlayer",
    "description": "Sets the properties of the specified layer of the selected layer builder object. There needs to be a layer builder object selected.",
    "usage": "setlayer();",
    "category": "general",
    "markdown": "# setlayer\r\n\r\nSets the properties of the specified layer of the selected layer builder object. There\r\nneeds to be a layer builder object selected.\r\n\r\n| **Syntax**                                                 | **Description**                                                                |\r\n| ---------------------------------------------------------- | ------------------------------------------------------------------------------ |\r\n| setlayer(\"layer name\", \"property name\", \"property value\"); | Sets the properties of a specified layer of the selected layer builder object. |\r\n\r\n**Example**\r\n\r\n```\r\nsetlayer(\"abc\",\"thickness\",0.5e-6);\r\nsetlayer(\"abc\",\"background material\",\"Ag (Silver) - CRC\");\r\nsetlayer(\"abc\",\"layer number\", \"(2:0 and 3:0) or 1:0\"); # generate the patterns corresponding to layer 1:0 plus the overlap of layers 2:0 and 3:0.\r\nsetlayer(\"abc\",\"pattern material\",\"Ag (Silver) - CRC\");\r\nsetlayer(\"abc\",\"name\",\"abc123\"); # change the name of \"abc\" to \"abc123\".\r\n```\r\n\r\nPlease refer\r\n[ this example ](https://optics.ansys.com/hc/en-us/articles/360034382394-Layer-builder)\r\nfor more details.",
    "summary": "Sets the properties of the specified layer of the selected layer builder object",
    "syntax": [
      {
        "syntax": "setlayer(\"layer name\", \"property name\", \"property value\");",
        "description": "Sets the properties of a specified layer of the selected layer builder object."
      }
    ],
    "example": "setlayer(\"abc\",\"thickness\",0.5e-6);\r\nsetlayer(\"abc\",\"background material\",\"Ag (Silver) - CRC\");\r\nsetlayer(\"abc\",\"layer number\", \"(2:0 and 3:0) or 1:0\"); # generate the patterns corresponding to layer 1:0 plus the overlap of layers 2:0 and 3:0.\r\nsetlayer(\"abc\",\"pattern material\",\"Ag (Silver) - CRC\");\r\nsetlayer(\"abc\",\"name\",\"abc123\"); # change the name of \"abc\" to \"abc123\"."
  },
  {
    "name": "setmaterial",
    "description": "Sets properties of a material in the material database. This command can only edit the properties of the materials that are NOT write protected.",
    "usage": "setmaterial();",
    "category": "general",
    "markdown": "# setmaterial\r\n\r\nSets properties of a material in the material database. This command can only edit the\r\nproperties of the materials that are NOT write protected.\r\n\r\n| **Syntax**                                              | **Description**                                                                                                                                                                                                                                                                                                                                         |\r\n| ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?setmaterial(\"materialname\");                           | Displays the property names of the specified material that can be modified.                                                                                                                                                                                                                                                                             |\r\n| setmaterial( \"materialname\", \"propertyname\", newvalue); | Sets the property named \"propertyname\" of the material with the name \"materialname\" to newvalue. The argument newvalue can be a number or a string. The arguments \"propertyname\" and \"materialname\" have to match correct string exactly. For example, setmaterial(\"Si\",\"Mesh order\",4); will set the property \"mesh order\" of the materials \"Si\" to 4. |\r\n| setmaterial( \"materialname\", **_struct_**);             | Update multiple material properties at the same time using a [struct](https://support.lumerical.com/hc/en-us/articles/360034409574-struct-Script-command) of associated properties. Keys are given the respective \"propertyname\", and values assigned to the new value.                                                                                 |\r\n\r\n**Example using struct**\r\n\r\n```\r\n# create a material\r\nsetmaterial(addmaterial(\"(n,k) Material\"), \"name\", \"myMaterial\");  \r\n\r\n# set the material properties\r\nsetmaterial(\"myMaterial\", {\"Refractive Index\": 1.3, \"Imaginary Refractive Index\": 1.5});\r\n```\r\n\r\n**Conductive material example**\r\n\r\nThis example adds a new Conductive material, sets the name to \"myMaterial\", anisotropy\r\nto \"Diagonal\", and sets the permittivity and conductivity properties for the material.\r\n\r\n```\r\nA=[4;5;6];\r\nB=[1;2;3];\r\ntemp = addmaterial(\"Conductive\");\r\nsetmaterial(temp,\"name\",\"myMaterial\");\r\nsetmaterial(\"myMaterial\", \"Anisotropy\", 1); # enable diagonal anisotropy\r\nsetmaterial(\"myMaterial\",\"Permittivity\", A);\r\nsetmaterial(\"myMaterial\",\"Conductivity\", B);\r\n```\r\n\r\n**Sampled data material example**\r\n\r\nThis example shows how to create a new Sampled data material.\r\n\r\nThe sampled data matrix must have 2 or 4 columns, for isotropic or anisotropic\r\nmaterials. The first column is the frequency vector, in Hz. The next column(s) are the\r\ncomplex valued permittivity.\r\n\r\nIf you have refractive index data (rather than permittivity), remember that permittivity\r\nis simply the square of the refractive index.\r\n\r\n```\r\nf = linspace(1000e12,300e12,30);   # frequency vector\r\neps = 2 + 1i*(1e6 / (2*pi*f*eps0)); # create example permittivity vector\r\nsampledData = [f,eps];        # collect f and eps in one matrix\r\nmatName = \"My material\";\r\ntemp = addmaterial(\"Sampled data\");\r\nsetmaterial(temp,\"name\",matName);        # rename material\r\nsetmaterial(matName,\"max coefficients\",2);    # set the number of coefficients\r\nsetmaterial(matName,\"sampled data\",sampledData); # load the sampled data matrix\r\n```\r\n\r\n**Index perturbation material example**\r\n\r\nThis example shows how to create a new Index perturbation material.\r\n\r\nThe Index perturbation material can define index perturbation for \"np Density\" and/or\r\n\"Temperature\". For a \"np Density\" index perturbation:\r\n\r\n- \"np density model\": takes an integer or string values of [0, 1, 2], 'Drude', 'Soref\r\n  and Bennet' or 'Custom'\r\n- for model type \"Custom\": \"n sensitivity table\" and \"p sensitivity table\" take a matrix\r\n  argument\r\n\r\nFor a \"Temperature\" index perturbation:\r\n\r\n- for model type \"Linear sensitivity\": users need to set individual values for 'Tref',\r\n  'dn/dt' and 'dk/dt'\r\n\r\n- for model type \"Table of values\": \"temperature sensitivity table\" takes a matrix\r\n  argument\r\n\r\n  nSensitivity = [1.5, 1.5e-3, 1.5e-3;  1.6, 1.6e-3, 1.6e-3; 1.7, 1.7e-3, 1.7e-3];\r\n  pSensitivity = [1, 1e-3, 1e-3;  1.2, 1.2e-3, 1.2e-3; 1.4, 1.4e-3, 1.4e-3]; matName =\r\n  \"May material\"; temp = addmaterial(\"Index perturbation\"); setmaterial(temp, \"name\",\r\n  matName); setmaterial(matName, \"np density model\", \"Custom\"); # use \"Custom\" model\r\n  type setmaterial(matName, \"n sensitivity table\", nSensitivity); # set n sensitivity\r\n  table setmaterial(matName, \"p sensitivity table\", pSensitivity); # set p sensitivity\r\n  table\r\n\r\nIt is possible to define the color of the material using command lines. An example is\r\nshown below. These script commands will create a material, define the material color,\r\nand assign that material to a rectangle to show the color change.\r\n\r\nThe 4 elements in the matrix for the new color value are for the red, green, blue, and\r\nalpha channels of the color, respectively. These elements can be set between 0 to 1,\r\nwhich represents a minimum of 0 and maximum of 255. Alpha defines the opacity, setting\r\nto to 0 means transparent, 1 means a solid color. For example, [1;0;0;1] would be solid\r\nred, [0;1;0;1] would be solid green, and [0;0;1;1] would be solid blue. More color\r\nchannel values can be found using an online color picker tool.\r\n\r\nNote that the color opacity can be also defined in the structure object by overriding\r\nthe material properties.\r\n\r\n```\r\nmymaterial = addmaterial(\"PEC\");\r\nsetmaterial(mymaterial,\"name\", \"test_material\");\r\nsetmaterial(\"test_material\", \"color\", [1; 0.6; 0.4; 0.3] ); # R, G, B, alpha channel\r\naddrect;\r\nset(\"material\", \"test_material\");\r\nset(\"override color opacity from material database\", 0);\r\n```",
    "summary": "Sets properties of a material in the material database",
    "syntax": [
      {
        "syntax": "?setmaterial(\"materialname\");",
        "description": "Displays the property names of the specified material that can be modified."
      },
      {
        "syntax": "setmaterial( \"materialname\", \"propertyname\", newvalue);",
        "description": "Sets the property named \"propertyname\" of the material with the name \"materialname\" to newvalue. The argument newvalue can be a number or a string. The arguments \"propertyname\" and \"materialname\" have to match correct string exactly. For example, setmaterial(\"Si\",\"Mesh order\",4); will set the property \"mesh order\" of the materials \"Si\" to 4."
      },
      {
        "syntax": "setmaterial( \"materialname\", _struct_);",
        "description": "Update multiple material properties at the same time using a [struct](https://support.lumerical.com/hc/en-us/articles/360034409574-struct-Script-command) of associated properties. Keys are given the respective \"propertyname\", and values assigned to the new value."
      }
    ],
    "example": ""
  },
  {
    "name": "setname",
    "description": "The script command setname is used to set the name of a datset.",
    "usage": "setname();",
    "category": "general",
    "markdown": "# setname\r\n\r\nThe script command setname is used to set the name of a datset.\r\n\r\n| **Syntax**       | **Description**                                    |\r\n| ---------------- | -------------------------------------------------- |\r\n| setname(\"test\"); | Returns the name of the dataset of the variable a. |\r\n\r\n**Example**\r\n\r\nThe following is a short example in which we create a matrix dataset named tt and assign\r\nit to variable named T. Using the setname script command the name of the dataset can be\r\nchanged.\r\n\r\n```\r\nT = matrixdataset(\"tt\"); \r\nT.setname(\"test\");\r\n?getname(T);\r\ntest\r\n?T.getname;\r\ntest\r\n```",
    "summary": "The script command setname is used to set the name of a datset",
    "syntax": [
      {
        "syntax": "setname(\"test\");",
        "description": "Returns the name of the dataset of the variable a."
      }
    ],
    "example": "T = matrixdataset(\"tt\"); \r\nT.setname(\"test\");\r\n?getname(T);\r\ntest\r\n?T.getname;\r\ntest"
  },
  {
    "name": "setnamed",
    "description": "Likes the set command, except that the object name must be specified. This command will return an error in analysis mode.",
    "usage": "setnamed();",
    "category": "general",
    "markdown": "# setnamed\r\n\r\nLikes the set command, except that the object name must be specified. This command will\r\nreturn an error in analysis mode.\r\n\r\n| **Syntax**                                        | **Description**                                                                                                                                                                                                                                                                                                               |\r\n| ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?setnamed(\"name\");                                | Returns a list of the properties of the objects called name.                                                                                                                                                                                                                                                                  |\r\n| setnamed(\"name\", \"property\", value);              | The same as set, but acts on objects with a specific name, instead of selected objects.                                                                                                                                                                                                                                       |\r\n| setnamed(\"name\", struct);                         | A struct can be accepted in place of \"property\"-value pair of arguments.                                                                                                                                                                                                                                                      |\r\n| setnamed(\"name\", \"property\", value,i);            | This form can be used to set the property of the ith named object when multiple objects have the same name. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree.                                         |\r\n| setnamed(\"groupname::name\", \"property\", value);   | The same as set, but acts on objects within the group named \"groupname\" that are named \"name\", instead of selected objects.                                                                                                                                                                                                   |\r\n| setnamed(\"groupname::name\", \"property\", value,i); | This form can be used to set the property of the ith object with the name \"name\" in the group \"groupname\" when multiple objects have the same name. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. |\r\n\r\n**Examples**\r\n\r\nSet the radius of the object called \"circle\" to 10nm:\r\n\r\n```\r\nsetnamed(\"circle\",\"radius\",10e-9); \r\n```\r\n\r\nAdd 2 microns to the radius of all selected objects named circle:\r\n\r\n```\r\nfor (i=1:getnamednumber(\"circle\")) {\r\n rad=getnamed(\"circle\",\"radius\",i);\r\n setnamed(\"circle\",\"radius\",rad+2e-6,i);\r\n}\r\n```\r\n\r\nUse struct as an input to set the coordinates and dimensions of an object called\r\n\"rectangle\":\r\n\r\n```\r\ncoordinates = {\"x\" : -3e-7,  \r\n               \"x span\" : 1e-6,  \r\n               \"y\" : 5e-6,  \r\n               \"y span\" : 1e-5,  \r\n               \"z\" : 1e-7,  \r\n               \"z span\" : 2.2e-7};  \r\n  \r\nsetnamed(\"rectangle\", coordinates);\r\n```\r\n\r\n**Notes**\r\n\r\nIn INTERCONNECT, the element property value must be entered in the setnamed command\r\nusing the fixed standard unit. In some cases, the standard unit is different from the\r\ndefault unit in the Property View. Following is an example of setting the ONA center\r\nfrequency. The center frequency default unit is THz, while the standard unit is Hz, and\r\nwhen using the setnamed command, the value needs to be in Hz:\r\n\r\n```\r\nsetnamed(\"ONA\", \"center frequency\", 193.1e12); \r\n```\r\n\r\nTo find the standard unit for an element property, open the element's help page on the\r\nKnowledge Page, and look at the Default unit column. A note is included for cases where\r\nthe default and standard units differ. For example, see the center frequency of the\r\n[ ONA ](**%20to%20be%20defined%20**) .",
    "summary": "Likes the set command, except that the object name must be specified",
    "syntax": [
      {
        "syntax": "?setnamed(\"name\");",
        "description": "Returns a list of the properties of the objects called name."
      },
      {
        "syntax": "setnamed(\"name\", \"property\", value);",
        "description": "The same as set, but acts on objects with a specific name, instead of selected objects."
      },
      {
        "syntax": "setnamed(\"name\", struct);",
        "description": "A struct can be accepted in place of \"property\"-value pair of arguments."
      },
      {
        "syntax": "setnamed(\"name\", \"property\", value,i);",
        "description": "This form can be used to set the property of the ith named object when multiple objects have the same name. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree."
      },
      {
        "syntax": "setnamed(\"groupname::name\", \"property\", value);",
        "description": "The same as set, but acts on objects within the group named \"groupname\" that are named \"name\", instead of selected objects."
      },
      {
        "syntax": "setnamed(\"groupname::name\", \"property\", value,i);",
        "description": "This form can be used to set the property of the ith object with the name \"name\" in the group \"groupname\" when multiple objects have the same name. The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree."
      }
    ],
    "example": ""
  },
  {
    "name": "setpersistcheckouts",
    "description": "Sets whether [persistent license checkout](https://optics.ansys.com/hc/en-us/articles/43817775863059-Upfront-and-Persistent-License-Checkout) is enabled.",
    "usage": "setpersistcheckouts();",
    "category": "general",
    "markdown": "# setpersistcheckouts\r\n\r\nSets whether\r\n[persistent license checkout](https://optics.ansys.com/hc/en-us/articles/43817775863059-Upfront-and-Persistent-License-Checkout)\r\nis enabled.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                             |\r\n| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| setpersistcheckouts(“state”); | Set whether the upfront license checkout feature is enabled. The only accepted states are logical true and false states or logical 0 and 1. |\r\n\r\n**Example**\r\n\r\n```\r\n#Enable the persistent license checkout feature\r\n  \r\nsetpersistcheckouts(true);\r\n\r\n#Disable the persistent license checkout feature\r\n#The logical 0 is used in place of false here\r\n\r\nsetpersistcheckouts(0);\r\n```\r\n",
    "summary": "Sets whether [persistent license checkout](https://optics",
    "syntax": [
      {
        "syntax": "setpersistcheckouts(“state”);",
        "description": "Set whether the upfront license checkout feature is enabled. The only accepted states are logical true and false states or logical 0 and 1."
      }
    ],
    "example": "#Enable the persistent license checkout feature\r\n  \r\nsetpersistcheckouts(true);\r\n\r\n#Disable the persistent license checkout feature\r\n#The logical 0 is used in place of false here\r\n\r\nsetpersistcheckouts(0);"
  },
  {
    "name": "setplot",
    "description": "Sets the plot properties of a figure.",
    "usage": "setplot();",
    "category": "general",
    "markdown": "# setplot\r\n\r\nSets the plot properties of a figure.\r\n\r\n| **Syntax**                             | **Description**                                                                                                                                                                              |\r\n| -------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?setplot;                              | Creates a string which lists all figure properties for the figure that is currently selected. Unless the selectfigure() command was called, the most recently created plot will be selected. |\r\n| setplot(\"property\", \"property value\"); | Set the desired property of the currently selected figure to property value.                                                                                                                 |\r\n\r\n**Example**\r\n\r\nThis example uses the script command setplot to see the properties of a line plot\r\nfigure, then adds a title to the figure.\r\n\r\n```\r\nplot(1:10,(1:10)^2);\r\n?setplot;\r\nx min\r\nx max\r\ny min\r\ny max\r\ntitle\r\nx label\r\ny label\r\nlegend position\r\nsetplot(\"title\",\"my figure\");   #add a title to the figure\r\n```\r\n\r\nThis example creates an image plot of a 10x10 matrix of random numbers between zero and\r\none, then sets the color bar limits to 0.2 - 0.8 with the setplot command.\r\n\r\n```\r\ndata=randmatrix(10,10);\r\nimage(1:10,1:10,data);\r\nsetplot(\"colorbar min\",0.2);\r\nsetplot(\"colorbar max\",0.8);\r\n```",
    "summary": "Sets the plot properties of a figure",
    "syntax": [
      {
        "syntax": "?setplot;",
        "description": "Creates a string which lists all figure properties for the figure that is currently selected. Unless the selectfigure() command was called, the most recently created plot will be selected."
      },
      {
        "syntax": "setplot(\"property\", \"property value\");",
        "description": "Set the desired property of the currently selected figure to property value."
      }
    ],
    "example": "plot(1:10,(1:10)^2);\r\n?setplot;\r\nx min\r\nx max\r\ny min\r\ny max\r\ntitle\r\nx label\r\ny label\r\nlegend position\r\nsetplot(\"title\",\"my figure\");   #add a title to the figure"
  },
  {
    "name": "setposition",
    "description": "Sets horizontal and vertical positions of an element.",
    "usage": "setposition();",
    "category": "general",
    "markdown": "# setposition\r\n\r\nSets horizontal and vertical positions of an element.\r\n\r\n| **Syntax**                  | **Description**                                   |\r\n| --------------------------- | ------------------------------------------------- |\r\n| setposition(\"element\",x,y); | Set an element vertical and horizontal positions. |\r\n\r\n**Example**\r\n\r\nTo set the position of an element named \"Waveguide Coupler_1\" to x=1.0um and y=2um, use\r\nthe following script\r\n\r\n```\r\nsetposition(\"Waveguide Coupler_1\",1e-6,2e-6);\r\n```\r\n\r\n**Example**",
    "summary": "Sets horizontal and vertical positions of an element",
    "syntax": [
      {
        "syntax": "setposition(\"element\",x,y);",
        "description": "Set an element vertical and horizontal positions."
      }
    ],
    "example": "setposition(\"Waveguide Coupler_1\",1e-6,2e-6);"
  },
  {
    "name": "setpsfoutput",
    "description": "Specifies the location of the PSF folder and avoids using the netlist location as a reference in the co-simulation.",
    "usage": "setpsfoutput();",
    "category": "general",
    "markdown": "# setpsfoutput\r\n\r\nSpecifies the location of the PSF folder and avoids using the netlist location as a\r\nreference in the co-simulation.\r\n\r\nBy default, INTERCONNECT uses the netlist path to create the PSF path. The setpsfoutput\r\ncommand allows the users to specify a location of the PSF folder instead of using the\r\ndefault netlist path.\r\n\r\n| **Syntax**           | **Description**                           |\r\n| -------------------- | ----------------------------------------- |\r\n| setpsfoutput(\"path\") | Specifies the location of the PSF folder. |\r\n\r\n**Example**\r\n\r\nThe following script command will import netlist, save file and save output data to a\r\nPSF folder in 3 different locations.\r\n\r\n```\r\nstatic const char* InitScript =\r\n\"new;\"\r\n\"historyoff;\"\r\n\"setpsfoutput(\\\"%path3%\\\");\r\n\"importnetlist(\\\"%path1%\\\");\"\r\n\"save(\\\"%path2%\\\");\"\r\n\"edacosimulation;\"\r\n\"setnamed('::Root Element','simulation output','psf');\"\r\n\"runinitialize;\";\r\n```",
    "summary": "Specifies the location of the PSF folder and avoids using the netlist location as a reference in the...",
    "syntax": [
      {
        "syntax": "setpsfoutput(\"path\")",
        "description": "Specifies the location of the PSF folder."
      }
    ],
    "example": "static const char* InitScript =\r\n\"new;\"\r\n\"historyoff;\"\r\n\"setpsfoutput(\\\"%path3%\\\");\r\n\"importnetlist(\\\"%path1%\\\");\"\r\n\"save(\\\"%path2%\\\");\"\r\n\"edacosimulation;\"\r\n\"setnamed('::Root Element','simulation output','psf');\"\r\n\"runinitialize;\";"
  },
  {
    "name": "setrectangle",
    "description": "Sets the width or height of an element rectangle.",
    "usage": "setrectangle();",
    "category": "general",
    "markdown": "# setrectangle\r\n\r\nSets the width or height of an element rectangle.\r\n\r\n| **Syntax**                    | **Description**                                            |\r\n| ----------------------------- | ---------------------------------------------------------- |\r\n| setrectangle (\"element\",w,h); | Sets the width (w) and height (h) of an element rectangle. |\r\n\r\n**Example**\r\n\r\nTo set a waveguide element named \"Straight Waveguide_1\" with w=1um and h=0.5um, use the\r\nfollowing script\r\n\r\n```\r\n setrectangle(\"Straight Waveguide_1\",1e-6,0.5e-6) ;\r\n```",
    "summary": "Sets the width or height of an element rectangle",
    "syntax": [
      {
        "syntax": "setrectangle (\"element\",w,h);",
        "description": "Sets the width (w) and height (h) of an element rectangle."
      }
    ],
    "example": "setrectangle(\"Straight Waveguide_1\",1e-6,0.5e-6) ;"
  },
  {
    "name": "setresource",
    "description": "Sets properties of the available resources in resource manager for the specified solver.",
    "usage": "setresource();",
    "category": "general",
    "markdown": "# setresource\r\n\r\nSets properties of the available resources in resource manager for the specified solver.\r\n\r\n| **Syntax**                                                | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\r\n| --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| setresource(\"solver\", resource_num, \"property\", \"value\"); | Sets properties of the available resources in resource manager for the specified solver. The \"solver\" argument is used to select the solver from which the resource is being selected. The \"solver\" argument is not supported by INTERCONNECT. resource_num is the number of the desired resource (row number in resource manager). If not specified, the command will return the number of resources currently available for the specified solver. \"property\" is the desired property of the resource and \"value\" is the value to be set or the specified property. |\r\n\r\n**Note** : The mpi executable cannot be set using this command while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Example**\r\n\r\nThis example will set the number of processes for the second resource of the DGTD solver\r\nto 4:\r\n\r\n```\r\nsetresource(\"DGTD\",2,\"processes\",\"4\");\r\n```",
    "summary": "Sets properties of the available resources in resource manager for the specified solver",
    "syntax": [
      {
        "syntax": "setresource(\"solver\", resource_num, \"property\", \"value\");",
        "description": "Sets properties of the available resources in resource manager for the specified solver. The \"solver\" argument is used to select the solver from which the resource is being selected. The \"solver\" argument is not supported by INTERCONNECT. resource_num is the number of the desired resource (row number in resource manager). If not specified, the command will return the number of resources currently available for the specified solver. \"property\" is the desired property of the resource and \"value\" is the value to be set or the specified property."
      }
    ],
    "example": "setresource(\"DGTD\",2,\"processes\",\"4\");"
  },
  {
    "name": "setresult",
    "description": "Sets the result of a Scripted or a Compound element. Note that this command is not available from the script prompt or script file editor. It should be used in the Scripted or Compound element \"Simulation\" tabs.",
    "usage": "setresult();",
    "category": "general",
    "markdown": "# setresult\r\n\r\nSets the result of a Scripted or a Compound element. Note that this command is not\r\navailable from the script prompt or script file editor. It should be used in the\r\nScripted or Compound element \"Simulation\" tabs.\r\n\r\n| **Syntax**                                   | **Description**                                                                                                                                         |\r\n| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| setresult(\"result\",value);                   | Sets the \"result\" for the scripted/compound element to the specified value. The \"result\" can be a matrix or a dataset.                                  |\r\n| setresult(\"result\",value,\"kind (unit)\");     | Sets the \"result\" for the scripted/compound element to the specified value with the given description. Note that units should be placed in parenthesis. |\r\n| setresult(\"result\",x,y,\"x title\",'y title'); | Sets the x, y parameters of the \"result\" for the scripted/compound element. This is useful for visualization.                                           |",
    "summary": "Sets the result of a Scripted or a Compound element",
    "syntax": [
      {
        "syntax": "setresult(\"result\",value);",
        "description": "Sets the \"result\" for the scripted/compound element to the specified value. The \"result\" can be a matrix or a dataset."
      },
      {
        "syntax": "setresult(\"result\",value,\"kind (unit)\");",
        "description": "Sets the \"result\" for the scripted/compound element to the specified value with the given description. Note that units should be placed in parenthesis."
      },
      {
        "syntax": "setresult(\"result\",x,y,\"x title\",'y title');",
        "description": "Sets the x, y parameters of the \"result\" for the scripted/compound element. This is useful for visualization."
      }
    ],
    "example": ""
  },
  {
    "name": "setsetting",
    "description": "Sets the value of a user defined setting. User settings are saved permanently and available after even closing the application.",
    "usage": "setsetting();",
    "category": "general",
    "markdown": "# setsetting\r\n\r\nSets the value of a user defined setting. User settings are saved permanently and\r\navailable after even closing the application.\r\n\r\n| **Syntax**                        | **Description**                          |\r\n| --------------------------------- | ---------------------------------------- |\r\n| setsetting(\"name\",\"string_value\") | Set the value of a user defined setting. |\r\n\r\n| **Parameter** | **Type** | **Description**       |\r\n| ------------- | -------- | --------------------- |\r\n| name          | string   | name of the setting.  |\r\n| string_value  | string   | value of the setting. |\r\n\r\n**Example**\r\n\r\nThis command allows users to define customized setting that is stored permanently, until\r\nthe software reinstallats.\r\n\r\n```\r\nsetsetting(\"in\",\"out\");\r\n?getsetting(\"in\");\r\nout # \"string_value\" of the setting \"in\"\r\n```",
    "summary": "Sets the value of a user defined setting",
    "syntax": [
      {
        "syntax": "setsetting(\"name\",\"string_value\")",
        "description": "Set the value of a user defined setting."
      }
    ],
    "example": "setsetting(\"in\",\"out\");\r\n?getsetting(\"in\");\r\nout # \"string_value\" of the setting \"in\""
  },
  {
    "name": "setsourcesignal",
    "description": "Loads a custom source time signal into a source. This advanced source property allows users to create a custom source source time signal and spectrum. Custom source time signals are required for some types of nonlinear simulations. This feature is not recommended for most types of linear simulations.",
    "usage": "setsourcesignal();",
    "category": "general",
    "markdown": "# setsourcesignal\r\n\r\nLoads a custom source time signal into a source. This advanced source property allows\r\nusers to create a custom source source time signal and spectrum. Custom source time\r\nsignals are required for some types of nonlinear simulations. This feature is not\r\nrecommended for most types of linear simulations.\r\n\r\nThe custom time signal must be defined in terms of the signal Amplitude and Phase. This\r\nis a convenient definition because the Amplitude and Phase are generally slowly varying\r\nas a function of time (compared with the actual time signal), meaning a lower sampling\r\nrate can be used to define the custom signal. The actual time domain signal injected by\r\nthe source is given by:\r\n\r\n| **Syntax**                                                        | **Description**                                                                                                                                                                                                                                                                                   |\r\n| ----------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| setsourcesignal(\"name\", t, amplitude, phase);                     | Sets the time domain signal of source named \"name\". t, amplitude, and phase are 1D vectors with the same length.                                                                                                                                                                                  |\r\n| setsourcesignal(\"name\", t, amplitude, phase, fcentre, bandwidth); | Allows you to specify the precise center frequency and bandwidth that will be used for all simulations. These values are used for materials fits, calculating the mesh, and source limits. If fcentre and bandwidth are not specified, they will be automatically estimated from the time signal. |\r\n\r\n**Example**\r\n\r\nSee the\r\n[Custom source time signal](https://optics.ansys.com/hc/en-us/articles/360034383114-Custom-time-signal)\r\nexample.",
    "summary": "Loads a custom source time signal into a source",
    "syntax": [
      {
        "syntax": "setsourcesignal(\"name\", t, amplitude, phase);",
        "description": "Sets the time domain signal of source named \"name\". t, amplitude, and phase are 1D vectors with the same length."
      },
      {
        "syntax": "setsourcesignal(\"name\", t, amplitude, phase, fcentre, bandwidth);",
        "description": "Allows you to specify the precise center frequency and bandwidth that will be used for all simulations. These values are used for materials fits, calculating the mesh, and source limits. If fcentre and bandwidth are not specified, they will be automatically estimated from the time signal."
      }
    ],
    "example": ""
  },
  {
    "name": "setsweep",
    "description": "Sets a property in a parameter sweep/optimization/Monte Carlo/S-parameter sweep item.",
    "usage": "setsweep();",
    "category": "general",
    "markdown": "# setsweep\r\n\r\nSets a property in a parameter sweep/optimization/Monte Carlo/S-parameter sweep item.\r\n\r\n| **Syntax**                                         | **Description**                                                                                                                                                                   |\r\n| -------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| setsweep(\"name\", \"property_name\", property_value); | Sets a property in a sweep/optimization/Monte Carlo/S-parameter item. \"name\" is the absolute name of an analysis item. \"property_name\" is the property showed in the edit window. |\r\n| ?setsweep(“name”);                                 | View the editable properties of the analysis item.                                                                                                                                |\r\n| “name” is the absolute name of the analysis item.  |                                                                                                                                                                                   |\r\n\r\nFor a\r\n[**parameter sweep**](https://optics.ansys.com/hc/en-us/articles/360034922873-Parameter-sweep-utility)analysis:\r\n\r\n| **Argument**                                  | **Description**                                                               |\r\n| --------------------------------------------- | ----------------------------------------------------------------------------- |\r\n| property_name = \"name\"                        | Sets the name of the sweep.                                                   |\r\n| property_name = \"solver\"                      | Sets the solver used for sweep.                                               |\r\n| property_name = \"type\"                        | Sets the type of the sweep. The value of \"type\" could be \"Ranges\" or \"Values\" |\r\n| property_name = \"number of points\"            | Sets the number of points of the sweep. The default number of points is 10.   |\r\n| property_name = \"resave files after analysis\" | Defines whether or not to re-save the file after analysis.                    |\r\n\r\nFor an\r\n\\*\\*[optimization](https://optics.ansys.com/hc/en-us/articles/360034922953-Optimization-utility)\r\n\\*\\* analysis:\r\n\r\n| **Argument**                                 | **Description**                                                              |\r\n| -------------------------------------------- | ---------------------------------------------------------------------------- |\r\n| property_name = \"name\"                       | Sets the name of the optimization.                                           |\r\n| property_name = \"algorithm\"                  | \"algorithm\" = \"Particle Swarm\", \"User Defined\"                               |\r\n| property_name = \"maximum generations\"        | Sets the maximum generation number.                                          |\r\n| property_name = \"reset random generator\"     | Checks the box of \"Reset random generation\".                                 |\r\n| property_name = \"type\"                       | \"Type\" = \"Maximum\", \"Minimum\"                                                |\r\n| property_name = \"generation size\"            | The number of simulations per generation.                                    |\r\n| property_name = \"tolerance\"                  | Sets the tolerance value.                                                    |\r\n| property_name = \"first generation script\"    | Sets the \"first generation script\" in the \"Advanced\" tab.                    |\r\n| property_name = \"next generation script\"     | Sets the \"next generation script\" in the \"Advanced\" tab.                     |\r\n| property_name = \"use figure of merit script\" | Checks the box of \"use figure of merit\" in the \"Figure of merit script\" tab. |\r\n| property_name = \"figure of merit script\"     | Sets the \"figure of merit script\" in the \"Figure of merit script\" tab.       |\r\n\r\nFor a\r\n[**Monte Carlo**](https://optics.ansys.com/hc/en-us/articles/360034403194-Monte-Carlo-analysis-utility)\r\nanalysis:\r\n\r\n| **Argument**                                  | **Description**                                                                            |\r\n| --------------------------------------------- | ------------------------------------------------------------------------------------------ |\r\n| property_name = \"name\"                        | Sets the name of the Monte Carlo.                                                          |\r\n| property_name = \"number of trials\"            | Sets the number of trials for the Monte Carlo. The default number of trials is 10.         |\r\n| property_name = \"variation\"                   | Sets the variation for \"Process\" or \"Mismatch\" or \"Both\". The default variation is \"Both\". |\r\n| property_name = \"seed\"                        | Sets the seed.                                                                             |\r\n| property_name = \"enable seed\"                 | Sets whether or not to enable the seed.                                                    |\r\n| property_name = \"individual trial\"            | Sets the individual trial number.                                                          |\r\n| property_name = \"enable individual trail\"     | Sets whether or not to enable individual trials.                                           |\r\n| property_name = “enable spatial correlations” | Sets whether spatial correlation is enabled.                                               |\r\n\r\nFor an\r\n[**S-parameter matrix sweep**](https://optics.ansys.com/hc/en-us/articles/360034403214-S-parameter-matrix-sweep-utility)\r\nanalysis:\r\n\r\n| **Argument**                                                                                                                                                 | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\r\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| property_name = \"name\"                                                                                                                                       | Sets the name of the S-parameter matrix sweep.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\r\n| property_name = \"excite all ports\"                                                                                                                           | If property_value = \"true\", the sweep will run as many simulations as there are defined rows in the S-Matrix Setup table. If property_value = \"false\", simulations will be run only for the selected rows in the S-Matrix Setup table. The default is \"true\".                                                                                                                                                                                                                                                                      |\r\n| property_name = \"calculate group delay\"                                                                                                                      | When enabled, the group delay of the device is calculated numerically using a finite difference approximation, using the derivative of phase with respect to frequency.                                                                                                                                                                                                                                                                                                                                                            |\r\n| property_name = \"invert sign\" property_name = \"map from\" property_name = \"active\" property_name = \"port\" property_name = \"mode\" property_name = \"map vector\" | These properties are set for each row of the S-Matrix Setup table tab. To set them manually, the command [addsweepparameter](https://optics.ansys.com/hc/en-us/articles/360034930493-addsweepparameter-Script-command) should be used. The meaning of each parameter can be found in the Knowledge Base Article on S-parameter sweeps. Once added, the rows cannot be changed and must be removed using [removesweepparameter](https://optics.ansys.com/hc/en-us/articles/360034930513-removesweepparameter-Script-command) first. |\r\n| property_name = \"auto symmetry\"                                                                                                                              | If property_value = \"true\", auto symmetry is calculated and applied when possible (see [ S-parameter matrix sweep ](https://optics.ansys.com/hc/en-us/articles/360034403214-S-parameter-matrix-sweep) ). If property_value = \"false\", no changes are applied to the S-parameter sweep. The default is \"false\". **Note:** The changes made to the S-parameter sweep cannot be undone by setting property_value = \"false\". When property_value = \"false\", no settings change in the current sweep.                                   |\r\n| property_name = \"export setup\"                                                                                                                               | This property sets up the layout of the export file for export of data in either Lumerical or Touchstone format. There are two possible arguments:                                                                                                                                                                                                                                                                                                                                                                                 |\r\n\r\n- “auto”: Uses automatic definition for the export table.\r\n- A custom structure defining each port, see the example below on how the structure\r\n  should be formatted.\r\n\r\nFor an\r\n[S-parameter matrix sweep](https://optics.ansys.com/hc/en-us/articles/360034403214-S-parameter-matrix-sweep-utility)\r\nanalysis in MODE:\r\n\r\n| **Argument**                             | **Description**                                                                                                                                                                                                                          |\r\n| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| property_name = \"name\"                   | Sets the name of the S-parameter matrix sweep.                                                                                                                                                                                           |\r\n| property_name = \"number of points\"       | Set the number of points in the sweep.                                                                                                                                                                                                   |\r\n| property_name = \"calculated group delay\" | Set whether the group delay is calculated.                                                                                                                                                                                               |\r\n| property_name = \"group delay wavelength\" | Set the wavelength to calculate group delay. This option has no effect unless “calculated group delay” is enabled. But if set prior to enabling the calculation, the set value will be automatically applied when the option is enabled. |\r\n| property_name = \"parameter label\"        | Set the name of the parameter of the sweep.                                                                                                                                                                                              |\r\n| property_name = \"start wavelength\"       | Set the start wavelength of the sweep.                                                                                                                                                                                                   |\r\n| property_name = \"stop wavelength\"        | Set the stop wavelength of the sweep.                                                                                                                                                                                                    |\r\n| property_name = \"include group delay\"    | This property sets up the layout of the export file for export of data in either Lumerical or Touchstone format. There are two possible arguments:                                                                                       |\r\n\r\n- “auto”: Uses automatic definition for the export table.\r\n- A custom structure defining each port, see the example below on how the structure\r\n  should be formatted.\r\n\r\n## Editing added sweep parameters: In addition to the listed default properties of the sweep/optimization/Monte Carlo/S-parameter, any added sweep parameters can be edited by the setsweep command by setting the \"property_name\" to the parameter name.\r\n\r\n**Examples**\r\n\r\nThis examples show how to set a sweep/optimization/Monte Carlo/S-parameter's properties\r\nrespectively. Please refer to the application example page\r\n[ Sweep scripting commands ](https://optics.ansys.com/hc/en-us/articles/360034922893-Sweep-scripting-commands)\r\nfor detailed information.\r\n\r\nSweep:\r\n\r\n```\r\naddsweep(0);\r\nsetsweep(\"sweep\", \"name\", \"thickness_sweep_script\");\r\nsetsweep(\"thickness_sweep_script\", \"type\", \"Ranges\");\r\nsetsweep(\"thickness_sweep_script\", \"number of points\", 10); \r\n```\r\n\r\nOptimization:\r\n\r\n```\r\naddsweep(1);\r\nsetsweep(\"optimization\", \"name\", \"thickness_optimization_script\");\r\nsetsweep(\"thickness_optimization_script\", \"Type\", \"Minimize\");\r\nsetsweep(\"thickness_optimization_script\", \"algorithm\", \"Particle Swarm\");\r\nsetsweep(\"thickness_optimization_script\", \"maximum generations\", 20);\r\nsetsweep(\"thickness_optimization_script\", \"generation size\", 10);\r\nsetsweep(\"thickness_optimization_script\", \"tolerance\", 0);\r\n```\r\n\r\nMonte Carlo:\r\n\r\n```\r\naddsweep(2);\r\nMC_name = \"MC_script\";\r\nsetsweep(\"Monte Carlo analysis\", \"name\", MC_name);\r\nsetsweep(MC_name, \"number of trials\", 50);\r\nsetsweep(MC_name, \"enable seed\", 1);\r\nsetsweep(MC_name, \"seed\", 1);\r\nsetsweep(MC_name, \"Variation\", \"Both\");\r\n```\r\n\r\nS-parameter sweep:\r\n\r\n```\r\naddsweep(3);\r\nsetsweep(\"s-parameter sweep\", \"name\", \"S sweep\");\r\nsetsweep(\"s-parameter sweep\", \"Excite all ports\", 0);\r\nsetsweep(\"S sweep\", \"auto symmetry\", true);\r\n```\r\n\r\nThis example defines and sets the export setup in FDTD for the setting shown in the\r\nfigure below. Columns other than “Mode label” , “Mode ID”, and “Port location” cannot be\r\nchanged.\r\n\r\n```\r\nmodestruct = {\"label\": \"mode 1\", \"id\" : 1};  \r\nrowstruct = {\"mode 1\": modestruct, \"location\": \"LEFT\"};  \r\nportstruct = {\"port 2\": rowstruct};   \r\nsetsweep(\"s-parameter sweep\", \"export setup\", portstruct);\r\n```\r\n\r\nThis example sets the export setup in MODE for the **second** row in the figure below.\r\nOther rows in the table are automatically filled based on the placement of Port objects\r\nin the simulation domain. Columns other than “Mode label” and “Mode ID” cannot be\r\nchanged.\r\n\r\n______________________________________________________________________\r\n\r\n```\r\nmodestruct = {\"label\": \"my mode 2\", \"id\" : 2};  \r\nrowstruct = {\"mode 1\": modestruct};  \r\nportstruct = {\"port 2\": rowstruct};   \r\nsetsweep(\"s-parameter sweep\", \"export setup\", portstruct);\r\n```",
    "summary": "Sets a property in a parameter sweep/optimization/Monte Carlo/S-parameter sweep item",
    "syntax": [
      {
        "syntax": "setsweep(\"name\", \"property_name\", property_value);",
        "description": "Sets a property in a sweep/optimization/Monte Carlo/S-parameter item. \"name\" is the absolute name of an analysis item. \"property_name\" is the property showed in the edit window."
      },
      {
        "syntax": "?setsweep(“name”);",
        "description": "View the editable properties of the analysis item."
      }
    ],
    "example": ""
  },
  {
    "name": "setvalue",
    "description": "Sets an internal value for an element's internal parameter.",
    "usage": "setvalue();",
    "category": "general",
    "markdown": "# setvalue\r\n\r\nSets an internal value for an element's internal parameter.\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                                                                                                                                                                          |\r\n| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| setvalue(element, parameter ,value); | Set an internal value for an ‘element’ internal ‘parameter’. Different from ‘set’ or ‘setnamed’, ‘setvalue’ can have direct access to internal element parameters. Currently only the ‘Optical N Port S-Parameter’ support this function for the internal ‘s parameters’ value. The ‘s parameters’ parameter is a cell that contains a complete description of the element s-parameters. |\r\n\r\n**Example**\r\n\r\n```\r\nM=cell(3);\r\nM{1}=struct;\r\nM{1}.numberOfNPorts=-1;\r\nM{2}=struct;\r\nM{2}.numberOfMPorts=-1;\r\nM{3}=cell(1);\r\nM{3}{1}=struct;\r\nM{3}{1}.data=matrix(5,3);\r\nM{3}{1}.data(1,1)=2.26258e+014;\r\nM{3}{1}.data(2,1)=2.27569e+014;\r\nM{3}{1}.data(3,1)=2.28879e+014;\r\nM{3}{1}.data(4,1)=2.3019e+014;\r\nM{3}{1}.data(5,1)=2.315e+014;\r\nM{3}{1}.data(1,2)=0.0104993;\r\nM{3}{1}.data(2,2)=0.00926858;\r\nM{3}{1}.data(3,2)=0.00596999;\r\nM{3}{1}.data(4,2)=0.00182042;\r\nM{3}{1}.data(5,2)=0.00429422;\r\nM{3}{1}.data(1,3)=-2.64534;\r\nM{3}{1}.data(2,3)=-2.75636;\r\nM{3}{1}.data(3,3)=-2.89119;\r\nM{3}{1}.data(4,3)=-3.62524;\r\nM{3}{1}.data(5,3)=-5.23423;\r\nM{3}{1}.modeInputLabel='TE';\r\nM{3}{1}.modeInputOID=1;\r\nM{3}{1}.modeInputUID='#1';\r\nM{3}{1}.modeOutputLabel='TE';\r\nM{3}{1}.modeOutputOID=1;\r\nM{3}{1}.modeOutputUID='#1';\r\nM{3}{1}.portInput='port 1';\r\nM{3}{1}.portOutput='port 2';\r\n# sets the s-parameter for the element SPAR_1\r\nsetvalue('SPAR_1','s parameters',M);\r\n```",
    "summary": "Sets an internal value for an element's internal parameter",
    "syntax": [
      {
        "syntax": "setvalue(element, parameter ,value);",
        "description": "Set an internal value for an ‘element’ internal ‘parameter’. Different from ‘set’ or ‘setnamed’, ‘setvalue’ can have direct access to internal element parameters. Currently only the ‘Optical N Port S-Parameter’ support this function for the internal ‘s parameters’ value. The ‘s parameters’ parameter is a cell that contains a complete description of the element s-parameters."
      }
    ],
    "example": "M=cell(3);\r\nM{1}=struct;\r\nM{1}.numberOfNPorts=-1;\r\nM{2}=struct;\r\nM{2}.numberOfMPorts=-1;\r\nM{3}=cell(1);\r\nM{3}{1}=struct;\r\nM{3}{1}.data=matrix(5,3);\r\nM{3}{1}.data(1,1)=2.26258e+014;\r\nM{3}{1}.data(2,1)=2.27569e+014;\r\nM{3}{1}.data(3,1)=2.28879e+014;\r\nM{3}{1}.data(4,1)=2.3019e+014;\r\nM{3}{1}.data(5,1)=2.315e+014;\r\nM{3}{1}.data(1,2)=0.0104993;\r\nM{3}{1}.data(2,2)=0.00926858;\r\nM{3}{1}.data(3,2)=0.00596999;\r\nM{3}{1}.data(4,2)=0.00182042;\r\nM{3}{1}.data(5,2)=0.00429422;\r\nM{3}{1}.data(1,3)=-2.64534;\r\nM{3}{1}.data(2,3)=-2.75636;\r\nM{3}{1}.data(3,3)=-2.89119;\r\nM{3}{1}.data(4,3)=-3.62524;\r\nM{3}{1}.data(5,3)=-5.23423;\r\nM{3}{1}.modeInputLabel='TE';\r\nM{3}{1}.modeInputOID=1;\r\nM{3}{1}.modeInputUID='#1';\r\nM{3}{1}.modeOutputLabel='TE';\r\nM{3}{1}.modeOutputOID=1;\r\nM{3}{1}.modeOutputUID='#1';\r\nM{3}{1}.portInput='port 1';\r\nM{3}{1}.portOutput='port 2';\r\n# sets the s-parameter for the element SPAR_1\r\nsetvalue('SPAR_1','s parameters',M);"
  },
  {
    "name": "setview",
    "description": "This command allows the viewing properties of the Layout Editor to be modified.",
    "usage": "setview();",
    "category": "general",
    "markdown": "# setview\r\n\r\nThis command allows the viewing properties of the Layout Editor to be modified.\r\n\r\n| **Syntax**           | **Description**                                                    |\r\n| -------------------- | ------------------------------------------------------------------ |\r\n| outstring = setview; | Returns a list of the view properties that can be set. The command |\r\n\r\n```\r\n?setview;\r\n```\r\n\r\nwill return\r\n\r\n```\r\nextent, zoom, theta, phi  \r\n```\r\n\r\nsetview(\"property\"); | Sets the default value for any of the view properties. For\r\nexample,\r\n\r\n```\r\nsetview(\"extent\");\r\n```\r\n\r\nis the same as pressing the graphical extent button.\\\r\nsetview(\"property\",value); | Sets the values to of any property for viewing.\r\n\r\nThe following table describes the properties that can be set\r\n\r\n| **Property**                                       | **Description**                                                                                                                                                       |\r\n| -------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| extent (not available in CHARGE, HEAT, FEEM, DGTD) | Control the view extent. In this case, value should be a 2x1, 4x1 or 6x1 matrix representing the view range min x, max x, min y, max y, min z and max z respectively. |\r\n| zoom                                               | Controls the relative zoom of the perspective view compared to the default level. To zoom in by a factor of 2 in the perspective view, use                            |\r\n\r\n```\r\nsetview(\"zoom\",2);  \r\n```\r\n\r\ntheta | Controls the polar angle of the perspective view, in degrees.\\\r\nphi | Controls the azimuthal angle of the perspective view, in degrees.\r\n\r\n**Example**\r\n\r\nThis example uses the setview command to spin the \"perspective view\" by 360 degrees.\r\n\r\n```\r\nsetview(\"extent\");\r\nsetview(\"zoom\",4);\r\nsetview(\"theta\", 30);\r\nfor (i=0:10:360) {\r\n  setview(\"phi\",i);\r\n} \r\n```",
    "summary": "This command allows the viewing properties of the Layout Editor to be modified",
    "syntax": [
      {
        "syntax": "outstring = setview;",
        "description": "Returns a list of the view properties that can be set. The command"
      }
    ],
    "example": "setview(\"extent\");\r\nsetview(\"zoom\",4);\r\nsetview(\"theta\", 30);\r\nfor (i=0:10:360) {\r\n  setview(\"phi\",i);\r\n}"
  },
  {
    "name": "shiftselect",
    "description": "Same as select, but does not unselect other currently selected objects. Note that only objects from the same \"group\" can be selected simultaneously.",
    "usage": "shiftselect();",
    "category": "general",
    "markdown": "# shiftselect\r\n\r\nSame as select, but does not unselect other currently selected objects. Note that only\r\nobjects from the same \"group\" can be selected simultaneously.\r\n\r\n| **Syntax**                       | **Description**                                                                                                                                               |\r\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| shiftselect(\"name\");             | The same as select(\"name\"), but does not unselect currently selected objects. Can be used to select multiple objects. This function does not return any data. |\r\n| shiftselect(\"group name::name\"); | The same as select(\"groupname::name\"), but does not unselect currently selected objects.                                                                      |\r\n\r\n**Example**\r\n\r\nAdd two objects and then select both and shift them the same amount.\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"substrate\");\r\naddring;# ring is selected automatically\r\nshiftselect(\"substrate\");# select both objects\r\nmove(0, 1e-6,0); # both will shift 1e-6 in y;\r\n```",
    "summary": "Same as select, but does not unselect other currently selected objects",
    "syntax": [
      {
        "syntax": "shiftselect(\"name\");",
        "description": "The same as select(\"name\"), but does not unselect currently selected objects. Can be used to select multiple objects. This function does not return any data."
      },
      {
        "syntax": "shiftselect(\"group name::name\");",
        "description": "The same as select(\"groupname::name\"), but does not unselect currently selected objects."
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"substrate\");\r\naddring;# ring is selected automatically\r\nshiftselect(\"substrate\");# select both objects\r\nmove(0, 1e-6,0); # both will shift 1e-6 in y;"
  },
  {
    "name": "shiftselectpartial",
    "description": "Same as selectpartial, but does not unselect other currently selected objects.",
    "usage": "shiftselectpartial();",
    "category": "general",
    "markdown": "# shiftselectpartial\r\n\r\nSame as selectpartial, but does not unselect other currently selected objects.\r\n\r\n| **Syntax**                                           | **Description**                                                                                                                                                             |\r\n| ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| shiftselectpartial(\"partialname\");                   | The same as selectpartial(\"partialname\"), but does not unselect currently selected objects. Can be used to select multiple objects. This function does not return any data. |\r\n| shiftselectpartial(\"partialgroupname::partialname\"); | The same as selectpartial(\"partialgroupname::partialname\"), but does not unselect currently selected objects. Can be used to select multiple objects.                       |\r\n\r\n**Example**\r\n\r\nSelect 2 objects with different partial names.\r\n\r\n```\r\naddrect; \r\nset(\"name\",\"substrate_1\");\r\naddrect; \r\nset(\"name\",\"pattern_1\");\r\nunselectall;\r\nshiftselectpartial(\"substrate\");\r\nshiftselectpartial(\"pattern\");\r\n```",
    "summary": "Same as selectpartial, but does not unselect other currently selected objects",
    "syntax": [
      {
        "syntax": "shiftselectpartial(\"partialname\");",
        "description": "The same as selectpartial(\"partialname\"), but does not unselect currently selected objects. Can be used to select multiple objects. This function does not return any data."
      },
      {
        "syntax": "shiftselectpartial(\"partialgroupname::partialname\");",
        "description": "The same as selectpartial(\"partialgroupname::partialname\"), but does not unselect currently selected objects. Can be used to select multiple objects."
      }
    ],
    "example": "addrect; \r\nset(\"name\",\"substrate_1\");\r\naddrect; \r\nset(\"name\",\"pattern_1\");\r\nunselectall;\r\nshiftselectpartial(\"substrate\");\r\nshiftselectpartial(\"pattern\");"
  },
  {
    "name": "show",
    "description": "Shows the graphical user interface, can be used with the [ hide ](./hide.md) command.",
    "usage": "show();",
    "category": "general",
    "markdown": "# show\r\n\r\nShows the graphical user interface, can be used with the [ hide ](./hide.md) command.\r\n\r\n| **Syntax** | **Description** |\r\n| ---------- | --------------- |\r\n| show;      | shows the GUI.  |",
    "summary": "Shows the graphical user interface, can be used with the [ hide ](",
    "syntax": [
      {
        "syntax": "show;",
        "description": "shows the GUI."
      }
    ],
    "example": ""
  },
  {
    "name": "showmenubar",
    "description": "Shows or hides the menu bar.",
    "usage": "showmenubar();",
    "category": "general",
    "markdown": "# showmenubar\r\n\r\nShows or hides the menu bar.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                  |\r\n| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| showmenubar(status); | Shows or hides the menu bar The parameter 'status' takes 'true' or 'false'. A value of 'true' for this parameter will show the menu bar and 'false' will hide it |",
    "summary": "Shows or hides the menu bar",
    "syntax": [
      {
        "syntax": "showmenubar(status);",
        "description": "Shows or hides the menu bar The parameter 'status' takes 'true' or 'false'. A value of 'true' for this parameter will show the menu bar and 'false' will hide it"
      }
    ],
    "example": ""
  },
  {
    "name": "sign",
    "description": "Returns the sign of a number.",
    "usage": "sign();",
    "category": "general",
    "markdown": "# sign\r\n\r\nReturns the sign of a number.\r\n\r\n| **Syntax**        | **Description**                                                                                                                                                             |\r\n| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sign(data); | If data is real: sign = 0 for data=0 sign = 1 for data>0 sign =-1 for data\\<0 If data is complex: sign = 0 for data=0+0i sign = data/abs(data) for data different from zero |\r\n\r\n**Example**\r\n\r\nExample output from sign function.\r\n\r\n```\r\n# real numbers\r\ndata = [2; 0; -2];\r\n?sign(data);\r\n# complex numbers\r\ndata = [2+2i; 0+0i; -2+0i];\r\n?sign(data);\r\n?abs( sign(data) ); \r\nresult: \r\n1  \r\n0  \r\n-1  \r\nresult: \r\n0.707107+0.707107i  \r\n0+0i  \r\n-1+0i  \r\nresult: \r\n1  \r\n0  \r\n1   \r\n```",
    "summary": "Returns the sign of a number",
    "syntax": [
      {
        "syntax": "out = sign(data);",
        "description": "If data is real: sign = 0 for data=0 sign = 1 for data>0 sign =-1 for data\\<0 If data is complex: sign = 0 for data=0+0i sign = data/abs(data) for data different from zero"
      }
    ],
    "example": "# real numbers\r\ndata = [2; 0; -2];\r\n?sign(data);\r\n# complex numbers\r\ndata = [2+2i; 0+0i; -2+0i];\r\n?sign(data);\r\n?abs( sign(data) ); \r\nresult: \r\n1  \r\n0  \r\n-1  \r\nresult: \r\n0.707107+0.707107i  \r\n0+0i  \r\n-1+0i  \r\nresult: \r\n1  \r\n0  \r\n1"
  },
  {
    "name": "simulation",
    "description": "The script command simulation returns bandwidth related simulation properties. The time domain simulator will try to accommodate the current channels into non-overlapping simulation bandwidths. Simulation properties include the center frequency, sample rate, number of samples, frequency grid spacing, lower and upper frequency limits. If a single bandwidth is listed, this means all channels fit in the same bandwidth, otherwise multiple bandwidths are required to accommodate all channels with the current sample rate.",
    "usage": "simulation();",
    "category": "general",
    "markdown": "# simulation\r\n\r\nThe script command simulation returns bandwidth related simulation properties. The time\r\ndomain simulator will try to accommodate the current channels into non-overlapping\r\nsimulation bandwidths. Simulation properties include the center frequency, sample rate,\r\nnumber of samples, frequency grid spacing, lower and upper frequency limits. If a single\r\nbandwidth is listed, this means all channels fit in the same bandwidth, otherwise\r\nmultiple bandwidths are required to accommodate all channels with the current sample\r\nrate.\r\n\r\nThe command also returns the list of source channels in the current simulation before\r\nthe simulation estimate the simulation bandwidths. This list includes the overlapped\r\nbandwidths. Simulation properties include the center frequency, sample rate, number of\r\nsamples, frequency grid spacing, lower and upper frequency limits. If a single bandwidth\r\nis listed, this means all channels fit in the same bandwidth, otherwise multiple\r\nbandwidths are required to accommodate all channels with the current sample rate.\r\n\r\nThis function is valid during analysis or run-time mode only.\r\n\r\n| **Syntax**                     | **Description**                                                                                                                                             |\r\n| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = simulation(“bandwidth”); | Returns bandwidth related simulation properties.                                                                                                            |\r\n| out = simulation(“channels”);  | Returns the list of source channels in the current simulation before the simulation estimate the simulation bandwidths.                                     |\r\n| out = simulation(“single”);    | Returns the recommended setting for simulation using a single band (total field) that will make sure all channels are merged into one simulation bandwidth. |\r\n\r\n### Example\r\n\r\nAccess simulation properties while the simulation is running, the circuit contains four\r\nlaser sources.\r\n\r\n```\r\n#list number of simulated channels\r\n?simulation(\"bandwidth\");\r\nresult: \r\n1.9315e+014 1.6e+011 1024 1.5625e+008 1.9307e+014 1.9323e+014 \r\n1.9335e+014 1.6e+011 1024 1.5625e+008 1.9327e+014 1.9343e+01\r\n#list number of available channel sources\r\n?simulation(\"channels\");\r\nresult: \r\n1.931e+014 1.6e+011 1024 1.5625e+008 1.9302e+014 1.9318e+014 \r\n1.932e+014 1.6e+011 1024 1.5625e+008 1.9312e+014 1.9328e+014 \r\n1.933e+014 1.6e+011 1024 1.5625e+008 1.9322e+014 1.9338e+014 \r\n1.934e+014 1.6e+011 1024 1.5625e+008 1.9332e+014 1.9348e+014\r\n#list recommended setting for single bandwidth\r\n?simulation(\"single\");\r\nresult: \r\n1.9325e+014 3.2e+011 2048 1.5625e+008 1.9309e+014 1.9341e+014\r\n```",
    "summary": "The script command simulation returns bandwidth related simulation properties",
    "syntax": [
      {
        "syntax": "out = simulation(“bandwidth”);",
        "description": "Returns bandwidth related simulation properties."
      },
      {
        "syntax": "out = simulation(“channels”);",
        "description": "Returns the list of source channels in the current simulation before the simulation estimate the simulation bandwidths."
      },
      {
        "syntax": "out = simulation(“single”);",
        "description": "Returns the recommended setting for simulation using a single band (total field) that will make sure all channels are merged into one simulation bandwidth."
      }
    ],
    "example": ""
  },
  {
    "name": "simulationdiverged",
    "description": "In layout mode, check whether the simulation reached the divergence checking auto shutoff threshold.",
    "usage": "simulationdiverged();",
    "category": "general",
    "markdown": "# simulationdiverged\r\n\r\nIn layout mode, check whether the simulation reached the divergence checking auto\r\nshutoff threshold.\r\n\r\n| **Syntax**              | **Description**                                                                  |\r\n| ----------------------- | -------------------------------------------------------------------------------- |\r\n| out=simulationdiverged; | Returns 1 if the simulation reached the auto shutoff max threshold, 0 otherwise. |",
    "summary": "In layout mode, check whether the simulation reached the divergence checking auto shutoff threshold",
    "syntax": [
      {
        "syntax": "out=simulationdiverged;",
        "description": "Returns 1 if the simulation reached the auto shutoff max threshold, 0 otherwise."
      }
    ],
    "example": ""
  },
  {
    "name": "sin",
    "description": "Calculates the trigonometric sine function. Angle units are in radians. The function is defined for complex angles. Phase of a complex number is evaluated between - π and π .",
    "usage": "sin();",
    "category": "general",
    "markdown": "# sin\r\n\r\nCalculates the trigonometric sine function. Angle units are in radians. The function is\r\ndefined for complex angles. Phase of a complex number is evaluated between - π and π .\r\n\r\n| **Syntax**    | **Description**                |\r\n| ------------- | ------------------------------ |\r\n| out = sin(x); | Returns the complex sine of x. |\r\n\r\n**Example**\r\n\r\nCalculate sin( π /4 + i).\r\n\r\n```\r\ntheta=pi/4+1i;\r\n?sin(theta);\r\nresult: \r\n1.09112+0.830993i \r\n```",
    "summary": "Calculates the trigonometric sine function",
    "syntax": [
      {
        "syntax": "out = sin(x);",
        "description": "Returns the complex sine of x."
      }
    ],
    "example": "theta=pi/4+1i;\r\n?sin(theta);\r\nresult: \r\n1.09112+0.830993i"
  },
  {
    "name": "size",
    "description": "Returns the size of a matrix.",
    "usage": "size();",
    "category": "general",
    "markdown": "# size\r\n\r\nReturns the size of a matrix.\r\n\r\n| **Syntax**     | **Description**                                                                  |\r\n| -------------- | -------------------------------------------------------------------------------- |\r\n| y = size(x);   | y is a matrix which shows the dimensions of x.                                   |\r\n| y = size(x,n); | n is an optional parameter to get the size of the matrix in a specific dimension |\r\n\r\n**Example**\r\n\r\nCheck the dimensions of a matrix.\r\n\r\n```\r\nx=matrix(2,3,3);\r\n?y=size(x);\r\nresult: \r\n2 3 3 \r\n?size(x,2);\r\nresult: \r\n3  \r\n```",
    "summary": "Returns the size of a matrix",
    "syntax": [
      {
        "syntax": "y = size(x);",
        "description": "y is a matrix which shows the dimensions of x."
      },
      {
        "syntax": "y = size(x,n);",
        "description": "n is an optional parameter to get the size of the matrix in a specific dimension"
      }
    ],
    "example": "x=matrix(2,3,3);\r\n?y=size(x);\r\nresult: \r\n2 3 3 \r\n?size(x,2);\r\nresult: \r\n3"
  },
  {
    "name": "smithchart",
    "description": "Plots impedance values in a Smith chart. The default impedance used for normalization is 50 Ohms; this can be modified in the plot settings once the plot has been created.",
    "usage": "smithchart();",
    "category": "general",
    "markdown": "# smithchart\r\n\r\nPlots impedance values in a Smith chart. The default impedance used for normalization is\r\n50 Ohms; this can be modified in the plot settings once the plot has been created.\r\n\r\n| **Syntax**                                            | **Description**                                                                                                                                                                           |\r\n| ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = smithchart(Z);                                  | Creates a curve in a Smith chart with the impedance values in the array Z. The array Z must be of the form NX1 or 1XN.                                                                    |\r\n| out = smithchart(Z1,Z2,Z3);                           | Creates three curves in a Smith chart with the impedance values in the arrays Z1, Z2 and Z3. Each array must be of the form NX1 or 1XN, but they do not have to be of the same dimension. |\r\n| out = smithchart(Z, \"title\", \"aspect ratio\", norm_Z); | Creates a Smith chart with a title, a given aspect ratio and a normalized impedance norm_Z. The aspect ratio must be string that is either \"1:1\" or \"fill scene\".                         |\r\n\r\n**Example**\r\n\r\nCreate a simple Smith chart\r\n\r\n```\r\nZ1 = 50*(3+1i*linspace(-50,50,101)); # re(Z) = 3 circle\r\nZ2 = 50*(linspace(0,50,101)+0.75i); # im(Z) = 0.75 line\r\nsmithchart(Z1,Z2,\"Example of Smith chart\", \"1:1\", 50); # Normalized impedance 50 Ohms\r\n#The plot properties can also be set using setplot:\r\nsmithchart(Z1,Z2);\r\nsetplot(\"title\", \"Example of Smith chart\");\r\nsetplot(\"aspect ratio\", \"1:1\");\r\nsetplot(\"normalized impedance\", 50);\r\n```\r\n\r\nThe following figure shows the output of the example code.",
    "summary": "Plots impedance values in a Smith chart",
    "syntax": [
      {
        "syntax": "out = smithchart(Z);",
        "description": "Creates a curve in a Smith chart with the impedance values in the array Z. The array Z must be of the form NX1 or 1XN."
      },
      {
        "syntax": "out = smithchart(Z1,Z2,Z3);",
        "description": "Creates three curves in a Smith chart with the impedance values in the arrays Z1, Z2 and Z3. Each array must be of the form NX1 or 1XN, but they do not have to be of the same dimension."
      },
      {
        "syntax": "out = smithchart(Z, \"title\", \"aspect ratio\", norm_Z);",
        "description": "Creates a Smith chart with a title, a given aspect ratio and a normalized impedance norm_Z. The aspect ratio must be string that is either \"1:1\" or \"fill scene\"."
      }
    ],
    "example": "Z1 = 50*(3+1i*linspace(-50,50,101)); # re(Z) = 3 circle\r\nZ2 = 50*(linspace(0,50,101)+0.75i); # im(Z) = 0.75 line\r\nsmithchart(Z1,Z2,\"Example of Smith chart\", \"1:1\", 50); # Normalized impedance 50 Ohms\r\n#The plot properties can also be set using setplot:\r\nsmithchart(Z1,Z2);\r\nsetplot(\"title\", \"Example of Smith chart\");\r\nsetplot(\"aspect ratio\", \"1:1\");\r\nsetplot(\"normalized impedance\", 50);"
  },
  {
    "name": "solar",
    "description": "Returns the solar power spectrum, in Watts/meter^2/meter.",
    "usage": "solar();",
    "category": "general",
    "markdown": "# solar\r\n\r\nReturns the solar power spectrum, in Watts/meter^2/meter.\r\n\r\nThe values are based on the global tilt values from the following link:\r\n[ Reference Solar Spectrum Irradiance: ASTM G-173 ](http://rredc.nrel.gov/solar/spectra/am1.5/ASTMG173/ASTMG173.html)\r\n.\r\n\r\n| **Syntax**      | **Description**                                                                 |\r\n| --------------- | ------------------------------------------------------------------------------- |\r\n| out = solar(1); | Returns the power of the solar spectrum as a function of wavelength, in W/m^2/m |\r\n| out = solar(0); | Returns the corresponding wavelength vector, in m                               |\r\n\r\n**Example**\r\n\r\nUse the solar command to get the solar power spectrum. Next, plot the spectrum in the\r\nmore common units of Watts/m^2/nm.\r\n\r\n```\r\nlambda=solar(0);   # wavelength vector in meters\r\nssp=solar(1);     # solar spectrum in Watts/meter^2/meter\r\nlambda = lambda*1e9; # convert to nm\r\nssp  = ssp * 1e-9; # convert to /nm\r\nplot(lambda,ssp,\"wavelength (nm)\",\"Power (W/m^2/nm)\", \"Solar Spectrum\");\r\n```",
    "summary": "Returns the solar power spectrum, in Watts/meter^2/meter",
    "syntax": [
      {
        "syntax": "out = solar(1);",
        "description": "Returns the power of the solar spectrum as a function of wavelength, in W/m^2/m"
      },
      {
        "syntax": "out = solar(0);",
        "description": "Returns the corresponding wavelength vector, in m"
      }
    ],
    "example": "lambda=solar(0);   # wavelength vector in meters\r\nssp=solar(1);     # solar spectrum in Watts/meter^2/meter\r\nlambda = lambda*1e9; # convert to nm\r\nssp  = ssp * 1e-9; # convert to /nm\r\nplot(lambda,ssp,\"wavelength (nm)\",\"Power (W/m^2/nm)\", \"Solar Spectrum\");"
  },
  {
    "name": "sort",
    "description": "Sorts a matrix in ascending or descending order. Complex values are sorted by magnitude and then by angle. For more complex sorting methods, see the sortmap function.",
    "usage": "sort();",
    "category": "general",
    "markdown": "# sort\r\n\r\nSorts a matrix in ascending or descending order. Complex values are sorted by magnitude\r\nand then by angle. For more complex sorting methods, see the sortmap function.\r\n\r\nThis function was introduced in the 2018a R6 release.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                    |\r\n| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sort(A);            | Returns the sorted matrix of A, in ascending order. Complex values are sorted by magnitude and then by angle. A is treated as a linear array for sorting, but out preserves the shape of A. Typically the command is used for Nx1 or 1xN matrices. |\r\n| out = sort(A, ascending); | The optional bool argument is set to true by default. When it is false, the sort is done in descending order.                                                                                                                                      |\r\n\r\n**Example**\r\n\r\nThis example shows a simple sort. For more complex usage, see sortmap .\r\n\r\n```\r\nA = [3, 4, 1, 7, 10, -1];\r\n?B = sort(A);\r\n?D = sort(A, false);\r\n```",
    "summary": "Sorts a matrix in ascending or descending order",
    "syntax": [
      {
        "syntax": "out = sort(A);",
        "description": "Returns the sorted matrix of A, in ascending order. Complex values are sorted by magnitude and then by angle. A is treated as a linear array for sorting, but out preserves the shape of A. Typically the command is used for Nx1 or 1xN matrices."
      },
      {
        "syntax": "out = sort(A, ascending);",
        "description": "The optional bool argument is set to true by default. When it is false, the sort is done in descending order."
      }
    ],
    "example": "A = [3, 4, 1, 7, 10, -1];\r\n?B = sort(A);\r\n?D = sort(A, false);"
  },
  {
    "name": "sortmap",
    "description": "The script command sortmap is used to sort matrices in more complex ways than simply ascending or descending order of the array. It is used to create a map of the sorted indices of the array that can be reused afterwards to sort the original matrix or other matrices.",
    "usage": "sortmap();",
    "category": "general",
    "markdown": "# sortmap\r\n\r\nThe script command sortmap is used to sort matrices in more complex ways than simply\r\nascending or descending order of the array. It is used to create a map of the sorted\r\nindices of the array that can be reused afterwards to sort the original matrix or other\r\nmatrices.\r\n\r\nThis function was introduced in the 2018a R6 release.\r\n\r\n| **Syntax**                   | **Description**                                                                                                                                                                                                                                             |\r\n| ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sortmap(A);            | Returns a matrix of indices that map the sorted matrix of A. Complex values are sorted by magnitude and then by angle. A is treated as a linear array for sorting, but out preserves the shape of A. Typically the command is used for Nx1 or 1xN matrices. |\r\n| out = sortmap(A, ascending); | The optional bool argument is set to true by default. When it is false, the sort is done in descending order.                                                                                                                                               |\r\n\r\n**Example**\r\n\r\nThis example shows how to use sortmap instead of sort, and that the results are\r\nequivalent\r\n\r\n```\r\nA = [3; 4; 1; 7; 10; -1];\r\n?B = sort(A);\r\nm = sortmap(A);\r\n?D = A(m);\r\n```\r\n\r\nThis example shows how to sort by ascending imaginary part, real part or magnitude\r\n\r\n```\r\nA = [3+1i; 4+0.1i; 1-10i; 7-20i; 10+15i; -1+0i];\r\nm = sortmap(imag(A));\r\n?B = A(m); # sorted by ascending imaginary part\r\nm = sortmap(real(A)); \r\n?D = A(m); # sort by ascending magnitude\r\nm = sortmap(abs(A)); \r\n?E = A(m); # sort by ascending magnitude\r\n```\r\n\r\nThis example shows how 2 different vectors (neff and ng) can be sorted according to\r\ndescending neff.\r\n\r\n```\r\nneff = [2.3; 2.4; 3.2; 1.45 ];\r\nng = [4.2; 4.3; 4.8; 4.9 ];\r\nm = sortmap(neff,false);\r\n?neff = neff(m);\r\n?ng = ng(m);\r\n```\r\n\r\nThis example shows how we can sort 2 vectors of x and y by the closest points to x0,y0\r\n\r\n```\r\nx = [4.3; -4; -2; 10; 2.0 ];\r\ny = [ -1;  1;  2;  5;  -4 ];\r\nx0 = 2;\r\ny0 = 2;\r\nm = sortmap( (x-x0)^2 + (y-y0)^2);\r\nx = x(m);\r\ny = y(m);\r\n?[x,y];\r\n```\r\n\r\nThis example shows how the rows of an NxM matrix can be sorted based on the values in\r\nthe 3rd column:\r\n\r\n```\r\nA = [ 2, 4, 6;\r\n      3, 2, 1;\r\n      4, 4, 4 ];\r\nm = sortmap(A(:,3));\r\n?A = A(m,:);\r\n```",
    "summary": "The script command sortmap is used to sort matrices in more complex ways than simply ascending or de...",
    "syntax": [
      {
        "syntax": "out = sortmap(A);",
        "description": "Returns a matrix of indices that map the sorted matrix of A. Complex values are sorted by magnitude and then by angle. A is treated as a linear array for sorting, but out preserves the shape of A. Typically the command is used for Nx1 or 1xN matrices."
      },
      {
        "syntax": "out = sortmap(A, ascending);",
        "description": "The optional bool argument is set to true by default. When it is false, the sort is done in descending order."
      }
    ],
    "example": "A = [3; 4; 1; 7; 10; -1];\r\n?B = sort(A);\r\nm = sortmap(A);\r\n?D = A(m);"
  },
  {
    "name": "sourceintensity",
    "description": "Returns the source power divided by the area of the source. In 3D simulations, the units will be in Watts/m 2 if CW norm is used, and Watts/m 2 /Hertz 2 if No norm is used. This function is often used when normalizing power measurements from simulations with a TFSF source.",
    "usage": "sourceintensity();",
    "category": "general",
    "markdown": "# sourceintensity\r\n\r\nReturns the source power divided by the area of the source. In 3D simulations, the units\r\nwill be in Watts/m 2 if CW norm is used, and Watts/m 2 /Hertz 2 if No norm is used. This\r\nfunction is often used when normalizing power measurements from simulations with a TFSF\r\nsource.\r\n\r\nIn the case of multiple sources, the sourceintensity(f) command will return the sum of\r\nall sourceintensity from all sources.\r\n\r\n| **Syntax**                              | **Description**                                                                                                                                                                                                                                                                           |\r\n| --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourceintensity(f);               | Returns the source intensity at the vector of frequency points f (f is the frequency in Hz).                                                                                                                                                                                              |\r\n| out = sourceintensity(f, option);       | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n| out = sourceintensity(f, option, name); | This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources.                                                                                                                                                    |\r\n\r\n**Examples**\r\n\r\nThis example shows how to use the transmission , sourcepower and sourceintensity\r\nfunctions to measure the power injected by a TFSF source. Notice that the monitor is 1/4\r\nthe area of the source.\r\n\r\n```\r\nnewproject;          # create new simulation\r\nsave(\"test\");\r\naddfdtd;         # add simulation region\r\nset(\"mesh accuracy\",4);\r\nset(\"x span\",2.5e-6);\r\nset(\"y span\",2.5e-6);\r\nset(\"z span\",2.5e-6);\r\naddtfsf;         # add source\r\nset(\"x span\",2e-6);\r\nset(\"y span\",2e-6);\r\nset(\"z span\",2e-6);\r\nset(\"wavelength span\",0);\r\naddpower;         # add monitor (1/4 area of source)\r\nset(\"x span\",1e-6);\r\nset(\"y span\",1e-6);\r\nrun;            # run simulation\r\nm=\"monitor\";       \r\nf=getdata(m,\"f\");     # get frequency vector\r\nT=transmission(m);     # get power transmission (fraction of source power)\r\nsp=sourcepower(f);     # get power injected by source (Watts)\r\nI=sourceintensity(f);   # get source intensity (Watts/m^2)\r\narea = getdata(\"source\",\"area\"); # get source area (it's not exactly 2um^2 due to finite sized mesh)\r\n# output results\r\n?\"Transmitted power (fraction of source power): \" +num2str(T);\r\n?\"Transmitted power (Watts): \" +num2str(T*sp);\r\n?\"Source power (Watts): \"+num2str(sp);\r\n?\"Source intensity (Watts/um^2): \" + num2str(I*1e-12);\r\n?\"Ensure Intensity*Area=Power: \" + num2str(I*area/sp);\r\n> Transmitted power (fraction of source power): 0.235078\r\n> Transmitted power (Watts): 1.24415e-015\r\n> Source power (Watts): 5.2925e-015\r\n> Source intensity (Watts/um^2): 1.30714e-015\r\n> Ensure Intensity*Area=Power: 1\r\n```",
    "summary": "Returns the source power divided by the area of the source",
    "syntax": [
      {
        "syntax": "out = sourceintensity(f);",
        "description": "Returns the source intensity at the vector of frequency points f (f is the frequency in Hz)."
      },
      {
        "syntax": "out = sourceintensity(f, option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      },
      {
        "syntax": "out = sourceintensity(f, option, name);",
        "description": "This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources."
      }
    ],
    "example": ""
  },
  {
    "name": "sourceintensity_avg",
    "description": "Returns the total spectral average intensity injected into the simulation by the source. The average intensity is equal to the average power divided by the source area. See the [sourcepower_pavg](https://optics.ansys.com/hc/en-us/articles/360034925353-sourcepower-pavg) command and the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "sourceintensity_avg();",
    "category": "general",
    "markdown": "# sourceintensity_avg\r\n\r\nReturns the total spectral average intensity injected into the simulation by the source.\r\nThe average intensity is equal to the average power divided by the source area. See the\r\n[sourcepower_pavg](https://optics.ansys.com/hc/en-us/articles/360034925353-sourcepower-pavg)\r\ncommand and the Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\n| **Syntax**                                       | **Description**                                                                                                                                                                                                                                                                           |\r\n| ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourceintensity_avg;                       | Returns the spectrally averaged source intensity as defined above.                                                                                                                                                                                                                        |\r\n| out = sourceintensity_avg(option);               | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n| out = sourceintensity_avg(option, \"sourcename\"); | This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources.                                                                                                                                                    |\r\n\r\n**Example**\r\n\r\nPlease refer to [sourceintensity](./sourceintensity.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the total spectral average intensity injected into the simulation by the source",
    "syntax": [
      {
        "syntax": "out = sourceintensity_avg;",
        "description": "Returns the spectrally averaged source intensity as defined above."
      },
      {
        "syntax": "out = sourceintensity_avg(option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      },
      {
        "syntax": "out = sourceintensity_avg(option, \"sourcename\");",
        "description": "This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources."
      }
    ],
    "example": ""
  },
  {
    "name": "sourceintensity_pavg",
    "description": "Returns the partial spectral average intensity injected into the simulation by the source. The partial average intensity is equal to the partial average power divided by the source area. See the [sourcepower_pavg](https://optics.ansys.com/hc/en-us/articles/360034925353-sourcepower-pavg) command and the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "sourceintensity_pavg();",
    "category": "general",
    "markdown": "# sourceintensity_pavg\r\n\r\nReturns the partial spectral average intensity injected into the simulation by the\r\nsource. The partial average intensity is equal to the partial average power divided by\r\nthe source area. See the\r\n[sourcepower_pavg](https://optics.ansys.com/hc/en-us/articles/360034925353-sourcepower-pavg)\r\ncommand and the Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\n| **Syntax**                                              | **Description**                                                                                                                                                                                                                                                                           |\r\n| ------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourceintensity_pavg (f,df);                      | Returns the spectrally averaged source power as defined above. The quantity f is the frequency and the quantity df is the frequency range around which the averaging is performed, both in Hz.                                                                                            |\r\n| out = sourceintensity_pavg(f,df, option);               | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n| out = sourceintensity_pavg(f,df, option, \"sourcename\"); | This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources.                                                                                                                                                    |\r\n\r\n**Example**\r\n\r\nPlease refer to [sourceintensity](./sourceintensity.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the partial spectral average intensity injected into the simulation by the source",
    "syntax": [
      {
        "syntax": "out = sourceintensity_pavg (f,df);",
        "description": "Returns the spectrally averaged source power as defined above. The quantity f is the frequency and the quantity df is the frequency range around which the averaging is performed, both in Hz."
      },
      {
        "syntax": "out = sourceintensity_pavg(f,df, option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      },
      {
        "syntax": "out = sourceintensity_pavg(f,df, option, \"sourcename\");",
        "description": "This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources."
      }
    ],
    "example": ""
  },
  {
    "name": "sourcenorm",
    "description": "Returns the source normalization spectrum used to normalize data in the cwnorm state for standard fourier transform quantities. See the [Units and normalization](https://optics.ansys.com/hc/en-us/articles/360034397034) page for more information.",
    "usage": "sourcenorm();",
    "category": "general",
    "markdown": "# sourcenorm\r\n\r\nReturns the source normalization spectrum used to normalize data in the cwnorm state for\r\nstandard fourier transform quantities. See the\r\n[Units and normalization](https://optics.ansys.com/hc/en-us/articles/360034397034) page\r\nfor more information.\r\n\r\n| **Syntax**           | **Description**                                                                                                                                                                                                                                                                                                                                |\r\n| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourcenorm(f); | Returns the source normalization spectrum used to normalize data in the cwnorm state at the vector of frequency points f. (f is the frequency in Hz) If the normalization state is set to 'CWNorm (average)': $$ s(\\\\omega)=\\\\operatorname{sourcenorm}(\\\\omega)=\\\\frac{1}{N} \\\\sum\\_{s o u r c e s} \\\\int \\\\exp (i \\\\omega t) s\\_{j}(t) d t $$ |\r\n\r\n- \\\\(s\\_{j}(t)\\\\): the time signal of the jth active source in the object tree\r\n- N is the number of active sources then\r\n\r\nIf the normalization state is set to 'CWNorm (first)': $$ s(\\\\omega)= \\\\int \\\\exp (i\r\n\\\\omega t) s\\_{1}(t) d t $$\\\r\nout = sourcenorm(f, name); | When you enter an additional argument for the source name,\r\nit uses the specific source of your choice, rather than the first source or the average\r\nof all the sources in the object tree.\r\n\r\n**Example**\r\n\r\nThis example shows how to reproduce the source spectrum figures shown in the\r\nFrequency/Wavelength tab of the source property window.\r\n\r\n```\r\nlambda1 = 0.4e-6; # start wavelength  \r\nlambda2 = 0.7e-6; # end wavelength  \r\nf=linspace(c/lambda2,c/lambda1,1000);  \r\n\r\n# get the source spectrum  \r\nspectrum=sourcenorm(f);  \r\nspectrum=abs(spectrum)^2;  \r\nspectrum=spectrum/max(spectrum);  \r\n\r\n# get the source time domain signal  \r\ntime = getdata(\"source\",\"time\");  \r\ntime_signal = getdata(\"source\",\"time_signal\");  \r\n\r\nplot(c/f*1e6,spectrum, \"wavelength (um)\",\"spectrum vs wavelength\");  \r\nplot(f/1e12,spectrum, \"frequency (THz)\",\"spectrum vs frequency\");  \r\nplot(time*1e15,time_signal,\"time (fs)\",\"amplitude\",\"Source time signal\"); \r\n```",
    "summary": "Returns the source normalization spectrum used to normalize data in the cwnorm state for standard fo...",
    "syntax": [
      {
        "syntax": "out = sourcenorm(f);",
        "description": "Returns the source normalization spectrum used to normalize data in the cwnorm state at the vector of frequency points f. (f is the frequency in Hz) If the normalization state is set to 'CWNorm (average)': $$ s(\\\\omega)=\\\\operatorname{sourcenorm}(\\\\omega)=\\\\frac{1}{N} \\\\sum\\_{s o u r c e s} \\\\int \\\\exp (i \\\\omega t) s\\_{j}(t) d t $$"
      }
    ],
    "example": "lambda1 = 0.4e-6; # start wavelength  \r\nlambda2 = 0.7e-6; # end wavelength  \r\nf=linspace(c/lambda2,c/lambda1,1000);  \r\n\r\n# get the source spectrum  \r\nspectrum=sourcenorm(f);  \r\nspectrum=abs(spectrum)^2;  \r\nspectrum=spectrum/max(spectrum);  \r\n\r\n# get the source time domain signal  \r\ntime = getdata(\"source\",\"time\");  \r\ntime_signal = getdata(\"source\",\"time_signal\");  \r\n\r\nplot(c/f*1e6,spectrum, \"wavelength (um)\",\"spectrum vs wavelength\");  \r\nplot(f/1e12,spectrum, \"frequency (THz)\",\"spectrum vs frequency\");  \r\nplot(time*1e15,time_signal,\"time (fs)\",\"amplitude\",\"Source time signal\");"
  },
  {
    "name": "sourcenorm2_avg",
    "description": "Returns the source normalization spectrum used to normalize data in the cwnorm state for the total spectral averaged quantities. See the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "sourcenorm2_avg();",
    "category": "general",
    "markdown": "# sourcenorm2_avg\r\n\r\nReturns the source normalization spectrum used to normalize data in the cwnorm state for\r\nthe total spectral averaged quantities. See the Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\nThe script function sourcenorm is defined as\r\n\r\n$$ s(\\\\omega)=\\\\operatorname{sourcenorm}(\\\\omega)=\\\\frac{1}{N} \\\\sum\\_{s o u r c s s}\r\n\\\\int \\\\exp (i \\\\omega t) s\\_{j}(t) d t $$\r\n\r\nIf sourcenorm2_avg is called without any arguments, it returns\r\n\r\n$$ \\\\text {sourcenorm} 2\\_{-}\r\n\\\\operatorname{avg}=\\\\int\\_{-\\\\infty}^{+\\\\infty}\\\\left|s\\\\left(\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2}\r\nd \\\\omega^{\\\\prime} $$\r\n\r\n| **Syntax**                            | **Description**                                                                                                                        |\r\n| ------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourcenorm2_avg;                | This function returns the source normalization for total spectral averaged quantities.                                                 |\r\n| out = sourcenorm2_avg( \"sourcename\"); | This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources. |\r\n\r\n**Example**\r\n\r\nPlease refer to [sourcenorm](./sourcenorm.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the source normalization spectrum used to normalize data in the cwnorm state for the total s...",
    "syntax": [
      {
        "syntax": "out = sourcenorm2_avg;",
        "description": "This function returns the source normalization for total spectral averaged quantities."
      },
      {
        "syntax": "out = sourcenorm2_avg( \"sourcename\");",
        "description": "This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources."
      }
    ],
    "example": ""
  },
  {
    "name": "sourcenorm2_pavg",
    "description": "Returns the source normalization spectrum used to normalize data in the cwnorm state for the partial spectral averaged quantities. See the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "sourcenorm2_pavg();",
    "category": "general",
    "markdown": "# sourcenorm2_pavg\r\n\r\nReturns the source normalization spectrum used to normalize data in the cwnorm state for\r\nthe partial spectral averaged quantities. See the Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\nIf the source time signal of the jth source in the simulation is sj(t), and N is the\r\nnumber of active sources then\r\n\r\n$$ s(\\\\omega)=\\\\operatorname{sourcenorm}(\\\\omega)=\\\\frac{1}{N} \\\\sum\\_{s o u r c s s}\r\n\\\\int \\\\exp (i \\\\omega t) s\\_{j}(t) d t $$\r\n\r\nPartial spectral averaging uses a Lorentzian weighting of the following form. Delta is\r\nthe FWHM of |h|2.\r\n\r\n$$ \\\\begin{array}{c}{\\\\left|h\\_{2}\\\\left(\\\\omega,\r\n\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2}=\\\\frac{\\\\delta}{2 \\\\pi}\r\n\\\\frac{1}{\\\\left(\\\\omega-\\\\omega^{\\\\prime}\\\\right)^{2}+(\\\\delta / 2)^{2}}} \\\\\\\\\r\n{\\\\int\\\\left|h\\\\left(\\\\omega, \\\\omega^{\\\\prime}\\\\right)\\\\right|^{2} d\r\n\\\\omega^{\\\\prime}=1}\\\\end{array} $$\r\n\r\nIf this function is called without any arguments, it returns\r\n\r\n$$ sourcenorm2\\_{pavg }=\\\\int\\_{-\\\\infty}^{+\\\\infty}\\\\left|h\\\\left(\\\\omega,\r\n\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2}\\\\left|s\\\\left(\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2}\r\nd \\\\omega^{\\\\prime} $$\r\n\r\n| **Syntax**                                       | **Description**                                                                                                                        |\r\n| ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourcenorm2_pavg( f, delta);               | This function returns the source normalization for partial spectral averaged quantities.                                               |\r\n| out = sourcenorm2_pavg( f, delta, \"sourcename\"); | This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources. |\r\n\r\n**Example**\r\n\r\nPlease refer to [sourcenorm](./sourcenorm.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the source normalization spectrum used to normalize data in the cwnorm state for the partial...",
    "syntax": [
      {
        "syntax": "out = sourcenorm2_pavg( f, delta);",
        "description": "This function returns the source normalization for partial spectral averaged quantities."
      },
      {
        "syntax": "out = sourcenorm2_pavg( f, delta, \"sourcename\");",
        "description": "This function makes it possible to perform the normalization using the spectrum of one source, rather than the sum of all the sources."
      }
    ],
    "example": ""
  },
  {
    "name": "sourcepower",
    "description": "Returns the power injected into the simulation by the source.",
    "usage": "sourcepower();",
    "category": "general",
    "markdown": "# sourcepower\r\n\r\nReturns the power injected into the simulation by the source.\r\n\r\n**Dipole sources**\r\n\r\nThe sourcepower script function returns the power the dipole source would radiate in a\r\nhomogeneous medium. This quantity can be calculated analytically (see\r\n[ Dipole source](https://optics.ansys.com/hc/en-us/articles/360034382794-Sources-Dipoles)).\r\nThe actual radiated power is not given by the sourcepower function. The actual radiated\r\npower is highly dependant on the surrounding materials since the reflections from the\r\nstructures will interfere with the fields from the dipole, changing the actual radiated\r\npower. To get the actual radiated power, see the [ dipolepower ](./dipolepower.md)\r\nscript function.\r\n\r\n**Other sources (Gaussian, plane wave, mode, etc)**\r\n\r\nThe sourcepower is determined from the equation below. Note that\r\n\\\\(P(f)^{\\\\text{Source}}\\\\) is the Poynting vector determined from the E, H fields\r\ninjected by the source. The integral is evaluated over the injection plane of the\r\nsource.\r\n\r\n$$ \\\\text {source power}\\_{\\\\text {no_norm}}(f)=\\\\frac{1}{2} \\\\int\r\n\\\\text{Re}\\\\left(P(f)^{\\\\text {Source}}\\\\right) \\\\cdot d S $$\r\n\r\n$$ \\\\text {source power}\\_{\\\\text {cw_norm}}(f)=\\\\frac{\\\\frac{1}{2} \\\\int\r\n\\\\text{Re}\\\\left(P(f)^{\\\\text {Source}}\\\\right) \\\\cdot d S}{ | \\\\text\r\n{sourcenorm}\\\\left.\\\\right |^{ 2 }} $$\r\n\r\nAs stated above, sourcepower gives the amount of power injected into the simulation. The\r\nonly exception is if the simulation is set up such that there is radiation that travels\r\nthrough the injection plane of the source in the source injection direction (pink\r\narrow). In such cases, the actual amount of power injected by the source will not be\r\ngiven by sourcepower . In this situation, the incident radiation interferes with the\r\nsource, changing the amount of injected power (similar to what happens for the dipole\r\nsource). In most cases, this means your simulation is not set up properly.\r\n\r\n## \\[[Notes:]\\] Multiple sources and CW normalization In the case of multiple sources, the sourcepower(f) command will return the sum of all sourcepowers from all sources. Since the value of the sourcenorm depend on the choice of cwnorm option, the calculated sourcepower will also be affected by it.\r\n\r\n| **Syntax**                          | **Description**                                                                                                                                                                                                                                                                                 |\r\n| ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourcepower(f);               | Returns the source power used to normalize transmission calculations at the vector of frequency points f (frequency in Hz). The unit of the source power is Watts if CW norm is used, and Watts/Hertz 2 if no norm is used.                                                                     |\r\n| out = sourcepower(f, option);       | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersects such a boundary at x min, y min, or z min. The default value of the option is 2. |\r\n| out = sourcepower(f, option, name); | This option allows you to obtain the spectrum of one source, rather than the sum of all sources. This option is only needed for simulations with multiple sources.                                                                                                                              |\r\n\r\n**Examples**\r\n\r\nThis example shows how to calculate the power injected by a source as a function of\r\nfrequency.\r\n\r\n```\r\nf=linspace(200e12,300e12,100);\r\nsp=sourcepower(f); # power in Watts, assuming CW norm is on.\r\n```\r\n\r\nThis example shows how to use the transmission and sourcepower functions to calculate\r\nthe power injected by a plane wave source.\r\n\r\n```\r\nnewproject;\r\nsave(\"test\");\r\n \r\n# simulation region\r\naddfdtd;\r\nset(\"x span\",1e-6); set(\"y span\",1e-6); set(\"z span\",1e-6);\r\nset(\"x min bc\",\"periodic\"); set(\"y min bc\",\"periodic\");\r\n \r\n# plane wave source\r\naddplane;\r\nset(\"z\",-0.3e-6);\r\nset(\"x span\",2e-6); set(\"y span\",2e-6);\r\nset(\"center wavelength\",500e-9);\r\nset(\"wavelength span\",0);\r\n \r\n# power monitor\r\naddpower; \r\nset(\"z\",0.3e-6);        \r\nset(\"x span\",2e-6); set(\"y span\",2e-6);\r\n# run simulation \r\nrun;            \r\n# get results \r\nm=\"monitor\";      \r\nf=getdata(m,\"f\");     # get frequency vector\r\nT=transmission(m);     # get power transmission (fraction of source power)\r\nsp=sourcepower(f);     # get power injected by source (Watts)\r\n \r\n# output results\r\n?\"Transmitted power (fraction of source power): \" +num2str(T);\r\n?\"Transmitted power (Watts): \" +num2str(T*sp);\r\n?\"Source power (Watts): \"+num2str(sp);\r\n> Transmitted power (fraction of source power): 0.999986\r\n> Transmitted power (Watts): 1.26203e-015\r\n> Source power (Watts): 1.26204e-015\r\n```",
    "summary": "Returns the power injected into the simulation by the source",
    "syntax": [
      {
        "syntax": "out = sourcepower(f);",
        "description": "Returns the source power used to normalize transmission calculations at the vector of frequency points f (frequency in Hz). The unit of the source power is Watts if CW norm is used, and Watts/Hertz 2 if no norm is used."
      },
      {
        "syntax": "out = sourcepower(f, option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersects such a boundary at x min, y min, or z min. The default value of the option is 2."
      },
      {
        "syntax": "out = sourcepower(f, option, name);",
        "description": "This option allows you to obtain the spectrum of one source, rather than the sum of all sources. This option is only needed for simulations with multiple sources."
      }
    ],
    "example": ""
  },
  {
    "name": "sourcepower_avg",
    "description": "Returns the total spectral average power injected into the simulation by the source. See the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "sourcepower_avg();",
    "category": "general",
    "markdown": "# sourcepower_avg\r\n\r\nReturns the total spectral average power injected into the simulation by the source. See\r\nthe Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\nThis script function calculates the following quantities, depending on whether the\r\nnormalization state is cwnorm or nonorm:\r\n\r\n$$ \\\\text {sourcepower}_{-}{\\\\text {avg}_{nonorm}}=\\\\int\\_{0}^{+\\\\infty} \\\\text\r\n{sourcepower}\\_{nonorm}(\\\\omega) d\\\\omega $$\r\n\r\n$$ \\\\text {sourcepower}_{-}{\\\\text\r\n{avg}_{cwnorm}}(f)=\\\\frac{\\\\int\\_{0}^{+\\\\infty}|s(\\\\omega)|^2 \\\\text\r\n{sourcepower}_{cwnorm}(\\\\omega) d\\\\omega}{\\\\int_{0}^{+\\\\infty}|s(\\\\omega)|^2d\\\\omega} $$\r\n\r\nwhere sourcepower is the quantity returned by the sourcepower script function, s(w) is\r\nreturned by sourcenorm, and ω=2πf. Typically, this function should be used in the cwnorm\r\nstate. Also see the sourcenorm2_pavg script function.\r\n\r\n| **Syntax**                                   | **Description**                                                                                                                                                                                                                                                                           |\r\n| -------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourcepower_avg;                       | Returns the spectrally averaged source power as defined above.                                                                                                                                                                                                                            |\r\n| out = sourcepower_avg(option);               | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n| out = sourcepower_avg(option, \"sourcename\"); | This option allows you to obtain the spectrum of one source, rather than the sum of all sources. This option is only needed for simulations with multiple sources.                                                                                                                        |\r\n\r\n**Example**\r\n\r\nPlease refer to [sourcepower](./sourcepower.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the total spectral average power injected into the simulation by the source",
    "syntax": [
      {
        "syntax": "out = sourcepower_avg;",
        "description": "Returns the spectrally averaged source power as defined above."
      },
      {
        "syntax": "out = sourcepower_avg(option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      },
      {
        "syntax": "out = sourcepower_avg(option, \"sourcename\");",
        "description": "This option allows you to obtain the spectrum of one source, rather than the sum of all sources. This option is only needed for simulations with multiple sources."
      }
    ],
    "example": ""
  },
  {
    "name": "sourcepower_pavg",
    "description": "Returns the partial spectral average power injected into the simulation by the source. See the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "sourcepower_pavg();",
    "category": "general",
    "markdown": "# sourcepower_pavg\r\n\r\nReturns the partial spectral average power injected into the simulation by the source.\r\nSee the Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\nPartial spectral averaging uses a Lorentzian weighting of the form\r\n\r\n$$ \\\\begin{array}{c}{\\\\left|h\\\\left(\\\\omega,\r\n\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2}=\\\\frac{\\\\delta}{2 \\\\pi}\r\n\\\\frac{1}{\\\\left(\\\\omega-\\\\omega^{\\\\prime}\\\\right)^{2}+(\\\\delta / 2)^{2}}} \\\\\\\\\r\n{\\\\int\\\\left|h\\\\left(\\\\omega, \\\\omega^{\\\\prime}\\\\right)\\\\right|^{2} d\r\n\\\\omega^{\\\\prime}=1}\\\\end{array} $$\r\n\r\nThis script function calculates the following quantities, depending on whether the\r\nnormalization state is cwnorm or nonorm:\r\n\r\n$$\r\n\\\\text{sourcepower}_{-}\\\\text{pavg}_{nonorm}(f)=\\\\int\\_{-\\\\infty}^{+\\\\infty}\\\\left|h\\\\left(\\\\omega,\r\n\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2} \\\\text { sourcepower}\\_ {nonorm } (\\\\omega ) d\r\n\\\\omega $$\r\n\r\n$$\r\n\\\\text{sourcepower}_{-}\\\\text{pavg}_{cwnorm}(f)=\\\\frac{\\\\int\\_{0}^{+\\\\infty}\\\\left|h\\\\left(\\\\omega,\r\n\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2} |s(\\\\omega)|^2\\\\text { sourcepower}\\_ {cwnorm }\r\n(\\\\omega^{\\\\prime} ) d \\\\omega^{\\\\prime}}{\\\\int\\_{0}^{+\\\\infty}\\\\left|h\\\\left(\\\\omega,\r\n\\\\omega^{\\\\prime}\\\\right)\\\\right|^{2} |s(\\\\omega)^{\\\\prime}|^2 d\\\\omega^{\\\\prime}} $$\r\n\r\nwhere sourcepower is the quantity returned by the sourcepower script function, s(w) is\r\nreturned by sourcenorm, and ω=2πf. Typically, this function should be used in the cwnorm\r\nstate. Also see the sourcenorm2_pavg script function.\r\n\r\n| **Syntax**                                          | **Description**                                                                                                                                                                                                                                                                           |\r\n| --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sourcepower_pavg(f,df);                       | Returns the spectrally averaged source power as defined above. The quantity f is the frequency and the quantity df is the frequency range around which the averaging is performed, both in Hz.                                                                                            |\r\n| out = sourcepower_pavg(f, df,option);               | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n| out = sourcepower_pavg(f,df, option, \"sourcename\"); | This option allows you to obtain the spectrum of one source, rather than the sum of all sources. This option is only needed for simulations with multiple sources.                                                                                                                        |\r\n\r\n**Example**\r\n\r\nPlease refer to [sourcepower](./sourcepower.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the partial spectral average power injected into the simulation by the source",
    "syntax": [
      {
        "syntax": "out = sourcepower_pavg(f,df);",
        "description": "Returns the spectrally averaged source power as defined above. The quantity f is the frequency and the quantity df is the frequency range around which the averaging is performed, both in Hz."
      },
      {
        "syntax": "out = sourcepower_pavg(f, df,option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      },
      {
        "syntax": "out = sourcepower_pavg(f,df, option, \"sourcename\");",
        "description": "This option allows you to obtain the spectrum of one source, rather than the sum of all sources. This option is only needed for simulations with multiple sources."
      }
    ],
    "example": ""
  },
  {
    "name": "spline",
    "description": "Does a cubic spline interpolation of a data set.",
    "usage": "spline();",
    "category": "general",
    "markdown": "# spline\r\n\r\nDoes a cubic spline interpolation of a data set.\r\n\r\n| **Syntax**                  | **Description**                                           |\r\n| --------------------------- | --------------------------------------------------------- |\r\n| out = spline(Ex,xold,xnew); | \"not-a-knot\" cubic spline interpolation of a 1D function. |\r\n\r\n- Ex is an existing data set\r\n- xold specifies the points where Ex is sampled\r\n- xnew specifies new points to interpolate the data.\r\n\r\nThe points in xnew do not have to be within the bounds of xold.\\\r\nspline(Ex,xold,xnew,[derivMin; derivMax]); | \"clamped cubic spline\" interpolation of a\r\n1D function.\r\n\r\n- Ex is an existing data set\r\n- xold specifies the points where Ex is sampled\r\n- xnew specifies new points to interpolate the data.\r\n- derivMin specifies the 1st-order derivatives at the starting point\r\n- derivMax specifies the 1st-order derivatives at the ending point\r\n\r\n\\[[NOTE:]\\] The \\[[spline]\\] script has been modified in version 2020R2 or later. To\r\nrecover the result from previous versions, use the \"clamped cubic spline\" option and\r\ndefine the \"derivMin\" and \"deriveMax\" as follows:\r\n\r\n```\r\nderivMin = (Ex(2)-Ex(1))/(xold(2)-xold(1));  \r\nderivMax = (Ex(end)-Ex(end-1))/(xold(end)-xold(end-1));  \r\n```\r\n\r\n______________________________________________________________________\r\n\r\n**Example**\r\n\r\nResample Ex at xnew using cubic spline and linear interpolation methods. Note that xnew\r\nis outside the bounds of xold.\r\n\r\n```\r\nxold=linspace(0,10,7);\r\nEx=sin(xold);\r\nxnew=linspace(-1,9,25); # defining a new x vector\r\nExnew=interp(Ex,xold,xnew); # interpolating the new data set\r\nExnew2=spline(Ex,xold,xnew); # smoothing\r\nplotxy(xold,Ex,xnew,Exnew,xnew,Exnew2,\"x\",\"y\",\"\");\r\nlegend(\"old data\", \"interp\", \"Spline\");\r\n```\r\n\r\nThe example code will generate the following plots, displaying the difference between\r\nthe linear and cubic spline interpolation techniques.",
    "summary": "Does a cubic spline interpolation of a data set",
    "syntax": [
      {
        "syntax": "out = spline(Ex,xold,xnew);",
        "description": "\"not-a-knot\" cubic spline interpolation of a 1D function."
      }
    ],
    "example": "xold=linspace(0,10,7);\r\nEx=sin(xold);\r\nxnew=linspace(-1,9,25); # defining a new x vector\r\nExnew=interp(Ex,xold,xnew); # interpolating the new data set\r\nExnew2=spline(Ex,xold,xnew); # smoothing\r\nplotxy(xold,Ex,xnew,Exnew,xnew,Exnew2,\"x\",\"y\",\"\");\r\nlegend(\"old data\", \"interp\", \"Spline\");"
  },
  {
    "name": "splitstring",
    "description": "Splits a long string into a series of substrings, where the substrings are stored in a cell (i.e., string) array.",
    "usage": "splitstring();",
    "category": "general",
    "markdown": "# splitstring\r\n\r\nSplits a long string into a series of substrings, where the substrings are stored in a\r\ncell (i.e., string) array.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                     |\r\n| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |\r\n| s2 = splitstring(s1,endl); | Split the string S1 into a series of strings, using the end of line character as the delimiter between strings. S2 is a cell array. |\r\n\r\n**Example**\r\n\r\nUse the splitstring command to get the contents of a directory in a cell (i.e., string)\r\narray. Then loop through the array looking for all FDTD project files (.fsp).\r\n\r\n```\r\nfiles = splitstring(dir,endl);        # directory contents in a cell (string) array\r\nfor(i=1:length(files)) {           # loop over all files\r\n if (findstring(files{i},\"fsp\") != -1) {  # look for 'fsp' files\r\n  if (fileexists(files{i})) {       # check if the file exists (ie. it's a file and not a directory)\r\n   ?files{i};               # output file name\r\n   load(files{i});            # load file\r\n  }\r\n }\r\n}\r\n```\r\n\r\nA similar example for getting the names of all monitors in a simulation. Loop through\r\nall monitors, checking if they contain a result named 'E'. If so, save that data to a\r\nfile.\r\n\r\n```\r\nmNames = splitstring(getresult,endl);\r\n \r\nfor (i=1:length(mNames)) {\r\n if (haveresult(mNames{i},\"E\")) {\r\n  E=getresult(mNames{i},\"E\");   # get a result from that monitor\r\n } else {\r\n  E = mNames{i} + \" did not contain the specified data.\";\r\n }\r\n filename = \"file\"+num2str(i);\r\n savedata(filename,E);     # save data to ldf files\r\n}\r\n```",
    "summary": "Splits a long string into a series of substrings, where the substrings are stored in a cell (i",
    "syntax": [
      {
        "syntax": "s2 = splitstring(s1,endl);",
        "description": "Split the string S1 into a series of strings, using the end of line character as the delimiter between strings. S2 is a cell array."
      }
    ],
    "example": "files = splitstring(dir,endl);        # directory contents in a cell (string) array\r\nfor(i=1:length(files)) {           # loop over all files\r\n if (findstring(files{i},\"fsp\") != -1) {  # look for 'fsp' files\r\n  if (fileexists(files{i})) {       # check if the file exists (ie. it's a file and not a directory)\r\n   ?files{i};               # output file name\r\n   load(files{i});            # load file\r\n  }\r\n }\r\n}"
  },
  {
    "name": "sqrt",
    "description": "Calculates the square root of a number. Input can be complex or negative.",
    "usage": "sqrt();",
    "category": "general",
    "markdown": "# sqrt\r\n\r\nCalculates the square root of a number. Input can be complex or negative.\r\n\r\n| **Syntax**     | **Description**                                                                                                                                                                                               |\r\n| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = sqrt(x); | The square root of x. The square root is chosen so that real(sqrt(x))≥0 for any complex number x. The imaginary part, imag(sqrt(x)), can be positive or negative but if real(sqrt(x))=0 then imag(sqrt(x))≥0. |\r\n\r\n**Example**\r\n\r\nCalculate the square root of a number.\r\n\r\n```\r\n?sqrt(4);\r\nresult: \r\n2 \r\n```\r\n\r\nThe square root function of z = x + iy in the complex plane has a branch cut at (-∞,0\\],\r\nas shown in the following example.\r\n\r\n```\r\nx = linspace(-1,1,100);\r\ny = linspace(-1,1,100);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\nimage(x,y,real(sqrt(X+1i*Y)),\"x\", \"y\",\"Real part of sqrt(x+iy)\");\r\nimage(x,y,imag(sqrt(X+1i*Y)),\"x\", \"y\",\"Imaginary part of sqrt(x+iy)\");\r\n```\r\n\r\n|\\\r\n\\---|---",
    "summary": "Calculates the square root of a number",
    "syntax": [
      {
        "syntax": "out = sqrt(x);",
        "description": "The square root of x. The square root is chosen so that real(sqrt(x))≥0 for any complex number x. The imaginary part, imag(sqrt(x)), can be positive or negative but if real(sqrt(x))=0 then imag(sqrt(x))≥0."
      }
    ],
    "example": "?sqrt(4);\r\nresult: \r\n2"
  },
  {
    "name": "sroughness",
    "description": "Returns a matrix containing a rough surface characterized by an RMS amplitude.",
    "usage": "sroughness();",
    "category": "general",
    "markdown": "# sroughness\r\n\r\nReturns a matrix containing a rough surface characterized by an RMS amplitude.\r\n\r\n| **Syntax**                                                        | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\r\n| ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out= sroughness(x_span, y_span, sigma_rms, corr_x, corr_y, seed); | Returns a matrix containing a rough surface characterized by an RMS amplitude ‘sigma_rms’ and correlation lengths ‘corr_x’ and ‘corr_y’. The roughness is generated by creating a random matrix of values in K space defined by ‘x_span’ and ‘y_span’. A Gaussian filter is applied to this matrix, then a Fourier transform is used to transform the matrix back to real space. Due to the way the Fourier transform is setup, the roughness will be periodic with period x, y span. This is convenient for some application, particularly when using periodic boundary conditions. The parameter ‘seed’ defined the random seed value used to generate the surface. |\r\n\r\n**Example**\r\n\r\nThis is a simple example of a rough surface created with sroughness:\r\n\r\n```\r\nx_span = 400e-6;\r\ny_span = 400e-6;\r\nsigma_rms = 0.3;\r\ncorr_length_x = 40e-6;\r\ncorr_length_y = 40e-6;\r\nseed_process = 1;\r\n# calculate the number of points in x and y\r\nNx = 100;\r\nNy = 100;\r\n# initialize required variables\r\nx_wafer = linspace(-x_span/2,x_span/2,Nx);\r\ny_wafer = linspace(-y_span/2,y_span/2,Ny);\r\nneff_xy_wafer = sroughness( x_wafer, y_wafer, sigma_rms, corr_length_x, corr_length_y, seed_process );\r\nimage(x_wafer/1e-6, y_wafer/1e-6, neff_xy_wafer, \"x (um)\", \"y(um)\", \"Rough surface\");\r\n```",
    "summary": "Returns a matrix containing a rough surface characterized by an RMS amplitude",
    "syntax": [
      {
        "syntax": "out= sroughness(x_span, y_span, sigma_rms, corr_x, corr_y, seed);",
        "description": "Returns a matrix containing a rough surface characterized by an RMS amplitude ‘sigma_rms’ and correlation lengths ‘corr_x’ and ‘corr_y’. The roughness is generated by creating a random matrix of values in K space defined by ‘x_span’ and ‘y_span’. A Gaussian filter is applied to this matrix, then a Fourier transform is used to transform the matrix back to real space. Due to the way the Fourier transform is setup, the roughness will be periodic with period x, y span. This is convenient for some application, particularly when using periodic boundary conditions. The parameter ‘seed’ defined the random seed value used to generate the surface."
      }
    ],
    "example": "x_span = 400e-6;\r\ny_span = 400e-6;\r\nsigma_rms = 0.3;\r\ncorr_length_x = 40e-6;\r\ncorr_length_y = 40e-6;\r\nseed_process = 1;\r\n# calculate the number of points in x and y\r\nNx = 100;\r\nNy = 100;\r\n# initialize required variables\r\nx_wafer = linspace(-x_span/2,x_span/2,Nx);\r\ny_wafer = linspace(-y_span/2,y_span/2,Ny);\r\nneff_xy_wafer = sroughness( x_wafer, y_wafer, sigma_rms, corr_length_x, corr_length_y, seed_process );\r\nimage(x_wafer/1e-6, y_wafer/1e-6, neff_xy_wafer, \"x (um)\", \"y(um)\", \"Rough surface\");"
  },
  {
    "name": "stackdipole",
    "description": "###",
    "usage": "stackdipole();",
    "category": "general",
    "markdown": "# stackdipole\r\n\r\n### \r\n\r\n### Results\r\n\r\nThis function analytically calculates the dipole emission properties of an unpatterned\r\nmultilayer stack. For structures that can be reduced to 1D this is technique is much\r\nmore efficient than running fully vectorial simulations with FDTD.\r\n\r\nThe results are calculated via the following equation. All results returned are\r\nfunctions of the emission angle \\\\( \\\\theta \\\\) measured from the surface normal (see\r\nabove image). Additionally the calculation assumes a current density of 1 \\\\( A/m^2\\\\).\r\nLimits of the integration are determined by the input dipole spectrum.\r\n\r\n$$\\\r\n\\\\text {stackdipole}(\\\\theta)=\\\\int\\_{\\\\lambda}(j \\\\times e f \\\\times st)\r\n\\\\left(\\\\frac{r d \\\\times F\\_{r a d}(\\\\theta, \\\\lambda)}{r d \\\\times F(\\\\lambda)+(1-r\r\nd)}\\\\right) \\\\left(\\\\text {photon probability}(\\\\lambda) \\\\times\r\nE\\_{ph}(\\\\lambda)\\\\right) d \\\\lambda\\\r\n$$\r\n\r\n| **Result**  | **Description**                                                                                                                                                                                                                 |\r\n| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| radiance    | \\\\( \\\\frac{W}{\\\\text{steradian }m^2 }\\\\) Radiance is a measure of the optical power in SI units, as function of \\\\( \\\\theta \\\\)                                                                                                 |\r\n| luminance   | \\\\( \\\\text{candela }/ m^2 \\\\) Luminance is a measure of apparent brightness to the human eye.                                                                                                                                   |\r\n| X, Y, and Z | Tristimulus values are basis vectors of the CIE 1931 color space[1], describing the perceived color quantitatively, see [colormatch](https://optics.ansys.com/hc/en-us/articles/360034926753) page for mathematical definition. |\r\n\r\nFor more information on the theory behind this approach, see\r\n[Stack dipole half-space](https://apps.lumerical.com/stackdipole_and_fdtd_simulations.html)\r\nexample. Additional discussion on the results can be found at\r\n[STACK GUI - OLED Device Introduction](https://support.lumerical.com/hc/en-us/articles/4402039667091-STACK-GUI-OLED-Device-Introduction),\r\nand [OLED Methodology](https://optics.ansys.com/hc/en-us/articles/360042225754)\r\nchromaticity section.\r\n\r\n## NOTE: In 2021R1.1 the length of the results from stack dipole may have changed. Previously singleton dimensions were reduced before output. If you have updated and run into problems you may need to [pinch](https://optics.ansys.com/hc/en-us/articles/360034405674) the results yourself.\r\n\r\n### Usage\r\n\r\n| **Syntax**                                                                               | **Description**                                                               |\r\n| ---------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |\r\n| dipole_emission = stackdipole(n,d,f,z,dipole_spec, orientation,res,direction, ef,st,rd); | Analytically calculates the dipole emission properties of a multi-layer stack |\r\n| dipole_emission = stackdipole(n,d,f,z,dipole_spec, options);                             |                                                                               |\r\n| **Parameter**                                                                            |                                                                               |\r\n| ---                                                                                      | ---                                                                           |\r\n| n                                                                                        | required                                                                      |\r\n\r\n- Nlayers: isotropic and non-dispersive\r\n- Nlayers x Nfreq: isotropic and dispersive\r\n- Nlayers x 3: anisotropic and non-dispersive\r\n- Nlayers x Nfreq x 3: anisotropic and dispersive materials are involved.\\\r\n  NOTE: Only birefringence in z (nx=ny≠nz) is supported. The commands will give an error\r\n  unless nx=ny.\r\n\r\nd | required | | vector | Thickness of each layer. Size is N_layers.\\\r\nf | required | | vector | Frequency vector with a length of Nfreq.\\\r\nz | required | | vector | Position of the dipoles (0 is the bottom of the stack). Size\r\nis N_dipoles, and dipoles must be located within boundaries.\\\r\ndipole_spec | required | | vector | Dipole spectrum. This is treated as a power\r\nintensity distribution, integrated by midpoint rule in wavelength. The photon\r\nprobability distribution is calculated by normalizing dipole_spec/f. Size is N_dipoles x\r\nlength(f).\\\r\norientation | optional | \"rand\" | cell of strings | Orientation of the dipoles. Accepts\r\nstring or cell array as 'orientation' argument with values:\r\n\r\n- \"random\" or \"rand\"\r\n- \"vertical\" or \"vert\"\r\n- \"horizontal\" or \"horz\"\r\n\r\nSize is N_dipoles.\\\r\nres | optional | 1000 | number | The resolution for far-field emission angle.\\\r\ndirection | optional | 1 | number | Choice of far-field half-space, this can be +1 (top)\r\nor -1 (bottom).\\\r\nef | optional | 1 | vector | The exciton fraction. The default value is 1, which means\r\nthat every carrier results in an exciton. Size is N_dipoles.\\\r\nst | optional | 0.25 | vector | The singlet exciton fraction. The default value is 0.25,\r\nwhich means that there are 3 spin triplets per spin-singlet. Size is N_dipoles.\\\r\nrd | optional | 1 | vector | The relative decay rate. The default value is 1, which\r\nmeans that every singlet exciton results in a photon and there is no contribution from\r\nnon-radiative decay processes. Size is N_dipoles.\\\r\noptions | optional | | struct | _In 2021R1.1 and later_ : This struct can be used to\r\npass optional arguments. Passing this struct allows users to specify the following\r\nparameters: \"orientation\": defines orientation of the dipole. \"res\"/\"theta\": defines the\r\noutput angles explicitly, instead of simply resolution. To specify the angles pass them\r\nas a vector \"theta\" in degrees \\[0,90). \"incoherent_propagation\": a vector argument\r\ndefines the coherent and incoherent layers of the stack with 0 = coherent propagation\r\nand 1 = incoherent propagation. The dipole cannot be located in an incoherent layer. If\r\nusing options then all optional arguments, must be passed through the struct.\r\n\r\n#### **Example**\r\n\r\nCalculate the radiated power of a dipole source in a dielectric half-space.\r\n\r\n```\r\n# geometry: halfspace of material n1 and n2\r\nn1 = 1.5; # lower halfspace\r\nn2 = 1.0; # upper halfspace  \r\n  \r\n# source: monochrome 500nm dipole\r\nwavelength = 500e-9;\r\ndelta = 80e-9; # position: in material n2 delta nm from interface  \r\n\r\nangular_res = 173; # resolution for emission angle (farfield angle)  \r\n  \r\n# set-up for STACK command\r\nn = [n1; n2]; #STACK optical properties\r\nd = [0, 2*delta]; #STACK geometric properties\r\nf = [c/wavelength]; #STACK frequency points\r\nz = [delta]; #STACK dipole position\r\nspectrum = [1.0]; #STACK dipole spectrum  \r\n\r\nresult_unpol = stackdipole(n,d,f,z,spectrum,\"rand\",angular_res);\r\nresult_Vert = stackdipole(n,d,f,z,spectrum,\"vert\",angular_res);\r\nresult_Horz = stackdipole(n,d,f,z,spectrum,\"horz\",angular_res);\r\n\r\nplot(result_unpol.theta,result_unpol.radiance,\"emission angle (degrees)\",\"power/steradian  (W/steradian/m^2)\",\"unpolarized\");\r\nplot(result_Vert.theta,result_Vert.radiance,\"emission angle (degrees)\",\"power/steradian  (W/steradian/m^2)\",\"vertical P orientation\");\r\nplot(result_Horz.theta,result_Horz.radiance,\"emission angle (degrees)\",\"power/steradian  (W/steradian/m^2)\",\"horizontal P orientation\");  \r\n\r\n# calculate power\r\nsin_theta = sin(pi/180*pinch(result_unpol.theta));\r\n#integrate power theta 0-pi/2 and phi 0-2pi\r\n?total_power_pVert_upward = (0.5*pi)*(2*pi)*integrate(sin_theta*result_Vert.radiance,1,linspace(0,1,angular_res));\r\n\r\n\r\n# In 2020R1.3  \r\noptions={ \"res\": 173, \"orientation\": 'rand', \"incoherent_propagation\": incoherent_propagation};  \r\nresult = stackdipole(n,d,f,z,spectrum,options);  \r\n  \r\noptions={ \"theta\": linspace(0,30,100), \"orientation\": 'rand', \"incoherent_propagation\": incoherent_propagation};  \r\nresult = stackdipole(n,d,f,z,spectrum,options);\r\n```\r\n\r\n### Related publications\r\n\r\n1. CIE Proceedings (1932), 1931. Cambridge: Cambridge University Press.",
    "summary": "###",
    "syntax": [
      {
        "syntax": "radiance",
        "description": "\\\\( \\\\frac{W}{\\\\text{steradian }m^2 }\\\\) Radiance is a measure of the optical power in SI units, as function of \\\\( \\\\theta \\\\)"
      },
      {
        "syntax": "luminance",
        "description": "\\\\( \\\\text{candela }/ m^2 \\\\) Luminance is a measure of apparent brightness to the human eye."
      },
      {
        "syntax": "X, Y, and Z",
        "description": "Tristimulus values are basis vectors of the CIE 1931 color space[1], describing the perceived color quantitatively, see [colormatch](https://optics.ansys.com/hc/en-us/articles/360034926753) page for mathematical definition."
      }
    ],
    "example": "# geometry: halfspace of material n1 and n2\r\nn1 = 1.5; # lower halfspace\r\nn2 = 1.0; # upper halfspace  \r\n  \r\n# source: monochrome 500nm dipole\r\nwavelength = 500e-9;\r\ndelta = 80e-9; # position: in material n2 delta nm from interface  \r\n\r\nangular_res = 173; # resolution for emission angle (farfield angle)  \r\n  \r\n# set-up for STACK command\r\nn = [n1; n2]; #STACK optical properties\r\nd = [0, 2*delta]; #STACK geometric properties\r\nf = [c/wavelength]; #STACK frequency points\r\nz = [delta]; #STACK dipole position\r\nspectrum = [1.0]; #STACK dipole spectrum  \r\n\r\nresult_unpol = stackdipole(n,d,f,z,spectrum,\"rand\",angular_res);\r\nresult_Vert = stackdipole(n,d,f,z,spectrum,\"vert\",angular_res);\r\nresult_Horz = stackdipole(n,d,f,z,spectrum,\"horz\",angular_res);\r\n\r\nplot(result_unpol.theta,result_unpol.radiance,\"emission angle (degrees)\",\"power/steradian  (W/steradian/m^2)\",\"unpolarized\");\r\nplot(result_Vert.theta,result_Vert.radiance,\"emission angle (degrees)\",\"power/steradian  (W/steradian/m^2)\",\"vertical P orientation\");\r\nplot(result_Horz.theta,result_Horz.radiance,\"emission angle (degrees)\",\"power/steradian  (W/steradian/m^2)\",\"horizontal P orientation\");  \r\n\r\n# calculate power\r\nsin_theta = sin(pi/180*pinch(result_unpol.theta));\r\n#integrate power theta 0-pi/2 and phi 0-2pi\r\n?total_power_pVert_upward = (0.5*pi)*(2*pi)*integrate(sin_theta*result_Vert.radiance,1,linspace(0,1,angular_res));\r\n\r\n\r\n# In 2020R1.3  \r\noptions={ \"res\": 173, \"orientation\": 'rand', \"incoherent_propagation\": incoherent_propagation};  \r\nresult = stackdipole(n,d,f,z,spectrum,options);  \r\n  \r\noptions={ \"theta\": linspace(0,30,100), \"orientation\": 'rand', \"incoherent_propagation\": incoherent_propagation};  \r\nresult = stackdipole(n,d,f,z,spectrum,options);"
  },
  {
    "name": "stackfield",
    "description": "Calculates the fields within a multilayer stack illuminated from below by a plane wave using the analytic transfer matrix method. This function returns the E and H fields (Es, Ep, Hs, Hp). All results are returned in a single dataset as a function of frequency, incidence angle and location in the stack (z).",
    "usage": "stackfield();",
    "category": "general",
    "markdown": "# stackfield\r\n\r\nCalculates the fields within a multilayer stack illuminated from below by a plane wave\r\nusing the analytic transfer matrix method. This function returns the E and H fields (Es,\r\nEp, Hs, Hp). All results are returned in a single dataset as a function of frequency,\r\nincidence angle and location in the stack (z).\r\n\r\n| **Syntax**                 | **Description**                                |\r\n| -------------------------- | ---------------------------------------------- |\r\n| field = stackfield(n,d,f); | n: Refractive index of each layer. Size can be |\r\n\r\n- Nlayers: isotropic and non-dispersive\r\n- Nlayers x Nfreq: isotropic and dispersive\r\n- Nlayers x 3: anisotropic and non-dispersive\r\n- Nlayers x Nfreq x 3: anisotropic and dispersive materials are involved.\\\r\n  NOTE: Only birefringence in z (nx=ny≠nz) is supported. The commands will give an error\r\n  unless nx=ny.\r\n\r\nd: Thickness of each layer. Size is Nlayers. f: Frequency vector with a length of\r\nNfreq.\\\r\nfield = stackfield(n,d,f,theta,res); | theta: Angle vector, in degrees. Optional,\r\ndefault is 0. res: resolution in the field result returned. Optional, default is 1000.\\\r\nfield = stackfield(n,d,f,theta,res,min,max); | min/max: the min/max position where the\r\nuser wishes to compute the field. 0 corresponds to the bottom of the stack. Optional,\r\ndefault is the span of the multilayer stack.\r\n\r\n**Example**\r\n\r\nCalculate the field distribution of a 5 layer stack.\r\n\r\n```\r\nf = linspace(c/400e-9, c/1000e-9,100); # frequency vector  \r\ntheta = 0:1:45; # angle vector  \r\nd = [0; 200e-9; 300e-9; 400e-9; 0]; # 5 layers (including air on top and bottom)  \r\nnf = length(f);  \r\nnd = length(d);  \r\n  \r\n# refractive indices for non-dispersive materials  \r\nn1 = [1; 1.5; 2.5; 1.5; 1];   \r\n\r\n# refractive indices for dispersive materials  \r\nn2 = matrix(nd,nf);  \r\nn2(1,1:nf) = 1; # air  \r\nn2(2,1:nf) = getfdtdindex(\"SiO2 (Glass) - Palik\",f,min(f),max(f));  \r\nn2(3,1:nf) = getfdtdindex(\"Si (Silicon) - Palik\",f,min(f),max(f));  \r\nn2(4,1:nf) = getfdtdindex(\"SiO2 (Glass) - Palik\",f,min(f),max(f));  \r\nn2(5,1:nf) = 1; # air  \r\n  \r\nfield1 = stackfield(n1,d,f); # non-dispersive index data, and theta=0  \r\nfield2 = stackfield(n2,d,f,theta); # dispersive data index data, and theta from 0 to 45 deg  \r\n\r\nvisualize(field1);  \r\nvisualize(field2);\r\n```\r\n\r\nHere's an example for a birefringent slab in air:\r\n\r\n```\r\nN_layers = 3;  \r\nNfreqs = 100;  \r\nres = 1000;  \r\nn = matrix(N_layers, Nfreqs, 3);  \r\n  \r\nn(1, :, :) = 1;   # air  \r\nn(2, :, 1) = 2.1; # nx  \r\nn(2, :, 2) = 2.1; # ny  \r\nn(2, :, 3) = 2.5; # nz  \r\nn(3, :, :) = 1;   # air  \r\n  \r\nd = [0; 1e-6; 0]; # air/ birefringent slab / air  \r\nf = linspace(c/1e-6, c/1.5e-6, Nfreqs);  \r\ntheta = 0:1:45;  \r\n  \r\nfield = stackfield(n,d,f,theta,res);   \r\n  \r\nvisualize(field);\r\n```",
    "summary": "Calculates the fields within a multilayer stack illuminated from below by a plane wave using the ana...",
    "syntax": [
      {
        "syntax": "field = stackfield(n,d,f);",
        "description": "n: Refractive index of each layer. Size can be"
      }
    ],
    "example": "f = linspace(c/400e-9, c/1000e-9,100); # frequency vector  \r\ntheta = 0:1:45; # angle vector  \r\nd = [0; 200e-9; 300e-9; 400e-9; 0]; # 5 layers (including air on top and bottom)  \r\nnf = length(f);  \r\nnd = length(d);  \r\n  \r\n# refractive indices for non-dispersive materials  \r\nn1 = [1; 1.5; 2.5; 1.5; 1];   \r\n\r\n# refractive indices for dispersive materials  \r\nn2 = matrix(nd,nf);  \r\nn2(1,1:nf) = 1; # air  \r\nn2(2,1:nf) = getfdtdindex(\"SiO2 (Glass) - Palik\",f,min(f),max(f));  \r\nn2(3,1:nf) = getfdtdindex(\"Si (Silicon) - Palik\",f,min(f),max(f));  \r\nn2(4,1:nf) = getfdtdindex(\"SiO2 (Glass) - Palik\",f,min(f),max(f));  \r\nn2(5,1:nf) = 1; # air  \r\n  \r\nfield1 = stackfield(n1,d,f); # non-dispersive index data, and theta=0  \r\nfield2 = stackfield(n2,d,f,theta); # dispersive data index data, and theta from 0 to 45 deg  \r\n\r\nvisualize(field1);  \r\nvisualize(field2);"
  },
  {
    "name": "stackpurcell",
    "description": "## Results",
    "usage": "stackpurcell();",
    "category": "general",
    "markdown": "# stackpurcell\r\n\r\n## Results\r\n\r\nAnalytically calculates the Purcell factor and far-field emission power density for a\r\nmultilayer stack. For more information on the theory behind this approach, see\r\n[Stack dipole half-space](https://apps.lumerical.com/stackdipole_and_fdtd_simulations.html)\r\nexample. The usage for this command is very similar to [stackdipole](./stackdipole.md),\r\nbut the result returned in this case is a struct that contains the following datasets.\r\nThe power_density is functions of the emission angle \\\\( \\\\theta \\\\) measured from the\r\nsurface normal (see above image).\r\n\r\n| **Result** | **Description**                                                                                                                                                                                                                                                                                            |\r\n| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| power      | Power [normalized] _Attribute:_ purcell_factor. This is the total power of a monochromatic dipole at the specified position and emission frequency divided by the power that it would radiate in a homogeneous medium. _Parameters:_ dipole/z, f/lambda                                                    |\r\n| density    | Power [normalized/steradian] _Attributes:_ upward, downward, upward_into_air, downward_into_air. This is the power density per unit solid angle, as function of far field emission angle, also normalized to the power that would radiate in a homogeneous medium. _Parameters:_ theta, dipole/z, f/lambda |\r\n\r\nFor more information on the theory behind this approach, see\r\n[Stack dipole half-space](https://optics.ansys.com/hc/en-us/articles/360042713433)\r\nexample. Additional discussion on the results can be found at\r\n[STACK GUI - OLED Device Introduction.](https://support.lumerical.com/hc/en-us/articles/4402039667091-STACK-GUI-OLED-Device-Introduction)\r\n\r\n## Usage\r\n\r\n| **Syntax**                                     | **Description**                                                                                        |\r\n| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\r\n| result = stackpurcell(n,d,f,z,orientation,res) | Analytically calculates the Purcell factor and far-field emission power density of a multi-layer stack |\r\n| result = stackpurcell(n,d,f,z,options)         |                                                                                                        |\r\n| **Parameter**                                  |                                                                                                        |\r\n| ---                                            | ---                                                                                                    |\r\n| n                                              | required                                                                                               |\r\n\r\n- Nlayers: isotropic and non-dispersive\r\n- Nlayers x Nfreq: isotropic and dispersive\r\n- Nlayers x 3: anisotropic and non-dispersive\r\n- Nlayers x Nfreq x 3: anisotropic and dispersive materials are involved.\\\r\n  NOTE: Only birefringence in z (nx=ny≠nz) is supported. The commands will give an error\r\n  unless nx=ny.\r\n\r\nd | required | | vector | Thickness of each layer. Size is N_layers.\\\r\nf | required | | vector | Frequency vector.\\\r\nz | required | | vector | Position of the dipoles (0 is the bottom of the stack). Size\r\nis N_dipoles, and dipoles must be located within boundaries.\\\r\norientation | optional | \"rand\" | cell of strings | Orientation of the dipoles. Accepts\r\nstring or cell array as 'orientation' argument with values:\r\n\r\n- \"random\" or \"rand\"\r\n- \"vertical\" or \"vert\"\r\n- \"horizontal\" or \"horz\"\r\n\r\nSize is N_dipoles.\\\r\nres | optional | 1000 | number | The resolution for far-field emission angle.\\\r\noptions | optional | | struct | _In 2021R1.1 and later_ : This struct can be used to\r\npass optional arguments. Passing this struct allows users to specify the following\r\nparameters: \"orientation\": defines orientation of the dipole. \"res\"/\"theta\": defines the\r\noutput angles explicitly, instead of simply resolution. To specify the angles pass them\r\nas a vector \"theta\" in degrees \\[0,90). \"incoherent_propagation\": a vector argument\r\ndefines the coherent and incoherent layers of the stack with 0 = coherent propagation\r\nand 1 = incoherent propagation. The dipole cannot be located in an incoherent layer. If\r\nusing options then all optional arguments, must be passed through the struct.\r\n\r\n## Example\r\n\r\nExplore the effect of the dipole position on the angular distribution of the far-field\r\nemission:\r\n\r\n```\r\n### Use stackpurcell to explore the position of dipole in a multilayer stack  \r\n# frequency range  \r\nN_freq = 101;  \r\nlambda = linspace(380e-9,780e-9,N_freq); # 380nm to 780nm  \r\nf = c/lambda;  \r\n  \r\n# Intialize multilayer geometry  \r\nn = matrix(5,N_freq);  \r\nd = matrix(5,1);  \r\n#Define optical and geometric layer propertie  \r\nn(1,1:N_freq) = getfdtdindex(\"Al (Aluminium) - Palik\",f,f(1),f(N_freq)); d(1) = 0; # bottom substrate  \r\n# Note: this reads the material properties from FDTD material database. If you are using another product, please enter (n,k) explicitly  \r\nn(2,1:N_freq) = 1.85; d(2) = 60e-9;  \r\nn(3,1:N_freq) = 1.9; d(3) = 220e-9;  \r\nn(4,1:N_freq) = 1.8; d(4) = 120e-9;  \r\nn(5,1:N_freq) = 1.53; d(5) = 0; # top substrate (glass)  \r\n  \r\n# dipole positions/orientations  \r\nN_dipole= 51; # number of dipoles  \r\nz = linspace( d(2)+1e-10, d(2)+d(3)+1e-10, N_dipole ); # consider positions only within middle dielectric layer  \r\norientation = cell(N_dipole); # consider only randomly oriented dipoles  \r\nfor(ii = 1:N_dipole){  \r\norientation{ii} = \"rand\";}  \r\n  \r\n# angular_res: resolution for emission angle (farfield angle)  \r\nres = 198;  \r\nresult = stackpurcell(n,d,f,z,orientation,res); # result is a struct  \r\n  \r\n# plot Purcell factor for dipole located at the middle of the layer  \r\npurcell = pinch(result.power.purcell_factor); # size is Ndipole by Nfreqs  \r\nplot(lambda*1e9, pinch(purcell,1,round(N_dipole/2)),'wavelength (nm)','Purcell factor');  \r\n  \r\n# plot far field power density at center frequency  \r\ntheta = pinch(result.density.theta);  \r\ndensity = pinch(result.density.upward_into_air); # size is res by Ndipole by Nfreqs  \r\nimage(theta, z*1e+9, pinch(density,3,round(N_freq/2)), \"far-field angle (degrees)\", \"dipole position (nm)\", num2str(f(round(N_freq/2))*1e-12)+\"THz into Air\");  \r\n  \r\n  \r\n\r\n\r\n\r\n# In 2020R1.2  \r\nincoherent_propagation = [0, 0, 1, 0, 0];  \r\noptions={ \"res\": 1000, \"orientation\": 'rand',\"incoherent_propagation\":incoherent_propagation};  \r\nstackpurcell(n,d,f,z,options);  \r\n#or  \r\noptions={ \"theta\": linspace(0,45,100) , \"orientation\": 'vert', \"incoherent_propagation\":incoherent_propagation};  \r\nstackpurcell(n,d,f,z,options);\r\n```",
    "summary": "## Results",
    "syntax": [
      {
        "syntax": "power",
        "description": "Power [normalized] _Attribute:_ purcell_factor. This is the total power of a monochromatic dipole at the specified position and emission frequency divided by the power that it would radiate in a homogeneous medium. _Parameters:_ dipole/z, f/lambda"
      },
      {
        "syntax": "density",
        "description": "Power [normalized/steradian] _Attributes:_ upward, downward, upward_into_air, downward_into_air. This is the power density per unit solid angle, as function of far field emission angle, also normalized to the power that would radiate in a homogeneous medium. _Parameters:_ theta, dipole/z, f/lambda"
      }
    ],
    "example": ""
  },
  {
    "name": "stackrt",
    "description": "Calculates the reflection and transmission of a plane wave through a multi-layer stack using the analytic transfer matrix method. This function returns the fraction of transmitted and reflected power (Ts, Tp, Rs, Rp), and the complex reflection and transmission coefficients (ts, tp, rs, rp), for both S and P polarizations. All results are returned in a single dataset as a function of frequency and incidence angle (optional).",
    "usage": "stackrt();",
    "category": "general",
    "markdown": "# stackrt\r\n\r\nCalculates the reflection and transmission of a plane wave through a multi-layer stack\r\nusing the analytic transfer matrix method. This function returns the fraction of\r\ntransmitted and reflected power (Ts, Tp, Rs, Rp), and the complex reflection and\r\ntransmission coefficients (ts, tp, rs, rp), for both S and P polarizations. All results\r\nare returned in a single dataset as a function of frequency and incidence angle\r\n(optional).\r\n\r\nNOTE: From 2022 R1.2, stackrt script command supports fully anisotropic and dispersive\r\nmaterials by specifying the nine values of the second-order refractive index tensor. For\r\nanisotropic materials, the polarization of reflected light could vary from its incident\r\npolarization. The suffix **sp** and **ps** denote how polarization is changed in the\r\nreturned power and coefficients. **sp** stands for **s** incident and **p**\r\nreflected/transmitted.\r\n\r\nTo calculate the fields within the stack, please see [ stackfield](./stackfield.md).\r\n\r\n| **Syntax**           | **Description**                                |\r\n| -------------------- | ---------------------------------------------- |\r\n| RT = stackrt(n,d,f); | n: Refractive index of each layer. Size can be |\r\n\r\n- Nlayers: isotropic and non-dispersive\r\n- Nlayers x Nfreq: isotropic and dispersive\r\n- Nlayers x 3: anisotropic and non-dispersive\r\n- Nlayers x Nfreq x 3: anisotropic and dispersive materials are involved.\\\r\n  NOTE: Only birefringence in z (nx=ny≠nz) is supported. The commands will give an error\r\n  unless nx=ny.\r\n- Nlayers x Nfreq x 9: anisotropic and dispersive materials are involved.\\\r\n  NOTE: We flatten the second-order refractive index tensor into an array. The third\r\n  dimension indicates the position in the tensor. For example, the position index \"1\",\r\n  \"2\", \"3\", \"4\" and \"5\" corresponds to n11, n21, n31, n12 and n22, respectively.\r\n\r\nd: Thickness of each layer. Size is Nlayers. f: Frequency vector with a length of\r\nNfreq.\\\r\nRT = stackrt(n,d,f,theta); | theta: Angle vector, in degrees. Optional.\r\n\r\nFor more information on the complex coefficients see\r\n[Stack optical solver overview](https://optics.ansys.com/hc/en-us/articles/360034914653).\r\n\r\n### Example 1: Five-layer stack with isotropic materials\r\n\r\nCalculate the reflection, transmission, and field distribution from a 5 layer stack.\r\n\r\n```\r\nf = linspace(c/400e-9, c/1000e-9,100); # frequency vector  \r\ntheta = 0:1:45; # angle vector  \r\nd = [0; 200e-9; 300e-9; 400e-9; 0]; # air/SiO2/Si/SiO2/air  \r\nnf = length(f);  \r\nnd = length(d);  \r\n  \r\n# refractive index of each layer (non-dispersive)  \r\nn1 = [1; 1.5; 2.5; 1.5; 1];   \r\n  \r\n# refractive index of each layer (dispersive)  \r\nn2 = matrix(nd,nf);  \r\nn2(1,1:nf) = 1; # air  \r\nn2(2,1:nf) = getfdtdindex(\"SiO2 (Glass) - Palik\",f,min(f),max(f));  \r\nn2(3,1:nf) = getfdtdindex(\"Si (Silicon) - Palik\",f,min(f),max(f));  \r\nn2(4,1:nf) = getfdtdindex(\"SiO2 (Glass) - Palik\",f,min(f),max(f));  \r\nn2(5,1:nf) = 1; # air  \r\n  \r\nRT1 = stackrt(n1,d,f); # non-dispersive index data, and theta=0  \r\nRT2 = stackrt(n2,d,f,theta); # dispersive data index data, and theta from 0 to 45 deg  \r\n  \r\nvisualize(RT1);  \r\nvisualize(RT2);  \r\n  \r\nplot(RT1.lambda*1e6,RT1.Rp,RT1.Rs,RT1.Tp,RT1.Ts,\"wavelength (um)\",\"Power\",\"non-disperisive, theta=0\");  \r\nlegend(\"Rp\",\"Rs\",\"Tp\",\"Ts\");  \r\nimage(RT2.lambda*1e6,RT2.theta,RT2.Rp,\"wavelength (um)\",\"theta (deg)\",\"Rp, dispersive example\");\r\n```\r\n\r\n### Example 2: Birefringent slab in air\r\n\r\n```\r\nN_layers = 3;  \r\nNfreqs = 100;  \r\nn = matrix(N_layers, Nfreqs, 3);  \r\n  \r\nn(1, :, :) = 1;   # air  \r\nn(2, :, 1) = 2.1; # nx  \r\nn(2, :, 2) = 2.1; # ny  \r\nn(2, :, 3) = 2.5; # nz  \r\nn(3, :, :) = 1;   # air  \r\n  \r\nd = [0; 1e-6; 0]; # air/ birefringent slab / air  \r\nf = linspace(c/1e-6, c/1.5e-6, Nfreqs);  \r\ntheta = 0:1:45;  \r\n  \r\nRT = stackrt(n,d,f,theta);  \r\n  \r\nvisualize(RT);\r\n```\r\n\r\n### Example 3: A fully anisotropic and dispersive slab in air\r\n\r\nDownload and run the attached script stackrt_anisotropic.lsf.\r\n\r\nPlease note that we use the Euler angle definition shown in lines 32-46 in the script\r\nfile to rotate a diagonalized permittivity matrix and then derive the refractive index\r\nmatrix.",
    "summary": "Calculates the reflection and transmission of a plane wave through a multi-layer stack using the ana...",
    "syntax": [
      {
        "syntax": "RT = stackrt(n,d,f);",
        "description": "n: Refractive index of each layer. Size can be"
      }
    ],
    "example": ""
  },
  {
    "name": "std",
    "description": "Returns the standard deviation of the all entries of the specified matrix. The standard deviation of a set of N numbers X = [x 1 ,...,x N ] is defined as",
    "usage": "std();",
    "category": "general",
    "markdown": "# std\r\n\r\nReturns the standard deviation of the all entries of the specified matrix. The standard\r\ndeviation of a set of N numbers X = [x 1 ,...,x N ] is defined as\r\n\r\n$$ \\\\sigma=\\\\sqrt{\\\\frac{1}{N} \\\\sum\\_{i=1}^{N}\\\\left(x\\_{i}-\\\\mu\\\\right)^{2}} $$\r\n\r\nwhere μ is the mean of X.\r\n\r\n| **Syntax**    | **Description**                                                      |\r\n| ------------- | -------------------------------------------------------------------- |\r\n| out = std(A); | Will return the standard deviation of matrix A, over all dimensions. |\r\n\r\n**Example**\r\n\r\nThese are some simple examples showing how to use this command.\r\n\r\n```\r\na =[1,2,3,4,5];\r\n?std(a);\r\nresult: \r\n1.41421 \r\nb =[1,2,3,4,5;5,4,3,2,1;1,4,2,5,8];\r\n?std(b);\r\n?sqrt(sum((b-mean(b))^2)/length(b)); # Compare with equivalent calculation using sum and mean\r\nresult: \r\n1.88562\r\nresult: \r\n1.88562  \r\nd = randmatrix(3,3,3);\r\n?d;\r\nresult(i,j,1):\r\n0.345988 0.84698 0.271889 \r\n0.471725 0.316874 0.982971 \r\n0.374981 0.456099 0.2978 \r\nresult(i,j,2):\r\n0.739189 0.761315 0.5009 \r\n0.567278 0.839442 0.890164 \r\n0.19599 0.397656 0.0274667 \r\nresult(i,j,3):\r\n0.994629 0.531327 0.626759 \r\n0.572588 0.194067 0.657613 \r\n0.0505081 0.843043 0.197851\r\n \r\n?std(d);\r\nresult: \r\n0.274514\r\n```",
    "summary": "Returns the standard deviation of the all entries of the specified matrix",
    "syntax": [
      {
        "syntax": "out = std(A);",
        "description": "Will return the standard deviation of matrix A, over all dimensions."
      }
    ],
    "example": "a =[1,2,3,4,5];\r\n?std(a);\r\nresult: \r\n1.41421 \r\nb =[1,2,3,4,5;5,4,3,2,1;1,4,2,5,8];\r\n?std(b);\r\n?sqrt(sum((b-mean(b))^2)/length(b)); # Compare with equivalent calculation using sum and mean\r\nresult: \r\n1.88562\r\nresult: \r\n1.88562  \r\nd = randmatrix(3,3,3);\r\n?d;\r\nresult(i,j,1):\r\n0.345988 0.84698 0.271889 \r\n0.471725 0.316874 0.982971 \r\n0.374981 0.456099 0.2978 \r\nresult(i,j,2):\r\n0.739189 0.761315 0.5009 \r\n0.567278 0.839442 0.890164 \r\n0.19599 0.397656 0.0274667 \r\nresult(i,j,3):\r\n0.994629 0.531327 0.626759 \r\n0.572588 0.194067 0.657613 \r\n0.0505081 0.843043 0.197851\r\n \r\n?std(d);\r\nresult: \r\n0.274514"
  },
  {
    "name": "stepimport",
    "description": "Adds a structure to the simulation environment with structure geometry loaded from specified [STEP or CAD file](https://optics.ansys.com/hc/en-us/articles/360034398374). This command is identical to [cadimport](https://optics.ansys.com/hc/en-us/articles/42995962396307-cadimport-Script-command).",
    "usage": "stepimport();",
    "category": "general",
    "markdown": "# stepimport\r\n\r\nAdds a structure to the simulation environment with structure geometry loaded from\r\nspecified [STEP or CAD file](https://optics.ansys.com/hc/en-us/articles/360034398374).\r\nThis command is identical to\r\n[cadimport](https://optics.ansys.com/hc/en-us/articles/42995962396307-cadimport-Script-command).\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                |\r\n| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| stepimport(\"filename\",scale_factor); | Add new structures from a specified CAD file. The list of supported file formats can be found in the Knowledge Base article on [CAD import](https://optics.ansys.com/hc/en-us/articles/360034398374). SCALE_FACTOR (optional): |\r\n\r\n- Allowed values are 3, 0, -3, -6, -9, corresponding to the options of the STEP import\r\n  dialog in Ansys Lumerical Multiphysics™. For example, the value -9 means that a STEP\r\n  file saved in meters will be read as if in nanometers. Structures will be imported as\r\n  \\\\(10^{-9}\\\\) times the actual size.\r\n\r\n- When 'scale_factor' is omitted, 'no scaling' is applied\r\n\r\n## This function does not return any data.<br /> Note: How to handle the \"Model size exceeds valid box\" error The geometry in the finite-element IDE cannot exceed a maximum size, a fixed number of length units. This error can be avoided by changing the solver to use a larger length unit, or by supplying a smaller 'scale_factor' argument.\r\n\r\n**Example**\r\n\r\nThe following script commands is used to create a 3D geometry based on the STEP file\r\nprovided in the Knowledge Base article on\r\n[CAD import](https://optics.ansys.com/hc/en-us/articles/360034398374).\r\n\r\n```\r\nfilename = \"stepimport.step\";  \r\nstepimport(filename);\r\n```\r\n\r\nThe following script commands is used to create a 3D geometry based on the SolidWork\r\nfile provided in the Knowledge Base article on CAD import, using a scaling factor of\r\n\\\\(10^{-6}\\\\).\r\n\r\n```\r\nfilename = \"Caliper.SLDPRT\";  \r\nstepimport(filename, -6);\r\n```",
    "summary": "Adds a structure to the simulation environment with structure geometry loaded from specified [STEP o...",
    "syntax": [
      {
        "syntax": "stepimport(\"filename\",scale_factor);",
        "description": "Add new structures from a specified CAD file. The list of supported file formats can be found in the Knowledge Base article on [CAD import](https://optics.ansys.com/hc/en-us/articles/360034398374). SCALE_FACTOR (optional):"
      }
    ],
    "example": "filename = \"stepimport.step\";  \r\nstepimport(filename);"
  },
  {
    "name": "stlimport",
    "description": "Adds a structure to the simulation environment with structure geometry loaded from specified STL file.",
    "usage": "stlimport();",
    "category": "general",
    "markdown": "# stlimport\r\n\r\nAdds a structure to the simulation environment with structure geometry loaded from\r\nspecified STL file.\r\n\r\n| **Syntax**                                                 | **Description**                                                                               |\r\n| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------- |\r\n| stlimport(filename,scalingFactor, vertexRadius,debugFlag); | Add a new structure from specified STL type CAD file. This function does not return any data. |\r\n\r\n| Parameter     |          | Default value | Type          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| ------------- | -------- | ------------- | ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| filename      | required |               | string        | Name of the STL CAD file.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\r\n| scalingFactor | optional | 1e-6          | number        | An STL file does not contain a unit. When imported to Lumerical's software, the unit is micron by default. To have the unit in nanometer, set scaling_factor 1e-9.                                                                                                                                                                                                                                                                                                                                                                                                                                        |\r\n| vertexRadius  | optional | 1e-12         | length (in m) | Vertices may be shared by multiple triangles so the same vertex may be loaded multiple times for different triangles. The vertexRadius is the minimum distance between two vertices so that they are considered to be distinct vertices.                                                                                                                                                                                                                                                                                                                                                                  |\r\n| debugFlag     | optional | false         | boolean       | If true, the following data will be printed to the script prompt: -Input Vertex Count (total number of vertices in the file) -Triangles (total number of triangles) -Filtered Vertices (number of unique vertices) -Vertex Collisions (Input Vertex Count minus Filtered Vertices) -Invalid Triangles -Expected Vertex Collisions If the number of invalid triangles is larger than 0, try adjusting the vertexRadius parameter and importing the object again. Note: If there are a large number of triangles in the STL file, the script function can take longer to run when debugFlag is set to true. |\r\n\r\n**Example**\r\n\r\nThe following script commands can be used to create a 3D geometry based on the .stl file\r\nprovided in this KB page:\r\n[ Import - STL ](https://optics.ansys.com/hc/en-us/articles/360034901953-Import-STL) .\r\n\r\n```\r\nfilename = \"stlimport_assembly.stl\";\r\nstlimport(filename);\r\nset(\"material\",\"Si (Silicon)\");\r\n```",
    "summary": "Adds a structure to the simulation environment with structure geometry loaded from specified STL fil...",
    "syntax": [
      {
        "syntax": "stlimport(filename,scalingFactor, vertexRadius,debugFlag);",
        "description": "Add a new structure from specified STL type CAD file. This function does not return any data."
      }
    ],
    "example": "filename = \"stlimport_assembly.stl\";\r\nstlimport(filename);\r\nset(\"material\",\"Si (Silicon)\");"
  },
  {
    "name": "str2num",
    "description": "Converts a string into a floating point number. Use the format script command to change the precision of the output.",
    "usage": "str2num();",
    "category": "general",
    "markdown": "# str2num\r\n\r\nConverts a string into a floating point number. Use the format script command to change\r\nthe precision of the output.\r\n\r\n| **Syntax**             | **Description**                |\r\n| ---------------------- | ------------------------------ |\r\n| out = str2num(string); | Converts string into a number. |\r\n\r\n**Example**\r\n\r\nConvert a string into a number.\r\n\r\n```\r\n?str2num(\"1+2\");\r\n3\r\n```\r\n\r\nCompare the output using almostequal .\r\n\r\n```\r\n?almostequal(str2num(\"1.5677\"), 1.5677);\r\nresult: \r\n1  \r\n```",
    "summary": "Converts a string into a floating point number",
    "syntax": [
      {
        "syntax": "out = str2num(string);",
        "description": "Converts string into a number."
      }
    ],
    "example": "?str2num(\"1+2\");\r\n3"
  },
  {
    "name": "struct",
    "description": "Creates a structure array. Any data type (such as matrix, string, dataset) can be added to structure arrays.",
    "usage": "struct();",
    "category": "general",
    "markdown": "# struct\r\n\r\nCreates a structure array. Any data type (such as matrix, string, dataset) can be added\r\nto structure arrays.\r\n\r\nSince Lumerical 2019b R4 version, users can also declare a structure array by using the\r\nbraces declaration method.\r\n\r\n| **Syntax**                                                            | **Description**                                       |\r\n| --------------------------------------------------------------------- | ----------------------------------------------------- |\r\n| a = {\"one\" : \"fish\", \"two\" : \"fish\", \"red\" : \"fish\", \"blue\" : \"fish\"} | Creates and initializes a structure array.            |\r\n| a = struct;                                                           | Creates an structure array.                           |\r\n| a.a = \"string\";                                                       | Adds a string field to the structure array.           |\r\n| a.b = matrix(5,5);                                                    | Adds a field of matrix of 5x5 to the structure array. |\r\n\r\n**Examples**\r\n\r\nA structure can be created and initialized quickly as follows:\r\n\r\n```\r\nC = {\"a\" : [1, 4, 9],  \r\n     \"b\" : \"a string\",  \r\n     \"d\" : matrix(5, 5),  \r\n     \"e\" : getresult(\"monitor\", \"T\")};\r\n```\r\n\r\nThe above structure array can also be declared more pedantically:\r\n\r\n```\r\nC = struct;  \r\nC.a = [1, 4, 9];   \r\nC.b = \"a string\";  \r\nC.d = matrix(5,5);   \r\nC.e = getresult(\"monitor\",\"T\");\r\n```\r\n\r\nBoth structure arrays are equivalent and will produce the same output:\r\n\r\n```\r\n?C;  \r\nStruct with fields:  \r\na  \r\nb  \r\nd  \r\ne  \r\n\r\n?C.a;  \r\nresult:   \r\n1 4 9   \r\n  \r\n?C.a(2);  \r\nresult:   \r\n4  \r\n\r\n?C.b;  \r\na string  \r\n\r\n?C.d;  \r\nresult:   \r\n0 0 0 0 0   \r\n0 0 0 0 0   \r\n0 0 0 0 0   \r\n0 0 0 0 0   \r\n0 0 0 0 0   \r\n\r\n?C.e;  \r\nT vs lambda/f\r\n```\r\n\r\nWhen two or more objects share the same parameters, a \"struct\" can be used for all of\r\nthem:\r\n\r\n```\r\n    addrect;  \r\n    props = struct;  \r\n    props.x = 1e-6;  \r\n    props.y = 2e-6;  \r\n    setnamed(\"rectangle\",props);  \r\n    addprofile;  \r\n    set(props);\r\n```\r\n\r\nIn the above example, both the geometry \"rectangle\" and the profile monitor have the\r\nsame x and y values, so the \"struct\" with given \"x,y\" can be applied to them in setnamed\r\nand/or set.\r\n\r\n\"struct\" can also be used to set the properties directly\r\n\r\n```\r\n addcircle( {\"name\":\"c1\",\"x\": 1e-6,\"y\": 2e-6,\"radius\":0.5e-6});  \r\n mystruct = {\"name\":\"c2\",\"x\":-1e-6,\"y\":-2e-6,\"radius\":0.5e-6};  \r\n addcircle(mystruct);\r\n```\r\n\r\nThe above scripts will create two circles \"c1\" and \"c2\" located in quadrants I and III\r\nwith the same radius.",
    "summary": "Creates a structure array",
    "syntax": [
      {
        "syntax": "a = {\"one\" : \"fish\", \"two\" : \"fish\", \"red\" : \"fish\", \"blue\" : \"fish\"}",
        "description": "Creates and initializes a structure array."
      },
      {
        "syntax": "a = struct;",
        "description": "Creates an structure array."
      },
      {
        "syntax": "a.a = \"string\";",
        "description": "Adds a string field to the structure array."
      },
      {
        "syntax": "a.b = matrix(5,5);",
        "description": "Adds a field of matrix of 5x5 to the structure array."
      }
    ],
    "example": ""
  },
  {
    "name": "substring",
    "description": "Extracts a substring from a string.",
    "usage": "substring();",
    "category": "general",
    "markdown": "# substring\r\n\r\nExtracts a substring from a string.\r\n\r\n| **Syntax**                 | **Description**                                                                                                                                                                                            |\r\n| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| s1 = substring(s,pos);     | Returns a substring of s, starting at position pos to the end of s. The position pos can be 1 to length(s).                                                                                                |\r\n| s1 = substring(s,pos,len); | Returns a substring of s, starting at position pos, with len characters. If len is -1 (or any value less than 0) it returns the substring at position pos to the end of s. The default value of len is -1. |\r\n\r\n**Example**\r\n\r\nThe following example shows the different ways to extract a substring from a string.\r\n\r\n```\r\n?substring(\"hello\",3);\r\nllo\r\n?substring(\"hello\",3,2);\r\nll  \r\n```",
    "summary": "Extracts a substring from a string",
    "syntax": [
      {
        "syntax": "s1 = substring(s,pos);",
        "description": "Returns a substring of s, starting at position pos to the end of s. The position pos can be 1 to length(s)."
      },
      {
        "syntax": "s1 = substring(s,pos,len);",
        "description": "Returns a substring of s, starting at position pos, with len characters. If len is -1 (or any value less than 0) it returns the substring at position pos to the end of s. The default value of len is -1."
      }
    ],
    "example": "?substring(\"hello\",3);\r\nllo\r\n?substring(\"hello\",3,2);\r\nll"
  },
  {
    "name": "sum",
    "description": "Returns the sum of elements in a matrix.",
    "usage": "sum();",
    "category": "general",
    "markdown": "# sum\r\n\r\nReturns the sum of elements in a matrix.\r\n\r\n| **Syntax**      | **Description**                                           |\r\n| --------------- | --------------------------------------------------------- |\r\n| out = sum(x);   | Sum of all the elements in matrix x, over all dimensions. |\r\n| out = sum(x,n); | Sum elements of x over the specified dimension n.         |\r\n\r\n**Example**\r\n\r\nThis example shows how you can sum all the elements of a matrix or just the elements\r\nover a specified dimension.\r\n\r\n```\r\n?a = [1,2;3,4]; # define a 2x2 matrix\r\nresult: \r\n1 2 \r\n3 4 \r\n?sum(a); # sum all elements\r\nresult: \r\n10\r\n?sum(a,2); # sum over the second dimension only\r\nresult: \r\n3 \r\n7  \r\n```",
    "summary": "Returns the sum of elements in a matrix",
    "syntax": [
      {
        "syntax": "out = sum(x);",
        "description": "Sum of all the elements in matrix x, over all dimensions."
      },
      {
        "syntax": "out = sum(x,n);",
        "description": "Sum elements of x over the specified dimension n."
      }
    ],
    "example": "?a = [1,2;3,4]; # define a 2x2 matrix\r\nresult: \r\n1 2 \r\n3 4 \r\n?sum(a); # sum all elements\r\nresult: \r\n10\r\n?sum(a,2); # sum over the second dimension only\r\nresult: \r\n3 \r\n7"
  },
  {
    "name": "svd",
    "description": "Returns a 3-cell array with the singular value decomposition of a matrix A. The command supports real and complex A.",
    "usage": "svd();",
    "category": "general",
    "markdown": "# svd\r\n\r\nReturns a 3-cell array with the singular value decomposition of a matrix A. The command\r\nsupports real and complex A.\r\n\r\n| **Syntax**          | **Description**                                                                                                                                                                                                                                                                                               |\r\n| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| [U,S,V\\*] = svd(A); | Returns a 3-cell array with the singular value decomposition of matrix A. S is a diagonal matrix of the same dimension as A, with non-negative diagonal elements in decreasing order. U and V\\* are unitary matrices (V\\* is the conjugate transpose of V). If M = svd(A), then A = mult( M{1}, M{2}, M{3} ). |\r\n\r\n**Example**\r\n\r\nFind the single value decomposition of a square matrix A and of a rectangular matrix B.\r\n\r\n```\r\nA = [ 1.5, 2,0; -2, 1.5,0; 0,0,1.2];\r\nM=svd(A);\r\n?U = M{1};\r\n?S = M{2};\r\n?V_ctranspose = M{3};\r\n?max(abs( mult(U,S,V_ctranspose)-A)); # this should be zero\r\nresult:\r\n-0.6 0.8 0 \r\n0.8 0.6 0 \r\n-0 -0 1 \r\nresult: \r\n2.5 0 0 \r\n0 2.5 0 \r\n0 0 1.2 \r\nresult: \r\n-1 -0 -0 \r\n0 1 -0 \r\n0 0 1 \r\nresult: \r\n2.22045e-016 \r\nB = [ 1.5, 2,0; -2, 1.5,0];\r\nM=svd(B);\r\n?U = M{1};\r\n?S = M{2};\r\n?V_ctranspose = M{3};\r\n?max(abs( mult(U,S,V_ctranspose)-B)); # this should be zero\r\nresult: \r\n-1  4.44089e-017  \r\n4.44089e-017  1  \r\nresult: \r\n2.5  0  0  \r\n0  2.5  0  \r\nresult: \r\n-0.6  -0.8  0  \r\n-0.8  0.6  0  \r\n0  0  1  \r\nresult: \r\n2.22045e-016  \r\n```",
    "summary": "Returns a 3-cell array with the singular value decomposition of a matrix A",
    "syntax": [
      {
        "syntax": "[U,S,V\\*] = svd(A);",
        "description": "Returns a 3-cell array with the singular value decomposition of matrix A. S is a diagonal matrix of the same dimension as A, with non-negative diagonal elements in decreasing order. U and V\\* are unitary matrices (V\\* is the conjugate transpose of V). If M = svd(A), then A = mult( M{1}, M{2}, M{3} )."
      }
    ],
    "example": "A = [ 1.5, 2,0; -2, 1.5,0; 0,0,1.2];\r\nM=svd(A);\r\n?U = M{1};\r\n?S = M{2};\r\n?V_ctranspose = M{3};\r\n?max(abs( mult(U,S,V_ctranspose)-A)); # this should be zero\r\nresult:\r\n-0.6 0.8 0 \r\n0.8 0.6 0 \r\n-0 -0 1 \r\nresult: \r\n2.5 0 0 \r\n0 2.5 0 \r\n0 0 1.2 \r\nresult: \r\n-1 -0 -0 \r\n0 1 -0 \r\n0 0 1 \r\nresult: \r\n2.22045e-016 \r\nB = [ 1.5, 2,0; -2, 1.5,0];\r\nM=svd(B);\r\n?U = M{1};\r\n?S = M{2};\r\n?V_ctranspose = M{3};\r\n?max(abs( mult(U,S,V_ctranspose)-B)); # this should be zero\r\nresult: \r\n-1  4.44089e-017  \r\n4.44089e-017  1  \r\nresult: \r\n2.5  0  0  \r\n0  2.5  0  \r\nresult: \r\n-0.6  -0.8  0  \r\n-0.8  0.6  0  \r\n0  0  1  \r\nresult: \r\n2.22045e-016"
  },
  {
    "name": "switchtodesign",
    "description": "Switches INTERCONNECT to DESIGN mode. The DESIGN mode allows you to add and modify circuit elements for a new simulation. Once a simulation is run, the solver goes into ANALYSIS mode and no elements can be added or modified. While in ANALYSIS mode, any command to modify or add elements will return error. You must switch to DESIGN mode for that. Note that any available results will be lost once the solver is switched back to DESIGN mode.",
    "usage": "switchtodesign();",
    "category": "general",
    "markdown": "# switchtodesign\r\n\r\nSwitches INTERCONNECT to DESIGN mode. The DESIGN mode allows you to add and modify\r\ncircuit elements for a new simulation. Once a simulation is run, the solver goes into\r\nANALYSIS mode and no elements can be added or modified. While in ANALYSIS mode, any\r\ncommand to modify or add elements will return error. You must switch to DESIGN mode for\r\nthat. Note that any available results will be lost once the solver is switched back to\r\nDESIGN mode.\r\n\r\n| **Syntax**      | **Description**                                                                             |\r\n| --------------- | ------------------------------------------------------------------------------------------- |\r\n| switchtodesign; | Switches INTERCONNECT from ANALYSIS to DESIGN mode. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will first run an INTERCONNECT simulation. The solver will\r\ngo to ANALYSIS mode. The \"switchtodesign\" command is then used to go to DESIGN mode so\r\nthat the simulation \"bitrate\" can be changed in the next line.\r\n\r\n```\r\nrun;\r\nswitchtodesign;\r\nsetnamed('::Root Element','bitrate',2e10);  # bit rate set to 20 Gbit/sec\r\n```",
    "summary": "Switches INTERCONNECT to DESIGN mode",
    "syntax": [
      {
        "syntax": "switchtodesign;",
        "description": "Switches INTERCONNECT from ANALYSIS to DESIGN mode. This function does not return any data."
      }
    ],
    "example": "run;\r\nswitchtodesign;\r\nsetnamed('::Root Element','bitrate',2e10);  # bit rate set to 20 Gbit/sec"
  },
  {
    "name": "switchtolayout",
    "description": "Switches the solver to LAYOUT mode. The LAYOUT mode allows you to add and modify simulation objects for a new simulation. Once a simulation is run, the solver goes into ANALYSIS mode and no simulation objects can be added or modified (Except for the \"Analysis\" tab of analysis groups). While in ANALYSIS mode, any commands to modify objects will return errors. You must switch to LAYOUT mode before modifying any objects. Note that any available results will be lost once the solver is switched back to LAYOUT mode.",
    "usage": "switchtolayout();",
    "category": "general",
    "markdown": "# switchtolayout\r\n\r\nSwitches the solver to LAYOUT mode. The LAYOUT mode allows you to add and modify\r\nsimulation objects for a new simulation. Once a simulation is run, the solver goes into\r\nANALYSIS mode and no simulation objects can be added or modified (Except for the\r\n\"Analysis\" tab of analysis groups). While in ANALYSIS mode, any commands to modify\r\nobjects will return errors. You must switch to LAYOUT mode before modifying any objects.\r\nNote that any available results will be lost once the solver is switched back to LAYOUT\r\nmode.\r\n\r\n| **Syntax**      | **Description**                                                                     |\r\n| --------------- | ----------------------------------------------------------------------------------- |\r\n| switchtolayout; | Switches to LAYOUT mode from ANALYSIS mode. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script commands will first run an FDTD simulation. The solver will go to\r\nANALYSIS mode. The \"switchtolayout\" command is then used to go to LAYOUT mode so that\r\nthe simulation temperature can be changed in the next line.\r\n\r\n```\r\nrun;\r\nswitchtolayout;\r\nsetnamed(\"FDTD\",\"simulation temperature\",400);   # simulation temp. set to 400 K\r\n```",
    "summary": "Switches the solver to LAYOUT mode",
    "syntax": [
      {
        "syntax": "switchtolayout;",
        "description": "Switches to LAYOUT mode from ANALYSIS mode. This function does not return any data."
      }
    ],
    "example": "run;\r\nswitchtolayout;\r\nsetnamed(\"FDTD\",\"simulation temperature\",400);   # simulation temp. set to 400 K"
  },
  {
    "name": "system",
    "description": "The system command allows you to have the operating system (OS) execute a command, rather than the Lumerical Script Prompt.",
    "usage": "system();",
    "category": "general",
    "markdown": "# system\r\n\r\nThe system command allows you to have the operating system (OS) execute a command,\r\nrather than the Lumerical Script Prompt.\r\n\r\n| **Syntax**         | **Description**                                                                      |\r\n| ------------------ | ------------------------------------------------------------------------------------ |\r\n| system(\"command\"); | Run \"command\" at the OS command prompt. The system command does not return any data. |\r\n\r\n**Note** : This command cannot be used while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Examples**\r\n\r\nOpens the text editor Notepad in windows.\r\n\r\n```\r\n system(\"notepad\");\r\n```\r\n\r\nThe following example demonstrates how the system command can be used to get the\r\ncomputer's date and time settings (wall-clock time), for example, to time stamp your\r\nfiles. It is necessary to run a system command because the Lumerical script language\r\ndoes not currently have a getDateAndTime scriptcommand. This example shows how to get\r\nthe time on a Windows machine, but it could easily be modified for other OS. The system\r\ncommand is used to save the current time from the system clock into a file. The read\r\ncommand is then used to read the time from the file.\r\n\r\n```\r\nfname=\"cur_time.txt\";    # file name to store current time  \r\n\r\ncmd=\"echo %time% >>\" + fname; # system command to get current time and write to fname   \r\n\r\nrm(fname);          # delete time file  \r\n\r\nsystem(cmd);         # run command to get time and save to file  \r\n\r\ncur_time=read(fname);     # read time from file  \r\n\r\n?cur_time;             # current time: Hr, Min, Sec \r\n```\r\n\r\nThis example shows how to start a new instance of the Lumerical GUI from a script file\r\non a Windows computer. For example, if you have multiple Lumerical products, you may\r\nfind it useful to have one product (eg. CHARGE) be able to start a second product (eg.\r\nFDTD). The following example will start a new instance of FDTD that runs the script file\r\nrunAnalysis.lsf.\r\n\r\nTwo variations of the command are provided. In the first, a new instance of FDTD\r\nSolution is started and will run the script file runAnalysis.lsf. When this is executed,\r\nthe initial instance of the GUI (the one running the system command) will be frozen\r\nwhile the new instance is running. The first instance will continue running once the\r\nsecond instance is closed. Tip: you should add an 'exit' command to the end of the\r\nrunAnalysis.lsf script so the new instance automatically closes when it reaches the end\r\nof the script.\r\n\r\nThe second variation allows the first instance of the GUI to continue running while the\r\nsecond instance is open.\r\n\r\n```\r\nsystem('\"\"C:\\Program files\\Lumerical\\[[verpath]]\\bin\\fdtd-solutions.exe\" -run \"C:\\temp\\runAnalysis.lsf\"\"');  \r\n\r\nsystem('start \"name\" /B \"C:\\Program files\\Lumerical\\[[verpath]]\\bin\\fdtd-solutions.exe\" -run \"C:\\temp\\runAnalysis.lsf\"');\r\n```\r\n\r\nThe following code can be used on Windows OS to launch an FDTD simulation from the\r\nterminal and then immediately close the graphical interface.\r\n\r\n```\r\n# specify command to run from the terminal  \r\n\r\nsave;  \r\n\r\nMPICMD = '\"C:\\Program Files\\Lumerical\\MPICH2\\mpiexec.exe\" -n 2';  \r\n\r\nengineCMD = '\"C:\\Program files\\Lumerical\\[[verpath]]\\bin\\fdtd-engine.exe\"';  \r\n\r\nsimulationCMD = '\"' + currentfilename + '\"';  \r\n\r\n?fullCMD = MPICMD + \" \" + engineCMD + \" \" + simulationCMD;  \r\n\r\n# run from terminal  \r\n\r\nsystem('start \"name\" /B ' + fullCMD);  \r\n\r\n# exit CAD  \r\n\r\nexit;\r\n```",
    "summary": "The system command allows you to have the operating system (OS) execute a command, rather than the L...",
    "syntax": [
      {
        "syntax": "system(\"command\");",
        "description": "Run \"command\" at the OS command prompt. The system command does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "tan",
    "description": "Calculates the trigonometric tangent function. Angle units are in radians. The function is defined for complex angles. Phase of a complex number is evaluated between - π and π .",
    "usage": "tan();",
    "category": "general",
    "markdown": "# tan\r\n\r\nCalculates the trigonometric tangent function. Angle units are in radians. The function\r\nis defined for complex angles. Phase of a complex number is evaluated between - π and π\r\n.\r\n\r\n| **Syntax**    | **Description**                   |\r\n| ------------- | --------------------------------- |\r\n| out = tan(x); | Returns the complex tangent of x. |\r\n\r\n**Example**\r\n\r\nCalculate tan( π /4 + i).\r\n\r\n```\r\ntheta=pi/4+1i;\r\n?tan(theta);\r\nresult: \r\n0.265802+0.964028i \r\n```",
    "summary": "Calculates the trigonometric tangent function",
    "syntax": [
      {
        "syntax": "out = tan(x);",
        "description": "Returns the complex tangent of x."
      }
    ],
    "example": "theta=pi/4+1i;\r\n?tan(theta);\r\nresult: \r\n0.265802+0.964028i"
  },
  {
    "name": "tecplotread",
    "description": "Imports data from Tecplot formatted file (text).",
    "usage": "tecplotread();",
    "category": "general",
    "markdown": "# tecplotread\r\n\r\nImports data from Tecplot formatted file (text).\r\n\r\n| **Syntax**                                               | **Description**                                       |\r\n| -------------------------------------------------------- | ----------------------------------------------------- |\r\n| ? tecplotread('filename.dat');                           | List all zones ( domains) in the data file.           |\r\n| ? tecplotread('filename.dat','zonename');                | List all of the data fields associated with the zone. |\r\n| out = tecplotread('filename.dat','zonename','dataname'); | Retrieve the data as an array                         |\r\n\r\n**Example**\r\n\r\nThe following example shows how the tecplotread command can be used to import data from\r\nthese files into CHARGE. Special field “FETriangle” represents the triangulation and X\r\nand Y coordinates of mesh are treated as node data. Names and units depend on original\r\ndata source but we must convert units to SI (m).\r\n\r\nThe first part of the tecplot_import_diode.lsf file reads the data from the\r\nexample_diode_tecplot.dat file. The following two lines in the script reads in the names\r\nof the zones and the data available in the zones of the tecplot file.\r\n\r\n```\r\nfilename = 'example_diode_tecplot.dat';  \r\nzonename = 'Silicon';  \r\n?\"Available zones: \" + tecplotread(filename);  \r\n?\"Data in zone \" + zonename + \": \" + tecplotread(filename,zonename);\r\n```\r\n\r\nThe next few lines read in the information about the finite element grid. Here t is the\r\nconnectivity matrix and x, y are the vertex matrices. Notice the coordinate data is\r\nconverted from units of micron to meter.\r\n\r\n```\r\nt = tecplotread(filename,zonename,'FETriangle');  \r\nx = 1e-6*tecplotread(filename,zonename,'X [um]'); # convert to SI from um to m  \r\ny = 1e-6*tecplotread(filename,zonename,'Y [um]'); # convert to SI, invert\r\n```\r\n\r\nThe following lines then read the doping data.\r\n\r\n```\r\nNA_name = 'NA [1/cm3]';  \r\nND_name = 'ND [1/cm3]';  \r\nNA = 1e6*tecplotread(filename,zonename,NA_name); # convert to SI (cm^-3 -- m^-3)  \r\nND = 1e6*tecplotread(filename,zonename,ND_name); # convert to SI (cm^-3 -- m^-3)\r\n```\r\n\r\nAfter reading the data, the code creates unstructured datasets for the doping data and\r\ncreates geometries and import doping objects. The same task can be performed using the\r\n[Dataset builder](https://optics.ansys.com/hc/en-us/articles/360034901713-Dataset-builder)\r\nin CHARGE once the data has been imported.",
    "summary": "Imports data from Tecplot formatted file (text)",
    "syntax": [
      {
        "syntax": "? tecplotread('filename.dat');",
        "description": "List all zones ( domains) in the data file."
      },
      {
        "syntax": "? tecplotread('filename.dat','zonename');",
        "description": "List all of the data fields associated with the zone."
      },
      {
        "syntax": "out = tecplotread('filename.dat','zonename','dataname');",
        "description": "Retrieve the data as an array"
      }
    ],
    "example": "filename = 'example_diode_tecplot.dat';  \r\nzonename = 'Silicon';  \r\n?\"Available zones: \" + tecplotread(filename);  \r\n?\"Data in zone \" + zonename + \": \" + tecplotread(filename,zonename);"
  },
  {
    "name": "toscript",
    "description": "Returns a string containing the equivalent script to generate a variable. This script function is particularly useful when debugging cells and structure variables.",
    "usage": "toscript();",
    "category": "general",
    "markdown": "# toscript\r\n\r\nReturns a string containing the equivalent script to generate a variable. This script\r\nfunction is particularly useful when debugging cells and structure variables.\r\n\r\n| **Syntax**                      | **Description**                                                                                                                                                                                                                                                                                            |\r\n| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=toscript(variable, expand); | Returns a string containing the equivalent script to generate ‘variable’. If ‘expand’ is true, matrix values will also be converted to script, regardless of their size – this can lead to large strings. To prevent the matrix values conversion set expand to ‘false’. The default for 'expand' is true. |\r\n\r\n**Example**\r\n\r\nCreate a cell of structure variables and find an equivalent script that generates the\r\nsame cell.\r\n\r\n```\r\nv=cell(2);\r\nv{1}=struct;\r\nv{1}.name='value 1';\r\nv{1}.value=matrix(4);\r\nv{1}.value(1)=1;\r\nv{1}.value(2)=2;\r\nv{1}.value(3)=3;\r\nv{1}.value(4)=4;\r\nv{2}=struct;\r\nv{2}.name='value 2';\r\nv{2}.value=matrix(4);\r\nv{2}.value(1)=5;\r\nv{2}.value(2)=6;\r\nv{2}.value(3)=7;\r\nv{2}.value(4)=8;\r\n?toscript(v,true);\r\nv=cell(2);\r\nv{1}=struct;\r\nv{1}.name='value 1';\r\nv{1}.value=matrix(4);\r\nv{1}.value(1)=1;\r\nv{1}.value(2)=2;\r\nv{1}.value(3)=3;\r\nv{1}.value(4)=4;\r\nv{2}=struct;\r\nv{2}.name='value 2';\r\nv{2}.value=matrix(4);\r\nv{2}.value(1)=5;\r\nv{2}.value(2)=6;\r\nv{2}.value(3)=7;\r\nv{2}.value(4)=8;\r\n?toscript(v,false); # do not include matrix values\r\nv=cell(2);\r\nv{1}=struct;\r\nv{1}.name='value 1';\r\nv{1}.value=matrix(4);\r\nv{2}=struct;\r\nv{2}.name='value 2';\r\nv{2}.value=matrix(4);\r\n```",
    "summary": "Returns a string containing the equivalent script to generate a variable",
    "syntax": [
      {
        "syntax": "out=toscript(variable, expand);",
        "description": "Returns a string containing the equivalent script to generate ‘variable’. If ‘expand’ is true, matrix values will also be converted to script, regardless of their size – this can lead to large strings. To prevent the matrix values conversion set expand to ‘false’. The default for 'expand' is true."
      }
    ],
    "example": "v=cell(2);\r\nv{1}=struct;\r\nv{1}.name='value 1';\r\nv{1}.value=matrix(4);\r\nv{1}.value(1)=1;\r\nv{1}.value(2)=2;\r\nv{1}.value(3)=3;\r\nv{1}.value(4)=4;\r\nv{2}=struct;\r\nv{2}.name='value 2';\r\nv{2}.value=matrix(4);\r\nv{2}.value(1)=5;\r\nv{2}.value(2)=6;\r\nv{2}.value(3)=7;\r\nv{2}.value(4)=8;\r\n?toscript(v,true);\r\nv=cell(2);\r\nv{1}=struct;\r\nv{1}.name='value 1';\r\nv{1}.value=matrix(4);\r\nv{1}.value(1)=1;\r\nv{1}.value(2)=2;\r\nv{1}.value(3)=3;\r\nv{1}.value(4)=4;\r\nv{2}=struct;\r\nv{2}.name='value 2';\r\nv{2}.value=matrix(4);\r\nv{2}.value(1)=5;\r\nv{2}.value(2)=6;\r\nv{2}.value(3)=7;\r\nv{2}.value(4)=8;\r\n?toscript(v,false); # do not include matrix values\r\nv=cell(2);\r\nv{1}=struct;\r\nv{1}.name='value 1';\r\nv{1}.value=matrix(4);\r\nv{2}=struct;\r\nv{2}.name='value 2';\r\nv{2}.value=matrix(4);"
  },
  {
    "name": "touchstoneload",
    "description": "Loads passive network data from a file containing Touchstone file formatted s-parameters. For more information about the Touchstone specification refer to [this page](https://helpfiles.keysight.com/csg/N1930xB/FilePrint/SnP_File_Format.htm).",
    "usage": "touchstoneload();",
    "category": "general",
    "markdown": "# touchstoneload\r\n\r\nLoads passive network data from a file containing Touchstone file formatted\r\ns-parameters. For more information about the Touchstone specification refer to\r\n[this page](https://helpfiles.keysight.com/csg/N1930xB/FilePrint/SnP_File_Format.htm).\r\n\r\n| **Syntax**                       | **Description**                                                                                                                                                                    |\r\n| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = touchstoneload (filename); | It returns a matrix where the first column contains the frequency values in Hz. S-parameters are returned using MA format, where M is the magnitude and A is the angle in radians. |\r\n\r\n### Example\r\n\r\nIn this simple example, an s2p formatted touchstone file is loaded.\r\n\r\n```\r\n#filename PA3-110.s2p\r\nout=touchstoneload('PA3-110.s2p');\r\n#display loaded values\r\n?out\r\nresult: \r\n2e+009 0.933287 -0.363001 0.01969 0.641089 0.000111993 1.32332 0.978723 -0.583973 \r\n3e+009 0.930915 -0.519211 0.0985939 0.0471047 0.000391381 -1.06654 0.950211 -0.84896 \r\n4e+009 0.930101 -0.670744 0.246948 -0.680015 0.000315715 1.6003 0.903597 -1.08584 \r\n5e+009 0.926808 -0.840421 0.716968 -2.01287 0.000155772 -0.796779 0.887657 -1.24546 \r\n6e+009 0.899653 -0.98587 0.426378 2.38857 0.00010399 -1.82364 0.914271 -1.43473 \r\n...\r\n```",
    "summary": "Loads passive network data from a file containing Touchstone file formatted s-parameters",
    "syntax": [
      {
        "syntax": "out = touchstoneload (filename);",
        "description": "It returns a matrix where the first column contains the frequency values in Hz. S-parameters are returned using MA format, where M is the magnitude and A is the angle in radians."
      }
    ],
    "example": ""
  },
  {
    "name": "transmission",
    "description": "Returns the amount of power transmitted through power monitors and profile monitors, normalized to the source power. A value of 0.3 means that 30% the optical power injected by the source passed through the monitor. Negative values mean the power is flowing in the negative direction.",
    "usage": "transmission();",
    "category": "general",
    "markdown": "# transmission\r\n\r\nReturns the amount of power transmitted through power monitors and profile monitors,\r\nnormalized to the source power. A value of 0.3 means that 30% the optical power injected\r\nby the source passed through the monitor. Negative values mean the power is flowing in\r\nthe negative direction.\r\n\r\nThe frequency domain power transmission is calculated with the following formula.\r\n\r\n$$ T(f) = \\\\frac{ \\\\frac{1}{2} \\\\int\\_{\\\\text{monitor}} \\\\mathbf{Re} (\\\\mathbf{P}(f))\r\n\\\\cdot d\\\\mathbf{S} }{\\\\text{ sourcepower(f)} } $$\r\n\r\nwhere\r\n\r\n\\\\(T(f)\\\\) is the normalized transmission as a function of frequency\r\n\r\n\\\\(\\\\mathbf{P}(f)\\\\) is the Poynting vector\r\n\r\n\\\\(d\\\\mathbf{S}\\\\) is the surface normal\r\n\r\nThe normalization state (cwnorm or nonorm) does not affect the result because of the\r\nsource power normalization.\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                                                                                                                                           |\r\n| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = transmission(\"mname\");         | Transmission through monitor mname. It must be obvious from the shape of the monitor which axis is normal to the monitor surface.                                                                                                                                                         |\r\n| out = transmission(\"mname\", option); | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n\r\n**Example**\r\n\r\nThis example shows how to plot the power transmission through a monitor.\r\n\r\n```\r\nm=\"x2\";    # monitor name  \r\nf=getdata(m,\"f\");  \r\nT=transmission(m);\r\nplot(c/f*1e6,T,\"wavelength(um)\",\"transmission\");  \r\n```",
    "summary": "Returns the amount of power transmitted through power monitors and profile monitors, normalized to t...",
    "syntax": [
      {
        "syntax": "out = transmission(\"mname\");",
        "description": "Transmission through monitor mname. It must be obvious from the shape of the monitor which axis is normal to the monitor surface."
      },
      {
        "syntax": "out = transmission(\"mname\", option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      }
    ],
    "example": "m=\"x2\";    # monitor name  \r\nf=getdata(m,\"f\");  \r\nT=transmission(m);\r\nplot(c/f*1e6,T,\"wavelength(um)\",\"transmission\");"
  },
  {
    "name": "transmission_avg",
    "description": "Returns the total spectral average power through a monitor surface, normalized to the total spectral average of the source. See the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "transmission_avg();",
    "category": "general",
    "markdown": "# transmission_avg\r\n\r\nReturns the total spectral average power through a monitor surface, normalized to the\r\ntotal spectral average of the source. See the Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\n$$ T\\_{avg}=\\\\frac{\\\\frac{1}{2} \\\\int real\\\\left(\\<P^{Monitor}>_{total}\\\\right) \\\\cdot\r\ndS}{sourcepower_{avg }} $$\r\n\r\nwhere\r\n\r\n\\\\(T\\_{avg}\\\\) is the normalized total spectral average transmission\r\n\r\n\\\\(P\\\\)is the total spectral average Poynting vector\r\n\r\n\\\\(dS\\\\) is the surface normal\r\n\r\nThe normalization state (cwnorm or nonorm) does not affect the result because of the\r\nsource power normalization.\r\n\r\n| **Syntax**                                      | **Description**                                                                                                                                                                                                                                                                           |\r\n| ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = transmission_avg (\"monitorname\");         | Returns the total spectral average transmission through monitorname. It must be obvious from the shape of the monitor which axis is normal to the monitor surface.                                                                                                                        |\r\n| out = transmission_avg (\"monitorname\", option); | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n\r\n**Example**\r\n\r\nPlease refer to [transmission](./transmission.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the total spectral average power through a monitor surface, normalized to the total spectral...",
    "syntax": [
      {
        "syntax": "out = transmission_avg (\"monitorname\");",
        "description": "Returns the total spectral average transmission through monitorname. It must be obvious from the shape of the monitor which axis is normal to the monitor surface."
      },
      {
        "syntax": "out = transmission_avg (\"monitorname\", option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      }
    ],
    "example": ""
  },
  {
    "name": "transmission_pavg",
    "description": "Returns the partial spectral average power through a monitor surface, normalized to the partial spectral average of the source. See the Units and normalization - [Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging) section for more information.",
    "usage": "transmission_pavg();",
    "category": "general",
    "markdown": "# transmission_pavg\r\n\r\nReturns the partial spectral average power through a monitor surface, normalized to the\r\npartial spectral average of the source. See the Units and normalization -\r\n[Spectral averaging](https://optics.ansys.com/hc/en-us/articles/360034394254-Spectral-averaging)\r\nsection for more information.\r\n\r\n$$ T\\_{pavg}(f) = \\\\frac{\\\\frac{1}{2} \\\\int real(_{partial}).dS}{sourcepower_{pavg}(f)}\r\n$$\r\n\r\nwhere\r\n\r\nTpavg is the normalized partial spectral average transmission\r\n\r\nis the partial spectral average Poynting vector\r\n\r\ndS is the surface normal\r\n\r\nThe normalization state (cwnorm or nonorm) does not affect the result because of the\r\nsource power normalization.\r\n\r\n| **Syntax**                                       | **Description**                                                                                                                                                                                                                                                                           |\r\n| ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = transmission_pavg (\"monitorname\");         | Returns the partial spectral average transmission through monitorname. It must be obvious from the shape of the monitor which axis is normal to the monitor surface.                                                                                                                      |\r\n| out = transmission_pavg (\"monitorname\", option); | The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2. |\r\n\r\n**Example**\r\n\r\nPlease refer to [transmission](./transmission.md) and\r\n[Spectral averaging - Usage](https://optics.ansys.com/hc/en-us/articles/360034383174-Spectral-averaging)",
    "summary": "Returns the partial spectral average power through a monitor surface, normalized to the partial spec...",
    "syntax": [
      {
        "syntax": "out = transmission_pavg (\"monitorname\");",
        "description": "Returns the partial spectral average transmission through monitorname. It must be obvious from the shape of the monitor which axis is normal to the monitor surface."
      },
      {
        "syntax": "out = transmission_pavg (\"monitorname\", option);",
        "description": "The additional argument, option, can have a value of 1 or 2. If it is 2, the data is unfolded where possible according to the symmetry or anti-symmetric boundaries if it comes from a monitor that intersect such a boundary at x min, y min or z min. The default value of option is 2."
      }
    ],
    "example": ""
  },
  {
    "name": "transpose",
    "description": "Transposes a 1D or 2D matrix.",
    "usage": "transpose();",
    "category": "general",
    "markdown": "# transpose\r\n\r\nTransposes a 1D or 2D matrix.\r\n\r\n| **Syntax**        | **Description**                                                                     |\r\n| ----------------- | ----------------------------------------------------------------------------------- |\r\n| y = transpose(x); | If x is an N x M matrix, then y will be M x N, where the entries are y(j,i)=x(i,j). |\r\n\r\n**Example**\r\n\r\nSimple example of how to transpose a 2D matrix.\r\n\r\n```\r\n?A = [1,2,3;4,5,6];\r\n?AT = transpose(A); # transpose of A\r\nresult:\r\n1  2  3  \r\n4  5  6  \r\nresult: \r\n1  4  \r\n2  5  \r\n3  6  \r\n```",
    "summary": "Transposes a 1D or 2D matrix",
    "syntax": [
      {
        "syntax": "y = transpose(x);",
        "description": "If x is an N x M matrix, then y will be M x N, where the entries are y(j,i)=x(i,j)."
      }
    ],
    "example": "?A = [1,2,3;4,5,6];\r\n?AT = transpose(A); # transpose of A\r\nresult:\r\n1  2  3  \r\n4  5  6  \r\nresult: \r\n1  4  \r\n2  5  \r\n3  6"
  },
  {
    "name": "try",
    "description": "Allows the execution of the script to continue even though an error occurs within a block.",
    "usage": "try();",
    "category": "general",
    "markdown": "# try\r\n\r\nAllows the execution of the script to continue even though an error occurs within a\r\nblock.\r\n\r\n| **Syntax**                                     | **Description**                                                                                                                |\r\n| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| try { Command1; Command2; ... }                | Runs the block of commands. If an error occurs, the error message is displayed and the script continues.                       |\r\n| try { Command1; Command2: ... } catch(errMsg); | Runs the block of commands. If an error occurs, the error message is stored in the variable \"errMsg\" and the script continues. |\r\n\r\n**Examples**\r\n\r\nAn error message will be displayed, but the script will continue:\r\n\r\n```\r\na=1;\r\ntry {\r\n ?C;\r\n}\r\n?a;\r\nError: prompt line 3: C is not a valid function or variable name\r\nResult:\r\n1\r\n```\r\n\r\nNo error message will be displayed, but it will be stored in the variable errMsg:\r\n\r\n```\r\na=1;\r\ntry {\r\n ?C;\r\n} catch(errMsg);\r\n?a;\r\n?errMsg;\r\nResult:\r\n1\r\nError: prompt line 3, C is not a valid function or variable name\r\n```",
    "summary": "Allows the execution of the script to continue even though an error occurs within a block",
    "syntax": [
      {
        "syntax": "try { Command1; Command2; ... }",
        "description": "Runs the block of commands. If an error occurs, the error message is displayed and the script continues."
      },
      {
        "syntax": "try { Command1; Command2: ... } catch(errMsg);",
        "description": "Runs the block of commands. If an error occurs, the error message is stored in the variable \"errMsg\" and the script continues."
      }
    ],
    "example": ""
  },
  {
    "name": "undo",
    "description": "Undos the last command that modified any objects, you can undo the last 5 commands.",
    "usage": "undo();",
    "category": "general",
    "markdown": "# undo\r\n\r\nUndos the last command that modified any objects, you can undo the last 5 commands.\r\n\r\n| **Syntax** | **Description**                                                          |\r\n| ---------- | ------------------------------------------------------------------------ |\r\n| undo;      | Undo last modify object command. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nIf you add some objects manually or type in commands in the prompt like this line by\r\nline\r\n\r\n```\r\naddplane;\r\naddrect;\r\naddring;\r\naddcircle;\r\naddpower;\r\naddfdtd;\r\n```\r\n\r\nthen type undo 5 times or more, it will only delete the last 5 objects.The first added\r\nplane wave source is kept.\r\n\r\nIf type redo 5 times or more, it will only recover the last 5 objects.",
    "summary": "Undos the last command that modified any objects, you can undo the last 5 commands",
    "syntax": [
      {
        "syntax": "undo;",
        "description": "Undo last modify object command. This function does not return any data."
      }
    ],
    "example": "addplane;\r\naddrect;\r\naddring;\r\naddcircle;\r\naddpower;\r\naddfdtd;"
  },
  {
    "name": "unfoldsymmetricdata",
    "description": "Unfolds data from a symmetric dataset based on a given plane of symmetry. This function is useful for obtaining the complete form of data from a symmetric simulation which only contains data from one half of the simulation. Only unstructured datasets are supported by this command.",
    "usage": "unfoldsymmetricdata();",
    "category": "general",
    "markdown": "# unfoldsymmetricdata\r\n\r\nUnfolds data from a symmetric dataset based on a given plane of symmetry. This function\r\nis useful for obtaining the complete form of data from a symmetric simulation which only\r\ncontains data from one half of the simulation. Only unstructured datasets are supported\r\nby this command.\r\n\r\n| **Syntax**                                     | **Description**                                                                                                                                                                                                                                                                                                                                                         |\r\n| ---------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| unfoldsymmetricdata(dataset,'symmetry_plane'); | Unfolds data from a symmetric dataset based on a given plane of symmetry. The first argument is a 2D or 3D unstructured dataset. The second argument is the plane of symmetry for the symmetric data in the format [+-][xyz], e.g. “-y” and refers to the axis of the plane of symmetry (i.e. the side of the simulation region that will act as the plane of symmetry) |\r\n\r\n**Examples**\r\n\r\nBelow is a simple example of unfolding an unstructured dataset generated from data\r\navailable in the\r\n[ unstructured_charge_example.mat ](https://lumerical.zendesk.com/hc/article_attachments/360046127893/unstructured_charge_example.mat)\r\nfile by assuming that the data is symmetric with respect to the \"+y\" plane.\r\n\r\n```\r\nmatlabload(\"unstructured_charge_example.mat\");\r\nx = charge.x;\r\ny = charge.y;\r\nz = charge.z;\r\nC = charge.elements;\r\ndata = unstructureddataset(\"test\",x,y,z,C);\r\ndata_unfolded=unfoldsymmetricdata(data,'+y');\r\n```",
    "summary": "Unfolds data from a symmetric dataset based on a given plane of symmetry",
    "syntax": [
      {
        "syntax": "unfoldsymmetricdata(dataset,'symmetry_plane');",
        "description": "Unfolds data from a symmetric dataset based on a given plane of symmetry. The first argument is a 2D or 3D unstructured dataset. The second argument is the plane of symmetry for the symmetric data in the format [+-][xyz], e.g. “-y” and refers to the axis of the plane of symmetry (i.e. the side of the simulation region that will act as the plane of symmetry)"
      }
    ],
    "example": ""
  },
  {
    "name": "uninstalldesignkit",
    "description": "Uninstalls a design kit file in the Design Kits folder.",
    "usage": "uninstalldesignkit();",
    "category": "general",
    "markdown": "# uninstalldesignkit\r\n\r\nUninstalls a design kit file in the Design Kits folder.\r\n\r\n| **Syntax**                               | **Description**                                                                                                                              |\r\n| ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| uninstalldesignkit(\"name\", [\"version\"]); | Uninstalls a design kit named 'name' with version 'version' in the Design Kits folder. \"version\" is optional and default is an empty string. |\r\n\r\n**Example**\r\n\r\n```\r\n# uninstalls a design kit folder \"LCML\" with version v1.1 from the Design Kits folder\r\nuninstalldesignkit(\"LCML\", \"v1.1\");\r\n```",
    "summary": "Uninstalls a design kit file in the Design Kits folder",
    "syntax": [
      {
        "syntax": "uninstalldesignkit(\"name\", [\"version\"]);",
        "description": "Uninstalls a design kit named 'name' with version 'version' in the Design Kits folder. \"version\" is optional and default is an empty string."
      }
    ],
    "example": "# uninstalls a design kit folder \"LCML\" with version v1.1 from the Design Kits folder\r\nuninstalldesignkit(\"LCML\", \"v1.1\");"
  },
  {
    "name": "unique",
    "description": "Returns an array containing all the unique values in a matrix. In other words, this command returns all the elements in a matrix without repeating them if they appear more than once in the matrix.",
    "usage": "unique();",
    "category": "general",
    "markdown": "# unique\r\n\r\nReturns an array containing all the unique values in a matrix. In other words, this\r\ncommand returns all the elements in a matrix without repeating them if they appear more\r\nthan once in the matrix.\r\n\r\n| **Syntax**     | **Description**                                                |\r\n| -------------- | -------------------------------------------------------------- |\r\n| out=unique(a); | Returns an array containing all unique values in the matrix a. |\r\n\r\n- This command is intended mainly for integer values.\r\n- It still works for floating-point numbers, but this is within the precision used\r\n  internally by the software so it might fail in cases where the difference between two\r\n  numbers is very small (see example below).\r\n\r\n**Example**\r\n\r\nDefine a matrix and display all the unique elements in the Script Prompt.\r\n\r\n```\r\nA = [1,2;2,3];  \r\n?unique(A);  \r\nresult:   \r\n1   \r\n2   \r\n3   \r\n  \r\nformat long; # set the precision to 16 digits  \r\nA= [2., 2.000000000000001; 3, 4.5];  \r\n?unique(A);  \r\nresult:   \r\n2.000000000000000   \r\n2.000000000000001   \r\n3.000000000000000   \r\n4.500000000000000   \r\n  \r\nformat short; # set the precision to 8 digits  \r\nB= [2., 2.0000000000000001; 3, 4.5];  \r\n?unique(B);  \r\nresult:   \r\n2   \r\n3   \r\n4.5 \r\n```",
    "summary": "Returns an array containing all the unique values in a matrix",
    "syntax": [
      {
        "syntax": "out=unique(a);",
        "description": "Returns an array containing all unique values in the matrix a."
      }
    ],
    "example": "A = [1,2;2,3];  \r\n?unique(A);  \r\nresult:   \r\n1   \r\n2   \r\n3   \r\n  \r\nformat long; # set the precision to 16 digits  \r\nA= [2., 2.000000000000001; 3, 4.5];  \r\n?unique(A);  \r\nresult:   \r\n2.000000000000000   \r\n2.000000000000001   \r\n3.000000000000000   \r\n4.500000000000000   \r\n  \r\nformat short; # set the precision to 8 digits  \r\nB= [2., 2.0000000000000001; 3, 4.5];  \r\n?unique(B);  \r\nresult:   \r\n2   \r\n3   \r\n4.5"
  },
  {
    "name": "uniquevertices",
    "description": "Given a matrix of vertices, returns a matrix of unique vertices with differences in values larger than a specified tolerance.",
    "usage": "uniquevertices();",
    "category": "general",
    "markdown": "# uniquevertices\r\n\r\nGiven a matrix of vertices, returns a matrix of unique vertices with differences in\r\nvalues larger than a specified tolerance.\r\n\r\n| **Syntax**                                     | **Description**                                                                                                                                                                     |\r\n| ---------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| out=uniquevertices(vertexTable, absTolerance); | Returns unique elements of a matrix with differences in values larger than a specified tolerance. vertexTable is a Mx2 or Mx3 matrix absTolerance is the magnitude of the tolerance |\r\n\r\n**Example**\r\n\r\nThis is a simple example showing how this command works.\r\n\r\n```\r\n# define a matrix with three vertices in 3D:\r\nvtx = [0,0,0; 1,0,0; 1,1,0; 1,1,0.09];\r\n?uniquevertices(vtx, 0.1); # for this tolerance the last two vertices are considered to be the same\r\n?uniquevertices(vtx, 0.01); # when the tolerance is decreased the last two vertices are distinguished\r\nresult: \r\n0  0  0  \r\n1  0  0  \r\n1  1  0  \r\nresult: \r\n0  0  0  \r\n1  0  0  \r\n1  1  0  \r\n1  1  0.09  \r\n```",
    "summary": "Given a matrix of vertices, returns a matrix of unique vertices with differences in values larger th...",
    "syntax": [
      {
        "syntax": "out=uniquevertices(vertexTable, absTolerance);",
        "description": "Returns unique elements of a matrix with differences in values larger than a specified tolerance. vertexTable is a Mx2 or Mx3 matrix absTolerance is the magnitude of the tolerance"
      }
    ],
    "example": "# define a matrix with three vertices in 3D:\r\nvtx = [0,0,0; 1,0,0; 1,1,0; 1,1,0.09];\r\n?uniquevertices(vtx, 0.1); # for this tolerance the last two vertices are considered to be the same\r\n?uniquevertices(vtx, 0.01); # when the tolerance is decreased the last two vertices are distinguished\r\nresult: \r\n0  0  0  \r\n1  0  0  \r\n1  1  0  \r\nresult: \r\n0  0  0  \r\n1  0  0  \r\n1  1  0  \r\n1  1  0.09"
  },
  {
    "name": "unselectall",
    "description": "Unselects all objects and groups. This is the counter operation of [ selectall ](./selectall.md) .",
    "usage": "unselectall();",
    "category": "general",
    "markdown": "# unselectall\r\n\r\nUnselects all objects and groups. This is the counter operation of\r\n[ selectall ](./selectall.md) .\r\n\r\n| **Syntax**   | **Description**                                                           |\r\n| ------------ | ------------------------------------------------------------------------- |\r\n| unselectall; | Unselects all objects and groups. This function does not return any data. |\r\n\r\n**Example**\r\n\r\nThe following script add two objects, select them and assign their x position. Unselect\r\nthem for other modifications .\r\n\r\n```\r\naddrect;\r\nset(\"name\",\"A1\");\r\naddring;\r\nset(\"name\",\"ring\");\r\nselectall;\r\nset(\"x\",-1e-6);\r\nunselectall;\r\n```",
    "summary": "Unselects all objects and groups",
    "syntax": [
      {
        "syntax": "unselectall;",
        "description": "Unselects all objects and groups. This function does not return any data."
      }
    ],
    "example": "addrect;\r\nset(\"name\",\"A1\");\r\naddring;\r\nset(\"name\",\"ring\");\r\nselectall;\r\nset(\"x\",-1e-6);\r\nunselectall;"
  },
  {
    "name": "unstructureddataset",
    "description": "Creates an empty dataset that is associated with arbitrary x/y/z coordinate in space, and with additional matrix, a connectivity matrix to connect them. The connectivity matrix comes after x, y, and z. Like rectilinear datasets, unstructured datasets can be parameterized, and can contain an arbitrary number of attributes (see [ addattribute) ](./addattribute.md) and parameters (see [ addparameter) ](./addparameter.md) .",
    "usage": "unstructureddataset();",
    "category": "general",
    "markdown": "# unstructureddataset\r\n\r\nCreates an empty dataset that is associated with arbitrary x/y/z coordinate in space,\r\nand with additional matrix, a connectivity matrix to connect them. The connectivity\r\nmatrix comes after x, y, and z. Like rectilinear datasets, unstructured datasets can be\r\nparameterized, and can contain an arbitrary number of attributes (see\r\n[ addattribute) ](./addattribute.md) and parameters (see\r\n[ addparameter) ](./addparameter.md) .\r\n\r\nSee\r\n[ Dataset introduction ](https://optics.ansys.com/hc/en-us/articles/360034409554-Datasets)\r\nfor more information. For datasets that are not associated with the x/y/z coordinates\r\n(ex. transmission as a function of frequency), see [ matrixdataset ](./matrixdataset.md)\r\n.\r\n\r\n| **Syntax**                    | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                         |\r\n| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| unstructureddataset(x,y,z,C); | Creates an empty unstructured dataset associated with the coordinates x/y/z and a connectivity matrix to connect them. Arguments 'x', 'y' and 'z' must be the same length; equivalent to the total number of points. The argument 'C' should be a matrix of integers where the number of rows equal to number of shapes in the mesh, the number of columns should be 2 (line segments), 3 (triangles) or 4 (tetrahedra), and values should be integers. |\r\n\r\n**Examples**\r\n\r\nBelow is a simple example of the usage of unstructured dataset. x, y and z vectors\r\nrepresent arbitrary points in space and C represent the connectivity matrix that\r\nconnects them. The values for the vectors can be loaded from the\r\n[ unstructured_charge_example.mat ](/hc/article_attachments/360046127873/unstructured_charge_example.mat)\r\nfile. It is possible to further script this process and import the data to an object,\r\neg, np density grid attribute, see the [ importdataset ](./importdataset.md) command.\r\n\r\n```\r\n# constructing an unstructured dataset\r\nmatlabload(\"unstructured_charge_example.mat\"); # taking the data from a CHARGE simulation. The data can be from a different source\r\nx = charge.x;\r\ny = charge.y;\r\nz = charge.z;\r\nC = charge.elements;\r\ndata = unstructureddataset(\"test\",x,y,z,C);\r\nV_cathode = charge.V_cathode;\r\nV_anode = charge.V_anode;\r\nn = pinch(charge.n);\r\np = pinch(charge.p);\r\ndata.addparameter(\"V_cathode\",V_cathode);\r\ndata.addparameter(\"V_anode\",V_anode);\r\ndata.addattribute(\"n\",n);\r\ndata.addattribute(\"p\",p);\r\nvisualize(data);\r\n```\r\n\r\nThis next example creates an unstructured dataset (with the name \"Absorption\") that\r\ncontains 2 data attributes: the power absorption Pabs, and the refractive index n. Both\r\nattributes are a function of the spatial parameters x/y/z and frequency f. Connectivity\r\nmatrix cm has also been specified. To allow the user to access the frequency parameter\r\nin terms of frequency or wavelength , both frequency (f) and wavelength (c/f) are added\r\nas interdependent parameters.\r\n\r\n```\r\nAbsorption = unstructureddataset(\"Absorption\",x,y,z,cm);\r\nAbsorption.addparameter(\"lambda\",c/f,\"f\",f);\r\nAbsorption.addattribute(\"Pabs\",Pabs);\r\nAbsorption.addattribute(\"refractive index\",n);\r\nvisualize(Absorption); # visualize this dataset in the Visualizer\r\n```\r\n\r\nThis example shows how to define an equilaterial triangle in the plane z=0\r\n\r\n```\r\nx = [0;1;2];\r\ny = [0;sqrt(3);0];\r\nz = [0;0;0];\r\nC = [1,3,2];\r\nds = unstructureddataset(x,y,z,C);\r\n```",
    "summary": "Creates an empty dataset that is associated with arbitrary x/y/z coordinate in space, and with addit...",
    "syntax": [
      {
        "syntax": "unstructureddataset(x,y,z,C);",
        "description": "Creates an empty unstructured dataset associated with the coordinates x/y/z and a connectivity matrix to connect them. Arguments 'x', 'y' and 'z' must be the same length; equivalent to the total number of points. The argument 'C' should be a matrix of integers where the number of rows equal to number of shapes in the mesh, the number of columns should be 2 (line segments), 3 (triangles) or 4 (tetrahedra), and values should be integers."
      }
    ],
    "example": ""
  },
  {
    "name": "unwrap",
    "description": "Removes changes of more than 2 π from a 1D array. It can be useful after angle(x) to see phase without discontinuities.",
    "usage": "unwrap();",
    "category": "general",
    "markdown": "# unwrap\r\n\r\nRemoves changes of more than 2 π from a 1D array. It can be useful after angle(x) to see\r\nphase without discontinuities.\r\n\r\nThe unwrap function is primarily intended for 1D arrays. Care must be taken when\r\napplying it to matrices with more than one dimension.\r\n\r\n| **Syntax**       | **Description**                                 |\r\n| ---------------- | ----------------------------------------------- |\r\n| out = unwrap(x); | Return the values of x without discontinuities. |\r\n\r\n**Example**\r\n\r\nApply the unwrap function to a 1D array.\r\n\r\n```\r\nvec=linspace(0,10,100);\r\nA=cos(vec) + sin(vec)*1i;\r\nB=angle(A);\r\nC=unwrap(B);\r\nplot(vec,real(A),B,C);\r\nlegend(\"cos(x)\",\"angle\", \"unwrap\");\r\n```\r\n\r\nThe following figure will be generated:\r\n\r\nApply the unwrap function to a 2D matrix. The unwrap function will treat the 2D matrix\r\nas a 1D vector (i.e. concatenate each row), meaning that the unwrapped phase of the 2nd\r\nrow will start at the phase of the end of the first row. Notice that the values in all 5\r\nrows of matrix D are identical, but after the unwrap function is applied, the lines are\r\n'stacked' on top of each other. This is because the unwrap treated the matrix as a large\r\n1D array, rather than treating each row independently.\r\n\r\n```\r\nvec=linspace(0,10,100);\r\nA=cos(vec) + sin(vec)*1i; # create complex sinusoid\r\nB=1:5;           # vector from 1:5\r\nC=meshgridx(A,B);     # 2D matrix with 5 copies of sinusoid\r\nD=angle(C);        # get angle of matrix \r\nimage(vec,B,D,\"vec\",\"5 copies\",\"angle\");  # image plot of matrix\r\nplot(vec,D,\"vec\",\"angle\");         # line plot (all 5 lines are identical)\r\nlegend(\"row 1\",\"row 2\",\"row 3\",\"row 4\",\"row 5\");\r\nplot(vec,unwrap(D),\"vec\",\"unwrap angle\"); # unwrap. Now lines are stacked\r\nlegend(\"row 1\",\"row 2\",\"row 3\",\"row 4\",\"row 5\");\r\n```\r\n\r\nTo apply the unwrap function to 2D phase data in 2D fashion (rather than treating it as\r\na single large 1D vector), see the following example. The unwrap function must be\r\napplied to one row at a time, then one column at a time.\r\n\r\nNote: A 2D unwrap operation is non-trivial. This example code works in some cases, but\r\nnot always. Please do some testing to determine if it works for your application.\r\n\r\n```\r\nx=linspace(-5,5,100); y=x;\r\nnx=length(x); ny=length(y);\r\ndata = exp( 1i* (meshgridx(x,y)+meshgridy(x,y)) );\r\nphase = angle(data); \r\nimage(x,y,phase,\"x\",\"y\",\"raw phase (rad)\");\r\n# unwrap over both dimensions \r\nfor (i=1:nx) {\r\n phase(i,1:ny) = unwrap( pinch(phase,1,i) );\r\n}\r\nfor (j=1:ny) {\r\n phase(1:nx,j) = unwrap( pinch(phase,2,j) );\r\n}\r\nimage(x,y,phase,\"x\",\"y\",\"unwrapped phase (rad)\"); \r\n```\r\n\r\n|\\\r\n\\---|---",
    "summary": "Removes changes of more than 2 π from a 1D array",
    "syntax": [
      {
        "syntax": "out = unwrap(x);",
        "description": "Return the values of x without discontinuities."
      }
    ],
    "example": "vec=linspace(0,10,100);\r\nA=cos(vec) + sin(vec)*1i;\r\nB=angle(A);\r\nC=unwrap(B);\r\nplot(vec,real(A),B,C);\r\nlegend(\"cos(x)\",\"angle\", \"unwrap\");"
  },
  {
    "name": "updatemodes",
    "description": "Updates the mode profile(s) of selected mode expansion monitor If there are no mode profiles stored in the mode expansion monitor, then the mode with the highest effective index will be selected. If mode profiles are already stored in the mode expansion monitor, then the modes with the best overlap with the old modes will be selected. Note that the mode expansion monitor must be selected before running this command.",
    "usage": "updatemodes();",
    "category": "general",
    "markdown": "# updatemodes\r\n\r\nUpdates the mode profile(s) of selected mode expansion monitor If there are no mode\r\nprofiles stored in the mode expansion monitor, then the mode with the highest effective\r\nindex will be selected. If mode profiles are already stored in the mode expansion\r\nmonitor, then the modes with the best overlap with the old modes will be selected. Note\r\nthat the mode expansion monitor must be selected before running this command.\r\n\r\n| **Syntax**                | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| updatemodes;              | Updates mode profile of the selected mode expansion monitor. Returns 1 if the update was successful and -1 if not.                                                                                                                                                                                                                                                                                                                                                       |\r\n| updatemodes(mode_number); | Updates the mode expansion monitor and selects the desired mode numbers. For example, updatemodes(1:10); will calculate the 10 modes with the highest refractive index. Please note that making this call will force a recalculation of a modes, even if the same modes have previously been calculated. In addition, making this call will force the mode selection method to become \"user select\". This optional argument was introduced in FDTD 8.6.3 and MODE 6.5.3. |\r\n\r\n## NOTE: Saving simulation files before using updatesourcemode If you have a script file which updates the simulation mesh, then you should use the [save script command](./save.md) before updating the source mode. This will ensure that the mesh has been updated before the new mode is calculated.\r\n\r\n## NOTE: overlap The fraction of electromagnetic fields that overlap between the two modes is given by the expression below. It is also the fraction of power from mode2 that can propagate in mode1. For more information, please see [overlap script command](./overlap.md). $$ \\\\text { overlap }=\\\\operatorname{Re}\\\\left\\[\\\\frac{\\\\left(\\\\int \\\\vec{E}_{1} \\\\times \\\\vec{H}_{2}^{*} \\\\cdot d \\\\vec{S}\\\\right)\\\\left(\\\\int \\\\vec{E}_{2} \\\\times \\\\vec{H}_{1}^{*} \\\\cdot d \\\\vec{S}\\\\right)}{\\\\int \\\\vec{E}_{1} \\\\times \\\\vec{H}_{1}^{*} \\\\cdot d \\\\vec{S}}\\\\right\\] \\\\frac{1}{\\\\operatorname{Re}\\\\left(\\\\int \\\\vec{E}_{2} \\\\times \\\\vec{H}_{2}^{*} \\\\cdot d \\\\vec{S}\\\\right)} $$\r\n\r\n**Example**\r\n\r\nSee the example in the [addmodeexpansion](./addmodeexpansion.md) script function",
    "summary": "Updates the mode profile(s) of selected mode expansion monitor If there are no mode profiles stored ...",
    "syntax": [
      {
        "syntax": "updatemodes;",
        "description": "Updates mode profile of the selected mode expansion monitor. Returns 1 if the update was successful and -1 if not."
      },
      {
        "syntax": "updatemodes(mode_number);",
        "description": "Updates the mode expansion monitor and selects the desired mode numbers. For example, updatemodes(1:10); will calculate the 10 modes with the highest refractive index. Please note that making this call will force a recalculation of a modes, even if the same modes have previously been calculated. In addition, making this call will force the mode selection method to become \"user select\". This optional argument was introduced in FDTD 8.6.3 and MODE 6.5.3."
      }
    ],
    "example": ""
  },
  {
    "name": "updateportmodes",
    "description": "Selects the specified modes in the selected port object in FDTD or MODE's EME solver, or updates already selected port modes. Modes are specified by the mode number in the eigensolver's mode list. For more information about the port object in FDTD see [ Ports ](https://optics.ansys.com/hc/en-us/articles/360034382554-Ports) .",
    "usage": "updateportmodes();",
    "category": "general",
    "markdown": "# updateportmodes\r\n\r\nSelects the specified modes in the selected port object in FDTD or MODE's EME solver, or\r\nupdates already selected port modes. Modes are specified by the mode number in the\r\neigensolver's mode list. For more information about the port object in FDTD see\r\n[ Ports ](https://optics.ansys.com/hc/en-us/articles/360034382554-Ports) .\r\n\r\n| **Syntax**                        | **Description**                                                                                                                                                          |\r\n| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| updateportmodes(modes_to_select); | Selects the specified modes in the the selected port object. This function returns 1 if modes were updated successfully and -1 if there was an error updating the modes. |\r\n| updateportmodes;                  | Updates the mode profiles of the selected mode ports.                                                                                                                    |\r\n\r\n**Examples**\r\n\r\nThe following demonstrates different possible syntax that can be used to specify the\r\nlist of modes to select.\r\n\r\n```\r\n# select the second mode\r\nupdateportmodes(2);\r\n# select the first 10 modes\r\nupdateportmodes(1:10);\r\n# select modes 1, 2, 3, 9. Note that the first mode specified in the \r\n# list will be used as the default source mode if the port is \r\n# selected as the source port.\r\nupdateportmodes([2,1,3,9]);\r\n# update already selected modes\r\nupdateportmodes;\r\n```\r\n\r\nThe following script adds a FDTD simulation region and port, then sets the name of the\r\nport, and selects the port modes and source mode.\r\n\r\n```\r\n# add objects\r\naddfdtd; # add FDTD simulation region\r\naddport; # add port\r\n# set up port\r\nset(\"name\",\"input_port\"); # set the name of the port\r\nseteigensolver(\"bent waveguide\",true); # set the solver to look for modes of a bent waveguide\r\nseteigensolver(\"bend radius\",10e-6); # set bending radius to 10 um\r\nupdateportmodes(1:2); # select the first 2 modes of the port\r\n# select the second mode of the port to be the source mode\r\nselect(\"FDTD::ports\"); # select the port group\r\nset(\"source port\",\"input_port\");\r\nset(\"source mode\",\"mode 2\");\r\n```",
    "summary": "Selects the specified modes in the selected port object in FDTD or MODE's EME solver, or updates alr...",
    "syntax": [
      {
        "syntax": "updateportmodes(modes_to_select);",
        "description": "Selects the specified modes in the the selected port object. This function returns 1 if modes were updated successfully and -1 if there was an error updating the modes."
      },
      {
        "syntax": "updateportmodes;",
        "description": "Updates the mode profiles of the selected mode ports."
      }
    ],
    "example": ""
  },
  {
    "name": "updatesourcemode",
    "description": "Updates the mode profile of selected mode source. If there is no mode profile stored in the source, then the mode with the highest effective index will be selected. If a mode is already stored in the source, then the mode with the best overlap with the old mode will be selected. Note that the mode source must be selected before running this command.",
    "usage": "updatesourcemode();",
    "category": "general",
    "markdown": "# updatesourcemode\r\n\r\nUpdates the mode profile of selected mode source. If there is no mode profile stored in\r\nthe source, then the mode with the highest effective index will be selected. If a mode\r\nis already stored in the source, then the mode with the best overlap with the old mode\r\nwill be selected. Note that the mode source must be selected before running this\r\ncommand.\r\n\r\n| **Syntax**                                                                                                                                                                                                                                                                                            | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ?updatesourcemode;                                                                                                                                                                                                                                                                                    | Updates mode profile of the selected Mode source. Returns the fraction of electromagnetic fields that overlap between the old and the new mode                                                                                                                                                                                                                                                                                    |\r\n| ?updatesourcemode(mode_number);                                                                                                                                                                                                                                                                       | Updates the mode source and selects the desired mode number. For example, updatesourcemode(1); will calculate the fundamental mode. Please note that making this call will force a recalculation of a mode, even if the same mode has previously been calculated. In addition, making this call will force the mode selection method to become \"user select\". This optional argument was introduced in FDTD 8.6.3 and MODE 6.5.3. |\r\n| NOTE: Saving simulation files before using updatesourcemode If you have a script file which updates the simulation mesh, then you should use the [save script command](./save.md) before updating the source mode. This will ensure that the mesh has been updated before the new mode is calculated. |                                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n\r\n______________________________________________________________________\r\n\r\n## NOTE: overlap The fraction of electromagnetic fields that overlap between the two modes is given by the expression below. It is also the fraction of power from mode2 that can propagate in mode1. For more information, please see [overlap script command](./overlap.md). $$ \\\\text { overlap }=\\\\operatorname{Re}\\\\left\\[\\\\frac{\\\\left(\\\\int \\\\vec{E}_{1} \\\\times \\\\vec{H}_{2}^{*} \\\\cdot d \\\\vec{S}\\\\right)\\\\left(\\\\int \\\\vec{E}_{2} \\\\times \\\\vec{H}_{1}^{*} \\\\cdot d \\\\vec{S}\\\\right)}{\\\\int \\\\vec{E}_{1} \\\\times \\\\vec{H}_{1}^{*} \\\\cdot d \\\\vec{S}}\\\\right\\] \\\\frac{1}{\\\\operatorname{Re}\\\\left(\\\\int \\\\vec{E}_{2} \\\\times \\\\vec{H}_{2}^{*} \\\\cdot d \\\\vec{S}\\\\right)} $$\r\n\r\n**Example**\r\n\r\nSelect the source, then update the mode profile. Once the mode profile has been updated,\r\noutput the mode effective index and visualize the mode field profile.\r\n\r\n```\r\n# update the source mode profile  \r\nselect(\"source\");  \r\nupdatesourcemode;  \r\n\r\n# get the mode profile and effective index  \r\nn=getresult(\"source\",\"neff\");  \r\n?\"Effective index = \" + num2str(n.neff);  \r\nfield=getresult(\"source\",\"mode profiles\");  \r\n  \r\nvisualize(field);\r\n```",
    "summary": "Updates the mode profile of selected mode source",
    "syntax": [
      {
        "syntax": "?updatesourcemode;",
        "description": "Updates mode profile of the selected Mode source. Returns the fraction of electromagnetic fields that overlap between the old and the new mode"
      },
      {
        "syntax": "?updatesourcemode(mode_number);",
        "description": "Updates the mode source and selects the desired mode number. For example, updatesourcemode(1); will calculate the fundamental mode. Please note that making this call will force a recalculation of a mode, even if the same mode has previously been calculated. In addition, making this call will force the mode selection method to become \"user select\". This optional argument was introduced in FDTD 8.6.3 and MODE 6.5.3."
      }
    ],
    "example": "# update the source mode profile  \r\nselect(\"source\");  \r\nupdatesourcemode;  \r\n\r\n# get the mode profile and effective index  \r\nn=getresult(\"source\",\"neff\");  \r\n?\"Effective index = \" + num2str(n.neff);  \r\nfield=getresult(\"source\",\"mode profiles\");  \r\n  \r\nvisualize(field);"
  },
  {
    "name": "upper",
    "description": "Converts all the characters in a string to upper case.",
    "usage": "upper();",
    "category": "general",
    "markdown": "# upper\r\n\r\nConverts all the characters in a string to upper case.\r\n\r\n| **Syntax**     | **Description**                  |\r\n| -------------- | -------------------------------- |\r\n| upper(string); | Converts a string to upper case. |\r\n\r\n**Example**\r\n\r\nUse upper case for all the characters in a string.\r\n\r\n```\r\n?upper(\"name\");\r\nNAME\r\n```",
    "summary": "Converts all the characters in a string to upper case",
    "syntax": [
      {
        "syntax": "upper(string);",
        "description": "Converts a string to upper case."
      }
    ],
    "example": "?upper(\"name\");\r\nNAME"
  },
  {
    "name": "validate",
    "description": "Updates the results for the specified analyzer.",
    "usage": "validate();",
    "category": "general",
    "markdown": "# validate\r\n\r\nUpdates the results for the specified analyzer.\r\n\r\n| **Syntax**            | **Description**                                                                                                       |\r\n| --------------------- | --------------------------------------------------------------------------------------------------------------------- |\r\n| validate(\"analyzer\"); | Updates the results for the specified \"analyzer\". If the name is not provided, the selected analyzer will be updated. |\r\n\r\n**Example**\r\n\r\n```\r\naddelement(\"Optical Network Analyzer\");  \r\nvalidate(\"ONA_1\");\r\n```",
    "summary": "Updates the results for the specified analyzer",
    "syntax": [
      {
        "syntax": "validate(\"analyzer\");",
        "description": "Updates the results for the specified \"analyzer\". If the name is not provided, the selected analyzer will be updated."
      }
    ],
    "example": "addelement(\"Optical Network Analyzer\");  \r\nvalidate(\"ONA_1\");"
  },
  {
    "name": "validateall",
    "description": "Updates the results for all the analyzers in the current simulation.",
    "usage": "validateall();",
    "category": "general",
    "markdown": "# validateall\r\n\r\nUpdates the results for all the analyzers in the current simulation.\r\n\r\n| **Syntax**   | **Description**                                                      |\r\n| ------------ | -------------------------------------------------------------------- |\r\n| validateall; | Updates the results for all the analyzers in the current simulation. |\r\n| **Example**  |                                                                      |\r\n\r\n```\r\nvalidateall;\r\n```",
    "summary": "Updates the results for all the analyzers in the current simulation",
    "syntax": [
      {
        "syntax": "validateall;",
        "description": "Updates the results for all the analyzers in the current simulation."
      }
    ],
    "example": ""
  },
  {
    "name": "var",
    "description": "Returns the variance of all entries of the matrix specified. The variance of a set of N numbers X = [x 1 ,...,x N ] is defined as",
    "usage": "var();",
    "category": "general",
    "markdown": "# var\r\n\r\nReturns the variance of all entries of the matrix specified. The variance of a set of N\r\nnumbers X = [x 1 ,...,x N ] is defined as\r\n\r\n$$ \\\\text{var}=\\\\frac{1}{N}\\\\sum\\_{i=1}^N(x_i-\\\\mu)^2 $$\r\n\r\nwhere μ is the mean of X.\r\n\r\n| **Syntax**    | **Description**                                               |\r\n| ------------- | ------------------------------------------------------------- |\r\n| out = var(A); | Will return variance of all of matrix A, over all dimensions. |\r\n\r\n**Example**\r\n\r\nThese are some simple examples showing how to use this command.\r\n\r\n```\r\na =[1,2,3,4,5];\r\n?var(a);\r\nresult: \r\n2 \r\nb =[1,2,3,4,5; 5,4,3,2,1; 1,4,2,5,8];\r\n?var(b);\r\n?sum((b-mean(b))^2)/length(b); # Compare with equivalent calculation using sum and mean\r\nresult: \r\n3.55556\r\nresult: \r\n3.55556 \r\nd = randmatrix(3,3,3);\r\n?d;\r\nresult(i,j,1):\r\n0.345988 0.84698 0.271889 \r\n0.471725 0.316874 0.982971 \r\n0.374981 0.456099 0.2978 \r\nresult(i,j,2):\r\n0.739189 0.761315 0.5009 \r\n0.567278 0.839442 0.890164 \r\n0.19599 0.397656 0.0274667 \r\nresult(i,j,3):\r\n0.994629 0.531327 0.626759 \r\n0.572588 0.194067 0.657613 \r\n0.0505081 0.843043 0.197851 \r\n?var(d);\r\nresult: \r\n0.0753581\r\n```",
    "summary": "Returns the variance of all entries of the matrix specified",
    "syntax": [
      {
        "syntax": "out = var(A);",
        "description": "Will return variance of all of matrix A, over all dimensions."
      }
    ],
    "example": "a =[1,2,3,4,5];\r\n?var(a);\r\nresult: \r\n2 \r\nb =[1,2,3,4,5; 5,4,3,2,1; 1,4,2,5,8];\r\n?var(b);\r\n?sum((b-mean(b))^2)/length(b); # Compare with equivalent calculation using sum and mean\r\nresult: \r\n3.55556\r\nresult: \r\n3.55556 \r\nd = randmatrix(3,3,3);\r\n?d;\r\nresult(i,j,1):\r\n0.345988 0.84698 0.271889 \r\n0.471725 0.316874 0.982971 \r\n0.374981 0.456099 0.2978 \r\nresult(i,j,2):\r\n0.739189 0.761315 0.5009 \r\n0.567278 0.839442 0.890164 \r\n0.19599 0.397656 0.0274667 \r\nresult(i,j,3):\r\n0.994629 0.531327 0.626759 \r\n0.572588 0.194067 0.657613 \r\n0.0505081 0.843043 0.197851 \r\n?var(d);\r\nresult: \r\n0.0753581"
  },
  {
    "name": "vectorplot",
    "description": "Creates a vector plot from a rectilinear dataset. The rectilinear dataset must be a vector, like the E field, and it must have no additional parameters (i.e., if you have E vs. x,y,z,f and f has two or more values, then the command fails). Generally, it is easier to use visualize(E) and then select the vector plot option in the [visualizer](https://optics.ansys.com/hc/en-us/articles/360037222234).",
    "usage": "vectorplot();",
    "category": "general",
    "markdown": "# vectorplot\r\n\r\nCreates a vector plot from a rectilinear dataset. The rectilinear dataset must be a\r\nvector, like the E field, and it must have no additional parameters (i.e., if you have E\r\nvs. x,y,z,f and f has two or more values, then the command fails). Generally, it is\r\neasier to use visualize(E) and then select the vector plot option in the\r\n[visualizer](https://optics.ansys.com/hc/en-us/articles/360037222234).\r\n\r\n| **Syntax**     | **Description**                      |\r\n| -------------- | ------------------------------------ |\r\n| vectorplot(E); | Creates a vector plot of the dataset |\r\n\r\n**Example**\r\n\r\nThis example will generate a vector plot of the dataset E.\r\n\r\n```\r\nx = linspace(-1,1,10);\r\ny = x;\r\nz = x;\r\nX = meshgrid3dx(x,y,z);\r\nY = meshgrid3dy(x,y,z);\r\nZ = meshgrid3dz(x,y,z);\r\nEx = exp( -X^2-Y^2-Z^2);\r\nEy = 0*Ex;\r\nEz = 0*Ex;\r\nE = rectilineardataset(\"E\",x,y,z);\r\nE.addattribute(\"E\",Ex,Ey,Ez);\r\nvectorplot(E);\r\n```\r\n\r\nThe following figure shows the output of the the example code.",
    "summary": "Creates a vector plot from a rectilinear dataset",
    "syntax": [
      {
        "syntax": "vectorplot(E);",
        "description": "Creates a vector plot of the dataset"
      }
    ],
    "example": "x = linspace(-1,1,10);\r\ny = x;\r\nz = x;\r\nX = meshgrid3dx(x,y,z);\r\nY = meshgrid3dy(x,y,z);\r\nZ = meshgrid3dz(x,y,z);\r\nEx = exp( -X^2-Y^2-Z^2);\r\nEy = 0*Ex;\r\nEz = 0*Ex;\r\nE = rectilineardataset(\"E\",x,y,z);\r\nE.addattribute(\"E\",Ex,Ey,Ez);\r\nvectorplot(E);"
  },
  {
    "name": "version",
    "description": "Returns the current version of the application.",
    "usage": "version();",
    "category": "general",
    "markdown": "# version\r\n\r\nReturns the current version of the application.\r\n\r\n| **Syntax**     | **Description**                         |\r\n| -------------- | --------------------------------------- |\r\n| out = version; | Returns the version of the application. |",
    "summary": "Returns the current version of the application",
    "syntax": [
      {
        "syntax": "out = version;",
        "description": "Returns the version of the application."
      }
    ],
    "example": ""
  },
  {
    "name": "versionfile",
    "description": "Returns the current version of the file loaded by the application.",
    "usage": "versionfile();",
    "category": "general",
    "markdown": "# versionfile\r\n\r\nReturns the current version of the file loaded by the application.\r\n\r\n| **Syntax**         | **Description**                                            |\r\n| ------------------ | ---------------------------------------------------------- |\r\n| out = versionfile; | Returns the version of the file loaded by the application. |",
    "summary": "Returns the current version of the file loaded by the application",
    "syntax": [
      {
        "syntax": "out = versionfile;",
        "description": "Returns the version of the file loaded by the application."
      }
    ],
    "example": ""
  },
  {
    "name": "visualize",
    "description": "Sends data to the [visualizer](https://optics.ansys.com/hc/en-us/articles/360037222234).",
    "usage": "visualize();",
    "category": "general",
    "markdown": "# visualize\r\n\r\nSends data to the [visualizer](https://optics.ansys.com/hc/en-us/articles/360037222234).\r\n\r\nFor FDTD, MODE, DGTD, FEEM, CHARGE, HEAT, and INTERCONNECT\r\n\r\n| **Syntax**      | **Description**                        |\r\n| --------------- | -------------------------------------- |\r\n| visualize(R);   | Plots the dataset R in the Visualizer. |\r\n| visualize(R,T); | Sends two datasets to the Visualizer.  |\r\n\r\n**Example**\r\n\r\nThis example creates a 3D dataset of random numbers and plots it in the visualizer. An\r\nadditional dataset is created and added to the visualizer using add2visualizer.\r\n\r\n```\r\nnPts=10;\r\naxis=1:nPts;\r\ndata=randmatrix(nPts,nPts,nPts);\r\ndataset = rectilineardataset(\"dataset\",axis,axis,axis);\r\ndataset.addattribute(\"data\",data);\r\nvisualize(dataset);\r\ndataset2 = rectilineardataset(\"dataset2\",axis,axis,axis);\r\ndataset2.addattribute(\"data\",data+10);\r\nadd2visualizer(dataset2, 1);\r\n```",
    "summary": "Sends data to the [visualizer](https://optics",
    "syntax": [
      {
        "syntax": "visualize(R);",
        "description": "Plots the dataset R in the Visualizer."
      },
      {
        "syntax": "visualize(R,T);",
        "description": "Sends two datasets to the Visualizer."
      }
    ],
    "example": "nPts=10;\r\naxis=1:nPts;\r\ndata=randmatrix(nPts,nPts,nPts);\r\ndataset = rectilineardataset(\"dataset\",axis,axis,axis);\r\ndataset.addattribute(\"data\",data);\r\nvisualize(dataset);\r\ndataset2 = rectilineardataset(\"dataset2\",axis,axis,axis);\r\ndataset2.addattribute(\"data\",data+10);\r\nadd2visualizer(dataset2, 1);"
  },
  {
    "name": "vtksave",
    "description": "Saves a Lumerical dataset into the VTK format. The command only saves rectilinear and unstructured datasets. The “filename” will have .vtr appended for rectilinear dataset, .vtu appended for unstructured dataset. The freely available data visualization program Paraview can then be used to create sophisticated plots of your data.",
    "usage": "vtksave();",
    "category": "general",
    "markdown": "# vtksave\r\n\r\nSaves a Lumerical dataset into the VTK format. The command only saves rectilinear and\r\nunstructured datasets. The “filename” will have .vtr appended for rectilinear dataset,\r\n.vtu appended for unstructured dataset. The freely available data visualization program\r\nParaview can then be used to create sophisticated plots of your data.\r\n\r\n| **Syntax**                    | **Description**                                     |\r\n| ----------------------------- | --------------------------------------------------- |\r\n| vtksave(“filename”, dataset); | Save the dataset in vtk file of the name specified. |\r\n\r\n**Examples**\r\n\r\nThe following simple example gets the result E, a rectilinear dataset and saves into the\r\nVTK format.\r\n\r\n```\r\nE = getresult(\"monitor2\", \"E\");\r\nvtksave(\"beam.vtr\", E);\r\n```",
    "summary": "Saves a Lumerical dataset into the VTK format",
    "syntax": [
      {
        "syntax": "vtksave(“filename”, dataset);",
        "description": "Save the dataset in vtk file of the name specified."
      }
    ],
    "example": ""
  },
  {
    "name": "waituntildone",
    "description": "This function only returns after the current simulation is done.",
    "usage": "waituntildone();",
    "category": "general",
    "markdown": "# waituntildone\r\n\r\nThis function only returns after the current simulation is done.\r\n\r\n| **Syntax**     | **Description**                                                                                                                                                                |\r\n| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| waituntildone; | This function only returns after the current simulation is done. It allows to wait for the simulation before performing any other tasks that depends on simulation completion. |",
    "summary": "This function only returns after the current simulation is done",
    "syntax": [
      {
        "syntax": "waituntildone;",
        "description": "This function only returns after the current simulation is done. It allows to wait for the simulation before performing any other tasks that depends on simulation completion."
      }
    ],
    "example": ""
  },
  {
    "name": "which",
    "description": "Returns the full file pathname for the specified file.",
    "usage": "which();",
    "category": "general",
    "markdown": "# which\r\n\r\nReturns the full file pathname for the specified file.\r\n\r\nThis function can be helpful when you have added several directories to the Lumerical\r\npath variable and you want to check which files are being accessed.\r\n\r\n| **Syntax**               | **Description**                                                                                                       |\r\n| ------------------------ | --------------------------------------------------------------------------------------------------------------------- |\r\n| out = which(\"filename\"); | Returns the pathname of the file \"filename\" as a string. Use ?which(\"filename\"); to display the result to the screen. |\r\n\r\n**Examples**\r\n\r\nGets the full path and filename of the file results.txt.\r\n\r\n```\r\nfile = \"results.txt\";    # set file name\r\nwrite(file,\"my data file\"); # create file\r\n?fullPath = which(file);   # get full name and path\r\n C:/Program Files/Lumerical/FDTD/scripts/results.txt\r\n```",
    "summary": "Returns the full file pathname for the specified file",
    "syntax": [
      {
        "syntax": "out = which(\"filename\");",
        "description": "Returns the pathname of the file \"filename\" as a string. Use ?which(\"filename\"); to display the result to the screen."
      }
    ],
    "example": ""
  },
  {
    "name": "wizarddata",
    "description": "This command will cause the wizard window to wait until the user selects OK or Cancel. It then returns value data from the matrix in a N+1 length matrix, where N is the number of widgets (excluding labels) in the current wizard page.",
    "usage": "wizarddata();",
    "category": "general",
    "markdown": "# wizarddata\r\n\r\nThis command will cause the wizard window to wait until the user selects OK or Cancel.\r\nIt then returns value data from the matrix in a N+1 length matrix, where N is the number\r\nof widgets (excluding labels) in the current wizard page.\r\n\r\n| **Syntax**        | **Description**       |\r\n| ----------------- | --------------------- |\r\n| out = wizarddata; | The values of out are |\r\n\r\n- out(1) = 0, 1 or -1. 0 means the user pressed Cancel, 1 means the user pressed the\r\n  first button (typically \"OK\" or \"Next\") and -1 means the user pressed the second\r\n  button (typically \"Back\")\r\n- out(2:N+1) gives the numeric values that the user entered for each input field **when\r\n  out(1) is 1** . Note that check boxes return 1 if checked and 0 if unchecked. Menu\r\n  items return a number between 1 and M where M is the number of choices in the menu. If\r\n  out(1) is 0 or -1, all the values out(2:N+1) are zero.\r\n\r\n**Examples**\r\n\r\nSee the newwizard page for an example.",
    "summary": "This command will cause the wizard window to wait until the user selects OK or Cancel",
    "syntax": [
      {
        "syntax": "out = wizarddata;",
        "description": "The values of out are"
      }
    ],
    "example": ""
  },
  {
    "name": "wizardgetdata",
    "description": "Returns data entered into a specific widget.",
    "usage": "wizardgetdata();",
    "category": "general",
    "markdown": "# wizardgetdata\r\n\r\nReturns data entered into a specific widget.\r\n\r\n| **Syntax**              | **Description**                                                                                                                 |\r\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------- |\r\n| out = wizardgetdata(N); | Returns the value that the user entered into the Nth widget. Out will be a number or a string, depending on the type of widget. |\r\n\r\n**Examples**\r\n\r\nSee the newwizard page for an example.",
    "summary": "Returns data entered into a specific widget",
    "syntax": [
      {
        "syntax": "out = wizardgetdata(N);",
        "description": "Returns the value that the user entered into the Nth widget. Out will be a number or a string, depending on the type of widget."
      }
    ],
    "example": ""
  },
  {
    "name": "wizardoption",
    "description": "Lumerical command: wizardoption",
    "usage": "wizardoption();",
    "category": "general",
    "markdown": "# wizardoption\r\n\r\n| Sets some options for wizard widgets and labels. **Syntax** | **Description** |\r\n| ----------------------------------------------------------- | --------------- |\r\n| wizardoption (\"optionname\",setting);                        | The options are |\r\n\r\n- \"fontsize\" sets the font size to any value between 8 and 40\r\n- \"fieldwidth\" sets the width of each widget field to any value between 20 and the full\r\n  width of the wizard window.\r\n- \"fieldheight\" sets the height of each field to any value between 8 and the full height\r\n  of the wizard window.\r\n- \"margin\", sets size of the left margin to any value between 0 and full width of the\r\n  wizard window.\r\n\r\n**Examples**\r\n\r\nSee the newwizard page for an example.",
    "summary": "wizardoption",
    "syntax": [
      {
        "syntax": "wizardoption (\"optionname\",setting);",
        "description": "The options are"
      }
    ],
    "example": ""
  },
  {
    "name": "wizardwidget",
    "description": "Adds a new widget to the current wizard window. This command should only be done after creating a new wizard page with the command newwizard.",
    "usage": "wizardwidget();",
    "category": "general",
    "markdown": "# wizardwidget\r\n\r\nAdds a new widget to the current wizard window. This command should only be done after\r\ncreating a new wizard page with the command newwizard.\r\n\r\n| **Syntax**                     | **Description** |\r\n| ------------------------------ | --------------- |\r\n| wizardwidget( \"type\", \"name\"); | type can be     |\r\n\r\n- \"number\" for a numeric input field\r\n- \"string\" for a alphanumeric field\r\n- \"checkbox\" for a checkbox\r\n- \"menu\" for a pulldown menu field\r\n- \"label\" to add a string label (wizardgetdata does not return information for labels)\r\n\r\nname is a string used to give the input field, checkbox, menu item or label a name.\\\r\nwizardwidget( \"type\", \"label\", defaultValue); | defaultValue provides a default value\r\nfor numeric inputs, checkboxes, menu items or strings.\\\r\nwizardwidget( \"type\", \"label\", \"choices\", defaultValue); | If the \"type\" of widget is a\r\n\"menu\", then the menu choices must be provided. These choices should be separated by the\r\ncharacter \"|\". For example, to create a pulldown widget with the name \"simulation type\"\r\nand 3 choices \"TE\",\"TM\",\"3D\", with the default choice \"3D\", the command is\r\nwizardwidget(\"menu\",\"simulation type\",\"TE|TM|3D\",3);\r\n\r\n**Examples**\r\n\r\nSee the newwizard page for an example.",
    "summary": "Adds a new widget to the current wizard window",
    "syntax": [
      {
        "syntax": "wizardwidget( \"type\", \"name\");",
        "description": "type can be"
      }
    ],
    "example": ""
  },
  {
    "name": "workspace",
    "description": "Returns a list of all the currently defined variables in the scripting workspace.",
    "usage": "workspace();",
    "category": "general",
    "markdown": "# workspace\r\n\r\nReturns a list of all the currently defined variables in the scripting workspace.\r\n\r\n| **Syntax**       | **Description**                                                                                                            |\r\n| ---------------- | -------------------------------------------------------------------------------------------------------------------------- |\r\n| out = workspace; | Returns a string that lists all currently defined variables in the workspace. Use ?workspace; to print this to the screen. |\r\n\r\n**Examples**\r\n\r\n```\r\nclear;\r\nmy_data=4;\r\nresult=matrix(2,2);\r\n?workspace;\r\nmatrices:\r\n pi mu0 eps0 my_data result c\r\n```",
    "summary": "Returns a list of all the currently defined variables in the scripting workspace",
    "syntax": [
      {
        "syntax": "out = workspace;",
        "description": "Returns a string that lists all currently defined variables in the workspace. Use ?workspace; to print this to the screen."
      }
    ],
    "example": ""
  },
  {
    "name": "write",
    "description": "Writes string variables to text files or to standard output.",
    "usage": "write();",
    "category": "general",
    "markdown": "# write\r\n\r\nWrites string variables to text files or to standard output.\r\n\r\nTypically the write command is used to output data to a text file. If the specified file\r\ndoes not exist, it will be created. If it does exist, then the output string will either\r\nbe appended to the end of the file or overwrite the file. The write command will\r\nautomatically add a new line character at the end of the string.\r\n\r\nOn Linux systems only, the write command will output to the standard output (stdout) if\r\na filename is not specified.\r\n\r\n| **Syntax**                                | **Description**                                                                                                                                                                                                                                                                                                                                                                   |\r\n| ----------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| write(my_string);                         | Write my_string to the standard output (Linux only).                                                                                                                                                                                                                                                                                                                              |\r\n| write(\"testfile.txt\", my_string, option); | Will write the contents of the string variable my_string to testfile.txt. The file \"testfile.txt\" will be created if it does not exist. option: can be \"append\" or \"overwrite\", to append the variable my_string to the end of the file or overwrite the file, respectively. If option is not provided, \"append\" will be used by default. This function does not return any data. |\r\n\r\n**Note** : This command cannot be used while in\r\n[safe mode](https://optics.ansys.com/hc/en-us/articles/360044709054-Running-script-in-safe-mode \"https://optics.ansys.com/hc/en-us/articles/360044709054-running-script-in-safe-mode\").\r\n\r\n**Examples**\r\n\r\nWrite an array of numbers to a text file. If you want to overwrite the file, use the\r\n\"overwrite\" option in the command.\r\n\r\n```\r\na=linspace(0,2*pi,9);\r\nwrite(\"testfile.txt\",num2str(a), \"overwrite\");\r\n```\r\n\r\nThe write command can output 2D matrices in a single command. Each column will be\r\nseparated with a TAB character.\r\n\r\n```\r\n# define the variables to export\r\na=linspace(0,2*pi,9);\r\nb=sin(a);\r\n# combine both vectors into a single 2D matrix to be output to file\r\ndata_to_print=[a,b];\r\n# write the data to the file\r\nwrite(\"testfile.txt\",num2str(data_to_print));\r\n```\r\n\r\nGenerally, more complicated formatting is required. For example, suppose you want to\r\nhave a header section that describes what the variables are. You also want to use comma\r\nseparated columns (CSV), rather than TAB separated. Finally, you want to output the full\r\ndouble precision numbers, rather than just the first 5 digits.\r\n\r\n```\r\n# define the variables to export\r\na=linspace(0,pi,9);\r\nb=sin(a);\r\n# remove the file if it already exists\r\nrm(\"testfile.txt\");\r\n# write the file header\r\nwrite(\"testfile.txt\",\"theta, sin(theta)\");\r\n# set num2str() to return 16 digits of precision\r\nformat long;\r\n# write the data to the file\r\nfor (i=1:length(a) ) {\r\n str= num2str(a(i))+\", \"+num2str(b(i));\r\n write(\"testfile.txt\",str);\r\n}\r\n```\r\n\r\nThe contents of testfile.txt will be:\r\n\r\ntheta, sin(theta)\r\n\r\n0.0000000000000000, 0.0000000000000000\r\n\r\n0.3926990816987241, 0.3826834323650898\r\n\r\n0.7853981633974483, 0.7071067811865475\r\n\r\n1.178097245096172, 0.9238795325112867\r\n\r\n1.570796326794897, 1.000000000000000\r\n\r\n1.963495408493621, 0.9238795325112867\r\n\r\n2.356194490192345, 0.7071067811865476\r\n\r\n2.748893571891069, 0.3826834323650899\r\n\r\n3.141592653589793, 1.224646799147353e-016",
    "summary": "Writes string variables to text files or to standard output",
    "syntax": [
      {
        "syntax": "write(my_string);",
        "description": "Write my_string to the standard output (Linux only)."
      },
      {
        "syntax": "write(\"testfile.txt\", my_string, option);",
        "description": "Will write the contents of the string variable my_string to testfile.txt. The file \"testfile.txt\" will be created if it does not exist. option: can be \"append\" or \"overwrite\", to append the variable my_string to the end of the file or overwrite the file, respectively. If option is not provided, \"append\" will be used by default. This function does not return any data."
      }
    ],
    "example": ""
  },
  {
    "name": "zbfexport",
    "description": "Exports data from a frequency field or field and power monitor to Zemax \\*.zbf file. This command can be also used to export data from a d-card to Zemax file. The return value of this command is the origin (x, y and z coordinates) of the monitor exported to the \\*.zbf file.",
    "usage": "zbfexport();",
    "category": "general",
    "markdown": "# zbfexport\r\n\r\nExports data from a frequency field or field and power monitor to Zemax \\*.zbf file.\r\nThis command can be also used to export data from a d-card to Zemax file. The return\r\nvalue of this command is the origin (x, y and z coordinates) of the monitor exported to\r\nthe \\*.zbf file.\r\n\r\n| **Syntax**                                                                                                                                                                                                                                                                                                             | **Description**                                                                                                                                                                                                                                |\r\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| output = zbfexport(\"monitorname\");                                                                                                                                                                                                                                                                                     | Export data from monitorname. By default, the first frequency point is exported. This function returns the origin of the monitor exported to the \\*.zbf file, in the format of an array with the x, y and z coordinates of the monitor origin. |\r\n| zbfexport(\"monitorname\",f);                                                                                                                                                                                                                                                                                            | Exports the frequency point specified by the index f.                                                                                                                                                                                          |\r\n| zbfexport(\"monitorname\",f,\"filename\");                                                                                                                                                                                                                                                                                 | Exports to the specified \"filename\" without opening the file browser window.                                                                                                                                                                   |\r\n| \\[[Note:]\\] The Zemax zbf file requires the data to be saved on a uniform grid of dimensions with a power of 2 (with \\\\(2^n \\\\times 2^m\\\\) points). The dataset will be interpolated on a grid with \\\\(n\\\\) and \\\\(m\\\\) defined so the mesh step is equal to or less than the smallest mesh step in the original data. |                                                                                                                                                                                                                                                |\r\n\r\n______________________________________________________________________\r\n\r\n### Example #1\r\n\r\nExport data from monitor \"beam_profile\" to a .zbf file for Zemax. The monitor had more\r\nthan one frequency point, so we elected to export the third frequency point.\r\n\r\n```\r\n?zbfexport(\"beam_profile\",3,\"test_export.zbf\");\r\nresult:\r\n1e-07\r\n3e-07\r\n0\r\n```\r\n\r\n### Example #2\r\n\r\nExport data from dcard named \"global_mode1\" to a .zbf file for Zemax. The d-card has one\r\nfrequency point, so we use f index =1.\r\n\r\n```\r\nzbfexport(\"global_mode1\",1,\"testfileDcard.zbf\");\r\n```",
    "summary": "Exports data from a frequency field or field and power monitor to Zemax \\*",
    "syntax": [
      {
        "syntax": "output = zbfexport(\"monitorname\");",
        "description": "Export data from monitorname. By default, the first frequency point is exported. This function returns the origin of the monitor exported to the \\*.zbf file, in the format of an array with the x, y and z coordinates of the monitor origin."
      },
      {
        "syntax": "zbfexport(\"monitorname\",f);",
        "description": "Exports the frequency point specified by the index f."
      },
      {
        "syntax": "zbfexport(\"monitorname\",f,\"filename\");",
        "description": "Exports to the specified \"filename\" without opening the file browser window."
      }
    ],
    "example": ""
  },
  {
    "name": "zbfload",
    "description": "Loads data from Zemax zbf file into a d-card called \"zbf_data\". If \"zbf_data\" already exists in the deck, it will be called \"zbf_data_2\". After loading a zbf file with zbfload command, you can extract any of the following data:",
    "usage": "zbfload();",
    "category": "general",
    "markdown": "# zbfload\r\n\r\nLoads data from Zemax zbf file into a d-card called \"zbf_data\". If \"zbf_data\" already\r\nexists in the deck, it will be called \"zbf_data_2\". After loading a zbf file with\r\nzbfload command, you can extract any of the following data:\r\n\r\n• Ex, Ey, Ez, Hx, Hy, Hz, x, y, z\r\n\r\n• frequency, wavelength, index\r\n\r\nNote that the H fields are calculated during the load operation in Lumerical tools using\r\nthe index from the original zbf file. Similarly, the longitudinal component in direction\r\nof propagation is not supported by the zbf format and it is populated with zero values\r\nduring the load operation.\r\n\r\n| **Syntax**                                     | **Description**                                                                                                                                                                                                                                                 |\r\n| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| zbfload                                        | Select the file to load with the file browser. This function does not return any data.                                                                                                                                                                          |\r\n| zbfload(\"filename\");                           | Loads data from a zbf file called \"filename\" without a file browser.                                                                                                                                                                                            |\r\n| zbfload(\"filename\", propagation axis)          | Loads data from a zbf file called \"filename\" without a file browser for a specified propagation axis. The propagation axis is an integer value that indicates the x, y and z axis.                                                                              |\r\n| zbfload(\"filename\", propagation axis, offset); | Loads data from a zbf file called \"filename\" without a file browser for a specified propagation axis with the specified offset. The offset is a floating number array that indicates the x, y and z coordinates shift of the load-in data to the original data. |\r\n\r\n### Example\r\n\r\nWe have data from Zemax saved in a file named \"myZemaxBeam.zbf\". We use zbfload command\r\nto load the Zemax data into FDE deck for further analysis using Lumerical tools.\r\n\r\n```\r\nzbfload(\"myZemaxBeam.zbf\");\r\n?getdata;\r\n ::zbf_data\r\n?getdata(\"zbf_data\");\r\n f  wavelength  index  x  y  z  Ex  Ey  Ez\r\n Hx  Hy  Hz \r\nEx = getdata(\"zbf_data\",\"Ex\");\r\nx = getdata(\"zbf_data\",\"x\"); \r\ny = getdata(\"zbf_data\",\"y\"); \r\nimage(x,y,pinch(real(Ex)));\r\n```\r\n\r\nResult of zbfload operation in Eigensolver Analysis window:\r\n\r\nWe have data from Zemax saved in a file named \"myZemaxBeam.zbf\". We use zbfload command\r\nto load the Zemax data twice, the first time without offset and the second time with the\r\n[x, y, z] offset as [1e-7, 3e-7, 0].\r\n\r\n```\r\nzbfload(\"myZemaxBeam.zbf\");\r\nEx = getdata(\"zbf_data\", \"Ex\");\r\nx = getdata(\"zbf_data\", \"x\");\r\ny = getdata(\"zbf_data\", \"y\");\r\nimage(x, y, pinch(real(Ex)));\r\n```\r\n\r\nThe load in E field of zbf_data:\r\n\r\n```\r\noffset = [0.0000001, 0.0000003, 0];\r\nzbfload(\"myZemaxBeam.zbf\", 3, offset);\r\nEx = getdata(\"zbf_data\", \"Ex\");\r\nx = getdata(\"zbf_data\", \"x\");\r\ny = getdata(\"zbf_data\", \"y\");\r\nimage(x, y, pinch(real(Ex)));\r\n```\r\n\r\nThe load in E field of zbf_data with offset:",
    "summary": "Loads data from Zemax zbf file into a d-card called \"zbf_data\"",
    "syntax": [
      {
        "syntax": "zbfload",
        "description": "Select the file to load with the file browser. This function does not return any data."
      },
      {
        "syntax": "zbfload(\"filename\");",
        "description": "Loads data from a zbf file called \"filename\" without a file browser."
      },
      {
        "syntax": "zbfload(\"filename\", propagation axis)",
        "description": "Loads data from a zbf file called \"filename\" without a file browser for a specified propagation axis. The propagation axis is an integer value that indicates the x, y and z axis."
      },
      {
        "syntax": "zbfload(\"filename\", propagation axis, offset);",
        "description": "Loads data from a zbf file called \"filename\" without a file browser for a specified propagation axis with the specified offset. The offset is a floating number array that indicates the x, y and z coordinates shift of the load-in data to the original data."
      }
    ],
    "example": ""
  },
  {
    "name": "zbfread",
    "description": "zbfread reads a Zemax zbf file and adds the data into structure array that will be available in the script workspace for further processing. The structure array will contain the following data:",
    "usage": "zbfread();",
    "category": "general",
    "markdown": "# zbfread\r\n\r\nzbfread reads a Zemax zbf file and adds the data into structure array that will be\r\navailable in the script workspace for further processing. The structure array will\r\ncontain the following data:\r\n\r\n• Ex, Ey, Ez, x, y, z\r\n\r\n• frequency, wavelength, index\r\n\r\nNote that ONLY the transverse E field components can be obtained from the zbf file. The\r\nlongitudinal component is not supported by the zbf format and it is populated with zero\r\nvalues during the read operation.\r\n\r\n| **Syntax**                           | **Description**                                                                                                                                                             |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| A = zbfread(\"filename.zbf\");         | Reads zbf file into structure array A where: A.index is the refractive index stored in the zbf file A.beam is the dataset that contains the E field vs frequency/wavelength |\r\n| A = zbfread(\"filename.zbf\", axis=3); | Axis = 1,2,3 is an optional parameter to specify if the beam should be rotated to propagate along x or y axis instead of the default z axis                                 |\r\n\r\n### Example\r\n\r\nThe following code example shows how to read zbf file data into a structure array with\r\nand without rotation of the default propagation direction.\r\n\r\n```\r\n# Create spatial distribution of E field data with Gaussian distribution\r\nx = linspace(-5e-6,5e-6,100);\r\ny = linspace(-6e-6,6e-6,101);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\nEx = exp(- (X^2+Y^2)/(2e-6)^2);\r\nEy = 2i*Ex;\r\nEz = 0*Ey;\r\n# Create dataset and add E field and wavelength data\r\nM = rectilineardataset(\"E\",x,y,0);\r\nM.addparameter(\"lambda\",500e-9);\r\nM.addattribute(\"E\",Ex,Ey,Ez);\r\nM.addattribute(\"scalar\",3*Ex);\r\n# Write dataset M into zbf file in with and without the optional parameters\r\nzbfwrite(\"testfile.zbf\",M);\r\n# Read the structured data from zbf file without rotation(default z direction)\r\nB = zbfread(\"testfile.zbf\");\r\nvisualize(B.beam);\r\n# Read the structured data from zbf file and rotate the propagation direction to y\r\nB = zbfread(\"testfile.zbf\",axis=2);\r\nvisualize(B.beam);\r\n```",
    "summary": "zbfread reads a Zemax zbf file and adds the data into structure array that will be available in the ...",
    "syntax": [
      {
        "syntax": "A = zbfread(\"filename.zbf\");",
        "description": "Reads zbf file into structure array A where: A.index is the refractive index stored in the zbf file A.beam is the dataset that contains the E field vs frequency/wavelength"
      },
      {
        "syntax": "A = zbfread(\"filename.zbf\", axis=3);",
        "description": "Axis = 1,2,3 is an optional parameter to specify if the beam should be rotated to propagate along x or y axis instead of the default z axis"
      }
    ],
    "example": ""
  },
  {
    "name": "zbfwrite",
    "description": "Zbfwrite writes a 4D dataset into a Zemax zbf file in the current directory. Data written into the zbf file:",
    "usage": "zbfwrite();",
    "category": "general",
    "markdown": "# zbfwrite\r\n\r\nZbfwrite writes a 4D dataset into a Zemax zbf file in the current directory. Data\r\nwritten into the zbf file:\r\n\r\n- Ex, Ey, Ez, x, y, z\r\n- frequency, wavelength, index\r\n\r\n\\[[Note:]\\] ONLY the transverse E field components are written to the zbf file. The\r\nlongitudinal component is not supported by the zbf format.\r\n\r\n| **Syntax**                                                                                                                                                                                                                                                                                                             | **Description**                                                                                                                                                                                                                                                                                                                                                         |\r\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| zbfwrite(\"filename\",M);                                                                                                                                                                                                                                                                                                | Writes dataset M into zbf file. The dataset must include one frequency or wavelength value. If the fourth dimension is named \"f\" or \"frequency\", it will be automatically converted into wavelength. Any other name will be assumed to carry wavelength information and it will not be converted.                                                                       |\r\n| zbfwrite(\"filename\",M,index);                                                                                                                                                                                                                                                                                          | The optional parameter \"index\" is the refractive index that will be written into zbf file. A default value of \"1\" is used if no \"index\" is provided.                                                                                                                                                                                                                    |\r\n| zbfwrite(\"filename\",M,index,\"attributeName\");                                                                                                                                                                                                                                                                          | atributeName is an optional parameter with default value = \"\". This specifies the vector or scalar attribute to write. If a scalar attribute is written, it becomes an \"unpolarized\" zbf file. If nothing is specified(default value =\"\"), then it will write the first vector attribute in the dataset, or the first scalar attribute if there is no vector attribute. |\r\n| \\[[Note:]\\] The Zemax zbf file requires the data to be saved on a uniform grid of dimensions with a power of 2 (with \\\\(2^n \\\\times 2^m\\\\) points). The dataset will be interpolated on a grid with \\\\(n\\\\) and \\\\(m\\\\) defined so the mesh step is equal to or less than the smallest mesh step in the original data. |                                                                                                                                                                                                                                                                                                                                                                         |\r\n\r\n______________________________________________________________________\r\n\r\n### Example\r\n\r\nThe following code example shows how to create a dataset with correct dimensions and\r\nwrite it into a zbf file with various optional parameters. The last section of the code\r\nreads back the saved zbf file into the structure array and plots the field profile,\r\nindex, and wavelength.\r\n\r\n```\r\n# Create spatial distribution of E field data with Gaussian distribution\r\nx = linspace(-5e-6,5e-6,100);\r\ny = linspace(-6e-6,6e-6,101);\r\nX = meshgridx(x,y);\r\nY = meshgridy(x,y);\r\nEx = exp(- (X^2+Y^2)/(2e-6)^2);\r\nEy = 2i*Ex;\r\nEz = 0*Ey;  \r\n\r\n# Create dataset and add E field and wavelength data\r\nM = rectilineardataset(\"E\",x,y,0);\r\nM.addparameter(\"lambda\",500e-9);\r\nM.addattribute(\"E\",Ex,Ey,Ez);\r\nM.addattribute(\"scalar\",3*Ex);  \r\n\r\n# Visualize the dataset before writing it into zbf file\r\nvisualize(M);  \r\n\r\n# Write dataset M into zbf file in with and without the optional parameters\r\nzbfwrite(\"testfile1.zbf\",M);\r\nzbfwrite(\"testfile2.zbf\",M,1);\r\nzbfwrite(\"testfile3.zbf\",M,1,\"E\");\r\nzbfwrite(\"testfile4.zbf\",M,2,\"scalar\");  \r\n\r\n# Read back the structured data from zbf file and visualize it\r\nB = zbfread(\"testfile4.zbf\");\r\nvisualize(B.beam);\r\n?B.index;\r\nB_beam=B.beam;\r\n?B_beam.wavelength;\r\n```",
    "summary": "Zbfwrite writes a 4D dataset into a Zemax zbf file in the current directory",
    "syntax": [
      {
        "syntax": "zbfwrite(\"filename\",M);",
        "description": "Writes dataset M into zbf file. The dataset must include one frequency or wavelength value. If the fourth dimension is named \"f\" or \"frequency\", it will be automatically converted into wavelength. Any other name will be assumed to carry wavelength information and it will not be converted."
      },
      {
        "syntax": "zbfwrite(\"filename\",M,index);",
        "description": "The optional parameter \"index\" is the refractive index that will be written into zbf file. A default value of \"1\" is used if no \"index\" is provided."
      },
      {
        "syntax": "zbfwrite(\"filename\",M,index,\"attributeName\");",
        "description": "atributeName is an optional parameter with default value = \"\". This specifies the vector or scalar attribute to write. If a scalar attribute is written, it becomes an \"unpolarized\" zbf file. If nothing is specified(default value =\"\"), then it will write the first vector attribute in the dataset, or the first scalar attribute if there is no vector attribute."
      }
    ],
    "example": ""
  }
]